var _Q=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports);var kBt=_Q((Bo,Vo)=>{function $Q(t,e){for(var n=0;n<e.length;n++){const s=e[n];if(typeof s!="string"&&!Array.isArray(s)){for(const r in s)if(r!=="default"&&!(r in t)){const o=Object.getOwnPropertyDescriptor(s,r);o&&Object.defineProperty(t,r,o.get?o:{enumerable:!0,get:()=>s[r]})}}}return Object.freeze(Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}))}(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const r of document.querySelectorAll('link[rel="modulepreload"]'))s(r);new MutationObserver(r=>{for(const o of r)if(o.type==="childList")for(const a of o.addedNodes)a.tagName==="LINK"&&a.rel==="modulepreload"&&s(a)}).observe(document,{childList:!0,subtree:!0});function n(r){const o={};return r.integrity&&(o.integrity=r.integrity),r.referrerpolicy&&(o.referrerPolicy=r.referrerpolicy),r.crossorigin==="use-credentials"?o.credentials="include":r.crossorigin==="anonymous"?o.credentials="omit":o.credentials="same-origin",o}function s(r){if(r.ep)return;r.ep=!0;const o=n(r);fetch(r.href,o)}})();function BS(t,e){const n=Object.create(null),s=t.split(",");for(let r=0;r<s.length;r++)n[s[r]]=!0;return e?r=>!!n[r.toLowerCase()]:r=>!!n[r]}function ot(t){if(Qe(t)){const e={};for(let n=0;n<t.length;n++){const s=t[n],r=wt(s)?kQ(s):ot(s);if(r)for(const o in r)e[o]=r[o]}return e}else{if(wt(t))return t;if(Bt(t))return t}}const xQ=/;(?![^(]*\))/g,SQ=/:([^]+)/,CQ=/\/\*.*?\*\//gs;function kQ(t){const e={};return t.replace(CQ,"").split(xQ).forEach(n=>{if(n){const s=n.split(SQ);s.length>1&&(e[s[0].trim()]=s[1].trim())}}),e}function P(t){let e="";if(wt(t))e=t;else if(Qe(t))for(let n=0;n<t.length;n++){const s=P(t[n]);s&&(e+=s+" ")}else if(Bt(t))for(const n in t)t[n]&&(e+=n+" ");return e.trim()}function Wa(t){if(!t)return null;let{class:e,style:n}=t;return e&&!wt(e)&&(t.class=P(e)),n&&(t.style=ot(n)),t}const TQ="itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly",NQ=BS(TQ);function rF(t){return!!t||t===""}function IQ(t,e){if(t.length!==e.length)return!1;let n=!0;for(let s=0;n&&s<t.length;s++)n=nh(t[s],e[s]);return n}function nh(t,e){if(t===e)return!0;let n=yd(t),s=yd(e);if(n||s)return n&&s?t.getTime()===e.getTime():!1;if(n=y0(t),s=y0(e),n||s)return t===e;if(n=Qe(t),s=Qe(e),n||s)return n&&s?IQ(t,e):!1;if(n=Bt(t),s=Bt(e),n||s){if(!n||!s)return!1;const r=Object.keys(t).length,o=Object.keys(e).length;if(r!==o)return!1;for(const a in t){const i=t.hasOwnProperty(a),l=e.hasOwnProperty(a);if(i&&!l||!i&&l||!nh(t[a],e[a]))return!1}}return String(t)===String(e)}function oF(t,e){return t.findIndex(n=>nh(n,e))}const Ue=t=>wt(t)?t:t==null?"":Qe(t)||Bt(t)&&(t.toString===iF||!vt(t.toString))?JSON.stringify(t,aF,2):String(t),aF=(t,e)=>e&&e.__v_isRef?aF(t,e.value):Vf(e)?{[`Map(${e.size})`]:[...e.entries()].reduce((n,[s,r])=>(n[`${s} =>`]=r,n),{})}:Vb(e)?{[`Set(${e.size})`]:[...e.values()]}:Bt(e)&&!Qe(e)&&!lF(e)?String(e):e,rs={},Bf=[],gn=()=>{},EQ=()=>!1,AQ=/^on[^a-z]/,Bb=t=>AQ.test(t),VS=t=>t.startsWith("onUpdate:"),rr=Object.assign,HS=(t,e)=>{const n=t.indexOf(e);n>-1&&t.splice(n,1)},OQ=Object.prototype.hasOwnProperty,Ut=(t,e)=>OQ.call(t,e),Qe=Array.isArray,Vf=t=>xg(t)==="[object Map]",Vb=t=>xg(t)==="[object Set]",yd=t=>xg(t)==="[object Date]",vt=t=>typeof t=="function",wt=t=>typeof t=="string",y0=t=>typeof t=="symbol",Bt=t=>t!==null&&typeof t=="object",b0=t=>Bt(t)&&vt(t.then)&&vt(t.catch),iF=Object.prototype.toString,xg=t=>iF.call(t),Fv=t=>xg(t).slice(8,-1),lF=t=>xg(t)==="[object Object]",WS=t=>wt(t)&&t!=="NaN"&&t[0]!=="-"&&""+parseInt(t,10)===t,Mv=BS(",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"),Hb=t=>{const e=Object.create(null);return n=>e[n]||(e[n]=t(n))},RQ=/-(\w)/g,wa=Hb(t=>t.replace(RQ,(e,n)=>n?n.toUpperCase():"")),DQ=/\B([A-Z])/g,ac=Hb(t=>t.replace(DQ,"-$1").toLowerCase()),Sg=Hb(t=>t.charAt(0).toUpperCase()+t.slice(1)),Pv=Hb(t=>t?`on${Sg(t)}`:""),w0=(t,e)=>!Object.is(t,e),Lv=(t,e)=>{for(let n=0;n<t.length;n++)t[n](e)},wy=(t,e,n)=>{Object.defineProperty(t,e,{configurable:!0,enumerable:!1,value:n})},_0=t=>{const e=parseFloat(t);return isNaN(e)?t:e};let e5;const FQ=()=>e5||(e5=typeof globalThis<"u"?globalThis:typeof self<"u"?self:typeof window<"u"?window:typeof global<"u"?global:{});let Ro;class uF{constructor(e=!1){this.detached=e,this.active=!0,this.effects=[],this.cleanups=[],this.parent=Ro,!e&&Ro&&(this.index=(Ro.scopes||(Ro.scopes=[])).push(this)-1)}run(e){if(this.active){const n=Ro;try{return Ro=this,e()}finally{Ro=n}}}on(){Ro=this}off(){Ro=this.parent}stop(e){if(this.active){let n,s;for(n=0,s=this.effects.length;n<s;n++)this.effects[n].stop();for(n=0,s=this.cleanups.length;n<s;n++)this.cleanups[n]();if(this.scopes)for(n=0,s=this.scopes.length;n<s;n++)this.scopes[n].stop(!0);if(!this.detached&&this.parent&&!e){const r=this.parent.scopes.pop();r&&r!==this&&(this.parent.scopes[this.index]=r,r.index=this.index)}this.parent=void 0,this.active=!1}}}function MQ(t){return new uF(t)}function PQ(t,e=Ro){e&&e.active&&e.effects.push(t)}function LQ(){return Ro}function cF(t){Ro&&Ro.cleanups.push(t)}const US=t=>{const e=new Set(t);return e.w=0,e.n=0,e},dF=t=>(t.w&Wu)>0,fF=t=>(t.n&Wu)>0,zQ=({deps:t})=>{if(t.length)for(let e=0;e<t.length;e++)t[e].w|=Wu},BQ=t=>{const{deps:e}=t;if(e.length){let n=0;for(let s=0;s<e.length;s++){const r=e[s];dF(r)&&!fF(r)?r.delete(t):e[n++]=r,r.w&=~Wu,r.n&=~Wu}e.length=n}},G$=new WeakMap;let Vm=0,Wu=1;const j$=30;let Ha;const td=Symbol(""),K$=Symbol("");class GS{constructor(e,n=null,s){this.fn=e,this.scheduler=n,this.active=!0,this.deps=[],this.parent=void 0,PQ(this,s)}run(){if(!this.active)return this.fn();let e=Ha,n=Ou;for(;e;){if(e===this)return;e=e.parent}try{return this.parent=Ha,Ha=this,Ou=!0,Wu=1<<++Vm,Vm<=j$?zQ(this):t5(this),this.fn()}finally{Vm<=j$&&BQ(this),Wu=1<<--Vm,Ha=this.parent,Ou=n,this.parent=void 0,this.deferStop&&this.stop()}}stop(){Ha===this?this.deferStop=!0:this.active&&(t5(this),this.onStop&&this.onStop(),this.active=!1)}}function t5(t){const{deps:e}=t;if(e.length){for(let n=0;n<e.length;n++)e[n].delete(t);e.length=0}}let Ou=!0;const hF=[];function Kh(){hF.push(Ou),Ou=!1}function qh(){const t=hF.pop();Ou=t===void 0?!0:t}function jo(t,e,n){if(Ou&&Ha){let s=G$.get(t);s||G$.set(t,s=new Map);let r=s.get(n);r||s.set(n,r=US()),pF(r)}}function pF(t,e){let n=!1;Vm<=j$?fF(t)||(t.n|=Wu,n=!dF(t)):n=!t.has(Ha),n&&(t.add(Ha),Ha.deps.push(t))}function wl(t,e,n,s,r,o){const a=G$.get(t);if(!a)return;let i=[];if(e==="clear")i=[...a.values()];else if(n==="length"&&Qe(t)){const l=_0(s);a.forEach((u,c)=>{(c==="length"||c>=l)&&i.push(u)})}else switch(n!==void 0&&i.push(a.get(n)),e){case"add":Qe(t)?WS(n)&&i.push(a.get("length")):(i.push(a.get(td)),Vf(t)&&i.push(a.get(K$)));break;case"delete":Qe(t)||(i.push(a.get(td)),Vf(t)&&i.push(a.get(K$)));break;case"set":Vf(t)&&i.push(a.get(td));break}if(i.length===1)i[0]&&q$(i[0]);else{const l=[];for(const u of i)u&&l.push(...u);q$(US(l))}}function q$(t,e){const n=Qe(t)?t:[...t];for(const s of n)s.computed&&n5(s);for(const s of n)s.computed||n5(s)}function n5(t,e){(t!==Ha||t.allowRecurse)&&(t.scheduler?t.scheduler():t.run())}const VQ=BS("__proto__,__v_isRef,__isVue"),mF=new Set(Object.getOwnPropertyNames(Symbol).filter(t=>t!=="arguments"&&t!=="caller").map(t=>Symbol[t]).filter(y0)),HQ=jS(),WQ=jS(!1,!0),UQ=jS(!0),s5=GQ();function GQ(){const t={};return["includes","indexOf","lastIndexOf"].forEach(e=>{t[e]=function(...n){const s=fn(this);for(let o=0,a=this.length;o<a;o++)jo(s,"get",o+"");const r=s[e](...n);return r===-1||r===!1?s[e](...n.map(fn)):r}}),["push","pop","shift","unshift","splice"].forEach(e=>{t[e]=function(...n){Kh();const s=fn(this)[e].apply(this,n);return qh(),s}}),t}function jS(t=!1,e=!1){return function(s,r,o){if(r==="__v_isReactive")return!t;if(r==="__v_isReadonly")return t;if(r==="__v_isShallow")return e;if(r==="__v_raw"&&o===(t?e?iee:wF:e?bF:yF).get(s))return s;const a=Qe(s);if(!t&&a&&Ut(s5,r))return Reflect.get(s5,r,o);const i=Reflect.get(s,r,o);return(y0(r)?mF.has(r):VQ(r))||(t||jo(s,"get",r),e)?i:kn(i)?a&&WS(r)?i:i.value:Bt(i)?t?Cg(i):on(i):i}}const jQ=gF(),KQ=gF(!0);function gF(t=!1){return function(n,s,r,o){let a=n[s];if(sh(a)&&kn(a)&&!kn(r))return!1;if(!t&&(!_y(r)&&!sh(r)&&(a=fn(a),r=fn(r)),!Qe(n)&&kn(a)&&!kn(r)))return a.value=r,!0;const i=Qe(n)&&WS(s)?Number(s)<n.length:Ut(n,s),l=Reflect.set(n,s,r,o);return n===fn(o)&&(i?w0(r,a)&&wl(n,"set",s,r):wl(n,"add",s,r)),l}}function qQ(t,e){const n=Ut(t,e);t[e];const s=Reflect.deleteProperty(t,e);return s&&n&&wl(t,"delete",e,void 0),s}function XQ(t,e){const n=Reflect.has(t,e);return(!y0(e)||!mF.has(e))&&jo(t,"has",e),n}function YQ(t){return jo(t,"iterate",Qe(t)?"length":td),Reflect.ownKeys(t)}const vF={get:HQ,set:jQ,deleteProperty:qQ,has:XQ,ownKeys:YQ},ZQ={get:UQ,set(t,e){return!0},deleteProperty(t,e){return!0}},JQ=rr({},vF,{get:WQ,set:KQ}),KS=t=>t,Wb=t=>Reflect.getPrototypeOf(t);function j2(t,e,n=!1,s=!1){t=t.__v_raw;const r=fn(t),o=fn(e);n||(e!==o&&jo(r,"get",e),jo(r,"get",o));const{has:a}=Wb(r),i=s?KS:n?YS:$0;if(a.call(r,e))return i(t.get(e));if(a.call(r,o))return i(t.get(o));t!==r&&t.get(e)}function K2(t,e=!1){const n=this.__v_raw,s=fn(n),r=fn(t);return e||(t!==r&&jo(s,"has",t),jo(s,"has",r)),t===r?n.has(t):n.has(t)||n.has(r)}function q2(t,e=!1){return t=t.__v_raw,!e&&jo(fn(t),"iterate",td),Reflect.get(t,"size",t)}function r5(t){t=fn(t);const e=fn(this);return Wb(e).has.call(e,t)||(e.add(t),wl(e,"add",t,t)),this}function o5(t,e){e=fn(e);const n=fn(this),{has:s,get:r}=Wb(n);let o=s.call(n,t);o||(t=fn(t),o=s.call(n,t));const a=r.call(n,t);return n.set(t,e),o?w0(e,a)&&wl(n,"set",t,e):wl(n,"add",t,e),this}function a5(t){const e=fn(this),{has:n,get:s}=Wb(e);let r=n.call(e,t);r||(t=fn(t),r=n.call(e,t)),s&&s.call(e,t);const o=e.delete(t);return r&&wl(e,"delete",t,void 0),o}function i5(){const t=fn(this),e=t.size!==0,n=t.clear();return e&&wl(t,"clear",void 0,void 0),n}function X2(t,e){return function(s,r){const o=this,a=o.__v_raw,i=fn(a),l=e?KS:t?YS:$0;return!t&&jo(i,"iterate",td),a.forEach((u,c)=>s.call(r,l(u),l(c),o))}}function Y2(t,e,n){return function(...s){const r=this.__v_raw,o=fn(r),a=Vf(o),i=t==="entries"||t===Symbol.iterator&&a,l=t==="keys"&&a,u=r[t](...s),c=n?KS:e?YS:$0;return!e&&jo(o,"iterate",l?K$:td),{next(){const{value:d,done:f}=u.next();return f?{value:d,done:f}:{value:i?[c(d[0]),c(d[1])]:c(d),done:f}},[Symbol.iterator](){return this}}}}function ru(t){return function(...e){return t==="delete"?!1:this}}function QQ(){const t={get(o){return j2(this,o)},get size(){return q2(this)},has:K2,add:r5,set:o5,delete:a5,clear:i5,forEach:X2(!1,!1)},e={get(o){return j2(this,o,!1,!0)},get size(){return q2(this)},has:K2,add:r5,set:o5,delete:a5,clear:i5,forEach:X2(!1,!0)},n={get(o){return j2(this,o,!0)},get size(){return q2(this,!0)},has(o){return K2.call(this,o,!0)},add:ru("add"),set:ru("set"),delete:ru("delete"),clear:ru("clear"),forEach:X2(!0,!1)},s={get(o){return j2(this,o,!0,!0)},get size(){return q2(this,!0)},has(o){return K2.call(this,o,!0)},add:ru("add"),set:ru("set"),delete:ru("delete"),clear:ru("clear"),forEach:X2(!0,!0)};return["keys","values","entries",Symbol.iterator].forEach(o=>{t[o]=Y2(o,!1,!1),n[o]=Y2(o,!0,!1),e[o]=Y2(o,!1,!0),s[o]=Y2(o,!0,!0)}),[t,n,e,s]}const[eee,tee,nee,see]=QQ();function qS(t,e){const n=e?t?see:nee:t?tee:eee;return(s,r,o)=>r==="__v_isReactive"?!t:r==="__v_isReadonly"?t:r==="__v_raw"?s:Reflect.get(Ut(n,r)&&r in s?n:s,r,o)}const ree={get:qS(!1,!1)},oee={get:qS(!1,!0)},aee={get:qS(!0,!1)},yF=new WeakMap,bF=new WeakMap,wF=new WeakMap,iee=new WeakMap;function lee(t){switch(t){case"Object":case"Array":return 1;case"Map":case"Set":case"WeakMap":case"WeakSet":return 2;default:return 0}}function uee(t){return t.__v_skip||!Object.isExtensible(t)?0:lee(Fv(t))}function on(t){return sh(t)?t:XS(t,!1,vF,ree,yF)}function _F(t){return XS(t,!1,JQ,oee,bF)}function Cg(t){return XS(t,!0,ZQ,aee,wF)}function XS(t,e,n,s,r){if(!Bt(t)||t.__v_raw&&!(e&&t.__v_isReactive))return t;const o=r.get(t);if(o)return o;const a=uee(t);if(a===0)return t;const i=new Proxy(t,a===2?s:n);return r.set(t,i),i}function Hf(t){return sh(t)?Hf(t.__v_raw):!!(t&&t.__v_isReactive)}function sh(t){return!!(t&&t.__v_isReadonly)}function _y(t){return!!(t&&t.__v_isShallow)}function $F(t){return Hf(t)||sh(t)}function fn(t){const e=t&&t.__v_raw;return e?fn(e):t}function nd(t){return wy(t,"__v_skip",!0),t}const $0=t=>Bt(t)?on(t):t,YS=t=>Bt(t)?Cg(t):t;function xF(t){Ou&&Ha&&(t=fn(t),pF(t.dep||(t.dep=US())))}function ZS(t,e){t=fn(t),t.dep&&q$(t.dep)}function kn(t){return!!(t&&t.__v_isRef===!0)}function U(t){return SF(t,!1)}function Nn(t){return SF(t,!0)}function SF(t,e){return kn(t)?t:new cee(t,e)}class cee{constructor(e,n){this.__v_isShallow=n,this.dep=void 0,this.__v_isRef=!0,this._rawValue=n?e:fn(e),this._value=n?e:$0(e)}get value(){return xF(this),this._value}set value(e){const n=this.__v_isShallow||_y(e)||sh(e);e=n?e:fn(e),w0(e,this._rawValue)&&(this._rawValue=e,this._value=n?e:$0(e),ZS(this))}}function Cm(t){ZS(t)}function v(t){return kn(t)?t.value:t}const dee={get:(t,e,n)=>v(Reflect.get(t,e,n)),set:(t,e,n,s)=>{const r=t[e];return kn(r)&&!kn(n)?(r.value=n,!0):Reflect.set(t,e,n,s)}};function CF(t){return Hf(t)?t:new Proxy(t,dee)}function Ps(t){const e=Qe(t)?new Array(t.length):{};for(const n in t)e[n]=Un(t,n);return e}class fee{constructor(e,n,s){this._object=e,this._key=n,this._defaultValue=s,this.__v_isRef=!0}get value(){const e=this._object[this._key];return e===void 0?this._defaultValue:e}set value(e){this._object[this._key]=e}}function Un(t,e,n){const s=t[e];return kn(s)?s:new fee(t,e,n)}var kF;class hee{constructor(e,n,s,r){this._setter=n,this.dep=void 0,this.__v_isRef=!0,this[kF]=!1,this._dirty=!0,this.effect=new GS(e,()=>{this._dirty||(this._dirty=!0,ZS(this))}),this.effect.computed=this,this.effect.active=this._cacheable=!r,this.__v_isReadonly=s}get value(){const e=fn(this);return xF(e),(e._dirty||!e._cacheable)&&(e._dirty=!1,e._value=e.effect.run()),e._value}set value(e){this._setter(e)}}kF="__v_isReadonly";function TF(t,e,n=!1){let s,r;const o=vt(t);return o?(s=t,r=gn):(s=t.get,r=t.set),new hee(s,r,o||!r,n)}function pee(t,...e){}function Ru(t,e,n,s){let r;try{r=s?t(...s):t()}catch(o){Ub(o,e,n)}return r}function va(t,e,n,s){if(vt(t)){const o=Ru(t,e,n,s);return o&&b0(o)&&o.catch(a=>{Ub(a,e,n)}),o}const r=[];for(let o=0;o<t.length;o++)r.push(va(t[o],e,n,s));return r}function Ub(t,e,n,s=!0){const r=e?e.vnode:null;if(e){let o=e.parent;const a=e.proxy,i=n;for(;o;){const u=o.ec;if(u){for(let c=0;c<u.length;c++)if(u[c](t,a,i)===!1)return}o=o.parent}const l=e.appContext.config.errorHandler;if(l){Ru(l,null,10,[t,a,i]);return}}mee(t,n,r,s)}function mee(t,e,n,s=!0){console.error(t)}let x0=!1,X$=!1;const kr=[];let wi=0;const Wf=[];let ol=null,Mc=0;const NF=Promise.resolve();let JS=null;function nt(t){const e=JS||NF;return t?e.then(this?t.bind(this):t):e}function gee(t){let e=wi+1,n=kr.length;for(;e<n;){const s=e+n>>>1;S0(kr[s])<t?e=s+1:n=s}return e}function QS(t){(!kr.length||!kr.includes(t,x0&&t.allowRecurse?wi+1:wi))&&(t.id==null?kr.push(t):kr.splice(gee(t.id),0,t),IF())}function IF(){!x0&&!X$&&(X$=!0,JS=NF.then(AF))}function vee(t){const e=kr.indexOf(t);e>wi&&kr.splice(e,1)}function yee(t){Qe(t)?Wf.push(...t):(!ol||!ol.includes(t,t.allowRecurse?Mc+1:Mc))&&Wf.push(t),IF()}function l5(t,e=x0?wi+1:0){for(;e<kr.length;e++){const n=kr[e];n&&n.pre&&(kr.splice(e,1),e--,n())}}function EF(t){if(Wf.length){const e=[...new Set(Wf)];if(Wf.length=0,ol){ol.push(...e);return}for(ol=e,ol.sort((n,s)=>S0(n)-S0(s)),Mc=0;Mc<ol.length;Mc++)ol[Mc]();ol=null,Mc=0}}const S0=t=>t.id==null?1/0:t.id,bee=(t,e)=>{const n=S0(t)-S0(e);if(n===0){if(t.pre&&!e.pre)return-1;if(e.pre&&!t.pre)return 1}return n};function AF(t){X$=!1,x0=!0,kr.sort(bee);const e=gn;try{for(wi=0;wi<kr.length;wi++){const n=kr[wi];n&&n.active!==!1&&Ru(n,null,14)}}finally{wi=0,kr.length=0,EF(),x0=!1,JS=null,(kr.length||Wf.length)&&AF()}}function wee(t,e,...n){if(t.isUnmounted)return;const s=t.vnode.props||rs;let r=n;const o=e.startsWith("update:"),a=o&&e.slice(7);if(a&&a in s){const c=`${a==="modelValue"?"model":a}Modifiers`,{number:d,trim:f}=s[c]||rs;f&&(r=n.map(h=>wt(h)?h.trim():h)),d&&(r=n.map(_0))}let i,l=s[i=Pv(e)]||s[i=Pv(wa(e))];!l&&o&&(l=s[i=Pv(ac(e))]),l&&va(l,t,6,r);const u=s[i+"Once"];if(u){if(!t.emitted)t.emitted={};else if(t.emitted[i])return;t.emitted[i]=!0,va(u,t,6,r)}}function OF(t,e,n=!1){const s=e.emitsCache,r=s.get(t);if(r!==void 0)return r;const o=t.emits;let a={},i=!1;if(!vt(t)){const l=u=>{const c=OF(u,e,!0);c&&(i=!0,rr(a,c))};!n&&e.mixins.length&&e.mixins.forEach(l),t.extends&&l(t.extends),t.mixins&&t.mixins.forEach(l)}return!o&&!i?(Bt(t)&&s.set(t,null),null):(Qe(o)?o.forEach(l=>a[l]=null):rr(a,o),Bt(t)&&s.set(t,a),a)}function Gb(t,e){return!t||!Bb(e)?!1:(e=e.slice(2).replace(/Once$/,""),Ut(t,e[0].toLowerCase()+e.slice(1))||Ut(t,ac(e))||Ut(t,e))}let gr=null,jb=null;function $y(t){const e=gr;return gr=t,jb=t&&t.type.__scopeId||null,e}function _ee(t){jb=t}function $ee(){jb=null}function ce(t,e=gr,n){if(!e||t._n)return t;const s=(...r)=>{s._d&&b5(-1);const o=$y(e);let a;try{a=t(...r)}finally{$y(o),s._d&&b5(1)}return a};return s._n=!0,s._c=!0,s._d=!0,s}function E4(t){const{type:e,vnode:n,proxy:s,withProxy:r,props:o,propsOptions:[a],slots:i,attrs:l,emit:u,render:c,renderCache:d,data:f,setupState:h,ctx:p,inheritAttrs:m}=t;let g,y;const w=$y(t);try{if(n.shapeFlag&4){const _=r||s;g=pi(c.call(_,_,d,o,h,f,p)),y=l}else{const _=e;g=pi(_.length>1?_(o,{attrs:l,slots:i,emit:u}):_(o,null)),y=e.props?l:xee(l)}}catch(_){s0.length=0,Ub(_,t,1),g=se(Gr)}let b=g;if(y&&m!==!1){const _=Object.keys(y),{shapeFlag:$}=b;_.length&&$&7&&(a&&_.some(VS)&&(y=See(y,a)),b=_l(b,y))}return n.dirs&&(b=_l(b),b.dirs=b.dirs?b.dirs.concat(n.dirs):n.dirs),n.transition&&(b.transition=n.transition),g=b,$y(w),g}const xee=t=>{let e;for(const n in t)(n==="class"||n==="style"||Bb(n))&&((e||(e={}))[n]=t[n]);return e},See=(t,e)=>{const n={};for(const s in t)(!VS(s)||!(s.slice(9)in e))&&(n[s]=t[s]);return n};function Cee(t,e,n){const{props:s,children:r,component:o}=t,{props:a,children:i,patchFlag:l}=e,u=o.emitsOptions;if(e.dirs||e.transition)return!0;if(n&&l>=0){if(l&1024)return!0;if(l&16)return s?u5(s,a,u):!!a;if(l&8){const c=e.dynamicProps;for(let d=0;d<c.length;d++){const f=c[d];if(a[f]!==s[f]&&!Gb(u,f))return!0}}}else return(r||i)&&(!i||!i.$stable)?!0:s===a?!1:s?a?u5(s,a,u):!0:!!a;return!1}function u5(t,e,n){const s=Object.keys(e);if(s.length!==Object.keys(t).length)return!0;for(let r=0;r<s.length;r++){const o=s[r];if(e[o]!==t[o]&&!Gb(n,o))return!0}return!1}function kee({vnode:t,parent:e},n){for(;e&&e.subTree===t;)(t=e.vnode).el=n,e=e.parent}const Tee=t=>t.__isSuspense;function Nee(t,e){e&&e.pendingBranch?Qe(t)?e.effects.push(...t):e.effects.push(t):yee(t)}function Lt(t,e){if(Js){let n=Js.provides;const s=Js.parent&&Js.parent.provides;s===n&&(n=Js.provides=Object.create(s)),n[t]=e}}function et(t,e,n=!1){const s=Js||gr;if(s){const r=s.parent==null?s.vnode.appContext&&s.vnode.appContext.provides:s.parent.provides;if(r&&t in r)return r[t];if(arguments.length>1)return n&&vt(e)?e.call(s.proxy):e}}function Ho(t,e){return eC(t,null,e)}const Z2={};function Me(t,e,n){return eC(t,e,n)}function eC(t,e,{immediate:n,deep:s,flush:r,onTrack:o,onTrigger:a}=rs){const i=Js;let l,u=!1,c=!1;if(kn(t)?(l=()=>t.value,u=_y(t)):Hf(t)?(l=()=>t,s=!0):Qe(t)?(c=!0,u=t.some(b=>Hf(b)||_y(b)),l=()=>t.map(b=>{if(kn(b))return b.value;if(Hf(b))return Gc(b);if(vt(b))return Ru(b,i,2)})):vt(t)?e?l=()=>Ru(t,i,2):l=()=>{if(!(i&&i.isUnmounted))return d&&d(),va(t,i,3,[f])}:l=gn,e&&s){const b=l;l=()=>Gc(b())}let d,f=b=>{d=y.onStop=()=>{Ru(b,i,4)}},h;if(N0)if(f=gn,e?n&&va(e,i,3,[l(),c?[]:void 0,f]):l(),r==="sync"){const b=gte();h=b.__watcherHandles||(b.__watcherHandles=[])}else return gn;let p=c?new Array(t.length).fill(Z2):Z2;const m=()=>{if(!!y.active)if(e){const b=y.run();(s||u||(c?b.some((_,$)=>w0(_,p[$])):w0(b,p)))&&(d&&d(),va(e,i,3,[b,p===Z2?void 0:c&&p[0]===Z2?[]:p,f]),p=b)}else y.run()};m.allowRecurse=!!e;let g;r==="sync"?g=m:r==="post"?g=()=>ao(m,i&&i.suspense):(m.pre=!0,i&&(m.id=i.uid),g=()=>QS(m));const y=new GS(l,g);e?n?m():p=y.run():r==="post"?ao(y.run.bind(y),i&&i.suspense):y.run();const w=()=>{y.stop(),i&&i.scope&&HS(i.scope.effects,y)};return h&&h.push(w),w}function Iee(t,e,n){const s=this.proxy,r=wt(t)?t.includes(".")?RF(s,t):()=>s[t]:t.bind(s,s);let o;vt(e)?o=e:(o=e.handler,n=e);const a=Js;oh(this);const i=eC(r,o.bind(s),n);return a?oh(a):sd(),i}function RF(t,e){const n=e.split(".");return()=>{let s=t;for(let r=0;r<n.length&&s;r++)s=s[n[r]];return s}}function Gc(t,e){if(!Bt(t)||t.__v_skip||(e=e||new Set,e.has(t)))return t;if(e.add(t),kn(t))Gc(t.value,e);else if(Qe(t))for(let n=0;n<t.length;n++)Gc(t[n],e);else if(Vb(t)||Vf(t))t.forEach(n=>{Gc(n,e)});else if(lF(t))for(const n in t)Gc(t[n],e);return t}function DF(){const t={isMounted:!1,isLeaving:!1,isUnmounting:!1,leavingVNodes:new Map};return It(()=>{t.isMounted=!0}),ts(()=>{t.isUnmounting=!0}),t}const Qo=[Function,Array],Eee={name:"BaseTransition",props:{mode:String,appear:Boolean,persisted:Boolean,onBeforeEnter:Qo,onEnter:Qo,onAfterEnter:Qo,onEnterCancelled:Qo,onBeforeLeave:Qo,onLeave:Qo,onAfterLeave:Qo,onLeaveCancelled:Qo,onBeforeAppear:Qo,onAppear:Qo,onAfterAppear:Qo,onAppearCancelled:Qo},setup(t,{slots:e}){const n=Rt(),s=DF();let r;return()=>{const o=e.default&&tC(e.default(),!0);if(!o||!o.length)return;let a=o[0];if(o.length>1){for(const m of o)if(m.type!==Gr){a=m;break}}const i=fn(t),{mode:l}=i;if(s.isLeaving)return A4(a);const u=c5(a);if(!u)return A4(a);const c=C0(u,i,s,n);k0(u,c);const d=n.subTree,f=d&&c5(d);let h=!1;const{getTransitionKey:p}=u.type;if(p){const m=p();r===void 0?r=m:m!==r&&(r=m,h=!0)}if(f&&f.type!==Gr&&(!Pc(u,f)||h)){const m=C0(f,i,s,n);if(k0(f,m),l==="out-in")return s.isLeaving=!0,m.afterLeave=()=>{s.isLeaving=!1,n.update.active!==!1&&n.update()},A4(a);l==="in-out"&&u.type!==Gr&&(m.delayLeave=(g,y,w)=>{const b=MF(s,f);b[String(f.key)]=f,g._leaveCb=()=>{y(),g._leaveCb=void 0,delete c.delayedLeave},c.delayedLeave=w})}return a}}},FF=Eee;function MF(t,e){const{leavingVNodes:n}=t;let s=n.get(e.type);return s||(s=Object.create(null),n.set(e.type,s)),s}function C0(t,e,n,s){const{appear:r,mode:o,persisted:a=!1,onBeforeEnter:i,onEnter:l,onAfterEnter:u,onEnterCancelled:c,onBeforeLeave:d,onLeave:f,onAfterLeave:h,onLeaveCancelled:p,onBeforeAppear:m,onAppear:g,onAfterAppear:y,onAppearCancelled:w}=e,b=String(t.key),_=MF(n,t),$=(C,T)=>{C&&va(C,s,9,T)},x=(C,T)=>{const N=T[1];$(C,T),Qe(C)?C.every(M=>M.length<=1)&&N():C.length<=1&&N()},k={mode:o,persisted:a,beforeEnter(C){let T=i;if(!n.isMounted)if(r)T=m||i;else return;C._leaveCb&&C._leaveCb(!0);const N=_[b];N&&Pc(t,N)&&N.el._leaveCb&&N.el._leaveCb(),$(T,[C])},enter(C){let T=l,N=u,M=c;if(!n.isMounted)if(r)T=g||l,N=y||u,M=w||c;else return;let R=!1;const D=C._enterCb=z=>{R||(R=!0,z?$(M,[C]):$(N,[C]),k.delayedLeave&&k.delayedLeave(),C._enterCb=void 0)};T?x(T,[C,D]):D()},leave(C,T){const N=String(t.key);if(C._enterCb&&C._enterCb(!0),n.isUnmounting)return T();$(d,[C]);let M=!1;const R=C._leaveCb=D=>{M||(M=!0,T(),D?$(p,[C]):$(h,[C]),C._leaveCb=void 0,_[N]===t&&delete _[N])};_[N]=t,f?x(f,[C,R]):R()},clone(C){return C0(C,e,n,s)}};return k}function A4(t){if(Kb(t))return t=_l(t),t.children=null,t}function c5(t){return Kb(t)?t.children?t.children[0]:void 0:t}function k0(t,e){t.shapeFlag&6&&t.component?k0(t.component.subTree,e):t.shapeFlag&128?(t.ssContent.transition=e.clone(t.ssContent),t.ssFallback.transition=e.clone(t.ssFallback)):t.transition=e}function tC(t,e=!1,n){let s=[],r=0;for(let o=0;o<t.length;o++){let a=t[o];const i=n==null?a.key:String(n)+String(a.key!=null?a.key:o);a.type===lt?(a.patchFlag&128&&r++,s=s.concat(tC(a.children,e,i))):(e||a.type!==Gr)&&s.push(i!=null?_l(a,{key:i}):a)}if(r>1)for(let o=0;o<s.length;o++)s[o].patchFlag=-2;return s}function ue(t){return vt(t)?{setup:t,name:t.name}:t}const e0=t=>!!t.type.__asyncLoader,Kb=t=>t.type.__isKeepAlive;function Aee(t,e){LF(t,"a",e)}function PF(t,e){LF(t,"da",e)}function LF(t,e,n=Js){const s=t.__wdc||(t.__wdc=()=>{let r=n;for(;r;){if(r.isDeactivated)return;r=r.parent}return t()});if(qb(e,s,n),n){let r=n.parent;for(;r&&r.parent;)Kb(r.parent.vnode)&&Oee(s,e,n,r),r=r.parent}}function Oee(t,e,n,s){const r=qb(e,t,s,!0);Xd(()=>{HS(s[e],r)},n)}function qb(t,e,n=Js,s=!1){if(n){const r=n[t]||(n[t]=[]),o=e.__weh||(e.__weh=(...a)=>{if(n.isUnmounted)return;Kh(),oh(n);const i=va(e,n,t,a);return sd(),qh(),i});return s?r.unshift(o):r.push(o),o}}const Fl=t=>(e,n=Js)=>(!N0||t==="sp")&&qb(t,(...s)=>e(...s),n),Xb=Fl("bm"),It=Fl("m"),zF=Fl("bu"),Ml=Fl("u"),ts=Fl("bum"),Xd=Fl("um"),Ree=Fl("sp"),Dee=Fl("rtg"),Fee=Fl("rtc");function Mee(t,e=Js){qb("ec",t,e)}function St(t,e){const n=gr;if(n===null)return t;const s=Jb(n)||n.proxy,r=t.dirs||(t.dirs=[]);for(let o=0;o<e.length;o++){let[a,i,l,u=rs]=e[o];a&&(vt(a)&&(a={mounted:a,updated:a}),a.deep&&Gc(i),r.push({dir:a,instance:s,value:i,oldValue:void 0,arg:l,modifiers:u}))}return t}function xc(t,e,n,s){const r=t.dirs,o=e&&e.dirs;for(let a=0;a<r.length;a++){const i=r[a];o&&(i.oldValue=o[a].value);let l=i.dir[s];l&&(Kh(),va(l,n,8,[t.el,i,t,e]),qh())}}const nC="components",Pee="directives";function pt(t,e){return sC(nC,t,!0,e)||t}const BF=Symbol();function Vt(t){return wt(t)?sC(nC,t,!1)||t:t||BF}function rh(t){return sC(Pee,t)}function sC(t,e,n=!0,s=!1){const r=gr||Js;if(r){const o=r.type;if(t===nC){const i=hte(o,!1);if(i&&(i===e||i===wa(e)||i===Sg(wa(e))))return o}const a=d5(r[t]||o[t],e)||d5(r.appContext[t],e);return!a&&s?o:a}}function d5(t,e){return t&&(t[e]||t[wa(e)]||t[Sg(wa(e))])}function Gt(t,e,n,s){let r;const o=n&&n[s];if(Qe(t)||wt(t)){r=new Array(t.length);for(let a=0,i=t.length;a<i;a++)r[a]=e(t[a],a,void 0,o&&o[a])}else if(typeof t=="number"){r=new Array(t);for(let a=0;a<t;a++)r[a]=e(a+1,a,void 0,o&&o[a])}else if(Bt(t))if(t[Symbol.iterator])r=Array.from(t,(a,i)=>e(a,i,void 0,o&&o[i]));else{const a=Object.keys(t);r=new Array(a.length);for(let i=0,l=a.length;i<l;i++){const u=a[i];r[i]=e(t[u],u,i,o&&o[i])}}else r=[];return n&&(n[s]=r),r}function Uu(t,e){for(let n=0;n<e.length;n++){const s=e[n];if(Qe(s))for(let r=0;r<s.length;r++)t[s[r].name]=s[r].fn;else s&&(t[s.name]=s.key?(...r)=>{const o=s.fn(...r);return o&&(o.key=s.key),o}:s.fn)}return t}function Oe(t,e,n={},s,r){if(gr.isCE||gr.parent&&e0(gr.parent)&&gr.parent.isCE)return e!=="default"&&(n.name=e),se("slot",n,s&&s());let o=t[e];o&&o._c&&(o._d=!1),S();const a=o&&VF(o(n)),i=$e(lt,{key:n.key||a&&a.key||`_${e}`},a||(s?s():[]),a&&t._===1?64:-2);return!r&&i.scopeId&&(i.slotScopeIds=[i.scopeId+"-s"]),o&&o._c&&(o._d=!0),i}function VF(t){return t.some(e=>Bn(e)?!(e.type===Gr||e.type===lt&&!VF(e.children)):!0)?t:null}function Lee(t,e){const n={};for(const s in t)n[e&&/[A-Z]/.test(s)?`on:${s}`:Pv(s)]=t[s];return n}const Y$=t=>t?JF(t)?Jb(t)||t.proxy:Y$(t.parent):null,t0=rr(Object.create(null),{$:t=>t,$el:t=>t.vnode.el,$data:t=>t.data,$props:t=>t.props,$attrs:t=>t.attrs,$slots:t=>t.slots,$refs:t=>t.refs,$parent:t=>Y$(t.parent),$root:t=>Y$(t.root),$emit:t=>t.emit,$options:t=>rC(t),$forceUpdate:t=>t.f||(t.f=()=>QS(t.update)),$nextTick:t=>t.n||(t.n=nt.bind(t.proxy)),$watch:t=>Iee.bind(t)}),O4=(t,e)=>t!==rs&&!t.__isScriptSetup&&Ut(t,e),zee={get({_:t},e){const{ctx:n,setupState:s,data:r,props:o,accessCache:a,type:i,appContext:l}=t;let u;if(e[0]!=="$"){const h=a[e];if(h!==void 0)switch(h){case 1:return s[e];case 2:return r[e];case 4:return n[e];case 3:return o[e]}else{if(O4(s,e))return a[e]=1,s[e];if(r!==rs&&Ut(r,e))return a[e]=2,r[e];if((u=t.propsOptions[0])&&Ut(u,e))return a[e]=3,o[e];if(n!==rs&&Ut(n,e))return a[e]=4,n[e];Z$&&(a[e]=0)}}const c=t0[e];let d,f;if(c)return e==="$attrs"&&jo(t,"get",e),c(t);if((d=i.__cssModules)&&(d=d[e]))return d;if(n!==rs&&Ut(n,e))return a[e]=4,n[e];if(f=l.config.globalProperties,Ut(f,e))return f[e]},set({_:t},e,n){const{data:s,setupState:r,ctx:o}=t;return O4(r,e)?(r[e]=n,!0):s!==rs&&Ut(s,e)?(s[e]=n,!0):Ut(t.props,e)||e[0]==="$"&&e.slice(1)in t?!1:(o[e]=n,!0)},has({_:{data:t,setupState:e,accessCache:n,ctx:s,appContext:r,propsOptions:o}},a){let i;return!!n[a]||t!==rs&&Ut(t,a)||O4(e,a)||(i=o[0])&&Ut(i,a)||Ut(s,a)||Ut(t0,a)||Ut(r.config.globalProperties,a)},defineProperty(t,e,n){return n.get!=null?t._.accessCache[e]=0:Ut(n,"value")&&this.set(t,e,n.value,null),Reflect.defineProperty(t,e,n)}};let Z$=!0;function Bee(t){const e=rC(t),n=t.proxy,s=t.ctx;Z$=!1,e.beforeCreate&&f5(e.beforeCreate,t,"bc");const{data:r,computed:o,methods:a,watch:i,provide:l,inject:u,created:c,beforeMount:d,mounted:f,beforeUpdate:h,updated:p,activated:m,deactivated:g,beforeDestroy:y,beforeUnmount:w,destroyed:b,unmounted:_,render:$,renderTracked:x,renderTriggered:k,errorCaptured:C,serverPrefetch:T,expose:N,inheritAttrs:M,components:R,directives:D,filters:z}=e;if(u&&Vee(u,s,null,t.appContext.config.unwrapInjectedRef),a)for(const O in a){const F=a[O];vt(F)&&(s[O]=F.bind(n))}if(r){const O=r.call(n,n);Bt(O)&&(t.data=on(O))}if(Z$=!0,o)for(const O in o){const F=o[O],L=vt(F)?F.bind(n,n):vt(F.get)?F.get.bind(n,n):gn,G=!vt(F)&&vt(F.set)?F.set.bind(n):gn,Z=A({get:L,set:G});Object.defineProperty(s,O,{enumerable:!0,configurable:!0,get:()=>Z.value,set:j=>Z.value=j})}if(i)for(const O in i)HF(i[O],s,n,O);if(l){const O=vt(l)?l.call(n):l;Reflect.ownKeys(O).forEach(F=>{Lt(F,O[F])})}c&&f5(c,t,"c");function V(O,F){Qe(F)?F.forEach(L=>O(L.bind(n))):F&&O(F.bind(n))}if(V(Xb,d),V(It,f),V(zF,h),V(Ml,p),V(Aee,m),V(PF,g),V(Mee,C),V(Fee,x),V(Dee,k),V(ts,w),V(Xd,_),V(Ree,T),Qe(N))if(N.length){const O=t.exposed||(t.exposed={});N.forEach(F=>{Object.defineProperty(O,F,{get:()=>n[F],set:L=>n[F]=L})})}else t.exposed||(t.exposed={});$&&t.render===gn&&(t.render=$),M!=null&&(t.inheritAttrs=M),R&&(t.components=R),D&&(t.directives=D)}function Vee(t,e,n=gn,s=!1){Qe(t)&&(t=J$(t));for(const r in t){const o=t[r];let a;Bt(o)?"default"in o?a=et(o.from||r,o.default,!0):a=et(o.from||r):a=et(o),kn(a)&&s?Object.defineProperty(e,r,{enumerable:!0,configurable:!0,get:()=>a.value,set:i=>a.value=i}):e[r]=a}}function f5(t,e,n){va(Qe(t)?t.map(s=>s.bind(e.proxy)):t.bind(e.proxy),e,n)}function HF(t,e,n,s){const r=s.includes(".")?RF(n,s):()=>n[s];if(wt(t)){const o=e[t];vt(o)&&Me(r,o)}else if(vt(t))Me(r,t.bind(n));else if(Bt(t))if(Qe(t))t.forEach(o=>HF(o,e,n,s));else{const o=vt(t.handler)?t.handler.bind(n):e[t.handler];vt(o)&&Me(r,o,t)}}function rC(t){const e=t.type,{mixins:n,extends:s}=e,{mixins:r,optionsCache:o,config:{optionMergeStrategies:a}}=t.appContext,i=o.get(e);let l;return i?l=i:!r.length&&!n&&!s?l=e:(l={},r.length&&r.forEach(u=>xy(l,u,a,!0)),xy(l,e,a)),Bt(e)&&o.set(e,l),l}function xy(t,e,n,s=!1){const{mixins:r,extends:o}=e;o&&xy(t,o,n,!0),r&&r.forEach(a=>xy(t,a,n,!0));for(const a in e)if(!(s&&a==="expose")){const i=Hee[a]||n&&n[a];t[a]=i?i(t[a],e[a]):e[a]}return t}const Hee={data:h5,props:Ac,emits:Ac,methods:Ac,computed:Ac,beforeCreate:Hr,created:Hr,beforeMount:Hr,mounted:Hr,beforeUpdate:Hr,updated:Hr,beforeDestroy:Hr,beforeUnmount:Hr,destroyed:Hr,unmounted:Hr,activated:Hr,deactivated:Hr,errorCaptured:Hr,serverPrefetch:Hr,components:Ac,directives:Ac,watch:Uee,provide:h5,inject:Wee};function h5(t,e){return e?t?function(){return rr(vt(t)?t.call(this,this):t,vt(e)?e.call(this,this):e)}:e:t}function Wee(t,e){return Ac(J$(t),J$(e))}function J$(t){if(Qe(t)){const e={};for(let n=0;n<t.length;n++)e[t[n]]=t[n];return e}return t}function Hr(t,e){return t?[...new Set([].concat(t,e))]:e}function Ac(t,e){return t?rr(rr(Object.create(null),t),e):e}function Uee(t,e){if(!t)return e;if(!e)return t;const n=rr(Object.create(null),t);for(const s in e)n[s]=Hr(t[s],e[s]);return n}function Gee(t,e,n,s=!1){const r={},o={};wy(o,Yb,1),t.propsDefaults=Object.create(null),WF(t,e,r,o);for(const a in t.propsOptions[0])a in r||(r[a]=void 0);n?t.props=s?r:_F(r):t.type.props?t.props=r:t.props=o,t.attrs=o}function jee(t,e,n,s){const{props:r,attrs:o,vnode:{patchFlag:a}}=t,i=fn(r),[l]=t.propsOptions;let u=!1;if((s||a>0)&&!(a&16)){if(a&8){const c=t.vnode.dynamicProps;for(let d=0;d<c.length;d++){let f=c[d];if(Gb(t.emitsOptions,f))continue;const h=e[f];if(l)if(Ut(o,f))h!==o[f]&&(o[f]=h,u=!0);else{const p=wa(f);r[p]=Q$(l,i,p,h,t,!1)}else h!==o[f]&&(o[f]=h,u=!0)}}}else{WF(t,e,r,o)&&(u=!0);let c;for(const d in i)(!e||!Ut(e,d)&&((c=ac(d))===d||!Ut(e,c)))&&(l?n&&(n[d]!==void 0||n[c]!==void 0)&&(r[d]=Q$(l,i,d,void 0,t,!0)):delete r[d]);if(o!==i)for(const d in o)(!e||!Ut(e,d)&&!0)&&(delete o[d],u=!0)}u&&wl(t,"set","$attrs")}function WF(t,e,n,s){const[r,o]=t.propsOptions;let a=!1,i;if(e)for(let l in e){if(Mv(l))continue;const u=e[l];let c;r&&Ut(r,c=wa(l))?!o||!o.includes(c)?n[c]=u:(i||(i={}))[c]=u:Gb(t.emitsOptions,l)||(!(l in s)||u!==s[l])&&(s[l]=u,a=!0)}if(o){const l=fn(n),u=i||rs;for(let c=0;c<o.length;c++){const d=o[c];n[d]=Q$(r,l,d,u[d],t,!Ut(u,d))}}return a}function Q$(t,e,n,s,r,o){const a=t[n];if(a!=null){const i=Ut(a,"default");if(i&&s===void 0){const l=a.default;if(a.type!==Function&&vt(l)){const{propsDefaults:u}=r;n in u?s=u[n]:(oh(r),s=u[n]=l.call(null,e),sd())}else s=l}a[0]&&(o&&!i?s=!1:a[1]&&(s===""||s===ac(n))&&(s=!0))}return s}function UF(t,e,n=!1){const s=e.propsCache,r=s.get(t);if(r)return r;const o=t.props,a={},i=[];let l=!1;if(!vt(t)){const c=d=>{l=!0;const[f,h]=UF(d,e,!0);rr(a,f),h&&i.push(...h)};!n&&e.mixins.length&&e.mixins.forEach(c),t.extends&&c(t.extends),t.mixins&&t.mixins.forEach(c)}if(!o&&!l)return Bt(t)&&s.set(t,Bf),Bf;if(Qe(o))for(let c=0;c<o.length;c++){const d=wa(o[c]);p5(d)&&(a[d]=rs)}else if(o)for(const c in o){const d=wa(c);if(p5(d)){const f=o[c],h=a[d]=Qe(f)||vt(f)?{type:f}:Object.assign({},f);if(h){const p=v5(Boolean,h.type),m=v5(String,h.type);h[0]=p>-1,h[1]=m<0||p<m,(p>-1||Ut(h,"default"))&&i.push(d)}}}const u=[a,i];return Bt(t)&&s.set(t,u),u}function p5(t){return t[0]!=="$"}function m5(t){const e=t&&t.toString().match(/^\s*function (\w+)/);return e?e[1]:t===null?"null":""}function g5(t,e){return m5(t)===m5(e)}function v5(t,e){return Qe(e)?e.findIndex(n=>g5(n,t)):vt(e)&&g5(e,t)?0:-1}const GF=t=>t[0]==="_"||t==="$stable",oC=t=>Qe(t)?t.map(pi):[pi(t)],Kee=(t,e,n)=>{if(e._n)return e;const s=ce((...r)=>oC(e(...r)),n);return s._c=!1,s},jF=(t,e,n)=>{const s=t._ctx;for(const r in t){if(GF(r))continue;const o=t[r];if(vt(o))e[r]=Kee(r,o,s);else if(o!=null){const a=oC(o);e[r]=()=>a}}},KF=(t,e)=>{const n=oC(e);t.slots.default=()=>n},qee=(t,e)=>{if(t.vnode.shapeFlag&32){const n=e._;n?(t.slots=fn(e),wy(e,"_",n)):jF(e,t.slots={})}else t.slots={},e&&KF(t,e);wy(t.slots,Yb,1)},Xee=(t,e,n)=>{const{vnode:s,slots:r}=t;let o=!0,a=rs;if(s.shapeFlag&32){const i=e._;i?n&&i===1?o=!1:(rr(r,e),!n&&i===1&&delete r._):(o=!e.$stable,jF(e,r)),a=e}else e&&(KF(t,e),a={default:1});if(o)for(const i in r)!GF(i)&&!(i in a)&&delete r[i]};function qF(){return{app:null,config:{isNativeTag:EQ,performance:!1,globalProperties:{},optionMergeStrategies:{},errorHandler:void 0,warnHandler:void 0,compilerOptions:{}},mixins:[],components:{},directives:{},provides:Object.create(null),optionsCache:new WeakMap,propsCache:new WeakMap,emitsCache:new WeakMap}}let Yee=0;function Zee(t,e){return function(s,r=null){vt(s)||(s=Object.assign({},s)),r!=null&&!Bt(r)&&(r=null);const o=qF(),a=new Set;let i=!1;const l=o.app={_uid:Yee++,_component:s,_props:r,_container:null,_context:o,_instance:null,version:vte,get config(){return o.config},set config(u){},use(u,...c){return a.has(u)||(u&&vt(u.install)?(a.add(u),u.install(l,...c)):vt(u)&&(a.add(u),u(l,...c))),l},mixin(u){return o.mixins.includes(u)||o.mixins.push(u),l},component(u,c){return c?(o.components[u]=c,l):o.components[u]},directive(u,c){return c?(o.directives[u]=c,l):o.directives[u]},mount(u,c,d){if(!i){const f=se(s,r);return f.appContext=o,c&&e?e(f,u):t(f,u,d),i=!0,l._container=u,u.__vue_app__=l,Jb(f.component)||f.component.proxy}},unmount(){i&&(t(null,l._container),delete l._container.__vue_app__)},provide(u,c){return o.provides[u]=c,l}};return l}}function e6(t,e,n,s,r=!1){if(Qe(t)){t.forEach((f,h)=>e6(f,e&&(Qe(e)?e[h]:e),n,s,r));return}if(e0(s)&&!r)return;const o=s.shapeFlag&4?Jb(s.component)||s.component.proxy:s.el,a=r?null:o,{i,r:l}=t,u=e&&e.r,c=i.refs===rs?i.refs={}:i.refs,d=i.setupState;if(u!=null&&u!==l&&(wt(u)?(c[u]=null,Ut(d,u)&&(d[u]=null)):kn(u)&&(u.value=null)),vt(l))Ru(l,i,12,[a,c]);else{const f=wt(l),h=kn(l);if(f||h){const p=()=>{if(t.f){const m=f?Ut(d,l)?d[l]:c[l]:l.value;r?Qe(m)&&HS(m,o):Qe(m)?m.includes(o)||m.push(o):f?(c[l]=[o],Ut(d,l)&&(d[l]=c[l])):(l.value=[o],t.k&&(c[t.k]=l.value))}else f?(c[l]=a,Ut(d,l)&&(d[l]=a)):h&&(l.value=a,t.k&&(c[t.k]=a))};a?(p.id=-1,ao(p,n)):p()}}}const ao=Nee;function Jee(t){return Qee(t)}function Qee(t,e){const n=FQ();n.__VUE__=!0;const{insert:s,remove:r,patchProp:o,createElement:a,createText:i,createComment:l,setText:u,setElementText:c,parentNode:d,nextSibling:f,setScopeId:h=gn,insertStaticContent:p}=t,m=(K,re,we,Ee=null,De=null,_e=null,ze=!1,Ae=null,he=!!re.dynamicChildren)=>{if(K===re)return;K&&!Pc(K,re)&&(Ee=ee(K),j(K,De,_e,!0),K=null),re.patchFlag===-2&&(he=!1,re.dynamicChildren=null);const{type:ve,ref:me,shapeFlag:Ve}=re;switch(ve){case Xh:g(K,re,we,Ee);break;case Gr:y(K,re,we,Ee);break;case zv:K==null&&w(re,we,Ee,ze);break;case lt:R(K,re,we,Ee,De,_e,ze,Ae,he);break;default:Ve&1?$(K,re,we,Ee,De,_e,ze,Ae,he):Ve&6?D(K,re,we,Ee,De,_e,ze,Ae,he):(Ve&64||Ve&128)&&ve.process(K,re,we,Ee,De,_e,ze,Ae,he,ie)}me!=null&&De&&e6(me,K&&K.ref,_e,re||K,!re)},g=(K,re,we,Ee)=>{if(K==null)s(re.el=i(re.children),we,Ee);else{const De=re.el=K.el;re.children!==K.children&&u(De,re.children)}},y=(K,re,we,Ee)=>{K==null?s(re.el=l(re.children||""),we,Ee):re.el=K.el},w=(K,re,we,Ee)=>{[K.el,K.anchor]=p(K.children,re,we,Ee,K.el,K.anchor)},b=({el:K,anchor:re},we,Ee)=>{let De;for(;K&&K!==re;)De=f(K),s(K,we,Ee),K=De;s(re,we,Ee)},_=({el:K,anchor:re})=>{let we;for(;K&&K!==re;)we=f(K),r(K),K=we;r(re)},$=(K,re,we,Ee,De,_e,ze,Ae,he)=>{ze=ze||re.type==="svg",K==null?x(re,we,Ee,De,_e,ze,Ae,he):T(K,re,De,_e,ze,Ae,he)},x=(K,re,we,Ee,De,_e,ze,Ae)=>{let he,ve;const{type:me,props:Ve,shapeFlag:Ye,transition:Je,dirs:ct}=K;if(he=K.el=a(K.type,_e,Ve&&Ve.is,Ve),Ye&8?c(he,K.children):Ye&16&&C(K.children,he,null,Ee,De,_e&&me!=="foreignObject",ze,Ae),ct&&xc(K,null,Ee,"created"),Ve){for(const dt in Ve)dt!=="value"&&!Mv(dt)&&o(he,dt,null,Ve[dt],_e,K.children,Ee,De,oe);"value"in Ve&&o(he,"value",null,Ve.value),(ve=Ve.onVnodeBeforeMount)&&hi(ve,Ee,K)}k(he,K,K.scopeId,ze,Ee),ct&&xc(K,null,Ee,"beforeMount");const xt=(!De||De&&!De.pendingBranch)&&Je&&!Je.persisted;xt&&Je.beforeEnter(he),s(he,re,we),((ve=Ve&&Ve.onVnodeMounted)||xt||ct)&&ao(()=>{ve&&hi(ve,Ee,K),xt&&Je.enter(he),ct&&xc(K,null,Ee,"mounted")},De)},k=(K,re,we,Ee,De)=>{if(we&&h(K,we),Ee)for(let _e=0;_e<Ee.length;_e++)h(K,Ee[_e]);if(De){let _e=De.subTree;if(re===_e){const ze=De.vnode;k(K,ze,ze.scopeId,ze.slotScopeIds,De.parent)}}},C=(K,re,we,Ee,De,_e,ze,Ae,he=0)=>{for(let ve=he;ve<K.length;ve++){const me=K[ve]=Ae?vu(K[ve]):pi(K[ve]);m(null,me,re,we,Ee,De,_e,ze,Ae)}},T=(K,re,we,Ee,De,_e,ze)=>{const Ae=re.el=K.el;let{patchFlag:he,dynamicChildren:ve,dirs:me}=re;he|=K.patchFlag&16;const Ve=K.props||rs,Ye=re.props||rs;let Je;we&&Sc(we,!1),(Je=Ye.onVnodeBeforeUpdate)&&hi(Je,we,re,K),me&&xc(re,K,we,"beforeUpdate"),we&&Sc(we,!0);const ct=De&&re.type!=="foreignObject";if(ve?N(K.dynamicChildren,ve,Ae,we,Ee,ct,_e):ze||F(K,re,Ae,null,we,Ee,ct,_e,!1),he>0){if(he&16)M(Ae,re,Ve,Ye,we,Ee,De);else if(he&2&&Ve.class!==Ye.class&&o(Ae,"class",null,Ye.class,De),he&4&&o(Ae,"style",Ve.style,Ye.style,De),he&8){const xt=re.dynamicProps;for(let dt=0;dt<xt.length;dt++){const xe=xt[dt],Ke=Ve[xe],at=Ye[xe];(at!==Ke||xe==="value")&&o(Ae,xe,Ke,at,De,K.children,we,Ee,oe)}}he&1&&K.children!==re.children&&c(Ae,re.children)}else!ze&&ve==null&&M(Ae,re,Ve,Ye,we,Ee,De);((Je=Ye.onVnodeUpdated)||me)&&ao(()=>{Je&&hi(Je,we,re,K),me&&xc(re,K,we,"updated")},Ee)},N=(K,re,we,Ee,De,_e,ze)=>{for(let Ae=0;Ae<re.length;Ae++){const he=K[Ae],ve=re[Ae],me=he.el&&(he.type===lt||!Pc(he,ve)||he.shapeFlag&70)?d(he.el):we;m(he,ve,me,null,Ee,De,_e,ze,!0)}},M=(K,re,we,Ee,De,_e,ze)=>{if(we!==Ee){if(we!==rs)for(const Ae in we)!Mv(Ae)&&!(Ae in Ee)&&o(K,Ae,we[Ae],null,ze,re.children,De,_e,oe);for(const Ae in Ee){if(Mv(Ae))continue;const he=Ee[Ae],ve=we[Ae];he!==ve&&Ae!=="value"&&o(K,Ae,ve,he,ze,re.children,De,_e,oe)}"value"in Ee&&o(K,"value",we.value,Ee.value)}},R=(K,re,we,Ee,De,_e,ze,Ae,he)=>{const ve=re.el=K?K.el:i(""),me=re.anchor=K?K.anchor:i("");let{patchFlag:Ve,dynamicChildren:Ye,slotScopeIds:Je}=re;Je&&(Ae=Ae?Ae.concat(Je):Je),K==null?(s(ve,we,Ee),s(me,we,Ee),C(re.children,we,me,De,_e,ze,Ae,he)):Ve>0&&Ve&64&&Ye&&K.dynamicChildren?(N(K.dynamicChildren,Ye,we,De,_e,ze,Ae),(re.key!=null||De&&re===De.subTree)&&aC(K,re,!0)):F(K,re,we,me,De,_e,ze,Ae,he)},D=(K,re,we,Ee,De,_e,ze,Ae,he)=>{re.slotScopeIds=Ae,K==null?re.shapeFlag&512?De.ctx.activate(re,we,Ee,ze,he):z(re,we,Ee,De,_e,ze,he):B(K,re,he)},z=(K,re,we,Ee,De,_e,ze)=>{const Ae=K.component=ute(K,Ee,De);if(Kb(K)&&(Ae.ctx.renderer=ie),cte(Ae),Ae.asyncDep){if(De&&De.registerDep(Ae,V),!K.el){const he=Ae.subTree=se(Gr);y(null,he,re,we)}return}V(Ae,K,re,we,De,_e,ze)},B=(K,re,we)=>{const Ee=re.component=K.component;if(Cee(K,re,we))if(Ee.asyncDep&&!Ee.asyncResolved){O(Ee,re,we);return}else Ee.next=re,vee(Ee.update),Ee.update();else re.el=K.el,Ee.vnode=re},V=(K,re,we,Ee,De,_e,ze)=>{const Ae=()=>{if(K.isMounted){let{next:me,bu:Ve,u:Ye,parent:Je,vnode:ct}=K,xt=me,dt;Sc(K,!1),me?(me.el=ct.el,O(K,me,ze)):me=ct,Ve&&Lv(Ve),(dt=me.props&&me.props.onVnodeBeforeUpdate)&&hi(dt,Je,me,ct),Sc(K,!0);const xe=E4(K),Ke=K.subTree;K.subTree=xe,m(Ke,xe,d(Ke.el),ee(Ke),K,De,_e),me.el=xe.el,xt===null&&kee(K,xe.el),Ye&&ao(Ye,De),(dt=me.props&&me.props.onVnodeUpdated)&&ao(()=>hi(dt,Je,me,ct),De)}else{let me;const{el:Ve,props:Ye}=re,{bm:Je,m:ct,parent:xt}=K,dt=e0(re);if(Sc(K,!1),Je&&Lv(Je),!dt&&(me=Ye&&Ye.onVnodeBeforeMount)&&hi(me,xt,re),Sc(K,!0),Ve&&Re){const xe=()=>{K.subTree=E4(K),Re(Ve,K.subTree,K,De,null)};dt?re.type.__asyncLoader().then(()=>!K.isUnmounted&&xe()):xe()}else{const xe=K.subTree=E4(K);m(null,xe,we,Ee,K,De,_e),re.el=xe.el}if(ct&&ao(ct,De),!dt&&(me=Ye&&Ye.onVnodeMounted)){const xe=re;ao(()=>hi(me,xt,xe),De)}(re.shapeFlag&256||xt&&e0(xt.vnode)&&xt.vnode.shapeFlag&256)&&K.a&&ao(K.a,De),K.isMounted=!0,re=we=Ee=null}},he=K.effect=new GS(Ae,()=>QS(ve),K.scope),ve=K.update=()=>he.run();ve.id=K.uid,Sc(K,!0),ve()},O=(K,re,we)=>{re.component=K;const Ee=K.vnode.props;K.vnode=re,K.next=null,jee(K,re.props,Ee,we),Xee(K,re.children,we),Kh(),l5(),qh()},F=(K,re,we,Ee,De,_e,ze,Ae,he=!1)=>{const ve=K&&K.children,me=K?K.shapeFlag:0,Ve=re.children,{patchFlag:Ye,shapeFlag:Je}=re;if(Ye>0){if(Ye&128){G(ve,Ve,we,Ee,De,_e,ze,Ae,he);return}else if(Ye&256){L(ve,Ve,we,Ee,De,_e,ze,Ae,he);return}}Je&8?(me&16&&oe(ve,De,_e),Ve!==ve&&c(we,Ve)):me&16?Je&16?G(ve,Ve,we,Ee,De,_e,ze,Ae,he):oe(ve,De,_e,!0):(me&8&&c(we,""),Je&16&&C(Ve,we,Ee,De,_e,ze,Ae,he))},L=(K,re,we,Ee,De,_e,ze,Ae,he)=>{K=K||Bf,re=re||Bf;const ve=K.length,me=re.length,Ve=Math.min(ve,me);let Ye;for(Ye=0;Ye<Ve;Ye++){const Je=re[Ye]=he?vu(re[Ye]):pi(re[Ye]);m(K[Ye],Je,we,null,De,_e,ze,Ae,he)}ve>me?oe(K,De,_e,!0,!1,Ve):C(re,we,Ee,De,_e,ze,Ae,he,Ve)},G=(K,re,we,Ee,De,_e,ze,Ae,he)=>{let ve=0;const me=re.length;let Ve=K.length-1,Ye=me-1;for(;ve<=Ve&&ve<=Ye;){const Je=K[ve],ct=re[ve]=he?vu(re[ve]):pi(re[ve]);if(Pc(Je,ct))m(Je,ct,we,null,De,_e,ze,Ae,he);else break;ve++}for(;ve<=Ve&&ve<=Ye;){const Je=K[Ve],ct=re[Ye]=he?vu(re[Ye]):pi(re[Ye]);if(Pc(Je,ct))m(Je,ct,we,null,De,_e,ze,Ae,he);else break;Ve--,Ye--}if(ve>Ve){if(ve<=Ye){const Je=Ye+1,ct=Je<me?re[Je].el:Ee;for(;ve<=Ye;)m(null,re[ve]=he?vu(re[ve]):pi(re[ve]),we,ct,De,_e,ze,Ae,he),ve++}}else if(ve>Ye)for(;ve<=Ve;)j(K[ve],De,_e,!0),ve++;else{const Je=ve,ct=ve,xt=new Map;for(ve=ct;ve<=Ye;ve++){const We=re[ve]=he?vu(re[ve]):pi(re[ve]);We.key!=null&&xt.set(We.key,ve)}let dt,xe=0;const Ke=Ye-ct+1;let at=!1,Y=0;const de=new Array(Ke);for(ve=0;ve<Ke;ve++)de[ve]=0;for(ve=Je;ve<=Ve;ve++){const We=K[ve];if(xe>=Ke){j(We,De,_e,!0);continue}let Ft;if(We.key!=null)Ft=xt.get(We.key);else for(dt=ct;dt<=Ye;dt++)if(de[dt-ct]===0&&Pc(We,re[dt])){Ft=dt;break}Ft===void 0?j(We,De,_e,!0):(de[Ft-ct]=ve+1,Ft>=Y?Y=Ft:at=!0,m(We,re[Ft],we,null,De,_e,ze,Ae,he),xe++)}const Pe=at?ete(de):Bf;for(dt=Pe.length-1,ve=Ke-1;ve>=0;ve--){const We=ct+ve,Ft=re[We],_n=We+1<me?re[We+1].el:Ee;de[ve]===0?m(null,Ft,we,_n,De,_e,ze,Ae,he):at&&(dt<0||ve!==Pe[dt]?Z(Ft,we,_n,2):dt--)}}},Z=(K,re,we,Ee,De=null)=>{const{el:_e,type:ze,transition:Ae,children:he,shapeFlag:ve}=K;if(ve&6){Z(K.component.subTree,re,we,Ee);return}if(ve&128){K.suspense.move(re,we,Ee);return}if(ve&64){ze.move(K,re,we,ie);return}if(ze===lt){s(_e,re,we);for(let Ve=0;Ve<he.length;Ve++)Z(he[Ve],re,we,Ee);s(K.anchor,re,we);return}if(ze===zv){b(K,re,we);return}if(Ee!==2&&ve&1&&Ae)if(Ee===0)Ae.beforeEnter(_e),s(_e,re,we),ao(()=>Ae.enter(_e),De);else{const{leave:Ve,delayLeave:Ye,afterLeave:Je}=Ae,ct=()=>s(_e,re,we),xt=()=>{Ve(_e,()=>{ct(),Je&&Je()})};Ye?Ye(_e,ct,xt):xt()}else s(_e,re,we)},j=(K,re,we,Ee=!1,De=!1)=>{const{type:_e,props:ze,ref:Ae,children:he,dynamicChildren:ve,shapeFlag:me,patchFlag:Ve,dirs:Ye}=K;if(Ae!=null&&e6(Ae,null,we,K,!0),me&256){re.ctx.deactivate(K);return}const Je=me&1&&Ye,ct=!e0(K);let xt;if(ct&&(xt=ze&&ze.onVnodeBeforeUnmount)&&hi(xt,re,K),me&6)X(K.component,we,Ee);else{if(me&128){K.suspense.unmount(we,Ee);return}Je&&xc(K,null,re,"beforeUnmount"),me&64?K.type.remove(K,re,we,De,ie,Ee):ve&&(_e!==lt||Ve>0&&Ve&64)?oe(ve,re,we,!1,!0):(_e===lt&&Ve&384||!De&&me&16)&&oe(he,re,we),Ee&&J(K)}(ct&&(xt=ze&&ze.onVnodeUnmounted)||Je)&&ao(()=>{xt&&hi(xt,re,K),Je&&xc(K,null,re,"unmounted")},we)},J=K=>{const{type:re,el:we,anchor:Ee,transition:De}=K;if(re===lt){fe(we,Ee);return}if(re===zv){_(K);return}const _e=()=>{r(we),De&&!De.persisted&&De.afterLeave&&De.afterLeave()};if(K.shapeFlag&1&&De&&!De.persisted){const{leave:ze,delayLeave:Ae}=De,he=()=>ze(we,_e);Ae?Ae(K.el,_e,he):he()}else _e()},fe=(K,re)=>{let we;for(;K!==re;)we=f(K),r(K),K=we;r(re)},X=(K,re,we)=>{const{bum:Ee,scope:De,update:_e,subTree:ze,um:Ae}=K;Ee&&Lv(Ee),De.stop(),_e&&(_e.active=!1,j(ze,K,re,we)),Ae&&ao(Ae,re),ao(()=>{K.isUnmounted=!0},re),re&&re.pendingBranch&&!re.isUnmounted&&K.asyncDep&&!K.asyncResolved&&K.suspenseId===re.pendingId&&(re.deps--,re.deps===0&&re.resolve())},oe=(K,re,we,Ee=!1,De=!1,_e=0)=>{for(let ze=_e;ze<K.length;ze++)j(K[ze],re,we,Ee,De)},ee=K=>K.shapeFlag&6?ee(K.component.subTree):K.shapeFlag&128?K.suspense.next():f(K.anchor||K.el),Q=(K,re,we)=>{K==null?re._vnode&&j(re._vnode,null,null,!0):m(re._vnode||null,K,re,null,null,null,we),l5(),EF(),re._vnode=K},ie={p:m,um:j,m:Z,r:J,mt:z,mc:C,pc:F,pbc:N,n:ee,o:t};let pe,Re;return e&&([pe,Re]=e(ie)),{render:Q,hydrate:pe,createApp:Zee(Q,pe)}}function Sc({effect:t,update:e},n){t.allowRecurse=e.allowRecurse=n}function aC(t,e,n=!1){const s=t.children,r=e.children;if(Qe(s)&&Qe(r))for(let o=0;o<s.length;o++){const a=s[o];let i=r[o];i.shapeFlag&1&&!i.dynamicChildren&&((i.patchFlag<=0||i.patchFlag===32)&&(i=r[o]=vu(r[o]),i.el=a.el),n||aC(a,i)),i.type===Xh&&(i.el=a.el)}}function ete(t){const e=t.slice(),n=[0];let s,r,o,a,i;const l=t.length;for(s=0;s<l;s++){const u=t[s];if(u!==0){if(r=n[n.length-1],t[r]<u){e[s]=r,n.push(s);continue}for(o=0,a=n.length-1;o<a;)i=o+a>>1,t[n[i]]<u?o=i+1:a=i;u<t[n[o]]&&(o>0&&(e[s]=n[o-1]),n[o]=s)}}for(o=n.length,a=n[o-1];o-- >0;)n[o]=a,a=e[a];return n}const tte=t=>t.__isTeleport,n0=t=>t&&(t.disabled||t.disabled===""),y5=t=>typeof SVGElement<"u"&&t instanceof SVGElement,t6=(t,e)=>{const n=t&&t.to;return wt(n)?e?e(n):null:n},nte={__isTeleport:!0,process(t,e,n,s,r,o,a,i,l,u){const{mc:c,pc:d,pbc:f,o:{insert:h,querySelector:p,createText:m,createComment:g}}=u,y=n0(e.props);let{shapeFlag:w,children:b,dynamicChildren:_}=e;if(t==null){const $=e.el=m(""),x=e.anchor=m("");h($,n,s),h(x,n,s);const k=e.target=t6(e.props,p),C=e.targetAnchor=m("");k&&(h(C,k),a=a||y5(k));const T=(N,M)=>{w&16&&c(b,N,M,r,o,a,i,l)};y?T(n,x):k&&T(k,C)}else{e.el=t.el;const $=e.anchor=t.anchor,x=e.target=t.target,k=e.targetAnchor=t.targetAnchor,C=n0(t.props),T=C?n:x,N=C?$:k;if(a=a||y5(x),_?(f(t.dynamicChildren,_,T,r,o,a,i),aC(t,e,!0)):l||d(t,e,T,N,r,o,a,i,!1),y)C||J2(e,n,$,u,1);else if((e.props&&e.props.to)!==(t.props&&t.props.to)){const M=e.target=t6(e.props,p);M&&J2(e,M,null,u,0)}else C&&J2(e,x,k,u,1)}XF(e)},remove(t,e,n,s,{um:r,o:{remove:o}},a){const{shapeFlag:i,children:l,anchor:u,targetAnchor:c,target:d,props:f}=t;if(d&&o(c),(a||!n0(f))&&(o(u),i&16))for(let h=0;h<l.length;h++){const p=l[h];r(p,e,n,!0,!!p.dynamicChildren)}},move:J2,hydrate:ste};function J2(t,e,n,{o:{insert:s},m:r},o=2){o===0&&s(t.targetAnchor,e,n);const{el:a,anchor:i,shapeFlag:l,children:u,props:c}=t,d=o===2;if(d&&s(a,e,n),(!d||n0(c))&&l&16)for(let f=0;f<u.length;f++)r(u[f],e,n,2);d&&s(i,e,n)}function ste(t,e,n,s,r,o,{o:{nextSibling:a,parentNode:i,querySelector:l}},u){const c=e.target=t6(e.props,l);if(c){const d=c._lpa||c.firstChild;if(e.shapeFlag&16)if(n0(e.props))e.anchor=u(a(t),e,i(t),n,s,r,o),e.targetAnchor=d;else{e.anchor=a(t);let f=d;for(;f;)if(f=a(f),f&&f.nodeType===8&&f.data==="teleport anchor"){e.targetAnchor=f,c._lpa=e.targetAnchor&&a(e.targetAnchor);break}u(d,e,c,n,s,r,o)}XF(e)}return e.anchor&&a(e.anchor)}const kg=nte;function XF(t){const e=t.ctx;if(e&&e.ut){let n=t.children[0].el;for(;n!==t.targetAnchor;)n.nodeType===1&&n.setAttribute("data-v-owner",e.uid),n=n.nextSibling;e.ut()}}const lt=Symbol(void 0),Xh=Symbol(void 0),Gr=Symbol(void 0),zv=Symbol(void 0),s0=[];let Ua=null;function S(t=!1){s0.push(Ua=t?null:[])}function rte(){s0.pop(),Ua=s0[s0.length-1]||null}let T0=1;function b5(t){T0+=t}function YF(t){return t.dynamicChildren=T0>0?Ua||Bf:null,rte(),T0>0&&Ua&&Ua.push(t),t}function E(t,e,n,s,r,o){return YF(I(t,e,n,s,r,o,!0))}function $e(t,e,n,s,r){return YF(se(t,e,n,s,r,!0))}function Bn(t){return t?t.__v_isVNode===!0:!1}function Pc(t,e){return t.type===e.type&&t.key===e.key}const Yb="__vInternal",ZF=({key:t})=>t??null,Bv=({ref:t,ref_key:e,ref_for:n})=>t!=null?wt(t)||kn(t)||vt(t)?{i:gr,r:t,k:e,f:!!n}:t:null;function I(t,e=null,n=null,s=0,r=null,o=t===lt?0:1,a=!1,i=!1){const l={__v_isVNode:!0,__v_skip:!0,type:t,props:e,key:e&&ZF(e),ref:e&&Bv(e),scopeId:jb,slotScopeIds:null,children:n,component:null,suspense:null,ssContent:null,ssFallback:null,dirs:null,transition:null,el:null,anchor:null,target:null,targetAnchor:null,staticCount:0,shapeFlag:o,patchFlag:s,dynamicProps:r,dynamicChildren:null,appContext:null,ctx:gr};return i?(iC(l,n),o&128&&t.normalize(l)):n&&(l.shapeFlag|=wt(n)?8:16),T0>0&&!a&&Ua&&(l.patchFlag>0||o&6)&&l.patchFlag!==32&&Ua.push(l),l}const se=ote;function ote(t,e=null,n=null,s=0,r=null,o=!1){if((!t||t===BF)&&(t=Gr),Bn(t)){const i=_l(t,e,!0);return n&&iC(i,n),T0>0&&!o&&Ua&&(i.shapeFlag&6?Ua[Ua.indexOf(t)]=i:Ua.push(i)),i.patchFlag|=-2,i}if(pte(t)&&(t=t.__vccOpts),e){e=Zb(e);let{class:i,style:l}=e;i&&!wt(i)&&(e.class=P(i)),Bt(l)&&($F(l)&&!Qe(l)&&(l=rr({},l)),e.style=ot(l))}const a=wt(t)?1:Tee(t)?128:tte(t)?64:Bt(t)?4:vt(t)?2:0;return I(t,e,n,s,r,a,o,!0)}function Zb(t){return t?$F(t)||Yb in t?rr({},t):t:null}function _l(t,e,n=!1){const{props:s,ref:r,patchFlag:o,children:a}=t,i=e?zt(s||{},e):s;return{__v_isVNode:!0,__v_skip:!0,type:t.type,props:i,key:i&&ZF(i),ref:e&&e.ref?n&&r?Qe(r)?r.concat(Bv(e)):[r,Bv(e)]:Bv(e):r,scopeId:t.scopeId,slotScopeIds:t.slotScopeIds,children:a,target:t.target,targetAnchor:t.targetAnchor,staticCount:t.staticCount,shapeFlag:t.shapeFlag,patchFlag:e&&t.type!==lt?o===-1?16:o|16:o,dynamicProps:t.dynamicProps,dynamicChildren:t.dynamicChildren,appContext:t.appContext,dirs:t.dirs,transition:t.transition,component:t.component,suspense:t.suspense,ssContent:t.ssContent&&_l(t.ssContent),ssFallback:t.ssFallback&&_l(t.ssFallback),el:t.el,anchor:t.anchor,ctx:t.ctx}}function Yt(t=" ",e=0){return se(Xh,null,t,e)}function ate(t,e){const n=se(zv,null,t);return n.staticCount=e,n}function ge(t="",e=!1){return e?(S(),$e(Gr,null,t)):se(Gr,null,t)}function pi(t){return t==null||typeof t=="boolean"?se(Gr):Qe(t)?se(lt,null,t.slice()):typeof t=="object"?vu(t):se(Xh,null,String(t))}function vu(t){return t.el===null&&t.patchFlag!==-1||t.memo?t:_l(t)}function iC(t,e){let n=0;const{shapeFlag:s}=t;if(e==null)e=null;else if(Qe(e))n=16;else if(typeof e=="object")if(s&65){const r=e.default;r&&(r._c&&(r._d=!1),iC(t,r()),r._c&&(r._d=!0));return}else{n=32;const r=e._;!r&&!(Yb in e)?e._ctx=gr:r===3&&gr&&(gr.slots._===1?e._=1:(e._=2,t.patchFlag|=1024))}else vt(e)?(e={default:e,_ctx:gr},n=32):(e=String(e),s&64?(n=16,e=[Yt(e)]):n=8);t.children=e,t.shapeFlag|=n}function zt(...t){const e={};for(let n=0;n<t.length;n++){const s=t[n];for(const r in s)if(r==="class")e.class!==s.class&&(e.class=P([e.class,s.class]));else if(r==="style")e.style=ot([e.style,s.style]);else if(Bb(r)){const o=e[r],a=s[r];a&&o!==a&&!(Qe(o)&&o.includes(a))&&(e[r]=o?[].concat(o,a):a)}else r!==""&&(e[r]=s[r])}return e}function hi(t,e,n,s=null){va(t,e,7,[n,s])}const ite=qF();let lte=0;function ute(t,e,n){const s=t.type,r=(e?e.appContext:t.appContext)||ite,o={uid:lte++,vnode:t,type:s,parent:e,appContext:r,root:null,next:null,subTree:null,effect:null,update:null,scope:new uF(!0),render:null,proxy:null,exposed:null,exposeProxy:null,withProxy:null,provides:e?e.provides:Object.create(r.provides),accessCache:null,renderCache:[],components:null,directives:null,propsOptions:UF(s,r),emitsOptions:OF(s,r),emit:null,emitted:null,propsDefaults:rs,inheritAttrs:s.inheritAttrs,ctx:rs,data:rs,props:rs,attrs:rs,slots:rs,refs:rs,setupState:rs,setupContext:null,suspense:n,suspenseId:n?n.pendingId:0,asyncDep:null,asyncResolved:!1,isMounted:!1,isUnmounted:!1,isDeactivated:!1,bc:null,c:null,bm:null,m:null,bu:null,u:null,um:null,bum:null,da:null,a:null,rtg:null,rtc:null,ec:null,sp:null};return o.ctx={_:o},o.root=e?e.root:o,o.emit=wee.bind(null,o),t.ce&&t.ce(o),o}let Js=null;const Rt=()=>Js||gr,oh=t=>{Js=t,t.scope.on()},sd=()=>{Js&&Js.scope.off(),Js=null};function JF(t){return t.vnode.shapeFlag&4}let N0=!1;function cte(t,e=!1){N0=e;const{props:n,children:s}=t.vnode,r=JF(t);Gee(t,n,r,e),qee(t,s);const o=r?dte(t,e):void 0;return N0=!1,o}function dte(t,e){const n=t.type;t.accessCache=Object.create(null),t.proxy=nd(new Proxy(t.ctx,zee));const{setup:s}=n;if(s){const r=t.setupContext=s.length>1?eM(t):null;oh(t),Kh();const o=Ru(s,t,0,[t.props,r]);if(qh(),sd(),b0(o)){if(o.then(sd,sd),e)return o.then(a=>{w5(t,a,e)}).catch(a=>{Ub(a,t,0)});t.asyncDep=o}else w5(t,o,e)}else QF(t,e)}function w5(t,e,n){vt(e)?t.type.__ssrInlineRender?t.ssrRender=e:t.render=e:Bt(e)&&(t.setupState=CF(e)),QF(t,n)}let _5;function QF(t,e,n){const s=t.type;if(!t.render){if(!e&&_5&&!s.render){const r=s.template||rC(t).template;if(r){const{isCustomElement:o,compilerOptions:a}=t.appContext.config,{delimiters:i,compilerOptions:l}=s,u=rr(rr({isCustomElement:o,delimiters:i},a),l);s.render=_5(r,u)}}t.render=s.render||gn}oh(t),Kh(),Bee(t),qh(),sd()}function fte(t){return new Proxy(t.attrs,{get(e,n){return jo(t,"get","$attrs"),e[n]}})}function eM(t){const e=s=>{t.exposed=s||{}};let n;return{get attrs(){return n||(n=fte(t))},slots:t.slots,emit:t.emit,expose:e}}function Jb(t){if(t.exposed)return t.exposeProxy||(t.exposeProxy=new Proxy(CF(nd(t.exposed)),{get(e,n){if(n in e)return e[n];if(n in t0)return t0[n](t)},has(e,n){return n in e||n in t0}}))}function hte(t,e=!0){return vt(t)?t.displayName||t.name:t.name||e&&t.__name}function pte(t){return vt(t)&&"__vccOpts"in t}const A=(t,e)=>TF(t,e,N0);function ir(){return tM().slots}function Tg(){return tM().attrs}function tM(){const t=Rt();return t.setupContext||(t.setupContext=eM(t))}function it(t,e,n){const s=arguments.length;return s===2?Bt(e)&&!Qe(e)?Bn(e)?se(t,null,[e]):se(t,e):se(t,null,e):(s>3?n=Array.prototype.slice.call(arguments,2):s===3&&Bn(n)&&(n=[n]),se(t,e,n))}const mte=Symbol(""),gte=()=>et(mte),vte="3.2.45",yte="http://www.w3.org/2000/svg",Lc=typeof document<"u"?document:null,$5=Lc&&Lc.createElement("template"),bte={insert:(t,e,n)=>{e.insertBefore(t,n||null)},remove:t=>{const e=t.parentNode;e&&e.removeChild(t)},createElement:(t,e,n,s)=>{const r=e?Lc.createElementNS(yte,t):Lc.createElement(t,n?{is:n}:void 0);return t==="select"&&s&&s.multiple!=null&&r.setAttribute("multiple",s.multiple),r},createText:t=>Lc.createTextNode(t),createComment:t=>Lc.createComment(t),setText:(t,e)=>{t.nodeValue=e},setElementText:(t,e)=>{t.textContent=e},parentNode:t=>t.parentNode,nextSibling:t=>t.nextSibling,querySelector:t=>Lc.querySelector(t),setScopeId(t,e){t.setAttribute(e,"")},insertStaticContent(t,e,n,s,r,o){const a=n?n.previousSibling:e.lastChild;if(r&&(r===o||r.nextSibling))for(;e.insertBefore(r.cloneNode(!0),n),!(r===o||!(r=r.nextSibling)););else{$5.innerHTML=s?`<svg>${t}</svg>`:t;const i=$5.content;if(s){const l=i.firstChild;for(;l.firstChild;)i.appendChild(l.firstChild);i.removeChild(l)}e.insertBefore(i,n)}return[a?a.nextSibling:e.firstChild,n?n.previousSibling:e.lastChild]}};function wte(t,e,n){const s=t._vtc;s&&(e=(e?[e,...s]:[...s]).join(" ")),e==null?t.removeAttribute("class"):n?t.setAttribute("class",e):t.className=e}function _te(t,e,n){const s=t.style,r=wt(n);if(n&&!r){for(const o in n)n6(s,o,n[o]);if(e&&!wt(e))for(const o in e)n[o]==null&&n6(s,o,"")}else{const o=s.display;r?e!==n&&(s.cssText=n):e&&t.removeAttribute("style"),"_vod"in t&&(s.display=o)}}const x5=/\s*!important$/;function n6(t,e,n){if(Qe(n))n.forEach(s=>n6(t,e,s));else if(n==null&&(n=""),e.startsWith("--"))t.setProperty(e,n);else{const s=$te(t,e);x5.test(n)?t.setProperty(ac(s),n.replace(x5,""),"important"):t[s]=n}}const S5=["Webkit","Moz","ms"],R4={};function $te(t,e){const n=R4[e];if(n)return n;let s=wa(e);if(s!=="filter"&&s in t)return R4[e]=s;s=Sg(s);for(let r=0;r<S5.length;r++){const o=S5[r]+s;if(o in t)return R4[e]=o}return e}const C5="http://www.w3.org/1999/xlink";function xte(t,e,n,s,r){if(s&&e.startsWith("xlink:"))n==null?t.removeAttributeNS(C5,e.slice(6,e.length)):t.setAttributeNS(C5,e,n);else{const o=NQ(e);n==null||o&&!rF(n)?t.removeAttribute(e):t.setAttribute(e,o?"":n)}}function Ste(t,e,n,s,r,o,a){if(e==="innerHTML"||e==="textContent"){s&&a(s,r,o),t[e]=n??"";return}if(e==="value"&&t.tagName!=="PROGRESS"&&!t.tagName.includes("-")){t._value=n;const l=n??"";(t.value!==l||t.tagName==="OPTION")&&(t.value=l),n==null&&t.removeAttribute(e);return}let i=!1;if(n===""||n==null){const l=typeof t[e];l==="boolean"?n=rF(n):n==null&&l==="string"?(n="",i=!0):l==="number"&&(n=0,i=!0)}try{t[e]=n}catch{}i&&t.removeAttribute(e)}function wu(t,e,n,s){t.addEventListener(e,n,s)}function Cte(t,e,n,s){t.removeEventListener(e,n,s)}function kte(t,e,n,s,r=null){const o=t._vei||(t._vei={}),a=o[e];if(s&&a)a.value=s;else{const[i,l]=Tte(e);if(s){const u=o[e]=Ete(s,r);wu(t,i,u,l)}else a&&(Cte(t,i,a,l),o[e]=void 0)}}const k5=/(?:Once|Passive|Capture)$/;function Tte(t){let e;if(k5.test(t)){e={};let s;for(;s=t.match(k5);)t=t.slice(0,t.length-s[0].length),e[s[0].toLowerCase()]=!0}return[t[2]===":"?t.slice(3):ac(t.slice(2)),e]}let D4=0;const Nte=Promise.resolve(),Ite=()=>D4||(Nte.then(()=>D4=0),D4=Date.now());function Ete(t,e){const n=s=>{if(!s._vts)s._vts=Date.now();else if(s._vts<=n.attached)return;va(Ate(s,n.value),e,5,[s])};return n.value=t,n.attached=Ite(),n}function Ate(t,e){if(Qe(e)){const n=t.stopImmediatePropagation;return t.stopImmediatePropagation=()=>{n.call(t),t._stopped=!0},e.map(s=>r=>!r._stopped&&s&&s(r))}else return e}const T5=/^on[a-z]/,Ote=(t,e,n,s,r=!1,o,a,i,l)=>{e==="class"?wte(t,s,r):e==="style"?_te(t,n,s):Bb(e)?VS(e)||kte(t,e,n,s,a):(e[0]==="."?(e=e.slice(1),!0):e[0]==="^"?(e=e.slice(1),!1):Rte(t,e,s,r))?Ste(t,e,s,o,a,i,l):(e==="true-value"?t._trueValue=s:e==="false-value"&&(t._falseValue=s),xte(t,e,s,r))};function Rte(t,e,n,s){return s?!!(e==="innerHTML"||e==="textContent"||e in t&&T5.test(e)&&vt(n)):e==="spellcheck"||e==="draggable"||e==="translate"||e==="form"||e==="list"&&t.tagName==="INPUT"||e==="type"&&t.tagName==="TEXTAREA"||T5.test(e)&&wt(n)?!1:e in t}const ou="transition",km="animation",ms=(t,{slots:e})=>it(FF,sM(t),e);ms.displayName="Transition";const nM={name:String,type:String,css:{type:Boolean,default:!0},duration:[String,Number,Object],enterFromClass:String,enterActiveClass:String,enterToClass:String,appearFromClass:String,appearActiveClass:String,appearToClass:String,leaveFromClass:String,leaveActiveClass:String,leaveToClass:String},Dte=ms.props=rr({},FF.props,nM),Cc=(t,e=[])=>{Qe(t)?t.forEach(n=>n(...e)):t&&t(...e)},N5=t=>t?Qe(t)?t.some(e=>e.length>1):t.length>1:!1;function sM(t){const e={};for(const R in t)R in nM||(e[R]=t[R]);if(t.css===!1)return e;const{name:n="v",type:s,duration:r,enterFromClass:o=`${n}-enter-from`,enterActiveClass:a=`${n}-enter-active`,enterToClass:i=`${n}-enter-to`,appearFromClass:l=o,appearActiveClass:u=a,appearToClass:c=i,leaveFromClass:d=`${n}-leave-from`,leaveActiveClass:f=`${n}-leave-active`,leaveToClass:h=`${n}-leave-to`}=t,p=Fte(r),m=p&&p[0],g=p&&p[1],{onBeforeEnter:y,onEnter:w,onEnterCancelled:b,onLeave:_,onLeaveCancelled:$,onBeforeAppear:x=y,onAppear:k=w,onAppearCancelled:C=b}=e,T=(R,D,z)=>{cu(R,D?c:i),cu(R,D?u:a),z&&z()},N=(R,D)=>{R._isLeaving=!1,cu(R,d),cu(R,h),cu(R,f),D&&D()},M=R=>(D,z)=>{const B=R?k:w,V=()=>T(D,R,z);Cc(B,[D,V]),I5(()=>{cu(D,R?l:o),tl(D,R?c:i),N5(B)||E5(D,s,m,V)})};return rr(e,{onBeforeEnter(R){Cc(y,[R]),tl(R,o),tl(R,a)},onBeforeAppear(R){Cc(x,[R]),tl(R,l),tl(R,u)},onEnter:M(!1),onAppear:M(!0),onLeave(R,D){R._isLeaving=!0;const z=()=>N(R,D);tl(R,d),oM(),tl(R,f),I5(()=>{!R._isLeaving||(cu(R,d),tl(R,h),N5(_)||E5(R,s,g,z))}),Cc(_,[R,z])},onEnterCancelled(R){T(R,!1),Cc(b,[R])},onAppearCancelled(R){T(R,!0),Cc(C,[R])},onLeaveCancelled(R){N(R),Cc($,[R])}})}function Fte(t){if(t==null)return null;if(Bt(t))return[F4(t.enter),F4(t.leave)];{const e=F4(t);return[e,e]}}function F4(t){return _0(t)}function tl(t,e){e.split(/\s+/).forEach(n=>n&&t.classList.add(n)),(t._vtc||(t._vtc=new Set)).add(e)}function cu(t,e){e.split(/\s+/).forEach(s=>s&&t.classList.remove(s));const{_vtc:n}=t;n&&(n.delete(e),n.size||(t._vtc=void 0))}function I5(t){requestAnimationFrame(()=>{requestAnimationFrame(t)})}let Mte=0;function E5(t,e,n,s){const r=t._endId=++Mte,o=()=>{r===t._endId&&s()};if(n)return setTimeout(o,n);const{type:a,timeout:i,propCount:l}=rM(t,e);if(!a)return s();const u=a+"end";let c=0;const d=()=>{t.removeEventListener(u,f),o()},f=h=>{h.target===t&&++c>=l&&d()};setTimeout(()=>{c<l&&d()},i+1),t.addEventListener(u,f)}function rM(t,e){const n=window.getComputedStyle(t),s=p=>(n[p]||"").split(", "),r=s(`${ou}Delay`),o=s(`${ou}Duration`),a=A5(r,o),i=s(`${km}Delay`),l=s(`${km}Duration`),u=A5(i,l);let c=null,d=0,f=0;e===ou?a>0&&(c=ou,d=a,f=o.length):e===km?u>0&&(c=km,d=u,f=l.length):(d=Math.max(a,u),c=d>0?a>u?ou:km:null,f=c?c===ou?o.length:l.length:0);const h=c===ou&&/\b(transform|all)(,|$)/.test(s(`${ou}Property`).toString());return{type:c,timeout:d,propCount:f,hasTransform:h}}function A5(t,e){for(;t.length<e.length;)t=t.concat(t);return Math.max(...e.map((n,s)=>O5(n)+O5(t[s])))}function O5(t){return Number(t.slice(0,-1).replace(",","."))*1e3}function oM(){return document.body.offsetHeight}const aM=new WeakMap,iM=new WeakMap,Pte={name:"TransitionGroup",props:rr({},Dte,{tag:String,moveClass:String}),setup(t,{slots:e}){const n=Rt(),s=DF();let r,o;return Ml(()=>{if(!r.length)return;const a=t.moveClass||`${t.name||"v"}-move`;if(!Hte(r[0].el,n.vnode.el,a))return;r.forEach(zte),r.forEach(Bte);const i=r.filter(Vte);oM(),i.forEach(l=>{const u=l.el,c=u.style;tl(u,a),c.transform=c.webkitTransform=c.transitionDuration="";const d=u._moveCb=f=>{f&&f.target!==u||(!f||/transform$/.test(f.propertyName))&&(u.removeEventListener("transitionend",d),u._moveCb=null,cu(u,a))};u.addEventListener("transitionend",d)})}),()=>{const a=fn(t),i=sM(a);let l=a.tag||lt;r=o,o=e.default?tC(e.default()):[];for(let u=0;u<o.length;u++){const c=o[u];c.key!=null&&k0(c,C0(c,i,s,n))}if(r)for(let u=0;u<r.length;u++){const c=r[u];k0(c,C0(c,i,s,n)),aM.set(c,c.el.getBoundingClientRect())}return se(l,null,o)}}},Lte=Pte;function zte(t){const e=t.el;e._moveCb&&e._moveCb(),e._enterCb&&e._enterCb()}function Bte(t){iM.set(t,t.el.getBoundingClientRect())}function Vte(t){const e=aM.get(t),n=iM.get(t),s=e.left-n.left,r=e.top-n.top;if(s||r){const o=t.el.style;return o.transform=o.webkitTransform=`translate(${s}px,${r}px)`,o.transitionDuration="0s",t}}function Hte(t,e,n){const s=t.cloneNode();t._vtc&&t._vtc.forEach(a=>{a.split(/\s+/).forEach(i=>i&&s.classList.remove(i))}),n.split(/\s+/).forEach(a=>a&&s.classList.add(a)),s.style.display="none";const r=e.nodeType===1?e:e.parentNode;r.appendChild(s);const{hasTransform:o}=rM(s);return r.removeChild(s),o}const ah=t=>{const e=t.props["onUpdate:modelValue"]||!1;return Qe(e)?n=>Lv(e,n):e};function Wte(t){t.target.composing=!0}function R5(t){const e=t.target;e.composing&&(e.composing=!1,e.dispatchEvent(new Event("input")))}const lC={created(t,{modifiers:{lazy:e,trim:n,number:s}},r){t._assign=ah(r);const o=s||r.props&&r.props.type==="number";wu(t,e?"change":"input",a=>{if(a.target.composing)return;let i=t.value;n&&(i=i.trim()),o&&(i=_0(i)),t._assign(i)}),n&&wu(t,"change",()=>{t.value=t.value.trim()}),e||(wu(t,"compositionstart",Wte),wu(t,"compositionend",R5),wu(t,"change",R5))},mounted(t,{value:e}){t.value=e??""},beforeUpdate(t,{value:e,modifiers:{lazy:n,trim:s,number:r}},o){if(t._assign=ah(o),t.composing||document.activeElement===t&&t.type!=="range"&&(n||s&&t.value.trim()===e||(r||t.type==="number")&&_0(t.value)===e))return;const a=e??"";t.value!==a&&(t.value=a)}},Sy={deep:!0,created(t,e,n){t._assign=ah(n),wu(t,"change",()=>{const s=t._modelValue,r=uM(t),o=t.checked,a=t._assign;if(Qe(s)){const i=oF(s,r),l=i!==-1;if(o&&!l)a(s.concat(r));else if(!o&&l){const u=[...s];u.splice(i,1),a(u)}}else if(Vb(s)){const i=new Set(s);o?i.add(r):i.delete(r),a(i)}else a(cM(t,o))})},mounted:D5,beforeUpdate(t,e,n){t._assign=ah(n),D5(t,e,n)}};function D5(t,{value:e,oldValue:n},s){t._modelValue=e,Qe(e)?t.checked=oF(e,s.props.value)>-1:Vb(e)?t.checked=e.has(s.props.value):e!==n&&(t.checked=nh(e,cM(t,!0)))}const lM={created(t,{value:e},n){t.checked=nh(e,n.props.value),t._assign=ah(n),wu(t,"change",()=>{t._assign(uM(t))})},beforeUpdate(t,{value:e,oldValue:n},s){t._assign=ah(s),e!==n&&(t.checked=nh(e,s.props.value))}};function uM(t){return"_value"in t?t._value:t.value}function cM(t,e){const n=e?"_trueValue":"_falseValue";return n in t?t[n]:e}const Ute=["ctrl","shift","alt","meta"],Gte={stop:t=>t.stopPropagation(),prevent:t=>t.preventDefault(),self:t=>t.target!==t.currentTarget,ctrl:t=>!t.ctrlKey,shift:t=>!t.shiftKey,alt:t=>!t.altKey,meta:t=>!t.metaKey,left:t=>"button"in t&&t.button!==0,middle:t=>"button"in t&&t.button!==1,right:t=>"button"in t&&t.button!==2,exact:(t,e)=>Ute.some(n=>t[`${n}Key`]&&!e.includes(n))},yt=(t,e)=>(n,...s)=>{for(let r=0;r<e.length;r++){const o=Gte[e[r]];if(o&&o(n,e))return}return t(n,...s)},jte={esc:"escape",space:" ",up:"arrow-up",left:"arrow-left",right:"arrow-right",down:"arrow-down",delete:"backspace"},qt=(t,e)=>n=>{if(!("key"in n))return;const s=ac(n.key);if(e.some(r=>r===s||jte[r]===s))return t(n)},Qt={beforeMount(t,{value:e},{transition:n}){t._vod=t.style.display==="none"?"":t.style.display,n&&e?n.beforeEnter(t):Tm(t,e)},mounted(t,{value:e},{transition:n}){n&&e&&n.enter(t)},updated(t,{value:e,oldValue:n},{transition:s}){!e!=!n&&(s?e?(s.beforeEnter(t),Tm(t,!0),s.enter(t)):s.leave(t,()=>{Tm(t,!1)}):Tm(t,e))},beforeUnmount(t,{value:e}){Tm(t,e)}};function Tm(t,e){t.style.display=e?t._vod:"none"}const Kte=rr({patchProp:Ote},bte);let F5;function dM(){return F5||(F5=Jee(Kte))}const ih=(...t)=>{dM().render(...t)},fM=(...t)=>{const e=dM().createApp(...t),{mount:n}=e;return e.mount=s=>{const r=qte(s);if(!r)return;const o=e._component;!vt(o)&&!o.render&&!o.template&&(o.template=r.innerHTML),r.innerHTML="";const a=n(r,!1,r instanceof SVGElement);return r instanceof Element&&(r.removeAttribute("v-cloak"),r.setAttribute("data-v-app","")),a},e};function qte(t){return wt(t)?document.querySelector(t):t}const hM=(t,e)=>{const n=t.__vccOpts||t;for(const[s,r]of e)n[s]=r;return n},Xte={};function Yte(t,e){const n=pt("RouterView");return S(),$e(n)}const Zte=hM(Xte,[["render",Yte]]);const Cf=typeof window<"u";function Jte(t){return t.__esModule||t[Symbol.toStringTag]==="Module"}const On=Object.assign;function M4(t,e){const n={};for(const s in e){const r=e[s];n[s]=Ja(r)?r.map(t):t(r)}return n}const r0=()=>{},Ja=Array.isArray,Qte=/\/$/,ene=t=>t.replace(Qte,"");function P4(t,e,n="/"){let s,r={},o="",a="";const i=e.indexOf("#");let l=e.indexOf("?");return i<l&&i>=0&&(l=-1),l>-1&&(s=e.slice(0,l),o=e.slice(l+1,i>-1?i:e.length),r=t(o)),i>-1&&(s=s||e.slice(0,i),a=e.slice(i,e.length)),s=rne(s??e,n),{fullPath:s+(o&&"?")+o+a,path:s,query:r,hash:a}}function tne(t,e){const n=e.query?t(e.query):"";return e.path+(n&&"?")+n+(e.hash||"")}function M5(t,e){return!e||!t.toLowerCase().startsWith(e.toLowerCase())?t:t.slice(e.length)||"/"}function nne(t,e,n){const s=e.matched.length-1,r=n.matched.length-1;return s>-1&&s===r&&lh(e.matched[s],n.matched[r])&&pM(e.params,n.params)&&t(e.query)===t(n.query)&&e.hash===n.hash}function lh(t,e){return(t.aliasOf||t)===(e.aliasOf||e)}function pM(t,e){if(Object.keys(t).length!==Object.keys(e).length)return!1;for(const n in t)if(!sne(t[n],e[n]))return!1;return!0}function sne(t,e){return Ja(t)?P5(t,e):Ja(e)?P5(e,t):t===e}function P5(t,e){return Ja(e)?t.length===e.length&&t.every((n,s)=>n===e[s]):t.length===1&&t[0]===e}function rne(t,e){if(t.startsWith("/"))return t;if(!t)return e;const n=e.split("/"),s=t.split("/");let r=n.length-1,o,a;for(o=0;o<s.length;o++)if(a=s[o],a!==".")if(a==="..")r>1&&r--;else break;return n.slice(0,r).join("/")+"/"+s.slice(o-(o===s.length?1:0)).join("/")}var I0;(function(t){t.pop="pop",t.push="push"})(I0||(I0={}));var o0;(function(t){t.back="back",t.forward="forward",t.unknown=""})(o0||(o0={}));function one(t){if(!t)if(Cf){const e=document.querySelector("base");t=e&&e.getAttribute("href")||"/",t=t.replace(/^\w+:\/\/[^\/]+/,"")}else t="/";return t[0]!=="/"&&t[0]!=="#"&&(t="/"+t),ene(t)}const ane=/^[^#]+#/;function ine(t,e){return t.replace(ane,"#")+e}function lne(t,e){const n=document.documentElement.getBoundingClientRect(),s=t.getBoundingClientRect();return{behavior:e.behavior,left:s.left-n.left-(e.left||0),top:s.top-n.top-(e.top||0)}}const Qb=()=>({left:window.pageXOffset,top:window.pageYOffset});function une(t){let e;if("el"in t){const n=t.el,s=typeof n=="string"&&n.startsWith("#"),r=typeof n=="string"?s?document.getElementById(n.slice(1)):document.querySelector(n):n;if(!r)return;e=lne(r,t)}else e=t;"scrollBehavior"in document.documentElement.style?window.scrollTo(e):window.scrollTo(e.left!=null?e.left:window.pageXOffset,e.top!=null?e.top:window.pageYOffset)}function L5(t,e){return(history.state?history.state.position-e:-1)+t}const s6=new Map;function cne(t,e){s6.set(t,e)}function dne(t){const e=s6.get(t);return s6.delete(t),e}let fne=()=>location.protocol+"//"+location.host;function mM(t,e){const{pathname:n,search:s,hash:r}=e,o=t.indexOf("#");if(o>-1){let i=r.includes(t.slice(o))?t.slice(o).length:1,l=r.slice(i);return l[0]!=="/"&&(l="/"+l),M5(l,"")}return M5(n,t)+s+r}function hne(t,e,n,s){let r=[],o=[],a=null;const i=({state:f})=>{const h=mM(t,location),p=n.value,m=e.value;let g=0;if(f){if(n.value=h,e.value=f,a&&a===p){a=null;return}g=m?f.position-m.position:0}else s(h);r.forEach(y=>{y(n.value,p,{delta:g,type:I0.pop,direction:g?g>0?o0.forward:o0.back:o0.unknown})})};function l(){a=n.value}function u(f){r.push(f);const h=()=>{const p=r.indexOf(f);p>-1&&r.splice(p,1)};return o.push(h),h}function c(){const{history:f}=window;!f.state||f.replaceState(On({},f.state,{scroll:Qb()}),"")}function d(){for(const f of o)f();o=[],window.removeEventListener("popstate",i),window.removeEventListener("beforeunload",c)}return window.addEventListener("popstate",i),window.addEventListener("beforeunload",c),{pauseListeners:l,listen:u,destroy:d}}function z5(t,e,n,s=!1,r=!1){return{back:t,current:e,forward:n,replaced:s,position:window.history.length,scroll:r?Qb():null}}function pne(t){const{history:e,location:n}=window,s={value:mM(t,n)},r={value:e.state};r.value||o(s.value,{back:null,current:s.value,forward:null,position:e.length-1,replaced:!0,scroll:null},!0);function o(l,u,c){const d=t.indexOf("#"),f=d>-1?(n.host&&document.querySelector("base")?t:t.slice(d))+l:fne()+t+l;try{e[c?"replaceState":"pushState"](u,"",f),r.value=u}catch(h){console.error(h),n[c?"replace":"assign"](f)}}function a(l,u){const c=On({},e.state,z5(r.value.back,l,r.value.forward,!0),u,{position:r.value.position});o(l,c,!0),s.value=l}function i(l,u){const c=On({},r.value,e.state,{forward:l,scroll:Qb()});o(c.current,c,!0);const d=On({},z5(s.value,l,null),{position:c.position+1},u);o(l,d,!1),s.value=l}return{location:s,state:r,push:i,replace:a}}function mne(t){t=one(t);const e=pne(t),n=hne(t,e.state,e.location,e.replace);function s(o,a=!0){a||n.pauseListeners(),history.go(o)}const r=On({location:"",base:t,go:s,createHref:ine.bind(null,t)},e,n);return Object.defineProperty(r,"location",{enumerable:!0,get:()=>e.location.value}),Object.defineProperty(r,"state",{enumerable:!0,get:()=>e.state.value}),r}function gne(t){return typeof t=="string"||t&&typeof t=="object"}function gM(t){return typeof t=="string"||typeof t=="symbol"}const au={path:"/",name:void 0,params:{},query:{},hash:"",fullPath:"/",matched:[],meta:{},redirectedFrom:void 0},vM=Symbol("");var B5;(function(t){t[t.aborted=4]="aborted",t[t.cancelled=8]="cancelled",t[t.duplicated=16]="duplicated"})(B5||(B5={}));function uh(t,e){return On(new Error,{type:t,[vM]:!0},e)}function Qi(t,e){return t instanceof Error&&vM in t&&(e==null||!!(t.type&e))}const V5="[^/]+?",vne={sensitive:!1,strict:!1,start:!0,end:!0},yne=/[.+*?^${}()[\]/\\]/g;function bne(t,e){const n=On({},vne,e),s=[];let r=n.start?"^":"";const o=[];for(const u of t){const c=u.length?[]:[90];n.strict&&!u.length&&(r+="/");for(let d=0;d<u.length;d++){const f=u[d];let h=40+(n.sensitive?.25:0);if(f.type===0)d||(r+="/"),r+=f.value.replace(yne,"\\$&"),h+=40;else if(f.type===1){const{value:p,repeatable:m,optional:g,regexp:y}=f;o.push({name:p,repeatable:m,optional:g});const w=y||V5;if(w!==V5){h+=10;try{new RegExp(`(${w})`)}catch(_){throw new Error(`Invalid custom RegExp for param "${p}" (${w}): `+_.message)}}let b=m?`((?:${w})(?:/(?:${w}))*)`:`(${w})`;d||(b=g&&u.length<2?`(?:/${b})`:"/"+b),g&&(b+="?"),r+=b,h+=20,g&&(h+=-8),m&&(h+=-20),w===".*"&&(h+=-50)}c.push(h)}s.push(c)}if(n.strict&&n.end){const u=s.length-1;s[u][s[u].length-1]+=.7000000000000001}n.strict||(r+="/?"),n.end?r+="$":n.strict&&(r+="(?:/|$)");const a=new RegExp(r,n.sensitive?"":"i");function i(u){const c=u.match(a),d={};if(!c)return null;for(let f=1;f<c.length;f++){const h=c[f]||"",p=o[f-1];d[p.name]=h&&p.repeatable?h.split("/"):h}return d}function l(u){let c="",d=!1;for(const f of t){(!d||!c.endsWith("/"))&&(c+="/"),d=!1;for(const h of f)if(h.type===0)c+=h.value;else if(h.type===1){const{value:p,repeatable:m,optional:g}=h,y=p in u?u[p]:"";if(Ja(y)&&!m)throw new Error(`Provided param "${p}" is an array but it is not repeatable (* or + modifiers)`);const w=Ja(y)?y.join("/"):y;if(!w)if(g)f.length<2&&(c.endsWith("/")?c=c.slice(0,-1):d=!0);else throw new Error(`Missing required param "${p}"`);c+=w}}return c||"/"}return{re:a,score:s,keys:o,parse:i,stringify:l}}function wne(t,e){let n=0;for(;n<t.length&&n<e.length;){const s=e[n]-t[n];if(s)return s;n++}return t.length<e.length?t.length===1&&t[0]===40+40?-1:1:t.length>e.length?e.length===1&&e[0]===40+40?1:-1:0}function _ne(t,e){let n=0;const s=t.score,r=e.score;for(;n<s.length&&n<r.length;){const o=wne(s[n],r[n]);if(o)return o;n++}if(Math.abs(r.length-s.length)===1){if(H5(s))return 1;if(H5(r))return-1}return r.length-s.length}function H5(t){const e=t[t.length-1];return t.length>0&&e[e.length-1]<0}const $ne={type:0,value:""},xne=/[a-zA-Z0-9_]/;function Sne(t){if(!t)return[[]];if(t==="/")return[[$ne]];if(!t.startsWith("/"))throw new Error(`Invalid path "${t}"`);function e(h){throw new Error(`ERR (${n})/"${u}": ${h}`)}let n=0,s=n;const r=[];let o;function a(){o&&r.push(o),o=[]}let i=0,l,u="",c="";function d(){!u||(n===0?o.push({type:0,value:u}):n===1||n===2||n===3?(o.length>1&&(l==="*"||l==="+")&&e(`A repeatable param (${u}) must be alone in its segment. eg: '/:ids+.`),o.push({type:1,value:u,regexp:c,repeatable:l==="*"||l==="+",optional:l==="*"||l==="?"})):e("Invalid state to consume buffer"),u="")}function f(){u+=l}for(;i<t.length;){if(l=t[i++],l==="\\"&&n!==2){s=n,n=4;continue}switch(n){case 0:l==="/"?(u&&d(),a()):l===":"?(d(),n=1):f();break;case 4:f(),n=s;break;case 1:l==="("?n=2:xne.test(l)?f():(d(),n=0,l!=="*"&&l!=="?"&&l!=="+"&&i--);break;case 2:l===")"?c[c.length-1]=="\\"?c=c.slice(0,-1)+l:n=3:c+=l;break;case 3:d(),n=0,l!=="*"&&l!=="?"&&l!=="+"&&i--,c="";break;default:e("Unknown state");break}}return n===2&&e(`Unfinished custom RegExp for param "${u}"`),d(),a(),r}function Cne(t,e,n){const s=bne(Sne(t.path),n),r=On(s,{record:t,parent:e,children:[],alias:[]});return e&&!r.record.aliasOf==!e.record.aliasOf&&e.children.push(r),r}function kne(t,e){const n=[],s=new Map;e=G5({strict:!1,end:!0,sensitive:!1},e);function r(c){return s.get(c)}function o(c,d,f){const h=!f,p=Tne(c);p.aliasOf=f&&f.record;const m=G5(e,c),g=[p];if("alias"in c){const b=typeof c.alias=="string"?[c.alias]:c.alias;for(const _ of b)g.push(On({},p,{components:f?f.record.components:p.components,path:_,aliasOf:f?f.record:p}))}let y,w;for(const b of g){const{path:_}=b;if(d&&_[0]!=="/"){const $=d.record.path,x=$[$.length-1]==="/"?"":"/";b.path=d.record.path+(_&&x+_)}if(y=Cne(b,d,m),f?f.alias.push(y):(w=w||y,w!==y&&w.alias.push(y),h&&c.name&&!U5(y)&&a(c.name)),p.children){const $=p.children;for(let x=0;x<$.length;x++)o($[x],y,f&&f.children[x])}f=f||y,(y.record.components&&Object.keys(y.record.components).length||y.record.name||y.record.redirect)&&l(y)}return w?()=>{a(w)}:r0}function a(c){if(gM(c)){const d=s.get(c);d&&(s.delete(c),n.splice(n.indexOf(d),1),d.children.forEach(a),d.alias.forEach(a))}else{const d=n.indexOf(c);d>-1&&(n.splice(d,1),c.record.name&&s.delete(c.record.name),c.children.forEach(a),c.alias.forEach(a))}}function i(){return n}function l(c){let d=0;for(;d<n.length&&_ne(c,n[d])>=0&&(c.record.path!==n[d].record.path||!yM(c,n[d]));)d++;n.splice(d,0,c),c.record.name&&!U5(c)&&s.set(c.record.name,c)}function u(c,d){let f,h={},p,m;if("name"in c&&c.name){if(f=s.get(c.name),!f)throw uh(1,{location:c});m=f.record.name,h=On(W5(d.params,f.keys.filter(w=>!w.optional).map(w=>w.name)),c.params&&W5(c.params,f.keys.map(w=>w.name))),p=f.stringify(h)}else if("path"in c)p=c.path,f=n.find(w=>w.re.test(p)),f&&(h=f.parse(p),m=f.record.name);else{if(f=d.name?s.get(d.name):n.find(w=>w.re.test(d.path)),!f)throw uh(1,{location:c,currentLocation:d});m=f.record.name,h=On({},d.params,c.params),p=f.stringify(h)}const g=[];let y=f;for(;y;)g.unshift(y.record),y=y.parent;return{name:m,path:p,params:h,matched:g,meta:Ine(g)}}return t.forEach(c=>o(c)),{addRoute:o,resolve:u,removeRoute:a,getRoutes:i,getRecordMatcher:r}}function W5(t,e){const n={};for(const s of e)s in t&&(n[s]=t[s]);return n}function Tne(t){return{path:t.path,redirect:t.redirect,name:t.name,meta:t.meta||{},aliasOf:void 0,beforeEnter:t.beforeEnter,props:Nne(t),children:t.children||[],instances:{},leaveGuards:new Set,updateGuards:new Set,enterCallbacks:{},components:"components"in t?t.components||null:t.component&&{default:t.component}}}function Nne(t){const e={},n=t.props||!1;if("component"in t)e.default=n;else for(const s in t.components)e[s]=typeof n=="boolean"?n:n[s];return e}function U5(t){for(;t;){if(t.record.aliasOf)return!0;t=t.parent}return!1}function Ine(t){return t.reduce((e,n)=>On(e,n.meta),{})}function G5(t,e){const n={};for(const s in t)n[s]=s in e?e[s]:t[s];return n}function yM(t,e){return e.children.some(n=>n===t||yM(t,n))}const bM=/#/g,Ene=/&/g,Ane=/\//g,One=/=/g,Rne=/\?/g,wM=/\+/g,Dne=/%5B/g,Fne=/%5D/g,_M=/%5E/g,Mne=/%60/g,$M=/%7B/g,Pne=/%7C/g,xM=/%7D/g,Lne=/%20/g;function uC(t){return encodeURI(""+t).replace(Pne,"|").replace(Dne,"[").replace(Fne,"]")}function zne(t){return uC(t).replace($M,"{").replace(xM,"}").replace(_M,"^")}function r6(t){return uC(t).replace(wM,"%2B").replace(Lne,"+").replace(bM,"%23").replace(Ene,"%26").replace(Mne,"`").replace($M,"{").replace(xM,"}").replace(_M,"^")}function Bne(t){return r6(t).replace(One,"%3D")}function Vne(t){return uC(t).replace(bM,"%23").replace(Rne,"%3F")}function Hne(t){return t==null?"":Vne(t).replace(Ane,"%2F")}function Cy(t){try{return decodeURIComponent(""+t)}catch{}return""+t}function Wne(t){const e={};if(t===""||t==="?")return e;const s=(t[0]==="?"?t.slice(1):t).split("&");for(let r=0;r<s.length;++r){const o=s[r].replace(wM," "),a=o.indexOf("="),i=Cy(a<0?o:o.slice(0,a)),l=a<0?null:Cy(o.slice(a+1));if(i in e){let u=e[i];Ja(u)||(u=e[i]=[u]),u.push(l)}else e[i]=l}return e}function j5(t){let e="";for(let n in t){const s=t[n];if(n=Bne(n),s==null){s!==void 0&&(e+=(e.length?"&":"")+n);continue}(Ja(s)?s.map(o=>o&&r6(o)):[s&&r6(s)]).forEach(o=>{o!==void 0&&(e+=(e.length?"&":"")+n,o!=null&&(e+="="+o))})}return e}function Une(t){const e={};for(const n in t){const s=t[n];s!==void 0&&(e[n]=Ja(s)?s.map(r=>r==null?null:""+r):s==null?s:""+s)}return e}const Gne=Symbol(""),K5=Symbol(""),cC=Symbol(""),SM=Symbol(""),o6=Symbol("");function Nm(){let t=[];function e(s){return t.push(s),()=>{const r=t.indexOf(s);r>-1&&t.splice(r,1)}}function n(){t=[]}return{add:e,list:()=>t,reset:n}}function yu(t,e,n,s,r){const o=s&&(s.enterCallbacks[r]=s.enterCallbacks[r]||[]);return()=>new Promise((a,i)=>{const l=d=>{d===!1?i(uh(4,{from:n,to:e})):d instanceof Error?i(d):gne(d)?i(uh(2,{from:e,to:d})):(o&&s.enterCallbacks[r]===o&&typeof d=="function"&&o.push(d),a())},u=t.call(s&&s.instances[r],e,n,l);let c=Promise.resolve(u);t.length<3&&(c=c.then(l)),c.catch(d=>i(d))})}function L4(t,e,n,s){const r=[];for(const o of t)for(const a in o.components){let i=o.components[a];if(!(e!=="beforeRouteEnter"&&!o.instances[a]))if(jne(i)){const u=(i.__vccOpts||i)[e];u&&r.push(yu(u,n,s,o,a))}else{let l=i();r.push(()=>l.then(u=>{if(!u)return Promise.reject(new Error(`Couldn't resolve component "${a}" at "${o.path}"`));const c=Jte(u)?u.default:u;o.components[a]=c;const f=(c.__vccOpts||c)[e];return f&&yu(f,n,s,o,a)()}))}}return r}function jne(t){return typeof t=="object"||"displayName"in t||"props"in t||"__vccOpts"in t}function q5(t){const e=et(cC),n=et(SM),s=A(()=>e.resolve(v(t.to))),r=A(()=>{const{matched:l}=s.value,{length:u}=l,c=l[u-1],d=n.matched;if(!c||!d.length)return-1;const f=d.findIndex(lh.bind(null,c));if(f>-1)return f;const h=X5(l[u-2]);return u>1&&X5(c)===h&&d[d.length-1].path!==h?d.findIndex(lh.bind(null,l[u-2])):f}),o=A(()=>r.value>-1&&Yne(n.params,s.value.params)),a=A(()=>r.value>-1&&r.value===n.matched.length-1&&pM(n.params,s.value.params));function i(l={}){return Xne(l)?e[v(t.replace)?"replace":"push"](v(t.to)).catch(r0):Promise.resolve()}return{route:s,href:A(()=>s.value.href),isActive:o,isExactActive:a,navigate:i}}const Kne=ue({name:"RouterLink",compatConfig:{MODE:3},props:{to:{type:[String,Object],required:!0},replace:Boolean,activeClass:String,exactActiveClass:String,custom:Boolean,ariaCurrentValue:{type:String,default:"page"}},useLink:q5,setup(t,{slots:e}){const n=on(q5(t)),{options:s}=et(cC),r=A(()=>({[Y5(t.activeClass,s.linkActiveClass,"router-link-active")]:n.isActive,[Y5(t.exactActiveClass,s.linkExactActiveClass,"router-link-exact-active")]:n.isExactActive}));return()=>{const o=e.default&&e.default(n);return t.custom?o:it("a",{"aria-current":n.isExactActive?t.ariaCurrentValue:null,href:n.href,onClick:n.navigate,class:r.value},o)}}}),qne=Kne;function Xne(t){if(!(t.metaKey||t.altKey||t.ctrlKey||t.shiftKey)&&!t.defaultPrevented&&!(t.button!==void 0&&t.button!==0)){if(t.currentTarget&&t.currentTarget.getAttribute){const e=t.currentTarget.getAttribute("target");if(/\b_blank\b/i.test(e))return}return t.preventDefault&&t.preventDefault(),!0}}function Yne(t,e){for(const n in e){const s=e[n],r=t[n];if(typeof s=="string"){if(s!==r)return!1}else if(!Ja(r)||r.length!==s.length||s.some((o,a)=>o!==r[a]))return!1}return!0}function X5(t){return t?t.aliasOf?t.aliasOf.path:t.path:""}const Y5=(t,e,n)=>t??e??n,Zne=ue({name:"RouterView",inheritAttrs:!1,props:{name:{type:String,default:"default"},route:Object},compatConfig:{MODE:3},setup(t,{attrs:e,slots:n}){const s=et(o6),r=A(()=>t.route||s.value),o=et(K5,0),a=A(()=>{let u=v(o);const{matched:c}=r.value;let d;for(;(d=c[u])&&!d.components;)u++;return u}),i=A(()=>r.value.matched[a.value]);Lt(K5,A(()=>a.value+1)),Lt(Gne,i),Lt(o6,r);const l=U();return Me(()=>[l.value,i.value,t.name],([u,c,d],[f,h,p])=>{c&&(c.instances[d]=u,h&&h!==c&&u&&u===f&&(c.leaveGuards.size||(c.leaveGuards=h.leaveGuards),c.updateGuards.size||(c.updateGuards=h.updateGuards))),u&&c&&(!h||!lh(c,h)||!f)&&(c.enterCallbacks[d]||[]).forEach(m=>m(u))},{flush:"post"}),()=>{const u=r.value,c=t.name,d=i.value,f=d&&d.components[c];if(!f)return Z5(n.default,{Component:f,route:u});const h=d.props[c],p=h?h===!0?u.params:typeof h=="function"?h(u):h:null,g=it(f,On({},p,e,{onVnodeUnmounted:y=>{y.component.isUnmounted&&(d.instances[c]=null)},ref:l}));return Z5(n.default,{Component:g,route:u})||g}}});function Z5(t,e){if(!t)return null;const n=t(e);return n.length===1?n[0]:n}const Jne=Zne;function Qne(t){const e=kne(t.routes,t),n=t.parseQuery||Wne,s=t.stringifyQuery||j5,r=t.history,o=Nm(),a=Nm(),i=Nm(),l=Nn(au);let u=au;Cf&&t.scrollBehavior&&"scrollRestoration"in history&&(history.scrollRestoration="manual");const c=M4.bind(null,X=>""+X),d=M4.bind(null,Hne),f=M4.bind(null,Cy);function h(X,oe){let ee,Q;return gM(X)?(ee=e.getRecordMatcher(X),Q=oe):Q=X,e.addRoute(Q,ee)}function p(X){const oe=e.getRecordMatcher(X);oe&&e.removeRoute(oe)}function m(){return e.getRoutes().map(X=>X.record)}function g(X){return!!e.getRecordMatcher(X)}function y(X,oe){if(oe=On({},oe||l.value),typeof X=="string"){const K=P4(n,X,oe.path),re=e.resolve({path:K.path},oe),we=r.createHref(K.fullPath);return On(K,re,{params:f(re.params),hash:Cy(K.hash),redirectedFrom:void 0,href:we})}let ee;if("path"in X)ee=On({},X,{path:P4(n,X.path,oe.path).path});else{const K=On({},X.params);for(const re in K)K[re]==null&&delete K[re];ee=On({},X,{params:d(X.params)}),oe.params=d(oe.params)}const Q=e.resolve(ee,oe),ie=X.hash||"";Q.params=c(f(Q.params));const pe=tne(s,On({},X,{hash:zne(ie),path:Q.path})),Re=r.createHref(pe);return On({fullPath:pe,hash:ie,query:s===j5?Une(X.query):X.query||{}},Q,{redirectedFrom:void 0,href:Re})}function w(X){return typeof X=="string"?P4(n,X,l.value.path):On({},X)}function b(X,oe){if(u!==X)return uh(8,{from:oe,to:X})}function _(X){return k(X)}function $(X){return _(On(w(X),{replace:!0}))}function x(X){const oe=X.matched[X.matched.length-1];if(oe&&oe.redirect){const{redirect:ee}=oe;let Q=typeof ee=="function"?ee(X):ee;return typeof Q=="string"&&(Q=Q.includes("?")||Q.includes("#")?Q=w(Q):{path:Q},Q.params={}),On({query:X.query,hash:X.hash,params:"path"in Q?{}:X.params},Q)}}function k(X,oe){const ee=u=y(X),Q=l.value,ie=X.state,pe=X.force,Re=X.replace===!0,K=x(ee);if(K)return k(On(w(K),{state:typeof K=="object"?On({},ie,K.state):ie,force:pe,replace:Re}),oe||ee);const re=ee;re.redirectedFrom=oe;let we;return!pe&&nne(s,Q,ee)&&(we=uh(16,{to:re,from:Q}),G(Q,Q,!0,!1)),(we?Promise.resolve(we):T(re,Q)).catch(Ee=>Qi(Ee)?Qi(Ee,2)?Ee:L(Ee):O(Ee,re,Q)).then(Ee=>{if(Ee){if(Qi(Ee,2))return k(On({replace:Re},w(Ee.to),{state:typeof Ee.to=="object"?On({},ie,Ee.to.state):ie,force:pe}),oe||re)}else Ee=M(re,Q,!0,Re,ie);return N(re,Q,Ee),Ee})}function C(X,oe){const ee=b(X,oe);return ee?Promise.reject(ee):Promise.resolve()}function T(X,oe){let ee;const[Q,ie,pe]=ese(X,oe);ee=L4(Q.reverse(),"beforeRouteLeave",X,oe);for(const K of Q)K.leaveGuards.forEach(re=>{ee.push(yu(re,X,oe))});const Re=C.bind(null,X,oe);return ee.push(Re),yf(ee).then(()=>{ee=[];for(const K of o.list())ee.push(yu(K,X,oe));return ee.push(Re),yf(ee)}).then(()=>{ee=L4(ie,"beforeRouteUpdate",X,oe);for(const K of ie)K.updateGuards.forEach(re=>{ee.push(yu(re,X,oe))});return ee.push(Re),yf(ee)}).then(()=>{ee=[];for(const K of X.matched)if(K.beforeEnter&&!oe.matched.includes(K))if(Ja(K.beforeEnter))for(const re of K.beforeEnter)ee.push(yu(re,X,oe));else ee.push(yu(K.beforeEnter,X,oe));return ee.push(Re),yf(ee)}).then(()=>(X.matched.forEach(K=>K.enterCallbacks={}),ee=L4(pe,"beforeRouteEnter",X,oe),ee.push(Re),yf(ee))).then(()=>{ee=[];for(const K of a.list())ee.push(yu(K,X,oe));return ee.push(Re),yf(ee)}).catch(K=>Qi(K,8)?K:Promise.reject(K))}function N(X,oe,ee){for(const Q of i.list())Q(X,oe,ee)}function M(X,oe,ee,Q,ie){const pe=b(X,oe);if(pe)return pe;const Re=oe===au,K=Cf?history.state:{};ee&&(Q||Re?r.replace(X.fullPath,On({scroll:Re&&K&&K.scroll},ie)):r.push(X.fullPath,ie)),l.value=X,G(X,oe,ee,Re),L()}let R;function D(){R||(R=r.listen((X,oe,ee)=>{if(!fe.listening)return;const Q=y(X),ie=x(Q);if(ie){k(On(ie,{replace:!0}),Q).catch(r0);return}u=Q;const pe=l.value;Cf&&cne(L5(pe.fullPath,ee.delta),Qb()),T(Q,pe).catch(Re=>Qi(Re,12)?Re:Qi(Re,2)?(k(Re.to,Q).then(K=>{Qi(K,20)&&!ee.delta&&ee.type===I0.pop&&r.go(-1,!1)}).catch(r0),Promise.reject()):(ee.delta&&r.go(-ee.delta,!1),O(Re,Q,pe))).then(Re=>{Re=Re||M(Q,pe,!1),Re&&(ee.delta&&!Qi(Re,8)?r.go(-ee.delta,!1):ee.type===I0.pop&&Qi(Re,20)&&r.go(-1,!1)),N(Q,pe,Re)}).catch(r0)}))}let z=Nm(),B=Nm(),V;function O(X,oe,ee){L(X);const Q=B.list();return Q.length?Q.forEach(ie=>ie(X,oe,ee)):console.error(X),Promise.reject(X)}function F(){return V&&l.value!==au?Promise.resolve():new Promise((X,oe)=>{z.add([X,oe])})}function L(X){return V||(V=!X,D(),z.list().forEach(([oe,ee])=>X?ee(X):oe()),z.reset()),X}function G(X,oe,ee,Q){const{scrollBehavior:ie}=t;if(!Cf||!ie)return Promise.resolve();const pe=!ee&&dne(L5(X.fullPath,0))||(Q||!ee)&&history.state&&history.state.scroll||null;return nt().then(()=>ie(X,oe,pe)).then(Re=>Re&&une(Re)).catch(Re=>O(Re,X,oe))}const Z=X=>r.go(X);let j;const J=new Set,fe={currentRoute:l,listening:!0,addRoute:h,removeRoute:p,hasRoute:g,getRoutes:m,resolve:y,options:t,push:_,replace:$,go:Z,back:()=>Z(-1),forward:()=>Z(1),beforeEach:o.add,beforeResolve:a.add,afterEach:i.add,onError:B.add,isReady:F,install(X){const oe=this;X.component("RouterLink",qne),X.component("RouterView",Jne),X.config.globalProperties.$router=oe,Object.defineProperty(X.config.globalProperties,"$route",{enumerable:!0,get:()=>v(l)}),Cf&&!j&&l.value===au&&(j=!0,_(r.location).catch(ie=>{}));const ee={};for(const ie in au)ee[ie]=A(()=>l.value[ie]);X.provide(cC,oe),X.provide(SM,on(ee)),X.provide(o6,l);const Q=X.unmount;J.add(X),X.unmount=function(){J.delete(X),J.size<1&&(u=au,R&&R(),R=null,l.value=au,j=!1,V=!1),Q()}}};return fe}function yf(t){return t.reduce((e,n)=>e.then(()=>n()),Promise.resolve())}function ese(t,e){const n=[],s=[],r=[],o=Math.max(e.matched.length,t.matched.length);for(let a=0;a<o;a++){const i=e.matched[a];i&&(t.matched.find(u=>lh(u,i))?s.push(i):n.push(i));const l=t.matched[a];l&&(e.matched.find(u=>lh(u,l))||r.push(l))}return[n,s,r]}const tse="/assets/banner-1dec3376.png";var nse=typeof global=="object"&&global&&global.Object===Object&&global;const CM=nse;var sse=typeof self=="object"&&self&&self.Object===Object&&self,rse=CM||sse||Function("return this")();const ri=rse;var ose=ri.Symbol;const _a=ose;var kM=Object.prototype,ase=kM.hasOwnProperty,ise=kM.toString,Im=_a?_a.toStringTag:void 0;function lse(t){var e=ase.call(t,Im),n=t[Im];try{t[Im]=void 0;var s=!0}catch{}var r=ise.call(t);return s&&(e?t[Im]=n:delete t[Im]),r}var use=Object.prototype,cse=use.toString;function dse(t){return cse.call(t)}var fse="[object Null]",hse="[object Undefined]",J5=_a?_a.toStringTag:void 0;function Yh(t){return t==null?t===void 0?hse:fse:J5&&J5 in Object(t)?lse(t):dse(t)}function $l(t){return t!=null&&typeof t=="object"}var pse="[object Symbol]";function ew(t){return typeof t=="symbol"||$l(t)&&Yh(t)==pse}function TM(t,e){for(var n=-1,s=t==null?0:t.length,r=Array(s);++n<s;)r[n]=e(t[n],n,t);return r}var mse=Array.isArray;const Ko=mse;var gse=1/0,Q5=_a?_a.prototype:void 0,eA=Q5?Q5.toString:void 0;function NM(t){if(typeof t=="string")return t;if(Ko(t))return TM(t,NM)+"";if(ew(t))return eA?eA.call(t):"";var e=t+"";return e=="0"&&1/t==-gse?"-0":e}var vse=/\s/;function yse(t){for(var e=t.length;e--&&vse.test(t.charAt(e)););return e}var bse=/^\s+/;function wse(t){return t&&t.slice(0,yse(t)+1).replace(bse,"")}function $a(t){var e=typeof t;return t!=null&&(e=="object"||e=="function")}var tA=0/0,_se=/^[-+]0x[0-9a-f]+$/i,$se=/^0b[01]+$/i,xse=/^0o[0-7]+$/i,Sse=parseInt;function nA(t){if(typeof t=="number")return t;if(ew(t))return tA;if($a(t)){var e=typeof t.valueOf=="function"?t.valueOf():t;t=$a(e)?e+"":e}if(typeof t!="string")return t===0?t:+t;t=wse(t);var n=$se.test(t);return n||xse.test(t)?Sse(t.slice(2),n?2:8):_se.test(t)?tA:+t}function dC(t){return t}var Cse="[object AsyncFunction]",kse="[object Function]",Tse="[object GeneratorFunction]",Nse="[object Proxy]";function IM(t){if(!$a(t))return!1;var e=Yh(t);return e==kse||e==Tse||e==Cse||e==Nse}var Ise=ri["__core-js_shared__"];const z4=Ise;var sA=function(){var t=/[^.]+$/.exec(z4&&z4.keys&&z4.keys.IE_PROTO||"");return t?"Symbol(src)_1."+t:""}();function Ese(t){return!!sA&&sA in t}var Ase=Function.prototype,Ose=Ase.toString;function Yd(t){if(t!=null){try{return Ose.call(t)}catch{}try{return t+""}catch{}}return""}var Rse=/[\\^$.*+?()[\]{}|]/g,Dse=/^\[object .+?Constructor\]$/,Fse=Function.prototype,Mse=Object.prototype,Pse=Fse.toString,Lse=Mse.hasOwnProperty,zse=RegExp("^"+Pse.call(Lse).replace(Rse,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$");function Bse(t){if(!$a(t)||Ese(t))return!1;var e=IM(t)?zse:Dse;return e.test(Yd(t))}function Vse(t,e){return t==null?void 0:t[e]}function Zd(t,e){var n=Vse(t,e);return Bse(n)?n:void 0}var Hse=Zd(ri,"WeakMap");const a6=Hse;var rA=Object.create,Wse=function(){function t(){}return function(e){if(!$a(e))return{};if(rA)return rA(e);t.prototype=e;var n=new t;return t.prototype=void 0,n}}();const Use=Wse;function Gse(t,e,n){switch(n.length){case 0:return t.call(e);case 1:return t.call(e,n[0]);case 2:return t.call(e,n[0],n[1]);case 3:return t.call(e,n[0],n[1],n[2])}return t.apply(e,n)}function jse(){}function Kse(t,e){var n=-1,s=t.length;for(e||(e=Array(s));++n<s;)e[n]=t[n];return e}var qse=800,Xse=16,Yse=Date.now;function Zse(t){var e=0,n=0;return function(){var s=Yse(),r=Xse-(s-n);if(n=s,r>0){if(++e>=qse)return arguments[0]}else e=0;return t.apply(void 0,arguments)}}function Jse(t){return function(){return t}}var Qse=function(){try{var t=Zd(Object,"defineProperty");return t({},"",{}),t}catch{}}();const ky=Qse;var ere=ky?function(t,e){return ky(t,"toString",{configurable:!0,enumerable:!1,value:Jse(e),writable:!0})}:dC;const tre=ere;var nre=Zse(tre);const EM=nre;function sre(t,e){for(var n=-1,s=t==null?0:t.length;++n<s&&e(t[n],n,t)!==!1;);return t}function rre(t,e,n,s){for(var r=t.length,o=n+(s?1:-1);s?o--:++o<r;)if(e(t[o],o,t))return o;return-1}function ore(t){return t!==t}function are(t,e,n){for(var s=n-1,r=t.length;++s<r;)if(t[s]===e)return s;return-1}function ire(t,e,n){return e===e?are(t,e,n):rre(t,ore,n)}function lre(t,e){var n=t==null?0:t.length;return!!n&&ire(t,e,0)>-1}var ure=9007199254740991,cre=/^(?:0|[1-9]\d*)$/;function fC(t,e){var n=typeof t;return e=e??ure,!!e&&(n=="number"||n!="symbol"&&cre.test(t))&&t>-1&&t%1==0&&t<e}function AM(t,e,n){e=="__proto__"&&ky?ky(t,e,{configurable:!0,enumerable:!0,value:n,writable:!0}):t[e]=n}function hC(t,e){return t===e||t!==t&&e!==e}var dre=Object.prototype,fre=dre.hasOwnProperty;function pC(t,e,n){var s=t[e];(!(fre.call(t,e)&&hC(s,n))||n===void 0&&!(e in t))&&AM(t,e,n)}function tw(t,e,n,s){var r=!n;n||(n={});for(var o=-1,a=e.length;++o<a;){var i=e[o],l=s?s(n[i],t[i],i,n,t):void 0;l===void 0&&(l=t[i]),r?AM(n,i,l):pC(n,i,l)}return n}var oA=Math.max;function OM(t,e,n){return e=oA(e===void 0?t.length-1:e,0),function(){for(var s=arguments,r=-1,o=oA(s.length-e,0),a=Array(o);++r<o;)a[r]=s[e+r];r=-1;for(var i=Array(e+1);++r<e;)i[r]=s[r];return i[e]=n(a),Gse(t,this,i)}}function hre(t,e){return EM(OM(t,e,dC),t+"")}var pre=9007199254740991;function mC(t){return typeof t=="number"&&t>-1&&t%1==0&&t<=pre}function Ng(t){return t!=null&&mC(t.length)&&!IM(t)}var mre=Object.prototype;function gC(t){var e=t&&t.constructor,n=typeof e=="function"&&e.prototype||mre;return t===n}function gre(t,e){for(var n=-1,s=Array(t);++n<t;)s[n]=e(n);return s}var vre="[object Arguments]";function aA(t){return $l(t)&&Yh(t)==vre}var RM=Object.prototype,yre=RM.hasOwnProperty,bre=RM.propertyIsEnumerable,wre=aA(function(){return arguments}())?aA:function(t){return $l(t)&&yre.call(t,"callee")&&!bre.call(t,"callee")};const vC=wre;function _re(){return!1}var DM=typeof Bo=="object"&&Bo&&!Bo.nodeType&&Bo,iA=DM&&typeof Vo=="object"&&Vo&&!Vo.nodeType&&Vo,$re=iA&&iA.exports===DM,lA=$re?ri.Buffer:void 0,xre=lA?lA.isBuffer:void 0,Sre=xre||_re;const Ty=Sre;var Cre="[object Arguments]",kre="[object Array]",Tre="[object Boolean]",Nre="[object Date]",Ire="[object Error]",Ere="[object Function]",Are="[object Map]",Ore="[object Number]",Rre="[object Object]",Dre="[object RegExp]",Fre="[object Set]",Mre="[object String]",Pre="[object WeakMap]",Lre="[object ArrayBuffer]",zre="[object DataView]",Bre="[object Float32Array]",Vre="[object Float64Array]",Hre="[object Int8Array]",Wre="[object Int16Array]",Ure="[object Int32Array]",Gre="[object Uint8Array]",jre="[object Uint8ClampedArray]",Kre="[object Uint16Array]",qre="[object Uint32Array]",ss={};ss[Bre]=ss[Vre]=ss[Hre]=ss[Wre]=ss[Ure]=ss[Gre]=ss[jre]=ss[Kre]=ss[qre]=!0;ss[Cre]=ss[kre]=ss[Lre]=ss[Tre]=ss[zre]=ss[Nre]=ss[Ire]=ss[Ere]=ss[Are]=ss[Ore]=ss[Rre]=ss[Dre]=ss[Fre]=ss[Mre]=ss[Pre]=!1;function Xre(t){return $l(t)&&mC(t.length)&&!!ss[Yh(t)]}function yC(t){return function(e){return t(e)}}var FM=typeof Bo=="object"&&Bo&&!Bo.nodeType&&Bo,a0=FM&&typeof Vo=="object"&&Vo&&!Vo.nodeType&&Vo,Yre=a0&&a0.exports===FM,B4=Yre&&CM.process,Zre=function(){try{var t=a0&&a0.require&&a0.require("util").types;return t||B4&&B4.binding&&B4.binding("util")}catch{}}();const ch=Zre;var uA=ch&&ch.isTypedArray,Jre=uA?yC(uA):Xre;const MM=Jre;var Qre=Object.prototype,eoe=Qre.hasOwnProperty;function PM(t,e){var n=Ko(t),s=!n&&vC(t),r=!n&&!s&&Ty(t),o=!n&&!s&&!r&&MM(t),a=n||s||r||o,i=a?gre(t.length,String):[],l=i.length;for(var u in t)(e||eoe.call(t,u))&&!(a&&(u=="length"||r&&(u=="offset"||u=="parent")||o&&(u=="buffer"||u=="byteLength"||u=="byteOffset")||fC(u,l)))&&i.push(u);return i}function LM(t,e){return function(n){return t(e(n))}}var toe=LM(Object.keys,Object);const noe=toe;var soe=Object.prototype,roe=soe.hasOwnProperty;function ooe(t){if(!gC(t))return noe(t);var e=[];for(var n in Object(t))roe.call(t,n)&&n!="constructor"&&e.push(n);return e}function Ig(t){return Ng(t)?PM(t):ooe(t)}function aoe(t){var e=[];if(t!=null)for(var n in Object(t))e.push(n);return e}var ioe=Object.prototype,loe=ioe.hasOwnProperty;function uoe(t){if(!$a(t))return aoe(t);var e=gC(t),n=[];for(var s in t)s=="constructor"&&(e||!loe.call(t,s))||n.push(s);return n}function bC(t){return Ng(t)?PM(t,!0):uoe(t)}var coe=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,doe=/^\w*$/;function wC(t,e){if(Ko(t))return!1;var n=typeof t;return n=="number"||n=="symbol"||n=="boolean"||t==null||ew(t)?!0:doe.test(t)||!coe.test(t)||e!=null&&t in Object(e)}var foe=Zd(Object,"create");const E0=foe;function hoe(){this.__data__=E0?E0(null):{},this.size=0}function poe(t){var e=this.has(t)&&delete this.__data__[t];return this.size-=e?1:0,e}var moe="__lodash_hash_undefined__",goe=Object.prototype,voe=goe.hasOwnProperty;function yoe(t){var e=this.__data__;if(E0){var n=e[t];return n===moe?void 0:n}return voe.call(e,t)?e[t]:void 0}var boe=Object.prototype,woe=boe.hasOwnProperty;function _oe(t){var e=this.__data__;return E0?e[t]!==void 0:woe.call(e,t)}var $oe="__lodash_hash_undefined__";function xoe(t,e){var n=this.__data__;return this.size+=this.has(t)?0:1,n[t]=E0&&e===void 0?$oe:e,this}function bd(t){var e=-1,n=t==null?0:t.length;for(this.clear();++e<n;){var s=t[e];this.set(s[0],s[1])}}bd.prototype.clear=hoe;bd.prototype.delete=poe;bd.prototype.get=yoe;bd.prototype.has=_oe;bd.prototype.set=xoe;function Soe(){this.__data__=[],this.size=0}function nw(t,e){for(var n=t.length;n--;)if(hC(t[n][0],e))return n;return-1}var Coe=Array.prototype,koe=Coe.splice;function Toe(t){var e=this.__data__,n=nw(e,t);if(n<0)return!1;var s=e.length-1;return n==s?e.pop():koe.call(e,n,1),--this.size,!0}function Noe(t){var e=this.__data__,n=nw(e,t);return n<0?void 0:e[n][1]}function Ioe(t){return nw(this.__data__,t)>-1}function Eoe(t,e){var n=this.__data__,s=nw(n,t);return s<0?(++this.size,n.push([t,e])):n[s][1]=e,this}function Pl(t){var e=-1,n=t==null?0:t.length;for(this.clear();++e<n;){var s=t[e];this.set(s[0],s[1])}}Pl.prototype.clear=Soe;Pl.prototype.delete=Toe;Pl.prototype.get=Noe;Pl.prototype.has=Ioe;Pl.prototype.set=Eoe;var Aoe=Zd(ri,"Map");const A0=Aoe;function Ooe(){this.size=0,this.__data__={hash:new bd,map:new(A0||Pl),string:new bd}}function Roe(t){var e=typeof t;return e=="string"||e=="number"||e=="symbol"||e=="boolean"?t!=="__proto__":t===null}function sw(t,e){var n=t.__data__;return Roe(e)?n[typeof e=="string"?"string":"hash"]:n.map}function Doe(t){var e=sw(this,t).delete(t);return this.size-=e?1:0,e}function Foe(t){return sw(this,t).get(t)}function Moe(t){return sw(this,t).has(t)}function Poe(t,e){var n=sw(this,t),s=n.size;return n.set(t,e),this.size+=n.size==s?0:1,this}function Ll(t){var e=-1,n=t==null?0:t.length;for(this.clear();++e<n;){var s=t[e];this.set(s[0],s[1])}}Ll.prototype.clear=Ooe;Ll.prototype.delete=Doe;Ll.prototype.get=Foe;Ll.prototype.has=Moe;Ll.prototype.set=Poe;var Loe="Expected a function";function rw(t,e){if(typeof t!="function"||e!=null&&typeof e!="function")throw new TypeError(Loe);var n=function(){var s=arguments,r=e?e.apply(this,s):s[0],o=n.cache;if(o.has(r))return o.get(r);var a=t.apply(this,s);return n.cache=o.set(r,a)||o,a};return n.cache=new(rw.Cache||Ll),n}rw.Cache=Ll;var zoe=500;function Boe(t){var e=rw(t,function(s){return n.size===zoe&&n.clear(),s}),n=e.cache;return e}var Voe=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,Hoe=/\\(\\)?/g,Woe=Boe(function(t){var e=[];return t.charCodeAt(0)===46&&e.push(""),t.replace(Voe,function(n,s,r,o){e.push(r?o.replace(Hoe,"$1"):s||n)}),e});const Uoe=Woe;function Goe(t){return t==null?"":NM(t)}function ow(t,e){return Ko(t)?t:wC(t,e)?[t]:Uoe(Goe(t))}var joe=1/0;function Eg(t){if(typeof t=="string"||ew(t))return t;var e=t+"";return e=="0"&&1/t==-joe?"-0":e}function _C(t,e){e=ow(e,t);for(var n=0,s=e.length;t!=null&&n<s;)t=t[Eg(e[n++])];return n&&n==s?t:void 0}function Pn(t,e,n){var s=t==null?void 0:_C(t,e);return s===void 0?n:s}function $C(t,e){for(var n=-1,s=e.length,r=t.length;++n<s;)t[r+n]=e[n];return t}var cA=_a?_a.isConcatSpreadable:void 0;function Koe(t){return Ko(t)||vC(t)||!!(cA&&t&&t[cA])}function Ag(t,e,n,s,r){var o=-1,a=t.length;for(n||(n=Koe),r||(r=[]);++o<a;){var i=t[o];e>0&&n(i)?e>1?Ag(i,e-1,n,s,r):$C(r,i):s||(r[r.length]=i)}return r}function zM(t){var e=t==null?0:t.length;return e?Ag(t,1):[]}function qoe(t){return EM(OM(t,void 0,zM),t+"")}var Xoe=LM(Object.getPrototypeOf,Object);const BM=Xoe;function dh(){if(!arguments.length)return[];var t=arguments[0];return Ko(t)?t:[t]}function Yoe(){this.__data__=new Pl,this.size=0}function Zoe(t){var e=this.__data__,n=e.delete(t);return this.size=e.size,n}function Joe(t){return this.__data__.get(t)}function Qoe(t){return this.__data__.has(t)}var eae=200;function tae(t,e){var n=this.__data__;if(n instanceof Pl){var s=n.__data__;if(!A0||s.length<eae-1)return s.push([t,e]),this.size=++n.size,this;n=this.__data__=new Ll(s)}return n.set(t,e),this.size=n.size,this}function Ei(t){var e=this.__data__=new Pl(t);this.size=e.size}Ei.prototype.clear=Yoe;Ei.prototype.delete=Zoe;Ei.prototype.get=Joe;Ei.prototype.has=Qoe;Ei.prototype.set=tae;function nae(t,e){return t&&tw(e,Ig(e),t)}function sae(t,e){return t&&tw(e,bC(e),t)}var VM=typeof Bo=="object"&&Bo&&!Bo.nodeType&&Bo,dA=VM&&typeof Vo=="object"&&Vo&&!Vo.nodeType&&Vo,rae=dA&&dA.exports===VM,fA=rae?ri.Buffer:void 0,hA=fA?fA.allocUnsafe:void 0;function oae(t,e){if(e)return t.slice();var n=t.length,s=hA?hA(n):new t.constructor(n);return t.copy(s),s}function aae(t,e){for(var n=-1,s=t==null?0:t.length,r=0,o=[];++n<s;){var a=t[n];e(a,n,t)&&(o[r++]=a)}return o}function HM(){return[]}var iae=Object.prototype,lae=iae.propertyIsEnumerable,pA=Object.getOwnPropertySymbols,uae=pA?function(t){return t==null?[]:(t=Object(t),aae(pA(t),function(e){return lae.call(t,e)}))}:HM;const xC=uae;function cae(t,e){return tw(t,xC(t),e)}var dae=Object.getOwnPropertySymbols,fae=dae?function(t){for(var e=[];t;)$C(e,xC(t)),t=BM(t);return e}:HM;const WM=fae;function hae(t,e){return tw(t,WM(t),e)}function UM(t,e,n){var s=e(t);return Ko(t)?s:$C(s,n(t))}function i6(t){return UM(t,Ig,xC)}function pae(t){return UM(t,bC,WM)}var mae=Zd(ri,"DataView");const l6=mae;var gae=Zd(ri,"Promise");const u6=gae;var vae=Zd(ri,"Set");const Uf=vae;var mA="[object Map]",yae="[object Object]",gA="[object Promise]",vA="[object Set]",yA="[object WeakMap]",bA="[object DataView]",bae=Yd(l6),wae=Yd(A0),_ae=Yd(u6),$ae=Yd(Uf),xae=Yd(a6),Oc=Yh;(l6&&Oc(new l6(new ArrayBuffer(1)))!=bA||A0&&Oc(new A0)!=mA||u6&&Oc(u6.resolve())!=gA||Uf&&Oc(new Uf)!=vA||a6&&Oc(new a6)!=yA)&&(Oc=function(t){var e=Yh(t),n=e==yae?t.constructor:void 0,s=n?Yd(n):"";if(s)switch(s){case bae:return bA;case wae:return mA;case _ae:return gA;case $ae:return vA;case xae:return yA}return e});const O0=Oc;var Sae=Object.prototype,Cae=Sae.hasOwnProperty;function kae(t){var e=t.length,n=new t.constructor(e);return e&&typeof t[0]=="string"&&Cae.call(t,"index")&&(n.index=t.index,n.input=t.input),n}var Tae=ri.Uint8Array;const Ny=Tae;function SC(t){var e=new t.constructor(t.byteLength);return new Ny(e).set(new Ny(t)),e}function Nae(t,e){var n=e?SC(t.buffer):t.buffer;return new t.constructor(n,t.byteOffset,t.byteLength)}var Iae=/\w*$/;function Eae(t){var e=new t.constructor(t.source,Iae.exec(t));return e.lastIndex=t.lastIndex,e}var wA=_a?_a.prototype:void 0,_A=wA?wA.valueOf:void 0;function Aae(t){return _A?Object(_A.call(t)):{}}function Oae(t,e){var n=e?SC(t.buffer):t.buffer;return new t.constructor(n,t.byteOffset,t.length)}var Rae="[object Boolean]",Dae="[object Date]",Fae="[object Map]",Mae="[object Number]",Pae="[object RegExp]",Lae="[object Set]",zae="[object String]",Bae="[object Symbol]",Vae="[object ArrayBuffer]",Hae="[object DataView]",Wae="[object Float32Array]",Uae="[object Float64Array]",Gae="[object Int8Array]",jae="[object Int16Array]",Kae="[object Int32Array]",qae="[object Uint8Array]",Xae="[object Uint8ClampedArray]",Yae="[object Uint16Array]",Zae="[object Uint32Array]";function Jae(t,e,n){var s=t.constructor;switch(e){case Vae:return SC(t);case Rae:case Dae:return new s(+t);case Hae:return Nae(t,n);case Wae:case Uae:case Gae:case jae:case Kae:case qae:case Xae:case Yae:case Zae:return Oae(t,n);case Fae:return new s;case Mae:case zae:return new s(t);case Pae:return Eae(t);case Lae:return new s;case Bae:return Aae(t)}}function Qae(t){return typeof t.constructor=="function"&&!gC(t)?Use(BM(t)):{}}var eie="[object Map]";function tie(t){return $l(t)&&O0(t)==eie}var $A=ch&&ch.isMap,nie=$A?yC($A):tie;const sie=nie;var rie="[object Set]";function oie(t){return $l(t)&&O0(t)==rie}var xA=ch&&ch.isSet,aie=xA?yC(xA):oie;const iie=aie;var lie=1,uie=2,cie=4,GM="[object Arguments]",die="[object Array]",fie="[object Boolean]",hie="[object Date]",pie="[object Error]",jM="[object Function]",mie="[object GeneratorFunction]",gie="[object Map]",vie="[object Number]",KM="[object Object]",yie="[object RegExp]",bie="[object Set]",wie="[object String]",_ie="[object Symbol]",$ie="[object WeakMap]",xie="[object ArrayBuffer]",Sie="[object DataView]",Cie="[object Float32Array]",kie="[object Float64Array]",Tie="[object Int8Array]",Nie="[object Int16Array]",Iie="[object Int32Array]",Eie="[object Uint8Array]",Aie="[object Uint8ClampedArray]",Oie="[object Uint16Array]",Rie="[object Uint32Array]",Kn={};Kn[GM]=Kn[die]=Kn[xie]=Kn[Sie]=Kn[fie]=Kn[hie]=Kn[Cie]=Kn[kie]=Kn[Tie]=Kn[Nie]=Kn[Iie]=Kn[gie]=Kn[vie]=Kn[KM]=Kn[yie]=Kn[bie]=Kn[wie]=Kn[_ie]=Kn[Eie]=Kn[Aie]=Kn[Oie]=Kn[Rie]=!0;Kn[pie]=Kn[jM]=Kn[$ie]=!1;function i0(t,e,n,s,r,o){var a,i=e&lie,l=e&uie,u=e&cie;if(n&&(a=r?n(t,s,r,o):n(t)),a!==void 0)return a;if(!$a(t))return t;var c=Ko(t);if(c){if(a=kae(t),!i)return Kse(t,a)}else{var d=O0(t),f=d==jM||d==mie;if(Ty(t))return oae(t,i);if(d==KM||d==GM||f&&!r){if(a=l||f?{}:Qae(t),!i)return l?hae(t,sae(a,t)):cae(t,nae(a,t))}else{if(!Kn[d])return r?t:{};a=Jae(t,d,i)}}o||(o=new Ei);var h=o.get(t);if(h)return h;o.set(t,a),iie(t)?t.forEach(function(g){a.add(i0(g,e,n,g,t,o))}):sie(t)&&t.forEach(function(g,y){a.set(y,i0(g,e,n,y,t,o))});var p=u?l?pae:i6:l?bC:Ig,m=c?void 0:p(t);return sre(m||t,function(g,y){m&&(y=g,g=t[y]),pC(a,y,i0(g,e,n,y,t,o))}),a}var Die=4;function SA(t){return i0(t,Die)}var Fie=1,Mie=4;function qM(t){return i0(t,Fie|Mie)}var Pie="__lodash_hash_undefined__";function Lie(t){return this.__data__.set(t,Pie),this}function zie(t){return this.__data__.has(t)}function R0(t){var e=-1,n=t==null?0:t.length;for(this.__data__=new Ll;++e<n;)this.add(t[e])}R0.prototype.add=R0.prototype.push=Lie;R0.prototype.has=zie;function Bie(t,e){for(var n=-1,s=t==null?0:t.length;++n<s;)if(e(t[n],n,t))return!0;return!1}function XM(t,e){return t.has(e)}var Vie=1,Hie=2;function YM(t,e,n,s,r,o){var a=n&Vie,i=t.length,l=e.length;if(i!=l&&!(a&&l>i))return!1;var u=o.get(t),c=o.get(e);if(u&&c)return u==e&&c==t;var d=-1,f=!0,h=n&Hie?new R0:void 0;for(o.set(t,e),o.set(e,t);++d<i;){var p=t[d],m=e[d];if(s)var g=a?s(m,p,d,e,t,o):s(p,m,d,t,e,o);if(g!==void 0){if(g)continue;f=!1;break}if(h){if(!Bie(e,function(y,w){if(!XM(h,w)&&(p===y||r(p,y,n,s,o)))return h.push(w)})){f=!1;break}}else if(!(p===m||r(p,m,n,s,o))){f=!1;break}}return o.delete(t),o.delete(e),f}function Wie(t){var e=-1,n=Array(t.size);return t.forEach(function(s,r){n[++e]=[r,s]}),n}function CC(t){var e=-1,n=Array(t.size);return t.forEach(function(s){n[++e]=s}),n}var Uie=1,Gie=2,jie="[object Boolean]",Kie="[object Date]",qie="[object Error]",Xie="[object Map]",Yie="[object Number]",Zie="[object RegExp]",Jie="[object Set]",Qie="[object String]",ele="[object Symbol]",tle="[object ArrayBuffer]",nle="[object DataView]",CA=_a?_a.prototype:void 0,V4=CA?CA.valueOf:void 0;function sle(t,e,n,s,r,o,a){switch(n){case nle:if(t.byteLength!=e.byteLength||t.byteOffset!=e.byteOffset)return!1;t=t.buffer,e=e.buffer;case tle:return!(t.byteLength!=e.byteLength||!o(new Ny(t),new Ny(e)));case jie:case Kie:case Yie:return hC(+t,+e);case qie:return t.name==e.name&&t.message==e.message;case Zie:case Qie:return t==e+"";case Xie:var i=Wie;case Jie:var l=s&Uie;if(i||(i=CC),t.size!=e.size&&!l)return!1;var u=a.get(t);if(u)return u==e;s|=Gie,a.set(t,e);var c=YM(i(t),i(e),s,r,o,a);return a.delete(t),c;case ele:if(V4)return V4.call(t)==V4.call(e)}return!1}var rle=1,ole=Object.prototype,ale=ole.hasOwnProperty;function ile(t,e,n,s,r,o){var a=n&rle,i=i6(t),l=i.length,u=i6(e),c=u.length;if(l!=c&&!a)return!1;for(var d=l;d--;){var f=i[d];if(!(a?f in e:ale.call(e,f)))return!1}var h=o.get(t),p=o.get(e);if(h&&p)return h==e&&p==t;var m=!0;o.set(t,e),o.set(e,t);for(var g=a;++d<l;){f=i[d];var y=t[f],w=e[f];if(s)var b=a?s(w,y,f,e,t,o):s(y,w,f,t,e,o);if(!(b===void 0?y===w||r(y,w,n,s,o):b)){m=!1;break}g||(g=f=="constructor")}if(m&&!g){var _=t.constructor,$=e.constructor;_!=$&&"constructor"in t&&"constructor"in e&&!(typeof _=="function"&&_ instanceof _&&typeof $=="function"&&$ instanceof $)&&(m=!1)}return o.delete(t),o.delete(e),m}var lle=1,kA="[object Arguments]",TA="[object Array]",Q2="[object Object]",ule=Object.prototype,NA=ule.hasOwnProperty;function cle(t,e,n,s,r,o){var a=Ko(t),i=Ko(e),l=a?TA:O0(t),u=i?TA:O0(e);l=l==kA?Q2:l,u=u==kA?Q2:u;var c=l==Q2,d=u==Q2,f=l==u;if(f&&Ty(t)){if(!Ty(e))return!1;a=!0,c=!1}if(f&&!c)return o||(o=new Ei),a||MM(t)?YM(t,e,n,s,r,o):sle(t,e,l,n,s,r,o);if(!(n&lle)){var h=c&&NA.call(t,"__wrapped__"),p=d&&NA.call(e,"__wrapped__");if(h||p){var m=h?t.value():t,g=p?e.value():e;return o||(o=new Ei),r(m,g,n,s,o)}}return f?(o||(o=new Ei),ile(t,e,n,s,r,o)):!1}function aw(t,e,n,s,r){return t===e?!0:t==null||e==null||!$l(t)&&!$l(e)?t!==t&&e!==e:cle(t,e,n,s,aw,r)}var dle=1,fle=2;function hle(t,e,n,s){var r=n.length,o=r,a=!s;if(t==null)return!o;for(t=Object(t);r--;){var i=n[r];if(a&&i[2]?i[1]!==t[i[0]]:!(i[0]in t))return!1}for(;++r<o;){i=n[r];var l=i[0],u=t[l],c=i[1];if(a&&i[2]){if(u===void 0&&!(l in t))return!1}else{var d=new Ei;if(s)var f=s(u,c,l,t,e,d);if(!(f===void 0?aw(c,u,dle|fle,s,d):f))return!1}}return!0}function ZM(t){return t===t&&!$a(t)}function ple(t){for(var e=Ig(t),n=e.length;n--;){var s=e[n],r=t[s];e[n]=[s,r,ZM(r)]}return e}function JM(t,e){return function(n){return n==null?!1:n[t]===e&&(e!==void 0||t in Object(n))}}function mle(t){var e=ple(t);return e.length==1&&e[0][2]?JM(e[0][0],e[0][1]):function(n){return n===t||hle(n,t,e)}}function gle(t,e){return t!=null&&e in Object(t)}function vle(t,e,n){e=ow(e,t);for(var s=-1,r=e.length,o=!1;++s<r;){var a=Eg(e[s]);if(!(o=t!=null&&n(t,a)))break;t=t[a]}return o||++s!=r?o:(r=t==null?0:t.length,!!r&&mC(r)&&fC(a,r)&&(Ko(t)||vC(t)))}function QM(t,e){return t!=null&&vle(t,e,gle)}var yle=1,ble=2;function wle(t,e){return wC(t)&&ZM(e)?JM(Eg(t),e):function(n){var s=Pn(n,t);return s===void 0&&s===e?QM(n,t):aw(e,s,yle|ble)}}function _le(t){return function(e){return e==null?void 0:e[t]}}function $le(t){return function(e){return _C(e,t)}}function xle(t){return wC(t)?_le(Eg(t)):$le(t)}function Sle(t){return typeof t=="function"?t:t==null?dC:typeof t=="object"?Ko(t)?wle(t[0],t[1]):mle(t):xle(t)}function Cle(t){return function(e,n,s){for(var r=-1,o=Object(e),a=s(e),i=a.length;i--;){var l=a[t?i:++r];if(n(o[l],l,o)===!1)break}return e}}var kle=Cle();const Tle=kle;function Nle(t,e){return t&&Tle(t,e,Ig)}function Ile(t,e){return function(n,s){if(n==null)return n;if(!Ng(n))return t(n,s);for(var r=n.length,o=e?r:-1,a=Object(n);(e?o--:++o<r)&&s(a[o],o,a)!==!1;);return n}}var Ele=Ile(Nle);const Ale=Ele;var Ole=function(){return ri.Date.now()};const H4=Ole;var Rle="Expected a function",Dle=Math.max,Fle=Math.min;function Xr(t,e,n){var s,r,o,a,i,l,u=0,c=!1,d=!1,f=!0;if(typeof t!="function")throw new TypeError(Rle);e=nA(e)||0,$a(n)&&(c=!!n.leading,d="maxWait"in n,o=d?Dle(nA(n.maxWait)||0,e):o,f="trailing"in n?!!n.trailing:f);function h(x){var k=s,C=r;return s=r=void 0,u=x,a=t.apply(C,k),a}function p(x){return u=x,i=setTimeout(y,e),c?h(x):a}function m(x){var k=x-l,C=x-u,T=e-k;return d?Fle(T,o-C):T}function g(x){var k=x-l,C=x-u;return l===void 0||k>=e||k<0||d&&C>=o}function y(){var x=H4();if(g(x))return w(x);i=setTimeout(y,m(x))}function w(x){return i=void 0,f&&s?h(x):(s=r=void 0,a)}function b(){i!==void 0&&clearTimeout(i),u=0,s=l=r=i=void 0}function _(){return i===void 0?a:w(H4())}function $(){var x=H4(),k=g(x);if(s=arguments,r=this,l=x,k){if(i===void 0)return p(l);if(d)return clearTimeout(i),i=setTimeout(y,e),h(l)}return i===void 0&&(i=setTimeout(y,e)),a}return $.cancel=b,$.flush=_,$}function Mle(t){return $l(t)&&Ng(t)}function Ple(t,e,n){for(var s=-1,r=t==null?0:t.length;++s<r;)if(n(e,t[s]))return!0;return!1}function Lle(t,e){var n=-1,s=Ng(t)?Array(t.length):[];return Ale(t,function(r,o,a){s[++n]=e(r,o,a)}),s}function zle(t,e){var n=Ko(t)?TM:Lle;return n(t,Sle(e))}function Ble(t,e){return Ag(zle(t,e),1)}var Vle=1/0;function Hle(t){var e=t==null?0:t.length;return e?Ag(t,Vle):[]}function eP(t){for(var e=-1,n=t==null?0:t.length,s={};++e<n;){var r=t[e];s[r[0]]=r[1]}return s}function Wo(t,e){return aw(t,e)}function nr(t){return t==null}function tP(t,e,n,s){if(!$a(t))return t;e=ow(e,t);for(var r=-1,o=e.length,a=o-1,i=t;i!=null&&++r<o;){var l=Eg(e[r]),u=n;if(l==="__proto__"||l==="constructor"||l==="prototype")return t;if(r!=a){var c=i[l];u=s?s(c,l,i):void 0,u===void 0&&(u=$a(c)?c:fC(e[r+1])?[]:{})}pC(i,l,u),i=i[l]}return t}function Wle(t,e,n){for(var s=-1,r=e.length,o={};++s<r;){var a=e[s],i=_C(t,a);n(i,a)&&tP(o,ow(a,t),i)}return o}function Ule(t,e){return Wle(t,e,function(n,s){return QM(t,s)})}var Gle=qoe(function(t,e){return t==null?{}:Ule(t,e)});const gl=Gle;function jle(t,e,n){return t==null?t:tP(t,e,n)}var Kle="Expected a function";function rd(t,e,n){var s=!0,r=!0;if(typeof t!="function")throw new TypeError(Kle);return $a(n)&&(s="leading"in n?!!n.leading:s,r="trailing"in n?!!n.trailing:r),Xr(t,e,{leading:s,maxWait:e,trailing:r})}var qle=1/0,Xle=Uf&&1/CC(new Uf([,-0]))[1]==qle?function(t){return new Uf(t)}:jse;const Yle=Xle;var Zle=200;function Jle(t,e,n){var s=-1,r=lre,o=t.length,a=!0,i=[],l=i;if(n)a=!1,r=Ple;else if(o>=Zle){var u=e?null:Yle(t);if(u)return CC(u);a=!1,r=XM,l=new R0}else l=e?[]:i;e:for(;++s<o;){var c=t[s],d=e?e(c):c;if(c=n||c!==0?c:0,a&&d===d){for(var f=l.length;f--;)if(l[f]===d)continue e;e&&l.push(d),i.push(c)}else r(l,d,n)||(l!==i&&l.push(d),i.push(c))}return i}var Qle=hre(function(t){return Jle(Ag(t,1,Mle,!0))});const W4=Qle,eue='a[href],button:not([disabled]),button:not([hidden]),:not([tabindex="-1"]),input:not([disabled]),input:not([type="hidden"]),select:not([disabled]),textarea:not([disabled])',tue=t=>getComputedStyle(t).position==="fixed"?!1:t.offsetParent!==null,IA=t=>Array.from(t.querySelectorAll(eue)).filter(e=>nue(e)&&tue(e)),nue=t=>{if(t.tabIndex>0||t.tabIndex===0&&t.getAttribute("tabIndex")!==null)return!0;if(t.disabled)return!1;switch(t.nodeName){case"A":return!!t.href&&t.rel!=="ignore";case"INPUT":return!(t.type==="hidden"||t.type==="file");case"BUTTON":case"SELECT":case"TEXTAREA":return!0;default:return!1}},Vv=function(t,e,...n){let s;e.includes("mouse")||e.includes("click")?s="MouseEvents":e.includes("key")?s="KeyboardEvent":s="HTMLEvents";const r=document.createEvent(s);return r.initEvent(e,...n),t.dispatchEvent(r),t},nP=t=>!t.getAttribute("aria-owns"),sP=(t,e,n)=>{const{parentNode:s}=t;if(!s)return null;const r=s.querySelectorAll(n),o=Array.prototype.indexOf.call(r,t);return r[o+e]||null},Hv=t=>{!t||(t.focus(),!nP(t)&&t.click())},Xn=(t,e,{checkForDefaultPrevented:n=!0}={})=>r=>{const o=t==null?void 0:t(r);if(n===!1||!o)return e==null?void 0:e(r)},EA=t=>e=>e.pointerType==="mouse"?t(e):void 0;var sue=Object.defineProperty,rue=Object.defineProperties,oue=Object.getOwnPropertyDescriptors,AA=Object.getOwnPropertySymbols,aue=Object.prototype.hasOwnProperty,iue=Object.prototype.propertyIsEnumerable,OA=(t,e,n)=>e in t?sue(t,e,{enumerable:!0,configurable:!0,writable:!0,value:n}):t[e]=n,lue=(t,e)=>{for(var n in e||(e={}))aue.call(e,n)&&OA(t,n,e[n]);if(AA)for(var n of AA(e))iue.call(e,n)&&OA(t,n,e[n]);return t},uue=(t,e)=>rue(t,oue(e));function RA(t,e){var n;const s=Nn();return Ho(()=>{s.value=t()},uue(lue({},e),{flush:(n=e==null?void 0:e.flush)!=null?n:"sync"})),Cg(s)}var DA;const Kt=typeof window<"u",cue=t=>typeof t<"u",Rs=t=>typeof t=="boolean",due=t=>typeof t=="function",Ct=t=>typeof t=="number",fue=t=>typeof t=="string",hue=()=>{};Kt&&((DA=window==null?void 0:window.navigator)==null?void 0:DA.userAgent)&&/iP(ad|hone|od)/.test(window.navigator.userAgent);function wd(t){return typeof t=="function"?t():v(t)}function rP(t,e){function n(...s){t(()=>e.apply(this,s),{fn:e,thisArg:this,args:s})}return n}function pue(t,e={}){let n,s;return o=>{const a=wd(t),i=wd(e.maxWait);if(n&&clearTimeout(n),a<=0||i!==void 0&&i<=0)return s&&(clearTimeout(s),s=null),o();i&&!s&&(s=setTimeout(()=>{n&&clearTimeout(n),s=null,o()},i)),n=setTimeout(()=>{s&&clearTimeout(s),s=null,o()},a)}}function mue(t,e=!0,n=!0){let s=0,r,o=!0;const a=()=>{r&&(clearTimeout(r),r=void 0)};return l=>{const u=wd(t),c=Date.now()-s;if(a(),u<=0)return s=Date.now(),l();c>u&&(n||!o)?(s=Date.now(),l()):e&&(r=setTimeout(()=>{s=Date.now(),o=!0,a(),l()},u-c)),!n&&!r&&(r=setTimeout(()=>o=!0,u)),o=!1}}function gue(t){return t}function iw(t){return LQ()?(cF(t),!0):!1}function vue(t,e=200,n={}){return rP(pue(e,n),t)}function yue(t,e=200,n={}){const s=U(t.value),r=vue(()=>{s.value=t.value},e,n);return Me(t,()=>r()),s}function oP(t,e=200,n=!1,s=!0){return rP(mue(e,n,s),t)}function kC(t,e=!0){Rt()?It(t):e?t():nt(t)}function _d(t,e,n={}){const{immediate:s=!0}=n,r=U(!1);let o=null;function a(){o&&(clearTimeout(o),o=null)}function i(){r.value=!1,a()}function l(...u){a(),r.value=!0,o=setTimeout(()=>{r.value=!1,o=null,t(...u)},wd(e))}return s&&(r.value=!0,Kt&&l()),iw(i),{isPending:r,start:l,stop:i}}function Mo(t){var e;const n=wd(t);return(e=n==null?void 0:n.$el)!=null?e:n}const Zh=Kt?window:void 0,bue=Kt?window.document:void 0;function Rn(...t){let e,n,s,r;if(fue(t[0])||Array.isArray(t[0])?([n,s,r]=t,e=Zh):[e,n,s,r]=t,!e)return hue;Array.isArray(n)||(n=[n]),Array.isArray(s)||(s=[s]);const o=[],a=()=>{o.forEach(c=>c()),o.length=0},i=(c,d,f)=>(c.addEventListener(d,f,r),()=>c.removeEventListener(d,f,r)),l=Me(()=>Mo(e),c=>{a(),c&&o.push(...n.flatMap(d=>s.map(f=>i(c,d,f))))},{immediate:!0,flush:"post"}),u=()=>{l(),a()};return iw(u),u}function TC(t,e,n={}){const{window:s=Zh,ignore:r,capture:o=!0,detectIframe:a=!1}=n;if(!s)return;let i=!0,l;const u=h=>{s.clearTimeout(l);const p=Mo(t);if(!(!p||p===h.target||h.composedPath().includes(p))){if(!i){i=!0;return}e(h)}},c=h=>r&&r.some(p=>{const m=Mo(p);return m&&(h.target===m||h.composedPath().includes(m))}),d=[Rn(s,"click",u,{passive:!0,capture:o}),Rn(s,"pointerdown",h=>{const p=Mo(t);p&&(i=!h.composedPath().includes(p)&&!c(h))},{passive:!0}),Rn(s,"pointerup",h=>{if(h.button===0){const p=h.composedPath();h.composedPath=()=>p,l=s.setTimeout(()=>u(h),50)}},{passive:!0}),a&&Rn(s,"blur",h=>{var p;const m=Mo(t);((p=s.document.activeElement)==null?void 0:p.tagName)==="IFRAME"&&!(m!=null&&m.contains(s.document.activeElement))&&e(h)})].filter(Boolean);return()=>d.forEach(h=>h())}function wue(t,e=!1){const n=U(),s=()=>n.value=Boolean(t());return s(),kC(s,e),n}function _ue(t){return JSON.parse(JSON.stringify(t))}const c6=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{},d6="__vueuse_ssr_handlers__";c6[d6]=c6[d6]||{};c6[d6];function $ue(t,e,{window:n=Zh,initialValue:s=""}={}){const r=U(s),o=A(()=>{var a;return Mo(e)||((a=n==null?void 0:n.document)==null?void 0:a.documentElement)});return Me([o,()=>wd(t)],([a,i])=>{var l;if(a&&n){const u=(l=n.getComputedStyle(a).getPropertyValue(i))==null?void 0:l.trim();r.value=u||s}},{immediate:!0}),Me(r,a=>{var i;(i=o.value)!=null&&i.style&&o.value.style.setProperty(wd(t),a)}),r}function xue({document:t=bue}={}){if(!t)return U("visible");const e=U(t.visibilityState);return Rn(t,"visibilitychange",()=>{e.value=t.visibilityState}),e}var FA=Object.getOwnPropertySymbols,Sue=Object.prototype.hasOwnProperty,Cue=Object.prototype.propertyIsEnumerable,kue=(t,e)=>{var n={};for(var s in t)Sue.call(t,s)&&e.indexOf(s)<0&&(n[s]=t[s]);if(t!=null&&FA)for(var s of FA(t))e.indexOf(s)<0&&Cue.call(t,s)&&(n[s]=t[s]);return n};function Dr(t,e,n={}){const s=n,{window:r=Zh}=s,o=kue(s,["window"]);let a;const i=wue(()=>r&&"ResizeObserver"in r),l=()=>{a&&(a.disconnect(),a=void 0)},u=Me(()=>Mo(t),d=>{l(),i.value&&r&&d&&(a=new ResizeObserver(e),a.observe(d,o))},{immediate:!0,flush:"post"}),c=()=>{l(),u()};return iw(c),{isSupported:i,stop:c}}function MA(t,e={}){const{reset:n=!0,windowResize:s=!0,windowScroll:r=!0,immediate:o=!0}=e,a=U(0),i=U(0),l=U(0),u=U(0),c=U(0),d=U(0),f=U(0),h=U(0);function p(){const m=Mo(t);if(!m){n&&(a.value=0,i.value=0,l.value=0,u.value=0,c.value=0,d.value=0,f.value=0,h.value=0);return}const g=m.getBoundingClientRect();a.value=g.height,i.value=g.bottom,l.value=g.left,u.value=g.right,c.value=g.top,d.value=g.width,f.value=g.x,h.value=g.y}return Dr(t,p),Me(()=>Mo(t),m=>!m&&p()),r&&Rn("scroll",p,{passive:!0}),s&&Rn("resize",p,{passive:!0}),kC(()=>{o&&p()}),{height:a,bottom:i,left:l,right:u,top:c,width:d,x:f,y:h,update:p}}var PA;(function(t){t.UP="UP",t.RIGHT="RIGHT",t.DOWN="DOWN",t.LEFT="LEFT",t.NONE="NONE"})(PA||(PA={}));var Tue=Object.defineProperty,LA=Object.getOwnPropertySymbols,Nue=Object.prototype.hasOwnProperty,Iue=Object.prototype.propertyIsEnumerable,zA=(t,e,n)=>e in t?Tue(t,e,{enumerable:!0,configurable:!0,writable:!0,value:n}):t[e]=n,Eue=(t,e)=>{for(var n in e||(e={}))Nue.call(e,n)&&zA(t,n,e[n]);if(LA)for(var n of LA(e))Iue.call(e,n)&&zA(t,n,e[n]);return t};const Aue={easeInSine:[.12,0,.39,0],easeOutSine:[.61,1,.88,1],easeInOutSine:[.37,0,.63,1],easeInQuad:[.11,0,.5,0],easeOutQuad:[.5,1,.89,1],easeInOutQuad:[.45,0,.55,1],easeInCubic:[.32,0,.67,0],easeOutCubic:[.33,1,.68,1],easeInOutCubic:[.65,0,.35,1],easeInQuart:[.5,0,.75,0],easeOutQuart:[.25,1,.5,1],easeInOutQuart:[.76,0,.24,1],easeInQuint:[.64,0,.78,0],easeOutQuint:[.22,1,.36,1],easeInOutQuint:[.83,0,.17,1],easeInExpo:[.7,0,.84,0],easeOutExpo:[.16,1,.3,1],easeInOutExpo:[.87,0,.13,1],easeInCirc:[.55,0,1,.45],easeOutCirc:[0,.55,.45,1],easeInOutCirc:[.85,0,.15,1],easeInBack:[.36,0,.66,-.56],easeOutBack:[.34,1.56,.64,1],easeInOutBack:[.68,-.6,.32,1.6]};Eue({linear:gue},Aue);function Oue(t,e,n,s={}){var r,o,a;const{clone:i=!1,passive:l=!1,eventName:u,deep:c=!1,defaultValue:d}=s,f=Rt(),h=n||(f==null?void 0:f.emit)||((r=f==null?void 0:f.$emit)==null?void 0:r.bind(f))||((a=(o=f==null?void 0:f.proxy)==null?void 0:o.$emit)==null?void 0:a.bind(f==null?void 0:f.proxy));let p=u;e||(e="modelValue"),p=u||p||`update:${e.toString()}`;const m=y=>i?due(i)?i(y):_ue(y):y,g=()=>cue(t[e])?m(t[e]):d;if(l){const y=g(),w=U(y);return Me(()=>t[e],b=>w.value=m(b)),Me(w,b=>{(b!==t[e]||c)&&h(p,b)},{deep:c}),w}else return A({get(){return g()},set(y){h(p,y)}})}function Rue({window:t=Zh}={}){if(!t)return U(!1);const e=U(t.document.hasFocus());return Rn(t,"blur",()=>{e.value=!1}),Rn(t,"focus",()=>{e.value=!0}),e}function Due(t={}){const{window:e=Zh,initialWidth:n=1/0,initialHeight:s=1/0,listenOrientation:r=!0,includeScrollbar:o=!0}=t,a=U(n),i=U(s),l=()=>{e&&(o?(a.value=e.innerWidth,i.value=e.innerHeight):(a.value=e.document.documentElement.clientWidth,i.value=e.document.documentElement.clientHeight))};return l(),kC(l),Rn("resize",l,{passive:!0}),r&&Rn("orientationchange",l,{passive:!0}),{width:a,height:i}}const Fue=(t,e)=>{if(!Kt||!t||!e)return!1;const n=t.getBoundingClientRect();let s;return e instanceof Element?s=e.getBoundingClientRect():s={top:0,right:window.innerWidth,bottom:window.innerHeight,left:0},n.top<s.bottom&&n.bottom>s.top&&n.right>s.left&&n.left<s.right},BA=t=>{let e=0,n=t;for(;n;)e+=n.offsetTop,n=n.offsetParent;return e},Mue=(t,e)=>Math.abs(BA(t)-BA(e)),NC=t=>{let e,n;return t.type==="touchend"?(n=t.changedTouches[0].clientY,e=t.changedTouches[0].clientX):t.type.startsWith("touch")?(n=t.touches[0].clientY,e=t.touches[0].clientX):(n=t.clientY,e=t.clientX),{clientX:e,clientY:n}},er=t=>t===void 0,ia=t=>!t&&t!==0||Qe(t)&&t.length===0||Bt(t)&&!Object.keys(t).length,Qa=t=>typeof Element>"u"?!1:t instanceof Element,Pue=t=>nr(t),Lue=t=>wt(t)?!Number.isNaN(Number(t)):!1,aP=(t="")=>t.replace(/[|\\{}()[\]^$+*?.]/g,"\\$&").replace(/-/g,"\\x2d"),la=t=>Sg(t),D0=t=>Object.keys(t),zue=t=>Object.entries(t),Wv=(t,e,n)=>({get value(){return Pn(t,e,n)},set value(s){jle(t,e,s)}});class Bue extends Error{constructor(e){super(e),this.name="ElementPlusError"}}function Ls(t,e){throw new Bue(`[${t}] ${e}`)}const iP=(t="")=>t.split(" ").filter(e=>!!e.trim()),ja=(t,e)=>{if(!t||!e)return!1;if(e.includes(" "))throw new Error("className should not contain space.");return t.classList.contains(e)},xi=(t,e)=>{!t||!e.trim()||t.classList.add(...iP(e))},mo=(t,e)=>{!t||!e.trim()||t.classList.remove(...iP(e))},dl=(t,e)=>{var n;if(!Kt||!t||!e)return"";let s=wa(e);s==="float"&&(s="cssFloat");try{const r=t.style[s];if(r)return r;const o=(n=document.defaultView)==null?void 0:n.getComputedStyle(t,"");return o?o[s]:""}catch{return t.style[s]}};function Cs(t,e="px"){if(!t)return"";if(Ct(t)||Lue(t))return`${t}${e}`;if(wt(t))return t}const Vue=(t,e)=>{if(!Kt)return!1;const n={undefined:"overflow",true:"overflow-y",false:"overflow-x"}[String(e)],s=dl(t,n);return["scroll","auto","overlay"].some(r=>s.includes(r))},IC=(t,e)=>{if(!Kt)return;let n=t;for(;n;){if([window,document,document.documentElement].includes(n))return window;if(Vue(n,e))return n;n=n.parentNode}return n};let ev;const lP=t=>{var e;if(!Kt)return 0;if(ev!==void 0)return ev;const n=document.createElement("div");n.className=`${t}-scrollbar__wrap`,n.style.visibility="hidden",n.style.width="100px",n.style.position="absolute",n.style.top="-9999px",document.body.appendChild(n);const s=n.offsetWidth;n.style.overflow="scroll";const r=document.createElement("div");r.style.width="100%",n.appendChild(r);const o=r.offsetWidth;return(e=n.parentNode)==null||e.removeChild(n),ev=s-o,ev};function uP(t,e){if(!Kt)return;if(!e){t.scrollTop=0;return}const n=[];let s=e.offsetParent;for(;s!==null&&t!==s&&t.contains(s);)n.push(s),s=s.offsetParent;const r=e.offsetTop+n.reduce((l,u)=>l+u.offsetTop,0),o=r+e.offsetHeight,a=t.scrollTop,i=a+t.clientHeight;r<a?t.scrollTop=r:o>i&&(t.scrollTop=o-t.clientHeight)}var Hue={name:"AddLocation"},ae=(t,e)=>{let n=t.__vccOpts||t;for(let[s,r]of e)n[s]=r;return n},Wue={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},Uue=I("path",{fill:"currentColor",d:"M288 896h448q32 0 32 32t-32 32H288q-32 0-32-32t32-32z"},null,-1),Gue=I("path",{fill:"currentColor",d:"M800 416a288 288 0 1 0-576 0c0 118.144 94.528 272.128 288 456.576C705.472 688.128 800 534.144 800 416zM512 960C277.312 746.688 160 565.312 160 416a352 352 0 0 1 704 0c0 149.312-117.312 330.688-352 544z"},null,-1),jue=I("path",{fill:"currentColor",d:"M544 384h96a32 32 0 1 1 0 64h-96v96a32 32 0 0 1-64 0v-96h-96a32 32 0 0 1 0-64h96v-96a32 32 0 0 1 64 0v96z"},null,-1),Kue=[Uue,Gue,jue];function que(t,e,n,s,r,o){return S(),E("svg",Wue,Kue)}var Xue=ae(Hue,[["render",que],["__file","add-location.vue"]]),Yue={name:"Aim"},Zue={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},Jue=I("path",{fill:"currentColor",d:"M512 896a384 384 0 1 0 0-768 384 384 0 0 0 0 768zm0 64a448 448 0 1 1 0-896 448 448 0 0 1 0 896z"},null,-1),Que=I("path",{fill:"currentColor",d:"M512 96a32 32 0 0 1 32 32v192a32 32 0 0 1-64 0V128a32 32 0 0 1 32-32zm0 576a32 32 0 0 1 32 32v192a32 32 0 1 1-64 0V704a32 32 0 0 1 32-32zM96 512a32 32 0 0 1 32-32h192a32 32 0 0 1 0 64H128a32 32 0 0 1-32-32zm576 0a32 32 0 0 1 32-32h192a32 32 0 1 1 0 64H704a32 32 0 0 1-32-32z"},null,-1),ece=[Jue,Que];function tce(t,e,n,s,r,o){return S(),E("svg",Zue,ece)}var nce=ae(Yue,[["render",tce],["__file","aim.vue"]]),sce={name:"AlarmClock"},rce={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},oce=I("path",{fill:"currentColor",d:"M512 832a320 320 0 1 0 0-640 320 320 0 0 0 0 640zm0 64a384 384 0 1 1 0-768 384 384 0 0 1 0 768z"},null,-1),ace=I("path",{fill:"currentColor",d:"m292.288 824.576 55.424 32-48 83.136a32 32 0 1 1-55.424-32l48-83.136zm439.424 0-55.424 32 48 83.136a32 32 0 1 0 55.424-32l-48-83.136zM512 512h160a32 32 0 1 1 0 64H480a32 32 0 0 1-32-32V320a32 32 0 0 1 64 0v192zM90.496 312.256A160 160 0 0 1 312.32 90.496l-46.848 46.848a96 96 0 0 0-128 128L90.56 312.256zm835.264 0A160 160 0 0 0 704 90.496l46.848 46.848a96 96 0 0 1 128 128l46.912 46.912z"},null,-1),ice=[oce,ace];function lce(t,e,n,s,r,o){return S(),E("svg",rce,ice)}var uce=ae(sce,[["render",lce],["__file","alarm-clock.vue"]]),cce={name:"Apple"},dce={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},fce=I("path",{fill:"currentColor",d:"M599.872 203.776a189.44 189.44 0 0 1 64.384-4.672l2.624.128c31.168 1.024 51.2 4.096 79.488 16.32 37.632 16.128 74.496 45.056 111.488 89.344 96.384 115.264 82.752 372.8-34.752 521.728-7.68 9.728-32 41.6-30.72 39.936a426.624 426.624 0 0 1-30.08 35.776c-31.232 32.576-65.28 49.216-110.08 50.048-31.36.64-53.568-5.312-84.288-18.752l-6.528-2.88c-20.992-9.216-30.592-11.904-47.296-11.904-18.112 0-28.608 2.88-51.136 12.672l-6.464 2.816c-28.416 12.224-48.32 18.048-76.16 19.2-74.112 2.752-116.928-38.08-180.672-132.16-96.64-142.08-132.608-349.312-55.04-486.4 46.272-81.92 129.92-133.632 220.672-135.04 32.832-.576 60.288 6.848 99.648 22.72 27.136 10.88 34.752 13.76 37.376 14.272 16.256-20.16 27.776-36.992 34.56-50.24 13.568-26.304 27.2-59.968 40.704-100.8a32 32 0 1 1 60.8 20.224c-12.608 37.888-25.408 70.4-38.528 97.664zm-51.52 78.08c-14.528 17.792-31.808 37.376-51.904 58.816a32 32 0 1 1-46.72-43.776l12.288-13.248c-28.032-11.2-61.248-26.688-95.68-26.112-70.4 1.088-135.296 41.6-171.648 105.792C121.6 492.608 176 684.16 247.296 788.992c34.816 51.328 76.352 108.992 130.944 106.944 52.48-2.112 72.32-34.688 135.872-34.688 63.552 0 81.28 34.688 136.96 33.536 56.448-1.088 75.776-39.04 126.848-103.872 107.904-136.768 107.904-362.752 35.776-449.088-72.192-86.272-124.672-84.096-151.68-85.12-41.472-4.288-81.6 12.544-113.664 25.152z"},null,-1),hce=[fce];function pce(t,e,n,s,r,o){return S(),E("svg",dce,hce)}var mce=ae(cce,[["render",pce],["__file","apple.vue"]]),gce={name:"ArrowDownBold"},vce={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},yce=I("path",{fill:"currentColor",d:"M104.704 338.752a64 64 0 0 1 90.496 0l316.8 316.8 316.8-316.8a64 64 0 0 1 90.496 90.496L557.248 791.296a64 64 0 0 1-90.496 0L104.704 429.248a64 64 0 0 1 0-90.496z"},null,-1),bce=[yce];function wce(t,e,n,s,r,o){return S(),E("svg",vce,bce)}var _ce=ae(gce,[["render",wce],["__file","arrow-down-bold.vue"]]),$ce={name:"ArrowDown"},xce={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},Sce=I("path",{fill:"currentColor",d:"M831.872 340.864 512 652.672 192.128 340.864a30.592 30.592 0 0 0-42.752 0 29.12 29.12 0 0 0 0 41.6L489.664 714.24a32 32 0 0 0 44.672 0l340.288-331.712a29.12 29.12 0 0 0 0-41.728 30.592 30.592 0 0 0-42.752 0z"},null,-1),Cce=[Sce];function kce(t,e,n,s,r,o){return S(),E("svg",xce,Cce)}var zl=ae($ce,[["render",kce],["__file","arrow-down.vue"]]),Tce={name:"ArrowLeftBold"},Nce={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},Ice=I("path",{fill:"currentColor",d:"M685.248 104.704a64 64 0 0 1 0 90.496L368.448 512l316.8 316.8a64 64 0 0 1-90.496 90.496L232.704 557.248a64 64 0 0 1 0-90.496l362.048-362.048a64 64 0 0 1 90.496 0z"},null,-1),Ece=[Ice];function Ace(t,e,n,s,r,o){return S(),E("svg",Nce,Ece)}var Oce=ae(Tce,[["render",Ace],["__file","arrow-left-bold.vue"]]),Rce={name:"ArrowLeft"},Dce={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},Fce=I("path",{fill:"currentColor",d:"M609.408 149.376 277.76 489.6a32 32 0 0 0 0 44.672l331.648 340.352a29.12 29.12 0 0 0 41.728 0 30.592 30.592 0 0 0 0-42.752L339.264 511.936l311.872-319.872a30.592 30.592 0 0 0 0-42.688 29.12 29.12 0 0 0-41.728 0z"},null,-1),Mce=[Fce];function Pce(t,e,n,s,r,o){return S(),E("svg",Dce,Mce)}var xl=ae(Rce,[["render",Pce],["__file","arrow-left.vue"]]),Lce={name:"ArrowRightBold"},zce={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},Bce=I("path",{fill:"currentColor",d:"M338.752 104.704a64 64 0 0 0 0 90.496l316.8 316.8-316.8 316.8a64 64 0 0 0 90.496 90.496l362.048-362.048a64 64 0 0 0 0-90.496L429.248 104.704a64 64 0 0 0-90.496 0z"},null,-1),Vce=[Bce];function Hce(t,e,n,s,r,o){return S(),E("svg",zce,Vce)}var Wce=ae(Lce,[["render",Hce],["__file","arrow-right-bold.vue"]]),Uce={name:"ArrowRight"},Gce={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},jce=I("path",{fill:"currentColor",d:"M340.864 149.312a30.592 30.592 0 0 0 0 42.752L652.736 512 340.864 831.872a30.592 30.592 0 0 0 0 42.752 29.12 29.12 0 0 0 41.728 0L714.24 534.336a32 32 0 0 0 0-44.672L382.592 149.376a29.12 29.12 0 0 0-41.728 0z"},null,-1),Kce=[jce];function qce(t,e,n,s,r,o){return S(),E("svg",Gce,Kce)}var Rr=ae(Uce,[["render",qce],["__file","arrow-right.vue"]]),Xce={name:"ArrowUpBold"},Yce={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},Zce=I("path",{fill:"currentColor",d:"M104.704 685.248a64 64 0 0 0 90.496 0l316.8-316.8 316.8 316.8a64 64 0 0 0 90.496-90.496L557.248 232.704a64 64 0 0 0-90.496 0L104.704 594.752a64 64 0 0 0 0 90.496z"},null,-1),Jce=[Zce];function Qce(t,e,n,s,r,o){return S(),E("svg",Yce,Jce)}var ede=ae(Xce,[["render",Qce],["__file","arrow-up-bold.vue"]]),tde={name:"ArrowUp"},nde={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},sde=I("path",{fill:"currentColor",d:"m488.832 344.32-339.84 356.672a32 32 0 0 0 0 44.16l.384.384a29.44 29.44 0 0 0 42.688 0l320-335.872 319.872 335.872a29.44 29.44 0 0 0 42.688 0l.384-.384a32 32 0 0 0 0-44.16L535.168 344.32a32 32 0 0 0-46.336 0z"},null,-1),rde=[sde];function ode(t,e,n,s,r,o){return S(),E("svg",nde,rde)}var Og=ae(tde,[["render",ode],["__file","arrow-up.vue"]]),ade={name:"Avatar"},ide={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},lde=I("path",{fill:"currentColor",d:"M628.736 528.896A416 416 0 0 1 928 928H96a415.872 415.872 0 0 1 299.264-399.104L512 704l116.736-175.104zM720 304a208 208 0 1 1-416 0 208 208 0 0 1 416 0z"},null,-1),ude=[lde];function cde(t,e,n,s,r,o){return S(),E("svg",ide,ude)}var dde=ae(ade,[["render",cde],["__file","avatar.vue"]]),fde={name:"Back"},hde={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},pde=I("path",{fill:"currentColor",d:"M224 480h640a32 32 0 1 1 0 64H224a32 32 0 0 1 0-64z"},null,-1),mde=I("path",{fill:"currentColor",d:"m237.248 512 265.408 265.344a32 32 0 0 1-45.312 45.312l-288-288a32 32 0 0 1 0-45.312l288-288a32 32 0 1 1 45.312 45.312L237.248 512z"},null,-1),gde=[pde,mde];function vde(t,e,n,s,r,o){return S(),E("svg",hde,gde)}var cP=ae(fde,[["render",vde],["__file","back.vue"]]),yde={name:"Baseball"},bde={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},wde=I("path",{fill:"currentColor",d:"M195.2 828.8a448 448 0 1 1 633.6-633.6 448 448 0 0 1-633.6 633.6zm45.248-45.248a384 384 0 1 0 543.104-543.104 384 384 0 0 0-543.104 543.104z"},null,-1),_de=I("path",{fill:"currentColor",d:"M497.472 96.896c22.784 4.672 44.416 9.472 64.896 14.528a256.128 256.128 0 0 0 350.208 350.208c5.056 20.48 9.856 42.112 14.528 64.896A320.128 320.128 0 0 1 497.472 96.896zM108.48 491.904a320.128 320.128 0 0 1 423.616 423.68c-23.04-3.648-44.992-7.424-65.728-11.52a256.128 256.128 0 0 0-346.496-346.432 1736.64 1736.64 0 0 1-11.392-65.728z"},null,-1),$de=[wde,_de];function xde(t,e,n,s,r,o){return S(),E("svg",bde,$de)}var Sde=ae(yde,[["render",xde],["__file","baseball.vue"]]),Cde={name:"Basketball"},kde={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},Tde=I("path",{fill:"currentColor",d:"M778.752 788.224a382.464 382.464 0 0 0 116.032-245.632 256.512 256.512 0 0 0-241.728-13.952 762.88 762.88 0 0 1 125.696 259.584zm-55.04 44.224a699.648 699.648 0 0 0-125.056-269.632 256.128 256.128 0 0 0-56.064 331.968 382.72 382.72 0 0 0 181.12-62.336zm-254.08 61.248A320.128 320.128 0 0 1 557.76 513.6a715.84 715.84 0 0 0-48.192-48.128 320.128 320.128 0 0 1-379.264 88.384 382.4 382.4 0 0 0 110.144 229.696 382.4 382.4 0 0 0 229.184 110.08zM129.28 481.088a256.128 256.128 0 0 0 331.072-56.448 699.648 699.648 0 0 0-268.8-124.352 382.656 382.656 0 0 0-62.272 180.8zm106.56-235.84a762.88 762.88 0 0 1 258.688 125.056 256.512 256.512 0 0 0-13.44-241.088A382.464 382.464 0 0 0 235.84 245.248zm318.08-114.944c40.576 89.536 37.76 193.92-8.448 281.344a779.84 779.84 0 0 1 66.176 66.112 320.832 320.832 0 0 1 282.112-8.128 382.4 382.4 0 0 0-110.144-229.12 382.4 382.4 0 0 0-229.632-110.208zM828.8 828.8a448 448 0 1 1-633.6-633.6 448 448 0 0 1 633.6 633.6z"},null,-1),Nde=[Tde];function Ide(t,e,n,s,r,o){return S(),E("svg",kde,Nde)}var Ede=ae(Cde,[["render",Ide],["__file","basketball.vue"]]),Ade={name:"BellFilled"},Ode={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},Rde=I("path",{fill:"currentColor",d:"M640 832a128 128 0 0 1-256 0h256zm192-64H134.4a38.4 38.4 0 0 1 0-76.8H192V448c0-154.88 110.08-284.16 256.32-313.6a64 64 0 1 1 127.36 0A320.128 320.128 0 0 1 832 448v243.2h57.6a38.4 38.4 0 0 1 0 76.8H832z"},null,-1),Dde=[Rde];function Fde(t,e,n,s,r,o){return S(),E("svg",Ode,Dde)}var Mde=ae(Ade,[["render",Fde],["__file","bell-filled.vue"]]),Pde={name:"Bell"},Lde={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},zde=I("path",{fill:"currentColor",d:"M512 64a64 64 0 0 1 64 64v64H448v-64a64 64 0 0 1 64-64z"},null,-1),Bde=I("path",{fill:"currentColor",d:"M256 768h512V448a256 256 0 1 0-512 0v320zm256-640a320 320 0 0 1 320 320v384H192V448a320 320 0 0 1 320-320z"},null,-1),Vde=I("path",{fill:"currentColor",d:"M96 768h832q32 0 32 32t-32 32H96q-32 0-32-32t32-32zm352 128h128a64 64 0 0 1-128 0z"},null,-1),Hde=[zde,Bde,Vde];function Wde(t,e,n,s,r,o){return S(),E("svg",Lde,Hde)}var Ude=ae(Pde,[["render",Wde],["__file","bell.vue"]]),Gde={name:"Bicycle"},jde={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},Kde=ate('<path fill="currentColor" d="M256 832a128 128 0 1 0 0-256 128 128 0 0 0 0 256zm0 64a192 192 0 1 1 0-384 192 192 0 0 1 0 384z"></path><path fill="currentColor" d="M288 672h320q32 0 32 32t-32 32H288q-32 0-32-32t32-32z"></path><path fill="currentColor" d="M768 832a128 128 0 1 0 0-256 128 128 0 0 0 0 256zm0 64a192 192 0 1 1 0-384 192 192 0 0 1 0 384z"></path><path fill="currentColor" d="M480 192a32 32 0 0 1 0-64h160a32 32 0 0 1 31.04 24.256l96 384a32 32 0 0 1-62.08 15.488L615.04 192H480zM96 384a32 32 0 0 1 0-64h128a32 32 0 0 1 30.336 21.888l64 192a32 32 0 1 1-60.672 20.224L200.96 384H96z"></path><path fill="currentColor" d="m373.376 599.808-42.752-47.616 320-288 42.752 47.616z"></path>',5),qde=[Kde];function Xde(t,e,n,s,r,o){return S(),E("svg",jde,qde)}var Yde=ae(Gde,[["render",Xde],["__file","bicycle.vue"]]),Zde={name:"BottomLeft"},Jde={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},Qde=I("path",{fill:"currentColor",d:"M256 768h416a32 32 0 1 1 0 64H224a32 32 0 0 1-32-32V352a32 32 0 0 1 64 0v416z"},null,-1),efe=I("path",{fill:"currentColor",d:"M246.656 822.656a32 32 0 0 1-45.312-45.312l544-544a32 32 0 0 1 45.312 45.312l-544 544z"},null,-1),tfe=[Qde,efe];function nfe(t,e,n,s,r,o){return S(),E("svg",Jde,tfe)}var sfe=ae(Zde,[["render",nfe],["__file","bottom-left.vue"]]),rfe={name:"BottomRight"},ofe={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},afe=I("path",{fill:"currentColor",d:"M352 768a32 32 0 1 0 0 64h448a32 32 0 0 0 32-32V352a32 32 0 0 0-64 0v416H352z"},null,-1),ife=I("path",{fill:"currentColor",d:"M777.344 822.656a32 32 0 0 0 45.312-45.312l-544-544a32 32 0 0 0-45.312 45.312l544 544z"},null,-1),lfe=[afe,ife];function ufe(t,e,n,s,r,o){return S(),E("svg",ofe,lfe)}var cfe=ae(rfe,[["render",ufe],["__file","bottom-right.vue"]]),dfe={name:"Bottom"},ffe={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},hfe=I("path",{fill:"currentColor",d:"M544 805.888V168a32 32 0 1 0-64 0v637.888L246.656 557.952a30.72 30.72 0 0 0-45.312 0 35.52 35.52 0 0 0 0 48.064l288 306.048a30.72 30.72 0 0 0 45.312 0l288-306.048a35.52 35.52 0 0 0 0-48 30.72 30.72 0 0 0-45.312 0L544 805.824z"},null,-1),pfe=[hfe];function mfe(t,e,n,s,r,o){return S(),E("svg",ffe,pfe)}var gfe=ae(dfe,[["render",mfe],["__file","bottom.vue"]]),vfe={name:"Bowl"},yfe={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},bfe=I("path",{fill:"currentColor",d:"M714.432 704a351.744 351.744 0 0 0 148.16-256H161.408a351.744 351.744 0 0 0 148.16 256h404.864zM288 766.592A415.68 415.68 0 0 1 96 416a32 32 0 0 1 32-32h768a32 32 0 0 1 32 32 415.68 415.68 0 0 1-192 350.592V832a64 64 0 0 1-64 64H352a64 64 0 0 1-64-64v-65.408zM493.248 320h-90.496l254.4-254.4a32 32 0 1 1 45.248 45.248L493.248 320zm187.328 0h-128l269.696-155.712a32 32 0 0 1 32 55.424L680.576 320zM352 768v64h320v-64H352z"},null,-1),wfe=[bfe];function _fe(t,e,n,s,r,o){return S(),E("svg",yfe,wfe)}var $fe=ae(vfe,[["render",_fe],["__file","bowl.vue"]]),xfe={name:"Box"},Sfe={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},Cfe=I("path",{fill:"currentColor",d:"M317.056 128 128 344.064V896h768V344.064L706.944 128H317.056zm-14.528-64h418.944a32 32 0 0 1 24.064 10.88l206.528 236.096A32 32 0 0 1 960 332.032V928a32 32 0 0 1-32 32H96a32 32 0 0 1-32-32V332.032a32 32 0 0 1 7.936-21.12L278.4 75.008A32 32 0 0 1 302.528 64z"},null,-1),kfe=I("path",{fill:"currentColor",d:"M64 320h896v64H64z"},null,-1),Tfe=I("path",{fill:"currentColor",d:"M448 327.872V640h128V327.872L526.08 128h-28.16L448 327.872zM448 64h128l64 256v352a32 32 0 0 1-32 32H416a32 32 0 0 1-32-32V320l64-256z"},null,-1),Nfe=[Cfe,kfe,Tfe];function Ife(t,e,n,s,r,o){return S(),E("svg",Sfe,Nfe)}var Efe=ae(xfe,[["render",Ife],["__file","box.vue"]]),Afe={name:"Briefcase"},Ofe={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},Rfe=I("path",{fill:"currentColor",d:"M320 320V128h384v192h192v192H128V320h192zM128 576h768v320H128V576zm256-256h256.064V192H384v128z"},null,-1),Dfe=[Rfe];function Ffe(t,e,n,s,r,o){return S(),E("svg",Ofe,Dfe)}var Mfe=ae(Afe,[["render",Ffe],["__file","briefcase.vue"]]),Pfe={name:"BrushFilled"},Lfe={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},zfe=I("path",{fill:"currentColor",d:"M608 704v160a96 96 0 0 1-192 0V704h-96a128 128 0 0 1-128-128h640a128 128 0 0 1-128 128h-96zM192 512V128.064h640V512H192z"},null,-1),Bfe=[zfe];function Vfe(t,e,n,s,r,o){return S(),E("svg",Lfe,Bfe)}var Hfe=ae(Pfe,[["render",Vfe],["__file","brush-filled.vue"]]),Wfe={name:"Brush"},Ufe={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},Gfe=I("path",{fill:"currentColor",d:"M896 448H128v192a64 64 0 0 0 64 64h192v192h256V704h192a64 64 0 0 0 64-64V448zm-770.752-64c0-47.552 5.248-90.24 15.552-128 14.72-54.016 42.496-107.392 83.2-160h417.28l-15.36 70.336L736 96h211.2c-24.832 42.88-41.92 96.256-51.2 160a663.872 663.872 0 0 0-6.144 128H960v256a128 128 0 0 1-128 128H704v160a32 32 0 0 1-32 32H352a32 32 0 0 1-32-32V768H192A128 128 0 0 1 64 640V384h61.248zm64 0h636.544c-2.048-45.824.256-91.584 6.848-137.216 4.48-30.848 10.688-59.776 18.688-86.784h-96.64l-221.12 141.248L561.92 160H256.512c-25.856 37.888-43.776 75.456-53.952 112.832-8.768 32.064-13.248 69.12-13.312 111.168z"},null,-1),jfe=[Gfe];function Kfe(t,e,n,s,r,o){return S(),E("svg",Ufe,jfe)}var qfe=ae(Wfe,[["render",Kfe],["__file","brush.vue"]]),Xfe={name:"Burger"},Yfe={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},Zfe=I("path",{fill:"currentColor",d:"M160 512a32 32 0 0 0-32 32v64a32 32 0 0 0 30.08 32H864a32 32 0 0 0 32-32v-64a32 32 0 0 0-32-32H160zm736-58.56A96 96 0 0 1 960 544v64a96 96 0 0 1-51.968 85.312L855.36 833.6a96 96 0 0 1-89.856 62.272H258.496A96 96 0 0 1 168.64 833.6l-52.608-140.224A96 96 0 0 1 64 608v-64a96 96 0 0 1 64-90.56V448a384 384 0 1 1 768 5.44zM832 448a320 320 0 0 0-640 0h640zM512 704H188.352l40.192 107.136a32 32 0 0 0 29.952 20.736h507.008a32 32 0 0 0 29.952-20.736L835.648 704H512z"},null,-1),Jfe=[Zfe];function Qfe(t,e,n,s,r,o){return S(),E("svg",Yfe,Jfe)}var ehe=ae(Xfe,[["render",Qfe],["__file","burger.vue"]]),the={name:"Calendar"},nhe={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},she=I("path",{fill:"currentColor",d:"M128 384v512h768V192H768v32a32 32 0 1 1-64 0v-32H320v32a32 32 0 0 1-64 0v-32H128v128h768v64H128zm192-256h384V96a32 32 0 1 1 64 0v32h160a32 32 0 0 1 32 32v768a32 32 0 0 1-32 32H96a32 32 0 0 1-32-32V160a32 32 0 0 1 32-32h160V96a32 32 0 0 1 64 0v32zm-32 384h64a32 32 0 0 1 0 64h-64a32 32 0 0 1 0-64zm0 192h64a32 32 0 1 1 0 64h-64a32 32 0 1 1 0-64zm192-192h64a32 32 0 0 1 0 64h-64a32 32 0 0 1 0-64zm0 192h64a32 32 0 1 1 0 64h-64a32 32 0 1 1 0-64zm192-192h64a32 32 0 1 1 0 64h-64a32 32 0 1 1 0-64zm0 192h64a32 32 0 1 1 0 64h-64a32 32 0 1 1 0-64z"},null,-1),rhe=[she];function ohe(t,e,n,s,r,o){return S(),E("svg",nhe,rhe)}var dP=ae(the,[["render",ohe],["__file","calendar.vue"]]),ahe={name:"CameraFilled"},ihe={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},lhe=I("path",{fill:"currentColor",d:"M160 224a64 64 0 0 0-64 64v512a64 64 0 0 0 64 64h704a64 64 0 0 0 64-64V288a64 64 0 0 0-64-64H748.416l-46.464-92.672A64 64 0 0 0 644.736 96H379.328a64 64 0 0 0-57.216 35.392L275.776 224H160zm352 435.2a115.2 115.2 0 1 0 0-230.4 115.2 115.2 0 0 0 0 230.4zm0 140.8a256 256 0 1 1 0-512 256 256 0 0 1 0 512z"},null,-1),uhe=[lhe];function che(t,e,n,s,r,o){return S(),E("svg",ihe,uhe)}var dhe=ae(ahe,[["render",che],["__file","camera-filled.vue"]]),fhe={name:"Camera"},hhe={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},phe=I("path",{fill:"currentColor",d:"M896 256H128v576h768V256zm-199.424-64-32.064-64h-304.96l-32 64h369.024zM96 192h160l46.336-92.608A64 64 0 0 1 359.552 64h304.96a64 64 0 0 1 57.216 35.328L768.192 192H928a32 32 0 0 1 32 32v640a32 32 0 0 1-32 32H96a32 32 0 0 1-32-32V224a32 32 0 0 1 32-32zm416 512a160 160 0 1 0 0-320 160 160 0 0 0 0 320zm0 64a224 224 0 1 1 0-448 224 224 0 0 1 0 448z"},null,-1),mhe=[phe];function ghe(t,e,n,s,r,o){return S(),E("svg",hhe,mhe)}var vhe=ae(fhe,[["render",ghe],["__file","camera.vue"]]),yhe={name:"CaretBottom"},bhe={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},whe=I("path",{fill:"currentColor",d:"m192 384 320 384 320-384z"},null,-1),_he=[whe];function $he(t,e,n,s,r,o){return S(),E("svg",bhe,_he)}var xhe=ae(yhe,[["render",$he],["__file","caret-bottom.vue"]]),She={name:"CaretLeft"},Che={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},khe=I("path",{fill:"currentColor",d:"M672 192 288 511.936 672 832z"},null,-1),The=[khe];function Nhe(t,e,n,s,r,o){return S(),E("svg",Che,The)}var Ihe=ae(She,[["render",Nhe],["__file","caret-left.vue"]]),Ehe={name:"CaretRight"},Ahe={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},Ohe=I("path",{fill:"currentColor",d:"M384 192v640l384-320.064z"},null,-1),Rhe=[Ohe];function Dhe(t,e,n,s,r,o){return S(),E("svg",Ahe,Rhe)}var EC=ae(Ehe,[["render",Dhe],["__file","caret-right.vue"]]),Fhe={name:"CaretTop"},Mhe={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},Phe=I("path",{fill:"currentColor",d:"M512 320 192 704h639.936z"},null,-1),Lhe=[Phe];function zhe(t,e,n,s,r,o){return S(),E("svg",Mhe,Lhe)}var fP=ae(Fhe,[["render",zhe],["__file","caret-top.vue"]]),Bhe={name:"Cellphone"},Vhe={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},Hhe=I("path",{fill:"currentColor",d:"M256 128a64 64 0 0 0-64 64v640a64 64 0 0 0 64 64h512a64 64 0 0 0 64-64V192a64 64 0 0 0-64-64H256zm0-64h512a128 128 0 0 1 128 128v640a128 128 0 0 1-128 128H256a128 128 0 0 1-128-128V192A128 128 0 0 1 256 64zm128 128h256a32 32 0 1 1 0 64H384a32 32 0 0 1 0-64zm128 640a64 64 0 1 1 0-128 64 64 0 0 1 0 128z"},null,-1),Whe=[Hhe];function Uhe(t,e,n,s,r,o){return S(),E("svg",Vhe,Whe)}var Ghe=ae(Bhe,[["render",Uhe],["__file","cellphone.vue"]]),jhe={name:"ChatDotRound"},Khe={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},qhe=I("path",{fill:"currentColor",d:"m174.72 855.68 135.296-45.12 23.68 11.84C388.096 849.536 448.576 864 512 864c211.84 0 384-166.784 384-352S723.84 160 512 160 128 326.784 128 512c0 69.12 24.96 139.264 70.848 199.232l22.08 28.8-46.272 115.584zm-45.248 82.56A32 32 0 0 1 89.6 896l58.368-145.92C94.72 680.32 64 596.864 64 512 64 299.904 256 96 512 96s448 203.904 448 416-192 416-448 416a461.056 461.056 0 0 1-206.912-48.384l-175.616 58.56z"},null,-1),Xhe=I("path",{fill:"currentColor",d:"M512 563.2a51.2 51.2 0 1 1 0-102.4 51.2 51.2 0 0 1 0 102.4zm192 0a51.2 51.2 0 1 1 0-102.4 51.2 51.2 0 0 1 0 102.4zm-384 0a51.2 51.2 0 1 1 0-102.4 51.2 51.2 0 0 1 0 102.4z"},null,-1),Yhe=[qhe,Xhe];function Zhe(t,e,n,s,r,o){return S(),E("svg",Khe,Yhe)}var Jhe=ae(jhe,[["render",Zhe],["__file","chat-dot-round.vue"]]),Qhe={name:"ChatDotSquare"},epe={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},tpe=I("path",{fill:"currentColor",d:"M273.536 736H800a64 64 0 0 0 64-64V256a64 64 0 0 0-64-64H224a64 64 0 0 0-64 64v570.88L273.536 736zM296 800 147.968 918.4A32 32 0 0 1 96 893.44V256a128 128 0 0 1 128-128h576a128 128 0 0 1 128 128v416a128 128 0 0 1-128 128H296z"},null,-1),npe=I("path",{fill:"currentColor",d:"M512 499.2a51.2 51.2 0 1 1 0-102.4 51.2 51.2 0 0 1 0 102.4zm192 0a51.2 51.2 0 1 1 0-102.4 51.2 51.2 0 0 1 0 102.4zm-384 0a51.2 51.2 0 1 1 0-102.4 51.2 51.2 0 0 1 0 102.4z"},null,-1),spe=[tpe,npe];function rpe(t,e,n,s,r,o){return S(),E("svg",epe,spe)}var ope=ae(Qhe,[["render",rpe],["__file","chat-dot-square.vue"]]),ape={name:"ChatLineRound"},ipe={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},lpe=I("path",{fill:"currentColor",d:"m174.72 855.68 135.296-45.12 23.68 11.84C388.096 849.536 448.576 864 512 864c211.84 0 384-166.784 384-352S723.84 160 512 160 128 326.784 128 512c0 69.12 24.96 139.264 70.848 199.232l22.08 28.8-46.272 115.584zm-45.248 82.56A32 32 0 0 1 89.6 896l58.368-145.92C94.72 680.32 64 596.864 64 512 64 299.904 256 96 512 96s448 203.904 448 416-192 416-448 416a461.056 461.056 0 0 1-206.912-48.384l-175.616 58.56z"},null,-1),upe=I("path",{fill:"currentColor",d:"M352 576h320q32 0 32 32t-32 32H352q-32 0-32-32t32-32zm32-192h256q32 0 32 32t-32 32H384q-32 0-32-32t32-32z"},null,-1),cpe=[lpe,upe];function dpe(t,e,n,s,r,o){return S(),E("svg",ipe,cpe)}var fpe=ae(ape,[["render",dpe],["__file","chat-line-round.vue"]]),hpe={name:"ChatLineSquare"},ppe={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},mpe=I("path",{fill:"currentColor",d:"M160 826.88 273.536 736H800a64 64 0 0 0 64-64V256a64 64 0 0 0-64-64H224a64 64 0 0 0-64 64v570.88zM296 800 147.968 918.4A32 32 0 0 1 96 893.44V256a128 128 0 0 1 128-128h576a128 128 0 0 1 128 128v416a128 128 0 0 1-128 128H296z"},null,-1),gpe=I("path",{fill:"currentColor",d:"M352 512h320q32 0 32 32t-32 32H352q-32 0-32-32t32-32zm0-192h320q32 0 32 32t-32 32H352q-32 0-32-32t32-32z"},null,-1),vpe=[mpe,gpe];function ype(t,e,n,s,r,o){return S(),E("svg",ppe,vpe)}var bpe=ae(hpe,[["render",ype],["__file","chat-line-square.vue"]]),wpe={name:"ChatRound"},_pe={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},$pe=I("path",{fill:"currentColor",d:"m174.72 855.68 130.048-43.392 23.424 11.392C382.4 849.984 444.352 864 512 864c223.744 0 384-159.872 384-352 0-192.832-159.104-352-384-352S128 319.168 128 512a341.12 341.12 0 0 0 69.248 204.288l21.632 28.8-44.16 110.528zm-45.248 82.56A32 32 0 0 1 89.6 896l56.512-141.248A405.12 405.12 0 0 1 64 512C64 299.904 235.648 96 512 96s448 203.904 448 416-173.44 416-448 416c-79.68 0-150.848-17.152-211.712-46.72l-170.88 56.96z"},null,-1),xpe=[$pe];function Spe(t,e,n,s,r,o){return S(),E("svg",_pe,xpe)}var Cpe=ae(wpe,[["render",Spe],["__file","chat-round.vue"]]),kpe={name:"ChatSquare"},Tpe={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},Npe=I("path",{fill:"currentColor",d:"M273.536 736H800a64 64 0 0 0 64-64V256a64 64 0 0 0-64-64H224a64 64 0 0 0-64 64v570.88L273.536 736zM296 800 147.968 918.4A32 32 0 0 1 96 893.44V256a128 128 0 0 1 128-128h576a128 128 0 0 1 128 128v416a128 128 0 0 1-128 128H296z"},null,-1),Ipe=[Npe];function Epe(t,e,n,s,r,o){return S(),E("svg",Tpe,Ipe)}var Ape=ae(kpe,[["render",Epe],["__file","chat-square.vue"]]),Ope={name:"Check"},Rpe={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},Dpe=I("path",{fill:"currentColor",d:"M406.656 706.944 195.84 496.256a32 32 0 1 0-45.248 45.248l256 256 512-512a32 32 0 0 0-45.248-45.248L406.592 706.944z"},null,-1),Fpe=[Dpe];function Mpe(t,e,n,s,r,o){return S(),E("svg",Rpe,Fpe)}var Jh=ae(Ope,[["render",Mpe],["__file","check.vue"]]),Ppe={name:"Checked"},Lpe={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},zpe=I("path",{fill:"currentColor",d:"M704 192h160v736H160V192h160.064v64H704v-64zM311.616 537.28l-45.312 45.248L447.36 763.52l316.8-316.8-45.312-45.184L447.36 673.024 311.616 537.28zM384 192V96h256v96H384z"},null,-1),Bpe=[zpe];function Vpe(t,e,n,s,r,o){return S(),E("svg",Lpe,Bpe)}var Hpe=ae(Ppe,[["render",Vpe],["__file","checked.vue"]]),Wpe={name:"Cherry"},Upe={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},Gpe=I("path",{fill:"currentColor",d:"M261.056 449.6c13.824-69.696 34.88-128.96 63.36-177.728 23.744-40.832 61.12-88.64 112.256-143.872H320a32 32 0 0 1 0-64h384a32 32 0 1 1 0 64H554.752c14.912 39.168 41.344 86.592 79.552 141.76 47.36 68.48 84.8 106.752 106.304 114.304a224 224 0 1 1-84.992 14.784c-22.656-22.912-47.04-53.76-73.92-92.608-38.848-56.128-67.008-105.792-84.352-149.312-55.296 58.24-94.528 107.52-117.76 147.2-23.168 39.744-41.088 88.768-53.568 147.072a224.064 224.064 0 1 1-64.96-1.6zM288 832a160 160 0 1 0 0-320 160 160 0 0 0 0 320zm448-64a160 160 0 1 0 0-320 160 160 0 0 0 0 320z"},null,-1),jpe=[Gpe];function Kpe(t,e,n,s,r,o){return S(),E("svg",Upe,jpe)}var qpe=ae(Wpe,[["render",Kpe],["__file","cherry.vue"]]),Xpe={name:"Chicken"},Ype={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},Zpe=I("path",{fill:"currentColor",d:"M349.952 716.992 478.72 588.16a106.688 106.688 0 0 1-26.176-19.072 106.688 106.688 0 0 1-19.072-26.176L304.704 671.744c.768 3.072 1.472 6.144 2.048 9.216l2.048 31.936 31.872 1.984c3.136.64 6.208 1.28 9.28 2.112zm57.344 33.152a128 128 0 1 1-216.32 114.432l-1.92-32-32-1.92a128 128 0 1 1 114.432-216.32L416.64 469.248c-2.432-101.44 58.112-239.104 149.056-330.048 107.328-107.328 231.296-85.504 316.8 0 85.44 85.44 107.328 209.408 0 316.8-91.008 90.88-228.672 151.424-330.112 149.056L407.296 750.08zm90.496-226.304c49.536 49.536 233.344-7.04 339.392-113.088 78.208-78.208 63.232-163.072 0-226.304-63.168-63.232-148.032-78.208-226.24 0C504.896 290.496 448.32 474.368 497.792 523.84zM244.864 708.928a64 64 0 1 0-59.84 59.84l56.32-3.52 3.52-56.32zm8.064 127.68a64 64 0 1 0 59.84-59.84l-56.32 3.52-3.52 56.32z"},null,-1),Jpe=[Zpe];function Qpe(t,e,n,s,r,o){return S(),E("svg",Ype,Jpe)}var eme=ae(Xpe,[["render",Qpe],["__file","chicken.vue"]]),tme={name:"ChromeFilled"},nme={xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 1024 1024",style:{"enable-background":"new 0 0 1024 1024"},"xml:space":"preserve"},sme=I("path",{d:"M938.67 512.01c0-44.59-6.82-87.6-19.54-128H682.67a212.372 212.372 0 0 1 42.67 128c.06 38.71-10.45 76.7-30.42 109.87l-182.91 316.8c235.65-.01 426.66-191.02 426.66-426.67z",fill:"currentColor"},null,-1),rme=I("path",{d:"M576.79 401.63a127.92 127.92 0 0 0-63.56-17.6c-22.36-.22-44.39 5.43-63.89 16.38s-35.79 26.82-47.25 46.02a128.005 128.005 0 0 0-2.16 127.44l1.24 2.13a127.906 127.906 0 0 0 46.36 46.61 127.907 127.907 0 0 0 63.38 17.44c22.29.2 44.24-5.43 63.68-16.33a127.94 127.94 0 0 0 47.16-45.79v-.01l1.11-1.92a127.984 127.984 0 0 0 .29-127.46 127.957 127.957 0 0 0-46.36-46.91z",fill:"currentColor"},null,-1),ome=I("path",{d:"M394.45 333.96A213.336 213.336 0 0 1 512 298.67h369.58A426.503 426.503 0 0 0 512 85.34a425.598 425.598 0 0 0-171.74 35.98 425.644 425.644 0 0 0-142.62 102.22l118.14 204.63a213.397 213.397 0 0 1 78.67-94.21zm117.56 604.72H512zm-97.25-236.73a213.284 213.284 0 0 1-89.54-86.81L142.48 298.6c-36.35 62.81-57.13 135.68-57.13 213.42 0 203.81 142.93 374.22 333.95 416.55h.04l118.19-204.71a213.315 213.315 0 0 1-122.77-21.91z",fill:"currentColor"},null,-1),ame=[sme,rme,ome];function ime(t,e,n,s,r,o){return S(),E("svg",nme,ame)}var lme=ae(tme,[["render",ime],["__file","chrome-filled.vue"]]),ume={name:"CircleCheckFilled"},cme={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},dme=I("path",{fill:"currentColor",d:"M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896zm-55.808 536.384-99.52-99.584a38.4 38.4 0 1 0-54.336 54.336l126.72 126.72a38.272 38.272 0 0 0 54.336 0l262.4-262.464a38.4 38.4 0 1 0-54.272-54.336L456.192 600.384z"},null,-1),fme=[dme];function hme(t,e,n,s,r,o){return S(),E("svg",cme,fme)}var hP=ae(ume,[["render",hme],["__file","circle-check-filled.vue"]]),pme={name:"CircleCheck"},mme={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},gme=I("path",{fill:"currentColor",d:"M512 896a384 384 0 1 0 0-768 384 384 0 0 0 0 768zm0 64a448 448 0 1 1 0-896 448 448 0 0 1 0 896z"},null,-1),vme=I("path",{fill:"currentColor",d:"M745.344 361.344a32 32 0 0 1 45.312 45.312l-288 288a32 32 0 0 1-45.312 0l-160-160a32 32 0 1 1 45.312-45.312L480 626.752l265.344-265.408z"},null,-1),yme=[gme,vme];function bme(t,e,n,s,r,o){return S(),E("svg",mme,yme)}var lw=ae(pme,[["render",bme],["__file","circle-check.vue"]]),wme={name:"CircleCloseFilled"},_me={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},$me=I("path",{fill:"currentColor",d:"M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896zm0 393.664L407.936 353.6a38.4 38.4 0 1 0-54.336 54.336L457.664 512 353.6 616.064a38.4 38.4 0 1 0 54.336 54.336L512 566.336 616.064 670.4a38.4 38.4 0 1 0 54.336-54.336L566.336 512 670.4 407.936a38.4 38.4 0 1 0-54.336-54.336L512 457.664z"},null,-1),xme=[$me];function Sme(t,e,n,s,r,o){return S(),E("svg",_me,xme)}var uw=ae(wme,[["render",Sme],["__file","circle-close-filled.vue"]]),Cme={name:"CircleClose"},kme={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},Tme=I("path",{fill:"currentColor",d:"m466.752 512-90.496-90.496a32 32 0 0 1 45.248-45.248L512 466.752l90.496-90.496a32 32 0 1 1 45.248 45.248L557.248 512l90.496 90.496a32 32 0 1 1-45.248 45.248L512 557.248l-90.496 90.496a32 32 0 0 1-45.248-45.248L466.752 512z"},null,-1),Nme=I("path",{fill:"currentColor",d:"M512 896a384 384 0 1 0 0-768 384 384 0 0 0 0 768zm0 64a448 448 0 1 1 0-896 448 448 0 0 1 0 896z"},null,-1),Ime=[Tme,Nme];function Eme(t,e,n,s,r,o){return S(),E("svg",kme,Ime)}var Bl=ae(Cme,[["render",Eme],["__file","circle-close.vue"]]),Ame={name:"CirclePlusFilled"},Ome={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},Rme=I("path",{fill:"currentColor",d:"M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896zm-38.4 409.6H326.4a38.4 38.4 0 1 0 0 76.8h147.2v147.2a38.4 38.4 0 0 0 76.8 0V550.4h147.2a38.4 38.4 0 0 0 0-76.8H550.4V326.4a38.4 38.4 0 1 0-76.8 0v147.2z"},null,-1),Dme=[Rme];function Fme(t,e,n,s,r,o){return S(),E("svg",Ome,Dme)}var Mme=ae(Ame,[["render",Fme],["__file","circle-plus-filled.vue"]]),Pme={name:"CirclePlus"},Lme={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},zme=I("path",{fill:"currentColor",d:"M352 480h320a32 32 0 1 1 0 64H352a32 32 0 0 1 0-64z"},null,-1),Bme=I("path",{fill:"currentColor",d:"M480 672V352a32 32 0 1 1 64 0v320a32 32 0 0 1-64 0z"},null,-1),Vme=I("path",{fill:"currentColor",d:"M512 896a384 384 0 1 0 0-768 384 384 0 0 0 0 768zm0 64a448 448 0 1 1 0-896 448 448 0 0 1 0 896z"},null,-1),Hme=[zme,Bme,Vme];function Wme(t,e,n,s,r,o){return S(),E("svg",Lme,Hme)}var Ume=ae(Pme,[["render",Wme],["__file","circle-plus.vue"]]),Gme={name:"Clock"},jme={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},Kme=I("path",{fill:"currentColor",d:"M512 896a384 384 0 1 0 0-768 384 384 0 0 0 0 768zm0 64a448 448 0 1 1 0-896 448 448 0 0 1 0 896z"},null,-1),qme=I("path",{fill:"currentColor",d:"M480 256a32 32 0 0 1 32 32v256a32 32 0 0 1-64 0V288a32 32 0 0 1 32-32z"},null,-1),Xme=I("path",{fill:"currentColor",d:"M480 512h256q32 0 32 32t-32 32H480q-32 0-32-32t32-32z"},null,-1),Yme=[Kme,qme,Xme];function Zme(t,e,n,s,r,o){return S(),E("svg",jme,Yme)}var AC=ae(Gme,[["render",Zme],["__file","clock.vue"]]),Jme={name:"CloseBold"},Qme={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},e0e=I("path",{fill:"currentColor",d:"M195.2 195.2a64 64 0 0 1 90.496 0L512 421.504 738.304 195.2a64 64 0 0 1 90.496 90.496L602.496 512 828.8 738.304a64 64 0 0 1-90.496 90.496L512 602.496 285.696 828.8a64 64 0 0 1-90.496-90.496L421.504 512 195.2 285.696a64 64 0 0 1 0-90.496z"},null,-1),t0e=[e0e];function n0e(t,e,n,s,r,o){return S(),E("svg",Qme,t0e)}var s0e=ae(Jme,[["render",n0e],["__file","close-bold.vue"]]),r0e={name:"Close"},o0e={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},a0e=I("path",{fill:"currentColor",d:"M764.288 214.592 512 466.88 259.712 214.592a31.936 31.936 0 0 0-45.12 45.12L466.752 512 214.528 764.224a31.936 31.936 0 1 0 45.12 45.184L512 557.184l252.288 252.288a31.936 31.936 0 0 0 45.12-45.12L557.12 512.064l252.288-252.352a31.936 31.936 0 1 0-45.12-45.184z"},null,-1),i0e=[a0e];function l0e(t,e,n,s,r,o){return S(),E("svg",o0e,i0e)}var xa=ae(r0e,[["render",l0e],["__file","close.vue"]]),u0e={name:"Cloudy"},c0e={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},d0e=I("path",{fill:"currentColor",d:"M598.4 831.872H328.192a256 256 0 0 1-34.496-510.528A352 352 0 1 1 598.4 831.872zm-271.36-64h272.256a288 288 0 1 0-248.512-417.664L335.04 381.44l-34.816 3.584a192 192 0 0 0 26.88 382.848z"},null,-1),f0e=[d0e];function h0e(t,e,n,s,r,o){return S(),E("svg",c0e,f0e)}var p0e=ae(u0e,[["render",h0e],["__file","cloudy.vue"]]),m0e={name:"CoffeeCup"},g0e={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},v0e=I("path",{fill:"currentColor",d:"M768 192a192 192 0 1 1-8 383.808A256.128 256.128 0 0 1 512 768H320A256 256 0 0 1 64 512V160a32 32 0 0 1 32-32h640a32 32 0 0 1 32 32v32zm0 64v256a128 128 0 1 0 0-256zM96 832h640a32 32 0 1 1 0 64H96a32 32 0 1 1 0-64zm32-640v320a192 192 0 0 0 192 192h192a192 192 0 0 0 192-192V192H128z"},null,-1),y0e=[v0e];function b0e(t,e,n,s,r,o){return S(),E("svg",g0e,y0e)}var w0e=ae(m0e,[["render",b0e],["__file","coffee-cup.vue"]]),_0e={name:"Coffee"},$0e={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},x0e=I("path",{fill:"currentColor",d:"M822.592 192h14.272a32 32 0 0 1 31.616 26.752l21.312 128A32 32 0 0 1 858.24 384h-49.344l-39.04 546.304A32 32 0 0 1 737.92 960H285.824a32 32 0 0 1-32-29.696L214.912 384H165.76a32 32 0 0 1-31.552-37.248l21.312-128A32 32 0 0 1 187.136 192h14.016l-6.72-93.696A32 32 0 0 1 226.368 64h571.008a32 32 0 0 1 31.936 34.304L822.592 192zm-64.128 0 4.544-64H260.736l4.544 64h493.184zm-548.16 128H820.48l-10.688-64H214.208l-10.688 64h6.784zm68.736 64 36.544 512H708.16l36.544-512H279.04z"},null,-1),S0e=[x0e];function C0e(t,e,n,s,r,o){return S(),E("svg",$0e,S0e)}var k0e=ae(_0e,[["render",C0e],["__file","coffee.vue"]]),T0e={name:"Coin"},N0e={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},I0e=I("path",{fill:"currentColor",d:"m161.92 580.736 29.888 58.88C171.328 659.776 160 681.728 160 704c0 82.304 155.328 160 352 160s352-77.696 352-160c0-22.272-11.392-44.16-31.808-64.32l30.464-58.432C903.936 615.808 928 657.664 928 704c0 129.728-188.544 224-416 224S96 833.728 96 704c0-46.592 24.32-88.576 65.92-123.264z"},null,-1),E0e=I("path",{fill:"currentColor",d:"m161.92 388.736 29.888 58.88C171.328 467.84 160 489.792 160 512c0 82.304 155.328 160 352 160s352-77.696 352-160c0-22.272-11.392-44.16-31.808-64.32l30.464-58.432C903.936 423.808 928 465.664 928 512c0 129.728-188.544 224-416 224S96 641.728 96 512c0-46.592 24.32-88.576 65.92-123.264z"},null,-1),A0e=I("path",{fill:"currentColor",d:"M512 544c-227.456 0-416-94.272-416-224S284.544 96 512 96s416 94.272 416 224-188.544 224-416 224zm0-64c196.672 0 352-77.696 352-160S708.672 160 512 160s-352 77.696-352 160 155.328 160 352 160z"},null,-1),O0e=[I0e,E0e,A0e];function R0e(t,e,n,s,r,o){return S(),E("svg",N0e,O0e)}var D0e=ae(T0e,[["render",R0e],["__file","coin.vue"]]),F0e={name:"ColdDrink"},M0e={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},P0e=I("path",{fill:"currentColor",d:"M768 64a192 192 0 1 1-69.952 370.88L480 725.376V896h96a32 32 0 1 1 0 64H320a32 32 0 1 1 0-64h96V725.376L76.8 273.536a64 64 0 0 1-12.8-38.4v-10.688a32 32 0 0 1 32-32h71.808l-65.536-83.84a32 32 0 0 1 50.432-39.424l96.256 123.264h337.728A192.064 192.064 0 0 1 768 64zM656.896 192.448H800a32 32 0 0 1 32 32v10.624a64 64 0 0 1-12.8 38.4l-80.448 107.2a128 128 0 1 0-81.92-188.16v-.064zm-357.888 64 129.472 165.76a32 32 0 0 1-50.432 39.36l-160.256-205.12H144l304 404.928 304-404.928H299.008z"},null,-1),L0e=[P0e];function z0e(t,e,n,s,r,o){return S(),E("svg",M0e,L0e)}var B0e=ae(F0e,[["render",z0e],["__file","cold-drink.vue"]]),V0e={name:"CollectionTag"},H0e={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},W0e=I("path",{fill:"currentColor",d:"M256 128v698.88l196.032-156.864a96 96 0 0 1 119.936 0L768 826.816V128H256zm-32-64h576a32 32 0 0 1 32 32v797.44a32 32 0 0 1-51.968 24.96L531.968 720a32 32 0 0 0-39.936 0L243.968 918.4A32 32 0 0 1 192 893.44V96a32 32 0 0 1 32-32z"},null,-1),U0e=[W0e];function G0e(t,e,n,s,r,o){return S(),E("svg",H0e,U0e)}var j0e=ae(V0e,[["render",G0e],["__file","collection-tag.vue"]]),K0e={name:"Collection"},q0e={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},X0e=I("path",{fill:"currentColor",d:"M192 736h640V128H256a64 64 0 0 0-64 64v544zm64-672h608a32 32 0 0 1 32 32v672a32 32 0 0 1-32 32H160l-32 57.536V192A128 128 0 0 1 256 64z"},null,-1),Y0e=I("path",{fill:"currentColor",d:"M240 800a48 48 0 1 0 0 96h592v-96H240zm0-64h656v160a64 64 0 0 1-64 64H240a112 112 0 0 1 0-224zm144-608v250.88l96-76.8 96 76.8V128H384zm-64-64h320v381.44a32 32 0 0 1-51.968 24.96L480 384l-108.032 86.4A32 32 0 0 1 320 445.44V64z"},null,-1),Z0e=[X0e,Y0e];function J0e(t,e,n,s,r,o){return S(),E("svg",q0e,Z0e)}var Q0e=ae(K0e,[["render",J0e],["__file","collection.vue"]]),ege={name:"Comment"},tge={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},nge=I("path",{fill:"currentColor",d:"M736 504a56 56 0 1 1 0-112 56 56 0 0 1 0 112zm-224 0a56 56 0 1 1 0-112 56 56 0 0 1 0 112zm-224 0a56 56 0 1 1 0-112 56 56 0 0 1 0 112zM128 128v640h192v160l224-160h352V128H128z"},null,-1),sge=[nge];function rge(t,e,n,s,r,o){return S(),E("svg",tge,sge)}var oge=ae(ege,[["render",rge],["__file","comment.vue"]]),age={name:"Compass"},ige={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},lge=I("path",{fill:"currentColor",d:"M512 896a384 384 0 1 0 0-768 384 384 0 0 0 0 768zm0 64a448 448 0 1 1 0-896 448 448 0 0 1 0 896z"},null,-1),uge=I("path",{fill:"currentColor",d:"M725.888 315.008C676.48 428.672 624 513.28 568.576 568.64c-55.424 55.424-139.968 107.904-253.568 157.312a12.8 12.8 0 0 1-16.896-16.832c49.536-113.728 102.016-198.272 157.312-253.632 55.36-55.296 139.904-107.776 253.632-157.312a12.8 12.8 0 0 1 16.832 16.832z"},null,-1),cge=[lge,uge];function dge(t,e,n,s,r,o){return S(),E("svg",ige,cge)}var fge=ae(age,[["render",dge],["__file","compass.vue"]]),hge={name:"Connection"},pge={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},mge=I("path",{fill:"currentColor",d:"M640 384v64H448a128 128 0 0 0-128 128v128a128 128 0 0 0 128 128h320a128 128 0 0 0 128-128V576a128 128 0 0 0-64-110.848V394.88c74.56 26.368 128 97.472 128 181.056v128a192 192 0 0 1-192 192H448a192 192 0 0 1-192-192V576a192 192 0 0 1 192-192h192z"},null,-1),gge=I("path",{fill:"currentColor",d:"M384 640v-64h192a128 128 0 0 0 128-128V320a128 128 0 0 0-128-128H256a128 128 0 0 0-128 128v128a128 128 0 0 0 64 110.848v70.272A192.064 192.064 0 0 1 64 448V320a192 192 0 0 1 192-192h320a192 192 0 0 1 192 192v128a192 192 0 0 1-192 192H384z"},null,-1),vge=[mge,gge];function yge(t,e,n,s,r,o){return S(),E("svg",pge,vge)}var bge=ae(hge,[["render",yge],["__file","connection.vue"]]),wge={name:"Coordinate"},_ge={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},$ge=I("path",{fill:"currentColor",d:"M480 512h64v320h-64z"},null,-1),xge=I("path",{fill:"currentColor",d:"M192 896h640a64 64 0 0 0-64-64H256a64 64 0 0 0-64 64zm64-128h512a128 128 0 0 1 128 128v64H128v-64a128 128 0 0 1 128-128zm256-256a192 192 0 1 0 0-384 192 192 0 0 0 0 384zm0 64a256 256 0 1 1 0-512 256 256 0 0 1 0 512z"},null,-1),Sge=[$ge,xge];function Cge(t,e,n,s,r,o){return S(),E("svg",_ge,Sge)}var kge=ae(wge,[["render",Cge],["__file","coordinate.vue"]]),Tge={name:"CopyDocument"},Nge={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},Ige=I("path",{fill:"currentColor",d:"M768 832a128 128 0 0 1-128 128H192A128 128 0 0 1 64 832V384a128 128 0 0 1 128-128v64a64 64 0 0 0-64 64v448a64 64 0 0 0 64 64h448a64 64 0 0 0 64-64h64z"},null,-1),Ege=I("path",{fill:"currentColor",d:"M384 128a64 64 0 0 0-64 64v448a64 64 0 0 0 64 64h448a64 64 0 0 0 64-64V192a64 64 0 0 0-64-64H384zm0-64h448a128 128 0 0 1 128 128v448a128 128 0 0 1-128 128H384a128 128 0 0 1-128-128V192A128 128 0 0 1 384 64z"},null,-1),Age=[Ige,Ege];function Oge(t,e,n,s,r,o){return S(),E("svg",Nge,Age)}var Rge=ae(Tge,[["render",Oge],["__file","copy-document.vue"]]),Dge={name:"Cpu"},Fge={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},Mge=I("path",{fill:"currentColor",d:"M320 256a64 64 0 0 0-64 64v384a64 64 0 0 0 64 64h384a64 64 0 0 0 64-64V320a64 64 0 0 0-64-64H320zm0-64h384a128 128 0 0 1 128 128v384a128 128 0 0 1-128 128H320a128 128 0 0 1-128-128V320a128 128 0 0 1 128-128z"},null,-1),Pge=I("path",{fill:"currentColor",d:"M512 64a32 32 0 0 1 32 32v128h-64V96a32 32 0 0 1 32-32zm160 0a32 32 0 0 1 32 32v128h-64V96a32 32 0 0 1 32-32zm-320 0a32 32 0 0 1 32 32v128h-64V96a32 32 0 0 1 32-32zm160 896a32 32 0 0 1-32-32V800h64v128a32 32 0 0 1-32 32zm160 0a32 32 0 0 1-32-32V800h64v128a32 32 0 0 1-32 32zm-320 0a32 32 0 0 1-32-32V800h64v128a32 32 0 0 1-32 32zM64 512a32 32 0 0 1 32-32h128v64H96a32 32 0 0 1-32-32zm0-160a32 32 0 0 1 32-32h128v64H96a32 32 0 0 1-32-32zm0 320a32 32 0 0 1 32-32h128v64H96a32 32 0 0 1-32-32zm896-160a32 32 0 0 1-32 32H800v-64h128a32 32 0 0 1 32 32zm0-160a32 32 0 0 1-32 32H800v-64h128a32 32 0 0 1 32 32zm0 320a32 32 0 0 1-32 32H800v-64h128a32 32 0 0 1 32 32z"},null,-1),Lge=[Mge,Pge];function zge(t,e,n,s,r,o){return S(),E("svg",Fge,Lge)}var Bge=ae(Dge,[["render",zge],["__file","cpu.vue"]]),Vge={name:"CreditCard"},Hge={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},Wge=I("path",{fill:"currentColor",d:"M896 324.096c0-42.368-2.496-55.296-9.536-68.48a52.352 52.352 0 0 0-22.144-22.08c-13.12-7.04-26.048-9.536-68.416-9.536H228.096c-42.368 0-55.296 2.496-68.48 9.536a52.352 52.352 0 0 0-22.08 22.144c-7.04 13.12-9.536 26.048-9.536 68.416v375.808c0 42.368 2.496 55.296 9.536 68.48a52.352 52.352 0 0 0 22.144 22.08c13.12 7.04 26.048 9.536 68.416 9.536h567.808c42.368 0 55.296-2.496 68.48-9.536a52.352 52.352 0 0 0 22.08-22.144c7.04-13.12 9.536-26.048 9.536-68.416V324.096zm64 0v375.808c0 57.088-5.952 77.76-17.088 98.56-11.136 20.928-27.52 37.312-48.384 48.448-20.864 11.136-41.6 17.088-98.56 17.088H228.032c-57.088 0-77.76-5.952-98.56-17.088a116.288 116.288 0 0 1-48.448-48.384c-11.136-20.864-17.088-41.6-17.088-98.56V324.032c0-57.088 5.952-77.76 17.088-98.56 11.136-20.928 27.52-37.312 48.384-48.448 20.864-11.136 41.6-17.088 98.56-17.088H795.84c57.088 0 77.76 5.952 98.56 17.088 20.928 11.136 37.312 27.52 48.448 48.384 11.136 20.864 17.088 41.6 17.088 98.56z"},null,-1),Uge=I("path",{fill:"currentColor",d:"M64 320h896v64H64v-64zm0 128h896v64H64v-64zm128 192h256v64H192z"},null,-1),Gge=[Wge,Uge];function jge(t,e,n,s,r,o){return S(),E("svg",Hge,Gge)}var Kge=ae(Vge,[["render",jge],["__file","credit-card.vue"]]),qge={name:"Crop"},Xge={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},Yge=I("path",{fill:"currentColor",d:"M256 768h672a32 32 0 1 1 0 64H224a32 32 0 0 1-32-32V96a32 32 0 0 1 64 0v672z"},null,-1),Zge=I("path",{fill:"currentColor",d:"M832 224v704a32 32 0 1 1-64 0V256H96a32 32 0 0 1 0-64h704a32 32 0 0 1 32 32z"},null,-1),Jge=[Yge,Zge];function Qge(t,e,n,s,r,o){return S(),E("svg",Xge,Jge)}var e1e=ae(qge,[["render",Qge],["__file","crop.vue"]]),t1e={name:"DArrowLeft"},n1e={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},s1e=I("path",{fill:"currentColor",d:"M529.408 149.376a29.12 29.12 0 0 1 41.728 0 30.592 30.592 0 0 1 0 42.688L259.264 511.936l311.872 319.936a30.592 30.592 0 0 1-.512 43.264 29.12 29.12 0 0 1-41.216-.512L197.76 534.272a32 32 0 0 1 0-44.672l331.648-340.224zm256 0a29.12 29.12 0 0 1 41.728 0 30.592 30.592 0 0 1 0 42.688L515.264 511.936l311.872 319.936a30.592 30.592 0 0 1-.512 43.264 29.12 29.12 0 0 1-41.216-.512L453.76 534.272a32 32 0 0 1 0-44.672l331.648-340.224z"},null,-1),r1e=[s1e];function o1e(t,e,n,s,r,o){return S(),E("svg",n1e,r1e)}var $d=ae(t1e,[["render",o1e],["__file","d-arrow-left.vue"]]),a1e={name:"DArrowRight"},i1e={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},l1e=I("path",{fill:"currentColor",d:"M452.864 149.312a29.12 29.12 0 0 1 41.728.064L826.24 489.664a32 32 0 0 1 0 44.672L494.592 874.624a29.12 29.12 0 0 1-41.728 0 30.592 30.592 0 0 1 0-42.752L764.736 512 452.864 192a30.592 30.592 0 0 1 0-42.688zm-256 0a29.12 29.12 0 0 1 41.728.064L570.24 489.664a32 32 0 0 1 0 44.672L238.592 874.624a29.12 29.12 0 0 1-41.728 0 30.592 30.592 0 0 1 0-42.752L508.736 512 196.864 192a30.592 30.592 0 0 1 0-42.688z"},null,-1),u1e=[l1e];function c1e(t,e,n,s,r,o){return S(),E("svg",i1e,u1e)}var xd=ae(a1e,[["render",c1e],["__file","d-arrow-right.vue"]]),d1e={name:"DCaret"},f1e={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},h1e=I("path",{fill:"currentColor",d:"m512 128 288 320H224l288-320zM224 576h576L512 896 224 576z"},null,-1),p1e=[h1e];function m1e(t,e,n,s,r,o){return S(),E("svg",f1e,p1e)}var g1e=ae(d1e,[["render",m1e],["__file","d-caret.vue"]]),v1e={name:"DataAnalysis"},y1e={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},b1e=I("path",{fill:"currentColor",d:"m665.216 768 110.848 192h-73.856L591.36 768H433.024L322.176 960H248.32l110.848-192H160a32 32 0 0 1-32-32V192H64a32 32 0 0 1 0-64h896a32 32 0 1 1 0 64h-64v544a32 32 0 0 1-32 32H665.216zM832 192H192v512h640V192zM352 448a32 32 0 0 1 32 32v64a32 32 0 0 1-64 0v-64a32 32 0 0 1 32-32zm160-64a32 32 0 0 1 32 32v128a32 32 0 0 1-64 0V416a32 32 0 0 1 32-32zm160-64a32 32 0 0 1 32 32v192a32 32 0 1 1-64 0V352a32 32 0 0 1 32-32z"},null,-1),w1e=[b1e];function _1e(t,e,n,s,r,o){return S(),E("svg",y1e,w1e)}var $1e=ae(v1e,[["render",_1e],["__file","data-analysis.vue"]]),x1e={name:"DataBoard"},S1e={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},C1e=I("path",{fill:"currentColor",d:"M32 128h960v64H32z"},null,-1),k1e=I("path",{fill:"currentColor",d:"M192 192v512h640V192H192zm-64-64h768v608a32 32 0 0 1-32 32H160a32 32 0 0 1-32-32V128z"},null,-1),T1e=I("path",{fill:"currentColor",d:"M322.176 960H248.32l144.64-250.56 55.424 32L322.176 960zm453.888 0h-73.856L576 741.44l55.424-32L776.064 960z"},null,-1),N1e=[C1e,k1e,T1e];function I1e(t,e,n,s,r,o){return S(),E("svg",S1e,N1e)}var E1e=ae(x1e,[["render",I1e],["__file","data-board.vue"]]),A1e={name:"DataLine"},O1e={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},R1e=I("path",{fill:"currentColor",d:"M359.168 768H160a32 32 0 0 1-32-32V192H64a32 32 0 0 1 0-64h896a32 32 0 1 1 0 64h-64v544a32 32 0 0 1-32 32H665.216l110.848 192h-73.856L591.36 768H433.024L322.176 960H248.32l110.848-192zM832 192H192v512h640V192zM342.656 534.656a32 32 0 1 1-45.312-45.312L444.992 341.76l125.44 94.08L679.04 300.032a32 32 0 1 1 49.92 39.936L581.632 524.224 451.008 426.24 342.656 534.592z"},null,-1),D1e=[R1e];function F1e(t,e,n,s,r,o){return S(),E("svg",O1e,D1e)}var M1e=ae(A1e,[["render",F1e],["__file","data-line.vue"]]),P1e={name:"DeleteFilled"},L1e={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},z1e=I("path",{fill:"currentColor",d:"M352 192V95.936a32 32 0 0 1 32-32h256a32 32 0 0 1 32 32V192h256a32 32 0 1 1 0 64H96a32 32 0 0 1 0-64h256zm64 0h192v-64H416v64zM192 960a32 32 0 0 1-32-32V256h704v672a32 32 0 0 1-32 32H192zm224-192a32 32 0 0 0 32-32V416a32 32 0 0 0-64 0v320a32 32 0 0 0 32 32zm192 0a32 32 0 0 0 32-32V416a32 32 0 0 0-64 0v320a32 32 0 0 0 32 32z"},null,-1),B1e=[z1e];function V1e(t,e,n,s,r,o){return S(),E("svg",L1e,B1e)}var H1e=ae(P1e,[["render",V1e],["__file","delete-filled.vue"]]),W1e={name:"DeleteLocation"},U1e={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},G1e=I("path",{fill:"currentColor",d:"M288 896h448q32 0 32 32t-32 32H288q-32 0-32-32t32-32z"},null,-1),j1e=I("path",{fill:"currentColor",d:"M800 416a288 288 0 1 0-576 0c0 118.144 94.528 272.128 288 456.576C705.472 688.128 800 534.144 800 416zM512 960C277.312 746.688 160 565.312 160 416a352 352 0 0 1 704 0c0 149.312-117.312 330.688-352 544z"},null,-1),K1e=I("path",{fill:"currentColor",d:"M384 384h256q32 0 32 32t-32 32H384q-32 0-32-32t32-32z"},null,-1),q1e=[G1e,j1e,K1e];function X1e(t,e,n,s,r,o){return S(),E("svg",U1e,q1e)}var Y1e=ae(W1e,[["render",X1e],["__file","delete-location.vue"]]),Z1e={name:"Delete"},J1e={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},Q1e=I("path",{fill:"currentColor",d:"M160 256H96a32 32 0 0 1 0-64h256V95.936a32 32 0 0 1 32-32h256a32 32 0 0 1 32 32V192h256a32 32 0 1 1 0 64h-64v672a32 32 0 0 1-32 32H192a32 32 0 0 1-32-32V256zm448-64v-64H416v64h192zM224 896h576V256H224v640zm192-128a32 32 0 0 1-32-32V416a32 32 0 0 1 64 0v320a32 32 0 0 1-32 32zm192 0a32 32 0 0 1-32-32V416a32 32 0 0 1 64 0v320a32 32 0 0 1-32 32z"},null,-1),e2e=[Q1e];function t2e(t,e,n,s,r,o){return S(),E("svg",J1e,e2e)}var pP=ae(Z1e,[["render",t2e],["__file","delete.vue"]]),n2e={name:"Dessert"},s2e={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},r2e=I("path",{fill:"currentColor",d:"M128 416v-48a144 144 0 0 1 168.64-141.888 224.128 224.128 0 0 1 430.72 0A144 144 0 0 1 896 368v48a384 384 0 0 1-352 382.72V896h-64v-97.28A384 384 0 0 1 128 416zm287.104-32.064h193.792a143.808 143.808 0 0 1 58.88-132.736 160.064 160.064 0 0 0-311.552 0 143.808 143.808 0 0 1 58.88 132.8zm-72.896 0a72 72 0 1 0-140.48 0h140.48zm339.584 0h140.416a72 72 0 1 0-140.48 0zM512 736a320 320 0 0 0 318.4-288.064H193.6A320 320 0 0 0 512 736zM384 896.064h256a32 32 0 1 1 0 64H384a32 32 0 1 1 0-64z"},null,-1),o2e=[r2e];function a2e(t,e,n,s,r,o){return S(),E("svg",s2e,o2e)}var i2e=ae(n2e,[["render",a2e],["__file","dessert.vue"]]),l2e={name:"Discount"},u2e={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},c2e=I("path",{fill:"currentColor",d:"M224 704h576V318.336L552.512 115.84a64 64 0 0 0-81.024 0L224 318.336V704zm0 64v128h576V768H224zM593.024 66.304l259.2 212.096A32 32 0 0 1 864 303.168V928a32 32 0 0 1-32 32H192a32 32 0 0 1-32-32V303.168a32 32 0 0 1 11.712-24.768l259.2-212.096a128 128 0 0 1 162.112 0z"},null,-1),d2e=I("path",{fill:"currentColor",d:"M512 448a64 64 0 1 0 0-128 64 64 0 0 0 0 128zm0 64a128 128 0 1 1 0-256 128 128 0 0 1 0 256z"},null,-1),f2e=[c2e,d2e];function h2e(t,e,n,s,r,o){return S(),E("svg",u2e,f2e)}var p2e=ae(l2e,[["render",h2e],["__file","discount.vue"]]),m2e={name:"DishDot"},g2e={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},v2e=I("path",{fill:"currentColor",d:"m384.064 274.56.064-50.688A128 128 0 0 1 512.128 96c70.528 0 127.68 57.152 127.68 127.68v50.752A448.192 448.192 0 0 1 955.392 768H68.544A448.192 448.192 0 0 1 384 274.56zM96 832h832a32 32 0 1 1 0 64H96a32 32 0 1 1 0-64zm32-128h768a384 384 0 1 0-768 0zm447.808-448v-32.32a63.68 63.68 0 0 0-63.68-63.68 64 64 0 0 0-64 63.936V256h127.68z"},null,-1),y2e=[v2e];function b2e(t,e,n,s,r,o){return S(),E("svg",g2e,y2e)}var w2e=ae(m2e,[["render",b2e],["__file","dish-dot.vue"]]),_2e={name:"Dish"},$2e={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},x2e=I("path",{fill:"currentColor",d:"M480 257.152V192h-96a32 32 0 0 1 0-64h256a32 32 0 1 1 0 64h-96v65.152A448 448 0 0 1 955.52 768H68.48A448 448 0 0 1 480 257.152zM128 704h768a384 384 0 1 0-768 0zM96 832h832a32 32 0 1 1 0 64H96a32 32 0 1 1 0-64z"},null,-1),S2e=[x2e];function C2e(t,e,n,s,r,o){return S(),E("svg",$2e,S2e)}var k2e=ae(_2e,[["render",C2e],["__file","dish.vue"]]),T2e={name:"DocumentAdd"},N2e={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},I2e=I("path",{fill:"currentColor",d:"M832 384H576V128H192v768h640V384zm-26.496-64L640 154.496V320h165.504zM160 64h480l256 256v608a32 32 0 0 1-32 32H160a32 32 0 0 1-32-32V96a32 32 0 0 1 32-32zm320 512V448h64v128h128v64H544v128h-64V640H352v-64h128z"},null,-1),E2e=[I2e];function A2e(t,e,n,s,r,o){return S(),E("svg",N2e,E2e)}var O2e=ae(T2e,[["render",A2e],["__file","document-add.vue"]]),R2e={name:"DocumentChecked"},D2e={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},F2e=I("path",{fill:"currentColor",d:"M805.504 320 640 154.496V320h165.504zM832 384H576V128H192v768h640V384zM160 64h480l256 256v608a32 32 0 0 1-32 32H160a32 32 0 0 1-32-32V96a32 32 0 0 1 32-32zm318.4 582.144 180.992-180.992L704.64 510.4 478.4 736.64 320 578.304l45.248-45.312L478.4 646.144z"},null,-1),M2e=[F2e];function P2e(t,e,n,s,r,o){return S(),E("svg",D2e,M2e)}var L2e=ae(R2e,[["render",P2e],["__file","document-checked.vue"]]),z2e={name:"DocumentCopy"},B2e={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},V2e=I("path",{fill:"currentColor",d:"M128 320v576h576V320H128zm-32-64h640a32 32 0 0 1 32 32v640a32 32 0 0 1-32 32H96a32 32 0 0 1-32-32V288a32 32 0 0 1 32-32zM960 96v704a32 32 0 0 1-32 32h-96v-64h64V128H384v64h-64V96a32 32 0 0 1 32-32h576a32 32 0 0 1 32 32zM256 672h320v64H256v-64zm0-192h320v64H256v-64z"},null,-1),H2e=[V2e];function W2e(t,e,n,s,r,o){return S(),E("svg",B2e,H2e)}var U2e=ae(z2e,[["render",W2e],["__file","document-copy.vue"]]),G2e={name:"DocumentDelete"},j2e={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},K2e=I("path",{fill:"currentColor",d:"M805.504 320 640 154.496V320h165.504zM832 384H576V128H192v768h640V384zM160 64h480l256 256v608a32 32 0 0 1-32 32H160a32 32 0 0 1-32-32V96a32 32 0 0 1 32-32zm308.992 546.304-90.496-90.624 45.248-45.248 90.56 90.496 90.496-90.432 45.248 45.248-90.496 90.56 90.496 90.496-45.248 45.248-90.496-90.496-90.56 90.496-45.248-45.248 90.496-90.496z"},null,-1),q2e=[K2e];function X2e(t,e,n,s,r,o){return S(),E("svg",j2e,q2e)}var Y2e=ae(G2e,[["render",X2e],["__file","document-delete.vue"]]),Z2e={name:"DocumentRemove"},J2e={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},Q2e=I("path",{fill:"currentColor",d:"M805.504 320 640 154.496V320h165.504zM832 384H576V128H192v768h640V384zM160 64h480l256 256v608a32 32 0 0 1-32 32H160a32 32 0 0 1-32-32V96a32 32 0 0 1 32-32zm192 512h320v64H352v-64z"},null,-1),eve=[Q2e];function tve(t,e,n,s,r,o){return S(),E("svg",J2e,eve)}var nve=ae(Z2e,[["render",tve],["__file","document-remove.vue"]]),sve={name:"Document"},rve={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},ove=I("path",{fill:"currentColor",d:"M832 384H576V128H192v768h640V384zm-26.496-64L640 154.496V320h165.504zM160 64h480l256 256v608a32 32 0 0 1-32 32H160a32 32 0 0 1-32-32V96a32 32 0 0 1 32-32zm160 448h384v64H320v-64zm0-192h160v64H320v-64zm0 384h384v64H320v-64z"},null,-1),ave=[ove];function ive(t,e,n,s,r,o){return S(),E("svg",rve,ave)}var mP=ae(sve,[["render",ive],["__file","document.vue"]]),lve={name:"Download"},uve={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},cve=I("path",{fill:"currentColor",d:"M160 832h704a32 32 0 1 1 0 64H160a32 32 0 1 1 0-64zm384-253.696 236.288-236.352 45.248 45.248L508.8 704 192 387.2l45.248-45.248L480 584.704V128h64v450.304z"},null,-1),dve=[cve];function fve(t,e,n,s,r,o){return S(),E("svg",uve,dve)}var hve=ae(lve,[["render",fve],["__file","download.vue"]]),pve={name:"Drizzling"},mve={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},gve=I("path",{fill:"currentColor",d:"m739.328 291.328-35.2-6.592-12.8-33.408a192.064 192.064 0 0 0-365.952 23.232l-9.92 40.896-41.472 7.04a176.32 176.32 0 0 0-146.24 173.568c0 97.28 78.72 175.936 175.808 175.936h400a192 192 0 0 0 35.776-380.672zM959.552 480a256 256 0 0 1-256 256h-400A239.808 239.808 0 0 1 63.744 496.192a240.32 240.32 0 0 1 199.488-236.8 256.128 256.128 0 0 1 487.872-30.976A256.064 256.064 0 0 1 959.552 480zM288 800h64v64h-64v-64zm192 0h64v64h-64v-64zm-96 96h64v64h-64v-64zm192 0h64v64h-64v-64zm96-96h64v64h-64v-64z"},null,-1),vve=[gve];function yve(t,e,n,s,r,o){return S(),E("svg",mve,vve)}var bve=ae(pve,[["render",yve],["__file","drizzling.vue"]]),wve={name:"EditPen"},_ve={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},$ve=I("path",{d:"m199.04 672.64 193.984 112 224-387.968-193.92-112-224 388.032zm-23.872 60.16 32.896 148.288 144.896-45.696L175.168 732.8zM455.04 229.248l193.92 112 56.704-98.112-193.984-112-56.64 98.112zM104.32 708.8l384-665.024 304.768 175.936L409.152 884.8h.064l-248.448 78.336L104.32 708.8zm384 254.272v-64h448v64h-448z",fill:"currentColor"},null,-1),xve=[$ve];function Sve(t,e,n,s,r,o){return S(),E("svg",_ve,xve)}var Cve=ae(wve,[["render",Sve],["__file","edit-pen.vue"]]),kve={name:"Edit"},Tve={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},Nve=I("path",{fill:"currentColor",d:"M832 512a32 32 0 1 1 64 0v352a32 32 0 0 1-32 32H160a32 32 0 0 1-32-32V160a32 32 0 0 1 32-32h352a32 32 0 0 1 0 64H192v640h640V512z"},null,-1),Ive=I("path",{fill:"currentColor",d:"m469.952 554.24 52.8-7.552L847.104 222.4a32 32 0 1 0-45.248-45.248L477.44 501.44l-7.552 52.8zm422.4-422.4a96 96 0 0 1 0 135.808l-331.84 331.84a32 32 0 0 1-18.112 9.088L436.8 623.68a32 32 0 0 1-36.224-36.224l15.104-105.6a32 32 0 0 1 9.024-18.112l331.904-331.84a96 96 0 0 1 135.744 0z"},null,-1),Eve=[Nve,Ive];function Ave(t,e,n,s,r,o){return S(),E("svg",Tve,Eve)}var Ove=ae(kve,[["render",Ave],["__file","edit.vue"]]),Rve={name:"ElemeFilled"},Dve={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},Fve=I("path",{fill:"currentColor",d:"M176 64h672c61.824 0 112 50.176 112 112v672a112 112 0 0 1-112 112H176A112 112 0 0 1 64 848V176c0-61.824 50.176-112 112-112zm150.528 173.568c-152.896 99.968-196.544 304.064-97.408 456.96a330.688 330.688 0 0 0 456.96 96.64c9.216-5.888 17.6-11.776 25.152-18.56a18.24 18.24 0 0 0 4.224-24.32L700.352 724.8a47.552 47.552 0 0 0-65.536-14.272A234.56 234.56 0 0 1 310.592 641.6C240 533.248 271.104 387.968 379.456 316.48a234.304 234.304 0 0 1 276.352 15.168c1.664.832 2.56 2.56 3.392 4.224 5.888 8.384 3.328 19.328-5.12 25.216L456.832 489.6a47.552 47.552 0 0 0-14.336 65.472l16 24.384c5.888 8.384 16.768 10.88 25.216 5.056l308.224-199.936a19.584 19.584 0 0 0 6.72-23.488v-.896c-4.992-9.216-10.048-17.6-15.104-26.88-99.968-151.168-304.064-194.88-456.96-95.744zM786.88 504.704l-62.208 40.32c-8.32 5.888-10.88 16.768-4.992 25.216L760 632.32c5.888 8.448 16.768 11.008 25.152 5.12l31.104-20.16a55.36 55.36 0 0 0 16-76.48l-20.224-31.04a19.52 19.52 0 0 0-25.152-5.12z"},null,-1),Mve=[Fve];function Pve(t,e,n,s,r,o){return S(),E("svg",Dve,Mve)}var Lve=ae(Rve,[["render",Pve],["__file","eleme-filled.vue"]]),zve={name:"Eleme"},Bve={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},Vve=I("path",{fill:"currentColor",d:"M300.032 188.8c174.72-113.28 408-63.36 522.24 109.44 5.76 10.56 11.52 20.16 17.28 30.72v.96a22.4 22.4 0 0 1-7.68 26.88l-352.32 228.48c-9.6 6.72-22.08 3.84-28.8-5.76l-18.24-27.84a54.336 54.336 0 0 1 16.32-74.88l225.6-146.88c9.6-6.72 12.48-19.2 5.76-28.8-.96-1.92-1.92-3.84-3.84-4.8a267.84 267.84 0 0 0-315.84-17.28c-123.84 81.6-159.36 247.68-78.72 371.52a268.096 268.096 0 0 0 370.56 78.72 54.336 54.336 0 0 1 74.88 16.32l17.28 26.88c5.76 9.6 3.84 21.12-4.8 27.84-8.64 7.68-18.24 14.4-28.8 21.12a377.92 377.92 0 0 1-522.24-110.4c-113.28-174.72-63.36-408 111.36-522.24zm526.08 305.28a22.336 22.336 0 0 1 28.8 5.76l23.04 35.52a63.232 63.232 0 0 1-18.24 87.36l-35.52 23.04c-9.6 6.72-22.08 3.84-28.8-5.76l-46.08-71.04c-6.72-9.6-3.84-22.08 5.76-28.8l71.04-46.08z"},null,-1),Hve=[Vve];function Wve(t,e,n,s,r,o){return S(),E("svg",Bve,Hve)}var Uve=ae(zve,[["render",Wve],["__file","eleme.vue"]]),Gve={name:"ElementPlus"},jve={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},Kve=I("path",{d:"M839.7 734.7c0 33.3-17.9 41-17.9 41S519.7 949.8 499.2 960c-10.2 5.1-20.5 5.1-30.7 0 0 0-314.9-184.3-325.1-192-5.1-5.1-10.2-12.8-12.8-20.5V368.6c0-17.9 20.5-28.2 20.5-28.2L466 158.6c12.8-5.1 25.6-5.1 38.4 0 0 0 279 161.3 309.8 179.2 17.9 7.7 28.2 25.6 25.6 46.1-.1-5-.1 317.5-.1 350.8zM714.2 371.2c-64-35.8-217.6-125.4-217.6-125.4-7.7-5.1-20.5-5.1-30.7 0L217.6 389.1s-17.9 10.2-17.9 23v297c0 5.1 5.1 12.8 7.7 17.9 7.7 5.1 256 148.5 256 148.5 7.7 5.1 17.9 5.1 25.6 0 15.4-7.7 250.9-145.9 250.9-145.9s12.8-5.1 12.8-30.7v-74.2l-276.5 169v-64c0-17.9 7.7-30.7 20.5-46.1L745 535c5.1-7.7 10.2-20.5 10.2-30.7v-66.6l-279 169v-69.1c0-15.4 5.1-30.7 17.9-38.4l220.1-128zM919 135.7c0-5.1-5.1-7.7-7.7-7.7h-58.9V66.6c0-5.1-5.1-5.1-10.2-5.1l-30.7 5.1c-5.1 0-5.1 2.6-5.1 5.1V128h-56.3c-5.1 0-5.1 5.1-7.7 5.1v38.4h69.1v64c0 5.1 5.1 5.1 10.2 5.1l30.7-5.1c5.1 0 5.1-2.6 5.1-5.1v-56.3h64l-2.5-38.4z",fill:"currentColor"},null,-1),qve=[Kve];function Xve(t,e,n,s,r,o){return S(),E("svg",jve,qve)}var Yve=ae(Gve,[["render",Xve],["__file","element-plus.vue"]]),Zve={name:"Expand"},Jve={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},Qve=I("path",{fill:"currentColor",d:"M128 192h768v128H128V192zm0 256h512v128H128V448zm0 256h768v128H128V704zm576-352 192 160-192 128V352z"},null,-1),eye=[Qve];function tye(t,e,n,s,r,o){return S(),E("svg",Jve,eye)}var nye=ae(Zve,[["render",tye],["__file","expand.vue"]]),sye={name:"Failed"},rye={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},oye=I("path",{fill:"currentColor",d:"m557.248 608 135.744-135.744-45.248-45.248-135.68 135.744-135.808-135.68-45.248 45.184L466.752 608l-135.68 135.68 45.184 45.312L512 653.248l135.744 135.744 45.248-45.248L557.312 608zM704 192h160v736H160V192h160v64h384v-64zm-320 0V96h256v96H384z"},null,-1),aye=[oye];function iye(t,e,n,s,r,o){return S(),E("svg",rye,aye)}var lye=ae(sye,[["render",iye],["__file","failed.vue"]]),uye={name:"Female"},cye={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},dye=I("path",{fill:"currentColor",d:"M512 640a256 256 0 1 0 0-512 256 256 0 0 0 0 512zm0 64a320 320 0 1 1 0-640 320 320 0 0 1 0 640z"},null,-1),fye=I("path",{fill:"currentColor",d:"M512 640q32 0 32 32v256q0 32-32 32t-32-32V672q0-32 32-32z"},null,-1),hye=I("path",{fill:"currentColor",d:"M352 800h320q32 0 32 32t-32 32H352q-32 0-32-32t32-32z"},null,-1),pye=[dye,fye,hye];function mye(t,e,n,s,r,o){return S(),E("svg",cye,pye)}var gye=ae(uye,[["render",mye],["__file","female.vue"]]),vye={name:"Files"},yye={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},bye=I("path",{fill:"currentColor",d:"M128 384v448h768V384H128zm-32-64h832a32 32 0 0 1 32 32v512a32 32 0 0 1-32 32H96a32 32 0 0 1-32-32V352a32 32 0 0 1 32-32zm64-128h704v64H160zm96-128h512v64H256z"},null,-1),wye=[bye];function _ye(t,e,n,s,r,o){return S(),E("svg",yye,wye)}var $ye=ae(vye,[["render",_ye],["__file","files.vue"]]),xye={name:"Film"},Sye={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},Cye=I("path",{fill:"currentColor",d:"M160 160v704h704V160H160zm-32-64h768a32 32 0 0 1 32 32v768a32 32 0 0 1-32 32H128a32 32 0 0 1-32-32V128a32 32 0 0 1 32-32z"},null,-1),kye=I("path",{fill:"currentColor",d:"M320 288V128h64v352h256V128h64v160h160v64H704v128h160v64H704v128h160v64H704v160h-64V544H384v352h-64V736H128v-64h192V544H128v-64h192V352H128v-64h192z"},null,-1),Tye=[Cye,kye];function Nye(t,e,n,s,r,o){return S(),E("svg",Sye,Tye)}var Iye=ae(xye,[["render",Nye],["__file","film.vue"]]),Eye={name:"Filter"},Aye={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},Oye=I("path",{fill:"currentColor",d:"M384 523.392V928a32 32 0 0 0 46.336 28.608l192-96A32 32 0 0 0 640 832V523.392l280.768-343.104a32 32 0 1 0-49.536-40.576l-288 352A32 32 0 0 0 576 512v300.224l-128 64V512a32 32 0 0 0-7.232-20.288L195.52 192H704a32 32 0 1 0 0-64H128a32 32 0 0 0-24.768 52.288L384 523.392z"},null,-1),Rye=[Oye];function Dye(t,e,n,s,r,o){return S(),E("svg",Aye,Rye)}var Fye=ae(Eye,[["render",Dye],["__file","filter.vue"]]),Mye={name:"Finished"},Pye={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},Lye=I("path",{fill:"currentColor",d:"M280.768 753.728 691.456 167.04a32 32 0 1 1 52.416 36.672L314.24 817.472a32 32 0 0 1-45.44 7.296l-230.4-172.8a32 32 0 0 1 38.4-51.2l203.968 152.96zM736 448a32 32 0 1 1 0-64h192a32 32 0 1 1 0 64H736zM608 640a32 32 0 0 1 0-64h319.936a32 32 0 1 1 0 64H608zM480 832a32 32 0 1 1 0-64h447.936a32 32 0 1 1 0 64H480z"},null,-1),zye=[Lye];function Bye(t,e,n,s,r,o){return S(),E("svg",Pye,zye)}var Vye=ae(Mye,[["render",Bye],["__file","finished.vue"]]),Hye={name:"FirstAidKit"},Wye={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},Uye=I("path",{fill:"currentColor",d:"M192 256a64 64 0 0 0-64 64v448a64 64 0 0 0 64 64h640a64 64 0 0 0 64-64V320a64 64 0 0 0-64-64H192zm0-64h640a128 128 0 0 1 128 128v448a128 128 0 0 1-128 128H192A128 128 0 0 1 64 768V320a128 128 0 0 1 128-128z"},null,-1),Gye=I("path",{fill:"currentColor",d:"M544 512h96a32 32 0 0 1 0 64h-96v96a32 32 0 0 1-64 0v-96h-96a32 32 0 0 1 0-64h96v-96a32 32 0 0 1 64 0v96zM352 128v64h320v-64H352zm-32-64h384a32 32 0 0 1 32 32v128a32 32 0 0 1-32 32H320a32 32 0 0 1-32-32V96a32 32 0 0 1 32-32z"},null,-1),jye=[Uye,Gye];function Kye(t,e,n,s,r,o){return S(),E("svg",Wye,jye)}var qye=ae(Hye,[["render",Kye],["__file","first-aid-kit.vue"]]),Xye={name:"Flag"},Yye={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},Zye=I("path",{fill:"currentColor",d:"M288 128h608L736 384l160 256H288v320h-96V64h96v64z"},null,-1),Jye=[Zye];function Qye(t,e,n,s,r,o){return S(),E("svg",Yye,Jye)}var ebe=ae(Xye,[["render",Qye],["__file","flag.vue"]]),tbe={name:"Fold"},nbe={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},sbe=I("path",{fill:"currentColor",d:"M896 192H128v128h768V192zm0 256H384v128h512V448zm0 256H128v128h768V704zM320 384 128 512l192 128V384z"},null,-1),rbe=[sbe];function obe(t,e,n,s,r,o){return S(),E("svg",nbe,rbe)}var abe=ae(tbe,[["render",obe],["__file","fold.vue"]]),ibe={name:"FolderAdd"},lbe={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},ube=I("path",{fill:"currentColor",d:"M128 192v640h768V320H485.76L357.504 192H128zm-32-64h287.872l128.384 128H928a32 32 0 0 1 32 32v576a32 32 0 0 1-32 32H96a32 32 0 0 1-32-32V160a32 32 0 0 1 32-32zm384 416V416h64v128h128v64H544v128h-64V608H352v-64h128z"},null,-1),cbe=[ube];function dbe(t,e,n,s,r,o){return S(),E("svg",lbe,cbe)}var fbe=ae(ibe,[["render",dbe],["__file","folder-add.vue"]]),hbe={name:"FolderChecked"},pbe={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},mbe=I("path",{fill:"currentColor",d:"M128 192v640h768V320H485.76L357.504 192H128zm-32-64h287.872l128.384 128H928a32 32 0 0 1 32 32v576a32 32 0 0 1-32 32H96a32 32 0 0 1-32-32V160a32 32 0 0 1 32-32zm414.08 502.144 180.992-180.992L736.32 494.4 510.08 720.64l-158.4-158.336 45.248-45.312L510.08 630.144z"},null,-1),gbe=[mbe];function vbe(t,e,n,s,r,o){return S(),E("svg",pbe,gbe)}var ybe=ae(hbe,[["render",vbe],["__file","folder-checked.vue"]]),bbe={name:"FolderDelete"},wbe={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},_be=I("path",{fill:"currentColor",d:"M128 192v640h768V320H485.76L357.504 192H128zm-32-64h287.872l128.384 128H928a32 32 0 0 1 32 32v576a32 32 0 0 1-32 32H96a32 32 0 0 1-32-32V160a32 32 0 0 1 32-32zm370.752 448-90.496-90.496 45.248-45.248L512 530.752l90.496-90.496 45.248 45.248L557.248 576l90.496 90.496-45.248 45.248L512 621.248l-90.496 90.496-45.248-45.248L466.752 576z"},null,-1),$be=[_be];function xbe(t,e,n,s,r,o){return S(),E("svg",wbe,$be)}var Sbe=ae(bbe,[["render",xbe],["__file","folder-delete.vue"]]),Cbe={name:"FolderOpened"},kbe={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},Tbe=I("path",{fill:"currentColor",d:"M878.08 448H241.92l-96 384h636.16l96-384zM832 384v-64H485.76L357.504 192H128v448l57.92-231.744A32 32 0 0 1 216.96 384H832zm-24.96 512H96a32 32 0 0 1-32-32V160a32 32 0 0 1 32-32h287.872l128.384 128H864a32 32 0 0 1 32 32v96h23.04a32 32 0 0 1 31.04 39.744l-112 448A32 32 0 0 1 807.04 896z"},null,-1),Nbe=[Tbe];function Ibe(t,e,n,s,r,o){return S(),E("svg",kbe,Nbe)}var Ebe=ae(Cbe,[["render",Ibe],["__file","folder-opened.vue"]]),Abe={name:"FolderRemove"},Obe={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},Rbe=I("path",{fill:"currentColor",d:"M128 192v640h768V320H485.76L357.504 192H128zm-32-64h287.872l128.384 128H928a32 32 0 0 1 32 32v576a32 32 0 0 1-32 32H96a32 32 0 0 1-32-32V160a32 32 0 0 1 32-32zm256 416h320v64H352v-64z"},null,-1),Dbe=[Rbe];function Fbe(t,e,n,s,r,o){return S(),E("svg",Obe,Dbe)}var Mbe=ae(Abe,[["render",Fbe],["__file","folder-remove.vue"]]),Pbe={name:"Folder"},Lbe={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},zbe=I("path",{fill:"currentColor",d:"M128 192v640h768V320H485.76L357.504 192H128zm-32-64h287.872l128.384 128H928a32 32 0 0 1 32 32v576a32 32 0 0 1-32 32H96a32 32 0 0 1-32-32V160a32 32 0 0 1 32-32z"},null,-1),Bbe=[zbe];function Vbe(t,e,n,s,r,o){return S(),E("svg",Lbe,Bbe)}var Hbe=ae(Pbe,[["render",Vbe],["__file","folder.vue"]]),Wbe={name:"Food"},Ube={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},Gbe=I("path",{fill:"currentColor",d:"M128 352.576V352a288 288 0 0 1 491.072-204.224 192 192 0 0 1 274.24 204.48 64 64 0 0 1 57.216 74.24C921.6 600.512 850.048 710.656 736 756.992V800a96 96 0 0 1-96 96H384a96 96 0 0 1-96-96v-43.008c-114.048-46.336-185.6-156.48-214.528-330.496A64 64 0 0 1 128 352.64zm64-.576h64a160 160 0 0 1 320 0h64a224 224 0 0 0-448 0zm128 0h192a96 96 0 0 0-192 0zm439.424 0h68.544A128.256 128.256 0 0 0 704 192c-15.36 0-29.952 2.688-43.52 7.616 11.328 18.176 20.672 37.76 27.84 58.304A64.128 64.128 0 0 1 759.424 352zM672 768H352v32a32 32 0 0 0 32 32h256a32 32 0 0 0 32-32v-32zm-342.528-64h365.056c101.504-32.64 165.76-124.928 192.896-288H136.576c27.136 163.072 91.392 255.36 192.896 288z"},null,-1),jbe=[Gbe];function Kbe(t,e,n,s,r,o){return S(),E("svg",Ube,jbe)}var qbe=ae(Wbe,[["render",Kbe],["__file","food.vue"]]),Xbe={name:"Football"},Ybe={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},Zbe=I("path",{fill:"currentColor",d:"M512 960a448 448 0 1 1 0-896 448 448 0 0 1 0 896zm0-64a384 384 0 1 0 0-768 384 384 0 0 0 0 768z"},null,-1),Jbe=I("path",{fill:"currentColor",d:"M186.816 268.288c16-16.384 31.616-31.744 46.976-46.08 17.472 30.656 39.808 58.112 65.984 81.28l-32.512 56.448a385.984 385.984 0 0 1-80.448-91.648zm653.696-5.312a385.92 385.92 0 0 1-83.776 96.96l-32.512-56.384a322.923 322.923 0 0 0 68.48-85.76c15.552 14.08 31.488 29.12 47.808 45.184zM465.984 445.248l11.136-63.104a323.584 323.584 0 0 0 69.76 0l11.136 63.104a387.968 387.968 0 0 1-92.032 0zm-62.72-12.8A381.824 381.824 0 0 1 320 396.544l32-55.424a319.885 319.885 0 0 0 62.464 27.712l-11.2 63.488zm300.8-35.84a381.824 381.824 0 0 1-83.328 35.84l-11.2-63.552A319.885 319.885 0 0 0 672 341.184l32 55.424zm-520.768 364.8a385.92 385.92 0 0 1 83.968-97.28l32.512 56.32c-26.88 23.936-49.856 52.352-67.52 84.032-16-13.44-32.32-27.712-48.96-43.072zm657.536.128a1442.759 1442.759 0 0 1-49.024 43.072 321.408 321.408 0 0 0-67.584-84.16l32.512-56.32c33.216 27.456 61.696 60.352 84.096 97.408zM465.92 578.752a387.968 387.968 0 0 1 92.032 0l-11.136 63.104a323.584 323.584 0 0 0-69.76 0l-11.136-63.104zm-62.72 12.8 11.2 63.552a319.885 319.885 0 0 0-62.464 27.712L320 627.392a381.824 381.824 0 0 1 83.264-35.84zm300.8 35.84-32 55.424a318.272 318.272 0 0 0-62.528-27.712l11.2-63.488c29.44 8.64 57.28 20.736 83.264 35.776z"},null,-1),Qbe=[Zbe,Jbe];function ewe(t,e,n,s,r,o){return S(),E("svg",Ybe,Qbe)}var twe=ae(Xbe,[["render",ewe],["__file","football.vue"]]),nwe={name:"ForkSpoon"},swe={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},rwe=I("path",{fill:"currentColor",d:"M256 410.304V96a32 32 0 0 1 64 0v314.304a96 96 0 0 0 64-90.56V96a32 32 0 0 1 64 0v223.744a160 160 0 0 1-128 156.8V928a32 32 0 1 1-64 0V476.544a160 160 0 0 1-128-156.8V96a32 32 0 0 1 64 0v223.744a96 96 0 0 0 64 90.56zM672 572.48C581.184 552.128 512 446.848 512 320c0-141.44 85.952-256 192-256s192 114.56 192 256c0 126.848-69.184 232.128-160 252.48V928a32 32 0 1 1-64 0V572.48zM704 512c66.048 0 128-82.56 128-192s-61.952-192-128-192-128 82.56-128 192 61.952 192 128 192z"},null,-1),owe=[rwe];function awe(t,e,n,s,r,o){return S(),E("svg",swe,owe)}var iwe=ae(nwe,[["render",awe],["__file","fork-spoon.vue"]]),lwe={name:"Fries"},uwe={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},cwe=I("path",{fill:"currentColor",d:"M608 224v-64a32 32 0 0 0-64 0v336h26.88A64 64 0 0 0 608 484.096V224zm101.12 160A64 64 0 0 0 672 395.904V384h64V224a32 32 0 1 0-64 0v160h37.12zm74.88 0a92.928 92.928 0 0 1 91.328 110.08l-60.672 323.584A96 96 0 0 1 720.32 896H303.68a96 96 0 0 1-94.336-78.336L148.672 494.08A92.928 92.928 0 0 1 240 384h-16V224a96 96 0 0 1 188.608-25.28A95.744 95.744 0 0 1 480 197.44V160a96 96 0 0 1 188.608-25.28A96 96 0 0 1 800 224v160h-16zM670.784 512a128 128 0 0 1-99.904 48H453.12a128 128 0 0 1-99.84-48H352v-1.536a128.128 128.128 0 0 1-9.984-14.976L314.88 448H240a28.928 28.928 0 0 0-28.48 34.304L241.088 640h541.824l29.568-157.696A28.928 28.928 0 0 0 784 448h-74.88l-27.136 47.488A132.405 132.405 0 0 1 672 510.464V512h-1.216zM480 288a32 32 0 0 0-64 0v196.096A64 64 0 0 0 453.12 496H480V288zm-128 96V224a32 32 0 0 0-64 0v160h64-37.12A64 64 0 0 1 352 395.904zm-98.88 320 19.072 101.888A32 32 0 0 0 303.68 832h416.64a32 32 0 0 0 31.488-26.112L770.88 704H253.12z"},null,-1),dwe=[cwe];function fwe(t,e,n,s,r,o){return S(),E("svg",uwe,dwe)}var hwe=ae(lwe,[["render",fwe],["__file","fries.vue"]]),pwe={name:"FullScreen"},mwe={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},gwe=I("path",{fill:"currentColor",d:"m160 96.064 192 .192a32 32 0 0 1 0 64l-192-.192V352a32 32 0 0 1-64 0V96h64v.064zm0 831.872V928H96V672a32 32 0 1 1 64 0v191.936l192-.192a32 32 0 1 1 0 64l-192 .192zM864 96.064V96h64v256a32 32 0 1 1-64 0V160.064l-192 .192a32 32 0 1 1 0-64l192-.192zm0 831.872-192-.192a32 32 0 0 1 0-64l192 .192V672a32 32 0 1 1 64 0v256h-64v-.064z"},null,-1),vwe=[gwe];function ywe(t,e,n,s,r,o){return S(),E("svg",mwe,vwe)}var gP=ae(pwe,[["render",ywe],["__file","full-screen.vue"]]),bwe={name:"GobletFull"},wwe={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},_we=I("path",{fill:"currentColor",d:"M256 320h512c0-78.592-12.608-142.4-36.928-192h-434.24C269.504 192.384 256 256.256 256 320zm503.936 64H264.064a256.128 256.128 0 0 0 495.872 0zM544 638.4V896h96a32 32 0 1 1 0 64H384a32 32 0 1 1 0-64h96V638.4A320 320 0 0 1 192 320c0-85.632 21.312-170.944 64-256h512c42.688 64.32 64 149.632 64 256a320 320 0 0 1-288 318.4z"},null,-1),$we=[_we];function xwe(t,e,n,s,r,o){return S(),E("svg",wwe,$we)}var Swe=ae(bwe,[["render",xwe],["__file","goblet-full.vue"]]),Cwe={name:"GobletSquareFull"},kwe={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},Twe=I("path",{fill:"currentColor",d:"M256 270.912c10.048 6.72 22.464 14.912 28.992 18.624a220.16 220.16 0 0 0 114.752 30.72c30.592 0 49.408-9.472 91.072-41.152l.64-.448c52.928-40.32 82.368-55.04 132.288-54.656 55.552.448 99.584 20.8 142.72 57.408l1.536 1.28V128H256v142.912zm.96 76.288C266.368 482.176 346.88 575.872 512 576c157.44.064 237.952-85.056 253.248-209.984a952.32 952.32 0 0 1-40.192-35.712c-32.704-27.776-63.36-41.92-101.888-42.24-31.552-.256-50.624 9.28-93.12 41.6l-.576.448c-52.096 39.616-81.024 54.208-129.792 54.208-54.784 0-100.48-13.376-142.784-37.056zM480 638.848C250.624 623.424 192 442.496 192 319.68V96a32 32 0 0 1 32-32h576a32 32 0 0 1 32 32v224c0 122.816-58.624 303.68-288 318.912V896h96a32 32 0 1 1 0 64H384a32 32 0 1 1 0-64h96V638.848z"},null,-1),Nwe=[Twe];function Iwe(t,e,n,s,r,o){return S(),E("svg",kwe,Nwe)}var Ewe=ae(Cwe,[["render",Iwe],["__file","goblet-square-full.vue"]]),Awe={name:"GobletSquare"},Owe={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},Rwe=I("path",{fill:"currentColor",d:"M544 638.912V896h96a32 32 0 1 1 0 64H384a32 32 0 1 1 0-64h96V638.848C250.624 623.424 192 442.496 192 319.68V96a32 32 0 0 1 32-32h576a32 32 0 0 1 32 32v224c0 122.816-58.624 303.68-288 318.912zM256 319.68c0 149.568 80 256.192 256 256.256C688.128 576 768 469.568 768 320V128H256v191.68z"},null,-1),Dwe=[Rwe];function Fwe(t,e,n,s,r,o){return S(),E("svg",Owe,Dwe)}var Mwe=ae(Awe,[["render",Fwe],["__file","goblet-square.vue"]]),Pwe={name:"Goblet"},Lwe={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},zwe=I("path",{fill:"currentColor",d:"M544 638.4V896h96a32 32 0 1 1 0 64H384a32 32 0 1 1 0-64h96V638.4A320 320 0 0 1 192 320c0-85.632 21.312-170.944 64-256h512c42.688 64.32 64 149.632 64 256a320 320 0 0 1-288 318.4zM256 320a256 256 0 1 0 512 0c0-78.592-12.608-142.4-36.928-192h-434.24C269.504 192.384 256 256.256 256 320z"},null,-1),Bwe=[zwe];function Vwe(t,e,n,s,r,o){return S(),E("svg",Lwe,Bwe)}var Hwe=ae(Pwe,[["render",Vwe],["__file","goblet.vue"]]),Wwe={name:"GoldMedal"},Uwe={xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 1024 1024",style:{"enable-background":"new 0 0 1024 1024"},"xml:space":"preserve"},Gwe=I("path",{d:"m772.13 452.84 53.86-351.81c1.32-10.01-1.17-18.68-7.49-26.02S804.35 64 795.01 64H228.99v-.01h-.06c-9.33 0-17.15 3.67-23.49 11.01s-8.83 16.01-7.49 26.02l53.87 351.89C213.54 505.73 193.59 568.09 192 640c2 90.67 33.17 166.17 93.5 226.5S421.33 957.99 512 960c90.67-2 166.17-33.17 226.5-93.5 60.33-60.34 91.49-135.83 93.5-226.5-1.59-71.94-21.56-134.32-59.87-187.16zM640.01 128h117.02l-39.01 254.02c-20.75-10.64-40.74-19.73-59.94-27.28-5.92-3-11.95-5.8-18.08-8.41V128h.01zM576 128v198.76c-13.18-2.58-26.74-4.43-40.67-5.55-8.07-.8-15.85-1.2-23.33-1.2-10.54 0-21.09.66-31.64 1.96a359.844 359.844 0 0 0-32.36 4.79V128h128zm-192 0h.04v218.3c-6.22 2.66-12.34 5.5-18.36 8.56-19.13 7.54-39.02 16.6-59.66 27.16L267.01 128H384zm308.99 692.99c-48 48-108.33 73-180.99 75.01-72.66-2.01-132.99-27.01-180.99-75.01S258.01 712.66 256 640c2.01-72.66 27.01-132.99 75.01-180.99 19.67-19.67 41.41-35.47 65.22-47.41 38.33-15.04 71.15-23.92 98.44-26.65 5.07-.41 10.2-.7 15.39-.88.63-.01 1.28-.03 1.91-.03.66 0 1.35.03 2.02.04 5.11.17 10.15.46 15.13.86 27.4 2.71 60.37 11.65 98.91 26.79 23.71 11.93 45.36 27.69 64.96 47.29 48 48 73 108.33 75.01 180.99-2.01 72.65-27.01 132.98-75.01 180.98z",fill:"currentColor"},null,-1),jwe=I("path",{d:"M544 480H416v64h64v192h-64v64h192v-64h-64z",fill:"currentColor"},null,-1),Kwe=[Gwe,jwe];function qwe(t,e,n,s,r,o){return S(),E("svg",Uwe,Kwe)}var Xwe=ae(Wwe,[["render",qwe],["__file","gold-medal.vue"]]),Ywe={name:"GoodsFilled"},Zwe={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},Jwe=I("path",{fill:"currentColor",d:"M192 352h640l64 544H128l64-544zm128 224h64V448h-64v128zm320 0h64V448h-64v128zM384 288h-64a192 192 0 1 1 384 0h-64a128 128 0 1 0-256 0z"},null,-1),Qwe=[Jwe];function e_e(t,e,n,s,r,o){return S(),E("svg",Zwe,Qwe)}var t_e=ae(Ywe,[["render",e_e],["__file","goods-filled.vue"]]),n_e={name:"Goods"},s_e={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},r_e=I("path",{fill:"currentColor",d:"M320 288v-22.336C320 154.688 405.504 64 512 64s192 90.688 192 201.664v22.4h131.072a32 32 0 0 1 31.808 28.8l57.6 576a32 32 0 0 1-31.808 35.2H131.328a32 32 0 0 1-31.808-35.2l57.6-576a32 32 0 0 1 31.808-28.8H320zm64 0h256v-22.336C640 189.248 582.272 128 512 128c-70.272 0-128 61.248-128 137.664v22.4zm-64 64H217.92l-51.2 512h690.56l-51.264-512H704v96a32 32 0 1 1-64 0v-96H384v96a32 32 0 0 1-64 0v-96z"},null,-1),o_e=[r_e];function a_e(t,e,n,s,r,o){return S(),E("svg",s_e,o_e)}var i_e=ae(n_e,[["render",a_e],["__file","goods.vue"]]),l_e={name:"Grape"},u_e={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},c_e=I("path",{fill:"currentColor",d:"M544 195.2a160 160 0 0 1 96 60.8 160 160 0 1 1 146.24 254.976 160 160 0 0 1-128 224 160 160 0 1 1-292.48 0 160 160 0 0 1-128-224A160 160 0 1 1 384 256a160 160 0 0 1 96-60.8V128h-64a32 32 0 0 1 0-64h192a32 32 0 0 1 0 64h-64v67.2zM512 448a96 96 0 1 0 0-192 96 96 0 0 0 0 192zm-256 0a96 96 0 1 0 0-192 96 96 0 0 0 0 192zm128 224a96 96 0 1 0 0-192 96 96 0 0 0 0 192zm128 224a96 96 0 1 0 0-192 96 96 0 0 0 0 192zm128-224a96 96 0 1 0 0-192 96 96 0 0 0 0 192zm128-224a96 96 0 1 0 0-192 96 96 0 0 0 0 192z"},null,-1),d_e=[c_e];function f_e(t,e,n,s,r,o){return S(),E("svg",u_e,d_e)}var h_e=ae(l_e,[["render",f_e],["__file","grape.vue"]]),p_e={name:"Grid"},m_e={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},g_e=I("path",{fill:"currentColor",d:"M640 384v256H384V384h256zm64 0h192v256H704V384zm-64 512H384V704h256v192zm64 0V704h192v192H704zm-64-768v192H384V128h256zm64 0h192v192H704V128zM320 384v256H128V384h192zm0 512H128V704h192v192zm0-768v192H128V128h192z"},null,-1),v_e=[g_e];function y_e(t,e,n,s,r,o){return S(),E("svg",m_e,v_e)}var b_e=ae(p_e,[["render",y_e],["__file","grid.vue"]]),w_e={name:"Guide"},__e={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},$_e=I("path",{fill:"currentColor",d:"M640 608h-64V416h64v192zm0 160v160a32 32 0 0 1-32 32H416a32 32 0 0 1-32-32V768h64v128h128V768h64zM384 608V416h64v192h-64zm256-352h-64V128H448v128h-64V96a32 32 0 0 1 32-32h192a32 32 0 0 1 32 32v160z"},null,-1),x_e=I("path",{fill:"currentColor",d:"m220.8 256-71.232 80 71.168 80H768V256H220.8zm-14.4-64H800a32 32 0 0 1 32 32v224a32 32 0 0 1-32 32H206.4a32 32 0 0 1-23.936-10.752l-99.584-112a32 32 0 0 1 0-42.496l99.584-112A32 32 0 0 1 206.4 192zm678.784 496-71.104 80H266.816V608h547.2l71.168 80zm-56.768-144H234.88a32 32 0 0 0-32 32v224a32 32 0 0 0 32 32h593.6a32 32 0 0 0 23.936-10.752l99.584-112a32 32 0 0 0 0-42.496l-99.584-112A32 32 0 0 0 828.48 544z"},null,-1),S_e=[$_e,x_e];function C_e(t,e,n,s,r,o){return S(),E("svg",__e,S_e)}var k_e=ae(w_e,[["render",C_e],["__file","guide.vue"]]),T_e={name:"Handbag"},N_e={xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 1024 1024",style:{"enable-background":"new 0 0 1024 1024"},"xml:space":"preserve"},I_e=I("path",{d:"M887.01 264.99c-6-5.99-13.67-8.99-23.01-8.99H704c-1.34-54.68-20.01-100.01-56-136s-81.32-54.66-136-56c-54.68 1.34-100.01 20.01-136 56s-54.66 81.32-56 136H160c-9.35 0-17.02 3-23.01 8.99-5.99 6-8.99 13.67-8.99 23.01v640c0 9.35 2.99 17.02 8.99 23.01S150.66 960 160 960h704c9.35 0 17.02-2.99 23.01-8.99S896 937.34 896 928V288c0-9.35-2.99-17.02-8.99-23.01zM421.5 165.5c24.32-24.34 54.49-36.84 90.5-37.5 35.99.68 66.16 13.18 90.5 37.5s36.84 54.49 37.5 90.5H384c.68-35.99 13.18-66.16 37.5-90.5zM832 896H192V320h128v128h64V320h256v128h64V320h128v576z",fill:"currentColor"},null,-1),E_e=[I_e];function A_e(t,e,n,s,r,o){return S(),E("svg",N_e,E_e)}var O_e=ae(T_e,[["render",A_e],["__file","handbag.vue"]]),R_e={name:"Headset"},D_e={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},F_e=I("path",{fill:"currentColor",d:"M896 529.152V512a384 384 0 1 0-768 0v17.152A128 128 0 0 1 320 640v128a128 128 0 1 1-256 0V512a448 448 0 1 1 896 0v256a128 128 0 1 1-256 0V640a128 128 0 0 1 192-110.848zM896 640a64 64 0 0 0-128 0v128a64 64 0 0 0 128 0V640zm-768 0v128a64 64 0 0 0 128 0V640a64 64 0 1 0-128 0z"},null,-1),M_e=[F_e];function P_e(t,e,n,s,r,o){return S(),E("svg",D_e,M_e)}var L_e=ae(R_e,[["render",P_e],["__file","headset.vue"]]),z_e={name:"HelpFilled"},B_e={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},V_e=I("path",{fill:"currentColor",d:"M926.784 480H701.312A192.512 192.512 0 0 0 544 322.688V97.216A416.064 416.064 0 0 1 926.784 480zm0 64A416.064 416.064 0 0 1 544 926.784V701.312A192.512 192.512 0 0 0 701.312 544h225.472zM97.28 544h225.472A192.512 192.512 0 0 0 480 701.312v225.472A416.064 416.064 0 0 1 97.216 544zm0-64A416.064 416.064 0 0 1 480 97.216v225.472A192.512 192.512 0 0 0 322.688 480H97.216z"},null,-1),H_e=[V_e];function W_e(t,e,n,s,r,o){return S(),E("svg",B_e,H_e)}var U_e=ae(z_e,[["render",W_e],["__file","help-filled.vue"]]),G_e={name:"Help"},j_e={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},K_e=I("path",{fill:"currentColor",d:"m759.936 805.248-90.944-91.008A254.912 254.912 0 0 1 512 768a254.912 254.912 0 0 1-156.992-53.76l-90.944 91.008A382.464 382.464 0 0 0 512 896c94.528 0 181.12-34.176 247.936-90.752zm45.312-45.312A382.464 382.464 0 0 0 896 512c0-94.528-34.176-181.12-90.752-247.936l-91.008 90.944C747.904 398.4 768 452.864 768 512c0 59.136-20.096 113.6-53.76 156.992l91.008 90.944zm-45.312-541.184A382.464 382.464 0 0 0 512 128c-94.528 0-181.12 34.176-247.936 90.752l90.944 91.008A254.912 254.912 0 0 1 512 256c59.136 0 113.6 20.096 156.992 53.76l90.944-91.008zm-541.184 45.312A382.464 382.464 0 0 0 128 512c0 94.528 34.176 181.12 90.752 247.936l91.008-90.944A254.912 254.912 0 0 1 256 512c0-59.136 20.096-113.6 53.76-156.992l-91.008-90.944zm417.28 394.496a194.56 194.56 0 0 0 22.528-22.528C686.912 602.56 704 559.232 704 512a191.232 191.232 0 0 0-67.968-146.56A191.296 191.296 0 0 0 512 320a191.232 191.232 0 0 0-146.56 67.968C337.088 421.44 320 464.768 320 512a191.232 191.232 0 0 0 67.968 146.56C421.44 686.912 464.768 704 512 704c47.296 0 90.56-17.088 124.032-45.44zM512 960a448 448 0 1 1 0-896 448 448 0 0 1 0 896z"},null,-1),q_e=[K_e];function X_e(t,e,n,s,r,o){return S(),E("svg",j_e,q_e)}var Y_e=ae(G_e,[["render",X_e],["__file","help.vue"]]),Z_e={name:"Hide"},J_e={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},Q_e=I("path",{d:"M876.8 156.8c0-9.6-3.2-16-9.6-22.4-6.4-6.4-12.8-9.6-22.4-9.6-9.6 0-16 3.2-22.4 9.6L736 220.8c-64-32-137.6-51.2-224-60.8-160 16-288 73.6-377.6 176C44.8 438.4 0 496 0 512s48 73.6 134.4 176c22.4 25.6 44.8 48 73.6 67.2l-86.4 89.6c-6.4 6.4-9.6 12.8-9.6 22.4 0 9.6 3.2 16 9.6 22.4 6.4 6.4 12.8 9.6 22.4 9.6 9.6 0 16-3.2 22.4-9.6l704-710.4c3.2-6.4 6.4-12.8 6.4-22.4Zm-646.4 528c-76.8-70.4-128-128-153.6-172.8 28.8-48 80-105.6 153.6-172.8C304 272 400 230.4 512 224c64 3.2 124.8 19.2 176 44.8l-54.4 54.4C598.4 300.8 560 288 512 288c-64 0-115.2 22.4-160 64s-64 96-64 160c0 48 12.8 89.6 35.2 124.8L256 707.2c-9.6-6.4-19.2-16-25.6-22.4Zm140.8-96c-12.8-22.4-19.2-48-19.2-76.8 0-44.8 16-83.2 48-112 32-28.8 67.2-48 112-48 28.8 0 54.4 6.4 73.6 19.2L371.2 588.8ZM889.599 336c-12.8-16-28.8-28.8-41.6-41.6l-48 48c73.6 67.2 124.8 124.8 150.4 169.6-28.8 48-80 105.6-153.6 172.8-73.6 67.2-172.8 108.8-284.8 115.2-51.2-3.2-99.2-12.8-140.8-28.8l-48 48c57.6 22.4 118.4 38.4 188.8 44.8 160-16 288-73.6 377.6-176C979.199 585.6 1024 528 1024 512s-48.001-73.6-134.401-176Z",fill:"currentColor"},null,-1),e3e=I("path",{d:"M511.998 672c-12.8 0-25.6-3.2-38.4-6.4l-51.2 51.2c28.8 12.8 57.6 19.2 89.6 19.2 64 0 115.2-22.4 160-64 41.6-41.6 64-96 64-160 0-32-6.4-64-19.2-89.6l-51.2 51.2c3.2 12.8 6.4 25.6 6.4 38.4 0 44.8-16 83.2-48 112-32 28.8-67.2 48-112 48Z",fill:"currentColor"},null,-1),t3e=[Q_e,e3e];function n3e(t,e,n,s,r,o){return S(),E("svg",J_e,t3e)}var vP=ae(Z_e,[["render",n3e],["__file","hide.vue"]]),s3e={name:"Histogram"},r3e={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},o3e=I("path",{fill:"currentColor",d:"M416 896V128h192v768H416zm-288 0V448h192v448H128zm576 0V320h192v576H704z"},null,-1),a3e=[o3e];function i3e(t,e,n,s,r,o){return S(),E("svg",r3e,a3e)}var l3e=ae(s3e,[["render",i3e],["__file","histogram.vue"]]),u3e={name:"HomeFilled"},c3e={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},d3e=I("path",{fill:"currentColor",d:"M512 128 128 447.936V896h255.936V640H640v256h255.936V447.936z"},null,-1),f3e=[d3e];function h3e(t,e,n,s,r,o){return S(),E("svg",c3e,f3e)}var p3e=ae(u3e,[["render",h3e],["__file","home-filled.vue"]]),m3e={name:"HotWater"},g3e={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},v3e=I("path",{fill:"currentColor",d:"M273.067 477.867h477.866V409.6H273.067v68.267zm0 68.266v51.2A187.733 187.733 0 0 0 460.8 785.067h102.4a187.733 187.733 0 0 0 187.733-187.734v-51.2H273.067zm-34.134-204.8h546.134a34.133 34.133 0 0 1 34.133 34.134v221.866a256 256 0 0 1-256 256H460.8a256 256 0 0 1-256-256V375.467a34.133 34.133 0 0 1 34.133-34.134zM512 34.133a34.133 34.133 0 0 1 34.133 34.134v170.666a34.133 34.133 0 0 1-68.266 0V68.267A34.133 34.133 0 0 1 512 34.133zM375.467 102.4a34.133 34.133 0 0 1 34.133 34.133v102.4a34.133 34.133 0 0 1-68.267 0v-102.4a34.133 34.133 0 0 1 34.134-34.133zm273.066 0a34.133 34.133 0 0 1 34.134 34.133v102.4a34.133 34.133 0 1 1-68.267 0v-102.4a34.133 34.133 0 0 1 34.133-34.133zM170.667 921.668h682.666a34.133 34.133 0 1 1 0 68.267H170.667a34.133 34.133 0 1 1 0-68.267z"},null,-1),y3e=[v3e];function b3e(t,e,n,s,r,o){return S(),E("svg",g3e,y3e)}var w3e=ae(m3e,[["render",b3e],["__file","hot-water.vue"]]),_3e={name:"House"},$3e={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},x3e=I("path",{fill:"currentColor",d:"M192 413.952V896h640V413.952L512 147.328 192 413.952zM139.52 374.4l352-293.312a32 32 0 0 1 40.96 0l352 293.312A32 32 0 0 1 896 398.976V928a32 32 0 0 1-32 32H160a32 32 0 0 1-32-32V398.976a32 32 0 0 1 11.52-24.576z"},null,-1),S3e=[x3e];function C3e(t,e,n,s,r,o){return S(),E("svg",$3e,S3e)}var k3e=ae(_3e,[["render",C3e],["__file","house.vue"]]),T3e={name:"IceCreamRound"},N3e={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},I3e=I("path",{fill:"currentColor",d:"m308.352 489.344 226.304 226.304a32 32 0 0 0 45.248 0L783.552 512A192 192 0 1 0 512 240.448L308.352 444.16a32 32 0 0 0 0 45.248zm135.744 226.304L308.352 851.392a96 96 0 0 1-135.744-135.744l135.744-135.744-45.248-45.248a96 96 0 0 1 0-135.808L466.752 195.2A256 256 0 0 1 828.8 557.248L625.152 760.96a96 96 0 0 1-135.808 0l-45.248-45.248zM398.848 670.4 353.6 625.152 217.856 760.896a32 32 0 0 0 45.248 45.248L398.848 670.4zm248.96-384.64a32 32 0 0 1 0 45.248L466.624 512a32 32 0 1 1-45.184-45.248l180.992-181.056a32 32 0 0 1 45.248 0zm90.496 90.496a32 32 0 0 1 0 45.248L557.248 602.496A32 32 0 1 1 512 557.248l180.992-180.992a32 32 0 0 1 45.312 0z"},null,-1),E3e=[I3e];function A3e(t,e,n,s,r,o){return S(),E("svg",N3e,E3e)}var O3e=ae(T3e,[["render",A3e],["__file","ice-cream-round.vue"]]),R3e={name:"IceCreamSquare"},D3e={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},F3e=I("path",{fill:"currentColor",d:"M416 640h256a32 32 0 0 0 32-32V160a32 32 0 0 0-32-32H352a32 32 0 0 0-32 32v448a32 32 0 0 0 32 32h64zm192 64v160a96 96 0 0 1-192 0V704h-64a96 96 0 0 1-96-96V160a96 96 0 0 1 96-96h320a96 96 0 0 1 96 96v448a96 96 0 0 1-96 96h-64zm-64 0h-64v160a32 32 0 1 0 64 0V704z"},null,-1),M3e=[F3e];function P3e(t,e,n,s,r,o){return S(),E("svg",D3e,M3e)}var L3e=ae(R3e,[["render",P3e],["__file","ice-cream-square.vue"]]),z3e={name:"IceCream"},B3e={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},V3e=I("path",{fill:"currentColor",d:"M128.64 448a208 208 0 0 1 193.536-191.552 224 224 0 0 1 445.248 15.488A208.128 208.128 0 0 1 894.784 448H896L548.8 983.68a32 32 0 0 1-53.248.704L128 448h.64zm64.256 0h286.208a144 144 0 0 0-286.208 0zm351.36 0h286.272a144 144 0 0 0-286.272 0zm-294.848 64 271.808 396.608L778.24 512H249.408zM511.68 352.64a207.872 207.872 0 0 1 189.184-96.192 160 160 0 0 0-314.752 5.632c52.608 12.992 97.28 46.08 125.568 90.56z"},null,-1),H3e=[V3e];function W3e(t,e,n,s,r,o){return S(),E("svg",B3e,H3e)}var U3e=ae(z3e,[["render",W3e],["__file","ice-cream.vue"]]),G3e={name:"IceDrink"},j3e={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},K3e=I("path",{fill:"currentColor",d:"M512 448v128h239.68l16.064-128H512zm-64 0H256.256l16.064 128H448V448zm64-255.36V384h247.744A256.128 256.128 0 0 0 512 192.64zm-64 8.064A256.448 256.448 0 0 0 264.256 384H448V200.704zm64-72.064A320.128 320.128 0 0 1 825.472 384H896a32 32 0 1 1 0 64h-64v1.92l-56.96 454.016A64 64 0 0 1 711.552 960H312.448a64 64 0 0 1-63.488-56.064L192 449.92V448h-64a32 32 0 0 1 0-64h70.528A320.384 320.384 0 0 1 448 135.04V96a96 96 0 0 1 96-96h128a32 32 0 1 1 0 64H544a32 32 0 0 0-32 32v32.64zM743.68 640H280.32l32.128 256h399.104l32.128-256z"},null,-1),q3e=[K3e];function X3e(t,e,n,s,r,o){return S(),E("svg",j3e,q3e)}var Y3e=ae(G3e,[["render",X3e],["__file","ice-drink.vue"]]),Z3e={name:"IceTea"},J3e={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},Q3e=I("path",{fill:"currentColor",d:"M197.696 259.648a320.128 320.128 0 0 1 628.608 0A96 96 0 0 1 896 352v64a96 96 0 0 1-71.616 92.864l-49.408 395.072A64 64 0 0 1 711.488 960H312.512a64 64 0 0 1-63.488-56.064l-49.408-395.072A96 96 0 0 1 128 416v-64a96 96 0 0 1 69.696-92.352zM264.064 256h495.872a256.128 256.128 0 0 0-495.872 0zm495.424 256H264.512l48 384h398.976l48-384zM224 448h576a32 32 0 0 0 32-32v-64a32 32 0 0 0-32-32H224a32 32 0 0 0-32 32v64a32 32 0 0 0 32 32zm160 192h64v64h-64v-64zm192 64h64v64h-64v-64zm-128 64h64v64h-64v-64zm64-192h64v64h-64v-64z"},null,-1),e4e=[Q3e];function t4e(t,e,n,s,r,o){return S(),E("svg",J3e,e4e)}var n4e=ae(Z3e,[["render",t4e],["__file","ice-tea.vue"]]),s4e={name:"InfoFilled"},r4e={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},o4e=I("path",{fill:"currentColor",d:"M512 64a448 448 0 1 1 0 896.064A448 448 0 0 1 512 64zm67.2 275.072c33.28 0 60.288-23.104 60.288-57.344s-27.072-57.344-60.288-57.344c-33.28 0-60.16 23.104-60.16 57.344s26.88 57.344 60.16 57.344zM590.912 699.2c0-6.848 2.368-24.64 1.024-34.752l-52.608 60.544c-10.88 11.456-24.512 19.392-30.912 17.28a12.992 12.992 0 0 1-8.256-14.72l87.68-276.992c7.168-35.136-12.544-67.2-54.336-71.296-44.096 0-108.992 44.736-148.48 101.504 0 6.784-1.28 23.68.064 33.792l52.544-60.608c10.88-11.328 23.552-19.328 29.952-17.152a12.8 12.8 0 0 1 7.808 16.128L388.48 728.576c-10.048 32.256 8.96 63.872 55.04 71.04 67.84 0 107.904-43.648 147.456-100.416z"},null,-1),a4e=[o4e];function i4e(t,e,n,s,r,o){return S(),E("svg",r4e,a4e)}var cw=ae(s4e,[["render",i4e],["__file","info-filled.vue"]]),l4e={name:"Iphone"},u4e={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},c4e=I("path",{fill:"currentColor",d:"M224 768v96.064a64 64 0 0 0 64 64h448a64 64 0 0 0 64-64V768H224zm0-64h576V160a64 64 0 0 0-64-64H288a64 64 0 0 0-64 64v544zm32 288a96 96 0 0 1-96-96V128a96 96 0 0 1 96-96h512a96 96 0 0 1 96 96v768a96 96 0 0 1-96 96H256zm304-144a48 48 0 1 1-96 0 48 48 0 0 1 96 0z"},null,-1),d4e=[c4e];function f4e(t,e,n,s,r,o){return S(),E("svg",u4e,d4e)}var h4e=ae(l4e,[["render",f4e],["__file","iphone.vue"]]),p4e={name:"Key"},m4e={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},g4e=I("path",{fill:"currentColor",d:"M448 456.064V96a32 32 0 0 1 32-32.064L672 64a32 32 0 0 1 0 64H512v128h160a32 32 0 0 1 0 64H512v128a256 256 0 1 1-64 8.064zM512 896a192 192 0 1 0 0-384 192 192 0 0 0 0 384z"},null,-1),v4e=[g4e];function y4e(t,e,n,s,r,o){return S(),E("svg",m4e,v4e)}var b4e=ae(p4e,[["render",y4e],["__file","key.vue"]]),w4e={name:"KnifeFork"},_4e={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},$4e=I("path",{fill:"currentColor",d:"M256 410.56V96a32 32 0 0 1 64 0v314.56A96 96 0 0 0 384 320V96a32 32 0 0 1 64 0v224a160 160 0 0 1-128 156.8V928a32 32 0 1 1-64 0V476.8A160 160 0 0 1 128 320V96a32 32 0 0 1 64 0v224a96 96 0 0 0 64 90.56zm384-250.24V544h126.72c-3.328-78.72-12.928-147.968-28.608-207.744-14.336-54.528-46.848-113.344-98.112-175.872zM640 608v320a32 32 0 1 1-64 0V64h64c85.312 89.472 138.688 174.848 160 256 21.312 81.152 32 177.152 32 288H640z"},null,-1),x4e=[$4e];function S4e(t,e,n,s,r,o){return S(),E("svg",_4e,x4e)}var C4e=ae(w4e,[["render",S4e],["__file","knife-fork.vue"]]),k4e={name:"Lightning"},T4e={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},N4e=I("path",{fill:"currentColor",d:"M288 671.36v64.128A239.808 239.808 0 0 1 63.744 496.192a240.32 240.32 0 0 1 199.488-236.8 256.128 256.128 0 0 1 487.872-30.976A256.064 256.064 0 0 1 736 734.016v-64.768a192 192 0 0 0 3.328-377.92l-35.2-6.592-12.8-33.408a192.064 192.064 0 0 0-365.952 23.232l-9.92 40.896-41.472 7.04a176.32 176.32 0 0 0-146.24 173.568c0 91.968 70.464 167.36 160.256 175.232z"},null,-1),I4e=I("path",{fill:"currentColor",d:"M416 736a32 32 0 0 1-27.776-47.872l128-224a32 32 0 1 1 55.552 31.744L471.168 672H608a32 32 0 0 1 27.776 47.872l-128 224a32 32 0 1 1-55.68-31.744L552.96 736H416z"},null,-1),E4e=[N4e,I4e];function A4e(t,e,n,s,r,o){return S(),E("svg",T4e,E4e)}var O4e=ae(k4e,[["render",A4e],["__file","lightning.vue"]]),R4e={name:"Link"},D4e={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},F4e=I("path",{fill:"currentColor",d:"M715.648 625.152 670.4 579.904l90.496-90.56c75.008-74.944 85.12-186.368 22.656-248.896-62.528-62.464-173.952-52.352-248.96 22.656L444.16 353.6l-45.248-45.248 90.496-90.496c100.032-99.968 251.968-110.08 339.456-22.656 87.488 87.488 77.312 239.424-22.656 339.456l-90.496 90.496zm-90.496 90.496-90.496 90.496C434.624 906.112 282.688 916.224 195.2 828.8c-87.488-87.488-77.312-239.424 22.656-339.456l90.496-90.496 45.248 45.248-90.496 90.56c-75.008 74.944-85.12 186.368-22.656 248.896 62.528 62.464 173.952 52.352 248.96-22.656l90.496-90.496 45.248 45.248zm0-362.048 45.248 45.248L398.848 670.4 353.6 625.152 625.152 353.6z"},null,-1),M4e=[F4e];function P4e(t,e,n,s,r,o){return S(),E("svg",D4e,M4e)}var L4e=ae(R4e,[["render",P4e],["__file","link.vue"]]),z4e={name:"List"},B4e={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},V4e=I("path",{fill:"currentColor",d:"M704 192h160v736H160V192h160v64h384v-64zM288 512h448v-64H288v64zm0 256h448v-64H288v64zm96-576V96h256v96H384z"},null,-1),H4e=[V4e];function W4e(t,e,n,s,r,o){return S(),E("svg",B4e,H4e)}var U4e=ae(z4e,[["render",W4e],["__file","list.vue"]]),G4e={name:"Loading"},j4e={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},K4e=I("path",{fill:"currentColor",d:"M512 64a32 32 0 0 1 32 32v192a32 32 0 0 1-64 0V96a32 32 0 0 1 32-32zm0 640a32 32 0 0 1 32 32v192a32 32 0 1 1-64 0V736a32 32 0 0 1 32-32zm448-192a32 32 0 0 1-32 32H736a32 32 0 1 1 0-64h192a32 32 0 0 1 32 32zm-640 0a32 32 0 0 1-32 32H96a32 32 0 0 1 0-64h192a32 32 0 0 1 32 32zM195.2 195.2a32 32 0 0 1 45.248 0L376.32 331.008a32 32 0 0 1-45.248 45.248L195.2 240.448a32 32 0 0 1 0-45.248zm452.544 452.544a32 32 0 0 1 45.248 0L828.8 783.552a32 32 0 0 1-45.248 45.248L647.744 692.992a32 32 0 0 1 0-45.248zM828.8 195.264a32 32 0 0 1 0 45.184L692.992 376.32a32 32 0 0 1-45.248-45.248l135.808-135.808a32 32 0 0 1 45.248 0zm-452.544 452.48a32 32 0 0 1 0 45.248L240.448 828.8a32 32 0 0 1-45.248-45.248l135.808-135.808a32 32 0 0 1 45.248 0z"},null,-1),q4e=[K4e];function X4e(t,e,n,s,r,o){return S(),E("svg",j4e,q4e)}var Vl=ae(G4e,[["render",X4e],["__file","loading.vue"]]),Y4e={name:"LocationFilled"},Z4e={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},J4e=I("path",{fill:"currentColor",d:"M512 928c23.936 0 117.504-68.352 192.064-153.152C803.456 661.888 864 535.808 864 416c0-189.632-155.84-320-352-320S160 226.368 160 416c0 120.32 60.544 246.4 159.936 359.232C394.432 859.84 488 928 512 928zm0-435.2a64 64 0 1 0 0-128 64 64 0 0 0 0 128zm0 140.8a204.8 204.8 0 1 1 0-409.6 204.8 204.8 0 0 1 0 409.6z"},null,-1),Q4e=[J4e];function e$e(t,e,n,s,r,o){return S(),E("svg",Z4e,Q4e)}var t$e=ae(Y4e,[["render",e$e],["__file","location-filled.vue"]]),n$e={name:"LocationInformation"},s$e={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},r$e=I("path",{fill:"currentColor",d:"M288 896h448q32 0 32 32t-32 32H288q-32 0-32-32t32-32z"},null,-1),o$e=I("path",{fill:"currentColor",d:"M800 416a288 288 0 1 0-576 0c0 118.144 94.528 272.128 288 456.576C705.472 688.128 800 534.144 800 416zM512 960C277.312 746.688 160 565.312 160 416a352 352 0 0 1 704 0c0 149.312-117.312 330.688-352 544z"},null,-1),a$e=I("path",{fill:"currentColor",d:"M512 512a96 96 0 1 0 0-192 96 96 0 0 0 0 192zm0 64a160 160 0 1 1 0-320 160 160 0 0 1 0 320z"},null,-1),i$e=[r$e,o$e,a$e];function l$e(t,e,n,s,r,o){return S(),E("svg",s$e,i$e)}var u$e=ae(n$e,[["render",l$e],["__file","location-information.vue"]]),c$e={name:"Location"},d$e={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},f$e=I("path",{fill:"currentColor",d:"M800 416a288 288 0 1 0-576 0c0 118.144 94.528 272.128 288 456.576C705.472 688.128 800 534.144 800 416zM512 960C277.312 746.688 160 565.312 160 416a352 352 0 0 1 704 0c0 149.312-117.312 330.688-352 544z"},null,-1),h$e=I("path",{fill:"currentColor",d:"M512 512a96 96 0 1 0 0-192 96 96 0 0 0 0 192zm0 64a160 160 0 1 1 0-320 160 160 0 0 1 0 320z"},null,-1),p$e=[f$e,h$e];function m$e(t,e,n,s,r,o){return S(),E("svg",d$e,p$e)}var g$e=ae(c$e,[["render",m$e],["__file","location.vue"]]),v$e={name:"Lock"},y$e={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},b$e=I("path",{fill:"currentColor",d:"M224 448a32 32 0 0 0-32 32v384a32 32 0 0 0 32 32h576a32 32 0 0 0 32-32V480a32 32 0 0 0-32-32H224zm0-64h576a96 96 0 0 1 96 96v384a96 96 0 0 1-96 96H224a96 96 0 0 1-96-96V480a96 96 0 0 1 96-96z"},null,-1),w$e=I("path",{fill:"currentColor",d:"M512 544a32 32 0 0 1 32 32v192a32 32 0 1 1-64 0V576a32 32 0 0 1 32-32zm192-160v-64a192 192 0 1 0-384 0v64h384zM512 64a256 256 0 0 1 256 256v128H256V320A256 256 0 0 1 512 64z"},null,-1),_$e=[b$e,w$e];function $$e(t,e,n,s,r,o){return S(),E("svg",y$e,_$e)}var x$e=ae(v$e,[["render",$$e],["__file","lock.vue"]]),S$e={name:"Lollipop"},C$e={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},k$e=I("path",{fill:"currentColor",d:"M513.28 448a64 64 0 1 1 76.544 49.728A96 96 0 0 0 768 448h64a160 160 0 0 1-320 0h1.28zm-126.976-29.696a256 256 0 1 0 43.52-180.48A256 256 0 0 1 832 448h-64a192 192 0 0 0-381.696-29.696zm105.664 249.472L285.696 874.048a96 96 0 0 1-135.68-135.744l206.208-206.272a320 320 0 1 1 135.744 135.744zm-54.464-36.032a321.92 321.92 0 0 1-45.248-45.248L195.2 783.552a32 32 0 1 0 45.248 45.248l197.056-197.12z"},null,-1),T$e=[k$e];function N$e(t,e,n,s,r,o){return S(),E("svg",C$e,T$e)}var I$e=ae(S$e,[["render",N$e],["__file","lollipop.vue"]]),E$e={name:"MagicStick"},A$e={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},O$e=I("path",{fill:"currentColor",d:"M512 64h64v192h-64V64zm0 576h64v192h-64V640zM160 480v-64h192v64H160zm576 0v-64h192v64H736zM249.856 199.04l45.248-45.184L430.848 289.6 385.6 334.848 249.856 199.104zM657.152 606.4l45.248-45.248 135.744 135.744-45.248 45.248L657.152 606.4zM114.048 923.2 68.8 877.952l316.8-316.8 45.248 45.248-316.8 316.8zM702.4 334.848 657.152 289.6l135.744-135.744 45.248 45.248L702.4 334.848z"},null,-1),R$e=[O$e];function D$e(t,e,n,s,r,o){return S(),E("svg",A$e,R$e)}var F$e=ae(E$e,[["render",D$e],["__file","magic-stick.vue"]]),M$e={name:"Magnet"},P$e={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},L$e=I("path",{fill:"currentColor",d:"M832 320V192H704v320a192 192 0 1 1-384 0V192H192v128h128v64H192v128a320 320 0 0 0 640 0V384H704v-64h128zM640 512V128h256v384a384 384 0 1 1-768 0V128h256v384a128 128 0 1 0 256 0z"},null,-1),z$e=[L$e];function B$e(t,e,n,s,r,o){return S(),E("svg",P$e,z$e)}var V$e=ae(M$e,[["render",B$e],["__file","magnet.vue"]]),H$e={name:"Male"},W$e={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},U$e=I("path",{fill:"currentColor",d:"M399.5 849.5a225 225 0 1 0 0-450 225 225 0 0 0 0 450zm0 56.25a281.25 281.25 0 1 1 0-562.5 281.25 281.25 0 0 1 0 562.5zm253.125-787.5h225q28.125 0 28.125 28.125T877.625 174.5h-225q-28.125 0-28.125-28.125t28.125-28.125z"},null,-1),G$e=I("path",{fill:"currentColor",d:"M877.625 118.25q28.125 0 28.125 28.125v225q0 28.125-28.125 28.125T849.5 371.375v-225q0-28.125 28.125-28.125z"},null,-1),j$e=I("path",{fill:"currentColor",d:"M604.813 458.9 565.1 419.131l292.613-292.668 39.825 39.824z"},null,-1),K$e=[U$e,G$e,j$e];function q$e(t,e,n,s,r,o){return S(),E("svg",W$e,K$e)}var X$e=ae(H$e,[["render",q$e],["__file","male.vue"]]),Y$e={name:"Management"},Z$e={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},J$e=I("path",{fill:"currentColor",d:"M576 128v288l96-96 96 96V128h128v768H320V128h256zm-448 0h128v768H128V128z"},null,-1),Q$e=[J$e];function e6e(t,e,n,s,r,o){return S(),E("svg",Z$e,Q$e)}var t6e=ae(Y$e,[["render",e6e],["__file","management.vue"]]),n6e={name:"MapLocation"},s6e={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},r6e=I("path",{fill:"currentColor",d:"M800 416a288 288 0 1 0-576 0c0 118.144 94.528 272.128 288 456.576C705.472 688.128 800 534.144 800 416zM512 960C277.312 746.688 160 565.312 160 416a352 352 0 0 1 704 0c0 149.312-117.312 330.688-352 544z"},null,-1),o6e=I("path",{fill:"currentColor",d:"M512 448a64 64 0 1 0 0-128 64 64 0 0 0 0 128zm0 64a128 128 0 1 1 0-256 128 128 0 0 1 0 256zm345.6 192L960 960H672v-64H352v64H64l102.4-256h691.2zm-68.928 0H235.328l-76.8 192h706.944l-76.8-192z"},null,-1),a6e=[r6e,o6e];function i6e(t,e,n,s,r,o){return S(),E("svg",s6e,a6e)}var l6e=ae(n6e,[["render",i6e],["__file","map-location.vue"]]),u6e={name:"Medal"},c6e={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},d6e=I("path",{fill:"currentColor",d:"M512 896a256 256 0 1 0 0-512 256 256 0 0 0 0 512zm0 64a320 320 0 1 1 0-640 320 320 0 0 1 0 640z"},null,-1),f6e=I("path",{fill:"currentColor",d:"M576 128H448v200a286.72 286.72 0 0 1 64-8c19.52 0 40.832 2.688 64 8V128zm64 0v219.648c24.448 9.088 50.56 20.416 78.4 33.92L757.44 128H640zm-256 0H266.624l39.04 253.568c27.84-13.504 53.888-24.832 78.336-33.92V128zM229.312 64h565.376a32 32 0 0 1 31.616 36.864L768 480c-113.792-64-199.104-96-256-96-56.896 0-142.208 32-256 96l-58.304-379.136A32 32 0 0 1 229.312 64z"},null,-1),h6e=[d6e,f6e];function p6e(t,e,n,s,r,o){return S(),E("svg",c6e,h6e)}var m6e=ae(u6e,[["render",p6e],["__file","medal.vue"]]),g6e={name:"Memo"},v6e={xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 1024 1024",style:{"enable-background":"new 0 0 1024 1024"},"xml:space":"preserve"},y6e=I("path",{d:"M480 320h192c21.33 0 32-10.67 32-32s-10.67-32-32-32H480c-21.33 0-32 10.67-32 32s10.67 32 32 32z",fill:"currentColor"},null,-1),b6e=I("path",{d:"M887.01 72.99C881.01 67 873.34 64 864 64H160c-9.35 0-17.02 3-23.01 8.99C131 78.99 128 86.66 128 96v832c0 9.35 2.99 17.02 8.99 23.01S150.66 960 160 960h704c9.35 0 17.02-2.99 23.01-8.99S896 937.34 896 928V96c0-9.35-3-17.02-8.99-23.01zM192 896V128h96v768h-96zm640 0H352V128h480v768z",fill:"currentColor"},null,-1),w6e=I("path",{d:"M480 512h192c21.33 0 32-10.67 32-32s-10.67-32-32-32H480c-21.33 0-32 10.67-32 32s10.67 32 32 32zm0 192h192c21.33 0 32-10.67 32-32s-10.67-32-32-32H480c-21.33 0-32 10.67-32 32s10.67 32 32 32z",fill:"currentColor"},null,-1),_6e=[y6e,b6e,w6e];function $6e(t,e,n,s,r,o){return S(),E("svg",v6e,_6e)}var x6e=ae(g6e,[["render",$6e],["__file","memo.vue"]]),S6e={name:"Menu"},C6e={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},k6e=I("path",{fill:"currentColor",d:"M160 448a32 32 0 0 1-32-32V160.064a32 32 0 0 1 32-32h256a32 32 0 0 1 32 32V416a32 32 0 0 1-32 32H160zm448 0a32 32 0 0 1-32-32V160.064a32 32 0 0 1 32-32h255.936a32 32 0 0 1 32 32V416a32 32 0 0 1-32 32H608zM160 896a32 32 0 0 1-32-32V608a32 32 0 0 1 32-32h256a32 32 0 0 1 32 32v256a32 32 0 0 1-32 32H160zm448 0a32 32 0 0 1-32-32V608a32 32 0 0 1 32-32h255.936a32 32 0 0 1 32 32v256a32 32 0 0 1-32 32H608z"},null,-1),T6e=[k6e];function N6e(t,e,n,s,r,o){return S(),E("svg",C6e,T6e)}var I6e=ae(S6e,[["render",N6e],["__file","menu.vue"]]),E6e={name:"MessageBox"},A6e={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},O6e=I("path",{fill:"currentColor",d:"M288 384h448v64H288v-64zm96-128h256v64H384v-64zM131.456 512H384v128h256V512h252.544L721.856 192H302.144L131.456 512zM896 576H704v128H320V576H128v256h768V576zM275.776 128h472.448a32 32 0 0 1 28.608 17.664l179.84 359.552A32 32 0 0 1 960 519.552V864a32 32 0 0 1-32 32H96a32 32 0 0 1-32-32V519.552a32 32 0 0 1 3.392-14.336l179.776-359.552A32 32 0 0 1 275.776 128z"},null,-1),R6e=[O6e];function D6e(t,e,n,s,r,o){return S(),E("svg",A6e,R6e)}var F6e=ae(E6e,[["render",D6e],["__file","message-box.vue"]]),M6e={name:"Message"},P6e={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},L6e=I("path",{fill:"currentColor",d:"M128 224v512a64 64 0 0 0 64 64h640a64 64 0 0 0 64-64V224H128zm0-64h768a64 64 0 0 1 64 64v512a128 128 0 0 1-128 128H192A128 128 0 0 1 64 736V224a64 64 0 0 1 64-64z"},null,-1),z6e=I("path",{fill:"currentColor",d:"M904 224 656.512 506.88a192 192 0 0 1-289.024 0L120 224h784zm-698.944 0 210.56 240.704a128 128 0 0 0 192.704 0L818.944 224H205.056z"},null,-1),B6e=[L6e,z6e];function V6e(t,e,n,s,r,o){return S(),E("svg",P6e,B6e)}var H6e=ae(M6e,[["render",V6e],["__file","message.vue"]]),W6e={name:"Mic"},U6e={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},G6e=I("path",{fill:"currentColor",d:"M480 704h160a64 64 0 0 0 64-64v-32h-96a32 32 0 0 1 0-64h96v-96h-96a32 32 0 0 1 0-64h96v-96h-96a32 32 0 0 1 0-64h96v-32a64 64 0 0 0-64-64H384a64 64 0 0 0-64 64v32h96a32 32 0 0 1 0 64h-96v96h96a32 32 0 0 1 0 64h-96v96h96a32 32 0 0 1 0 64h-96v32a64 64 0 0 0 64 64h96zm64 64v128h192a32 32 0 1 1 0 64H288a32 32 0 1 1 0-64h192V768h-96a128 128 0 0 1-128-128V192A128 128 0 0 1 384 64h256a128 128 0 0 1 128 128v448a128 128 0 0 1-128 128h-96z"},null,-1),j6e=[G6e];function K6e(t,e,n,s,r,o){return S(),E("svg",U6e,j6e)}var q6e=ae(W6e,[["render",K6e],["__file","mic.vue"]]),X6e={name:"Microphone"},Y6e={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},Z6e=I("path",{fill:"currentColor",d:"M512 128a128 128 0 0 0-128 128v256a128 128 0 1 0 256 0V256a128 128 0 0 0-128-128zm0-64a192 192 0 0 1 192 192v256a192 192 0 1 1-384 0V256A192 192 0 0 1 512 64zm-32 832v-64a288 288 0 0 1-288-288v-32a32 32 0 0 1 64 0v32a224 224 0 0 0 224 224h64a224 224 0 0 0 224-224v-32a32 32 0 1 1 64 0v32a288 288 0 0 1-288 288v64h64a32 32 0 1 1 0 64H416a32 32 0 1 1 0-64h64z"},null,-1),J6e=[Z6e];function Q6e(t,e,n,s,r,o){return S(),E("svg",Y6e,J6e)}var exe=ae(X6e,[["render",Q6e],["__file","microphone.vue"]]),txe={name:"MilkTea"},nxe={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},sxe=I("path",{fill:"currentColor",d:"M416 128V96a96 96 0 0 1 96-96h128a32 32 0 1 1 0 64H512a32 32 0 0 0-32 32v32h320a96 96 0 0 1 11.712 191.296l-39.68 581.056A64 64 0 0 1 708.224 960H315.776a64 64 0 0 1-63.872-59.648l-39.616-581.056A96 96 0 0 1 224 128h192zM276.48 320l39.296 576h392.448l4.8-70.784a224.064 224.064 0 0 1 30.016-439.808L747.52 320H276.48zM224 256h576a32 32 0 1 0 0-64H224a32 32 0 0 0 0 64zm493.44 503.872 21.12-309.12a160 160 0 0 0-21.12 309.12z"},null,-1),rxe=[sxe];function oxe(t,e,n,s,r,o){return S(),E("svg",nxe,rxe)}var axe=ae(txe,[["render",oxe],["__file","milk-tea.vue"]]),ixe={name:"Minus"},lxe={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},uxe=I("path",{fill:"currentColor",d:"M128 544h768a32 32 0 1 0 0-64H128a32 32 0 0 0 0 64z"},null,-1),cxe=[uxe];function dxe(t,e,n,s,r,o){return S(),E("svg",lxe,cxe)}var yP=ae(ixe,[["render",dxe],["__file","minus.vue"]]),fxe={name:"Money"},hxe={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},pxe=I("path",{fill:"currentColor",d:"M256 640v192h640V384H768v-64h150.976c14.272 0 19.456 1.472 24.64 4.288a29.056 29.056 0 0 1 12.16 12.096c2.752 5.184 4.224 10.368 4.224 24.64v493.952c0 14.272-1.472 19.456-4.288 24.64a29.056 29.056 0 0 1-12.096 12.16c-5.184 2.752-10.368 4.224-24.64 4.224H233.024c-14.272 0-19.456-1.472-24.64-4.288a29.056 29.056 0 0 1-12.16-12.096c-2.688-5.184-4.224-10.368-4.224-24.576V640h64z"},null,-1),mxe=I("path",{fill:"currentColor",d:"M768 192H128v448h640V192zm64-22.976v493.952c0 14.272-1.472 19.456-4.288 24.64a29.056 29.056 0 0 1-12.096 12.16c-5.184 2.752-10.368 4.224-24.64 4.224H105.024c-14.272 0-19.456-1.472-24.64-4.288a29.056 29.056 0 0 1-12.16-12.096C65.536 682.432 64 677.248 64 663.04V169.024c0-14.272 1.472-19.456 4.288-24.64a29.056 29.056 0 0 1 12.096-12.16C85.568 129.536 90.752 128 104.96 128h685.952c14.272 0 19.456 1.472 24.64 4.288a29.056 29.056 0 0 1 12.16 12.096c2.752 5.184 4.224 10.368 4.224 24.64z"},null,-1),gxe=I("path",{fill:"currentColor",d:"M448 576a160 160 0 1 1 0-320 160 160 0 0 1 0 320zm0-64a96 96 0 1 0 0-192 96 96 0 0 0 0 192z"},null,-1),vxe=[pxe,mxe,gxe];function yxe(t,e,n,s,r,o){return S(),E("svg",hxe,vxe)}var bxe=ae(fxe,[["render",yxe],["__file","money.vue"]]),wxe={name:"Monitor"},_xe={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},$xe=I("path",{fill:"currentColor",d:"M544 768v128h192a32 32 0 1 1 0 64H288a32 32 0 1 1 0-64h192V768H192A128 128 0 0 1 64 640V256a128 128 0 0 1 128-128h640a128 128 0 0 1 128 128v384a128 128 0 0 1-128 128H544zM192 192a64 64 0 0 0-64 64v384a64 64 0 0 0 64 64h640a64 64 0 0 0 64-64V256a64 64 0 0 0-64-64H192z"},null,-1),xxe=[$xe];function Sxe(t,e,n,s,r,o){return S(),E("svg",_xe,xxe)}var Cxe=ae(wxe,[["render",Sxe],["__file","monitor.vue"]]),kxe={name:"MoonNight"},Txe={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},Nxe=I("path",{fill:"currentColor",d:"M384 512a448 448 0 0 1 215.872-383.296A384 384 0 0 0 213.76 640h188.8A448.256 448.256 0 0 1 384 512zM171.136 704a448 448 0 0 1 636.992-575.296A384 384 0 0 0 499.328 704h-328.32z"},null,-1),Ixe=I("path",{fill:"currentColor",d:"M32 640h960q32 0 32 32t-32 32H32q-32 0-32-32t32-32zm128 128h384a32 32 0 1 1 0 64H160a32 32 0 1 1 0-64zm160 127.68 224 .256a32 32 0 0 1 32 32V928a32 32 0 0 1-32 32l-224-.384a32 32 0 0 1-32-32v-.064a32 32 0 0 1 32-32z"},null,-1),Exe=[Nxe,Ixe];function Axe(t,e,n,s,r,o){return S(),E("svg",Txe,Exe)}var Oxe=ae(kxe,[["render",Axe],["__file","moon-night.vue"]]),Rxe={name:"Moon"},Dxe={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},Fxe=I("path",{fill:"currentColor",d:"M240.448 240.448a384 384 0 1 0 559.424 525.696 448 448 0 0 1-542.016-542.08 390.592 390.592 0 0 0-17.408 16.384zm181.056 362.048a384 384 0 0 0 525.632 16.384A448 448 0 1 1 405.056 76.8a384 384 0 0 0 16.448 525.696z"},null,-1),Mxe=[Fxe];function Pxe(t,e,n,s,r,o){return S(),E("svg",Dxe,Mxe)}var Lxe=ae(Rxe,[["render",Pxe],["__file","moon.vue"]]),zxe={name:"MoreFilled"},Bxe={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},Vxe=I("path",{fill:"currentColor",d:"M176 416a112 112 0 1 1 0 224 112 112 0 0 1 0-224zm336 0a112 112 0 1 1 0 224 112 112 0 0 1 0-224zm336 0a112 112 0 1 1 0 224 112 112 0 0 1 0-224z"},null,-1),Hxe=[Vxe];function Wxe(t,e,n,s,r,o){return S(),E("svg",Bxe,Hxe)}var f6=ae(zxe,[["render",Wxe],["__file","more-filled.vue"]]),Uxe={name:"More"},Gxe={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},jxe=I("path",{fill:"currentColor",d:"M176 416a112 112 0 1 0 0 224 112 112 0 0 0 0-224m0 64a48 48 0 1 1 0 96 48 48 0 0 1 0-96zm336-64a112 112 0 1 1 0 224 112 112 0 0 1 0-224zm0 64a48 48 0 1 0 0 96 48 48 0 0 0 0-96zm336-64a112 112 0 1 1 0 224 112 112 0 0 1 0-224zm0 64a48 48 0 1 0 0 96 48 48 0 0 0 0-96z"},null,-1),Kxe=[jxe];function qxe(t,e,n,s,r,o){return S(),E("svg",Gxe,Kxe)}var bP=ae(Uxe,[["render",qxe],["__file","more.vue"]]),Xxe={name:"MostlyCloudy"},Yxe={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},Zxe=I("path",{fill:"currentColor",d:"M737.216 357.952 704 349.824l-11.776-32a192.064 192.064 0 0 0-367.424 23.04l-8.96 39.04-39.04 8.96A192.064 192.064 0 0 0 320 768h368a207.808 207.808 0 0 0 207.808-208 208.32 208.32 0 0 0-158.592-202.048zm15.168-62.208A272.32 272.32 0 0 1 959.744 560a271.808 271.808 0 0 1-271.552 272H320a256 256 0 0 1-57.536-505.536 256.128 256.128 0 0 1 489.92-30.72z"},null,-1),Jxe=[Zxe];function Qxe(t,e,n,s,r,o){return S(),E("svg",Yxe,Jxe)}var eSe=ae(Xxe,[["render",Qxe],["__file","mostly-cloudy.vue"]]),tSe={name:"Mouse"},nSe={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},sSe=I("path",{fill:"currentColor",d:"M438.144 256c-68.352 0-92.736 4.672-117.76 18.112-20.096 10.752-35.52 26.176-46.272 46.272C260.672 345.408 256 369.792 256 438.144v275.712c0 68.352 4.672 92.736 18.112 117.76 10.752 20.096 26.176 35.52 46.272 46.272C345.408 891.328 369.792 896 438.144 896h147.712c68.352 0 92.736-4.672 117.76-18.112 20.096-10.752 35.52-26.176 46.272-46.272C763.328 806.592 768 782.208 768 713.856V438.144c0-68.352-4.672-92.736-18.112-117.76a110.464 110.464 0 0 0-46.272-46.272C678.592 260.672 654.208 256 585.856 256H438.144zm0-64h147.712c85.568 0 116.608 8.96 147.904 25.6 31.36 16.768 55.872 41.344 72.576 72.64C823.104 321.536 832 352.576 832 438.08v275.84c0 85.504-8.96 116.544-25.6 147.84a174.464 174.464 0 0 1-72.64 72.576C702.464 951.104 671.424 960 585.92 960H438.08c-85.504 0-116.544-8.96-147.84-25.6a174.464 174.464 0 0 1-72.64-72.704c-16.768-31.296-25.664-62.336-25.664-147.84v-275.84c0-85.504 8.96-116.544 25.6-147.84a174.464 174.464 0 0 1 72.768-72.576c31.232-16.704 62.272-25.6 147.776-25.6z"},null,-1),rSe=I("path",{fill:"currentColor",d:"M512 320q32 0 32 32v128q0 32-32 32t-32-32V352q0-32 32-32zm32-96a32 32 0 0 1-64 0v-64a32 32 0 0 0-32-32h-96a32 32 0 0 1 0-64h96a96 96 0 0 1 96 96v64z"},null,-1),oSe=[sSe,rSe];function aSe(t,e,n,s,r,o){return S(),E("svg",nSe,oSe)}var iSe=ae(tSe,[["render",aSe],["__file","mouse.vue"]]),lSe={name:"Mug"},uSe={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},cSe=I("path",{fill:"currentColor",d:"M736 800V160H160v640a64 64 0 0 0 64 64h448a64 64 0 0 0 64-64zm64-544h63.552a96 96 0 0 1 96 96v224a96 96 0 0 1-96 96H800v128a128 128 0 0 1-128 128H224A128 128 0 0 1 96 800V128a32 32 0 0 1 32-32h640a32 32 0 0 1 32 32v128zm0 64v288h63.552a32 32 0 0 0 32-32V352a32 32 0 0 0-32-32H800z"},null,-1),dSe=[cSe];function fSe(t,e,n,s,r,o){return S(),E("svg",uSe,dSe)}var hSe=ae(lSe,[["render",fSe],["__file","mug.vue"]]),pSe={name:"MuteNotification"},mSe={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},gSe=I("path",{fill:"currentColor",d:"m241.216 832 63.616-64H768V448c0-42.368-10.24-82.304-28.48-117.504l46.912-47.232C815.36 331.392 832 387.84 832 448v320h96a32 32 0 1 1 0 64H241.216zm-90.24 0H96a32 32 0 1 1 0-64h96V448a320.128 320.128 0 0 1 256-313.6V128a64 64 0 1 1 128 0v6.4a319.552 319.552 0 0 1 171.648 97.088l-45.184 45.44A256 256 0 0 0 256 448v278.336L151.04 832zM448 896h128a64 64 0 0 1-128 0z"},null,-1),vSe=I("path",{fill:"currentColor",d:"M150.72 859.072a32 32 0 0 1-45.44-45.056l704-708.544a32 32 0 0 1 45.44 45.056l-704 708.544z"},null,-1),ySe=[gSe,vSe];function bSe(t,e,n,s,r,o){return S(),E("svg",mSe,ySe)}var wSe=ae(pSe,[["render",bSe],["__file","mute-notification.vue"]]),_Se={name:"Mute"},$Se={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},xSe=I("path",{fill:"currentColor",d:"m412.16 592.128-45.44 45.44A191.232 191.232 0 0 1 320 512V256a192 192 0 1 1 384 0v44.352l-64 64V256a128 128 0 1 0-256 0v256c0 30.336 10.56 58.24 28.16 80.128zm51.968 38.592A128 128 0 0 0 640 512v-57.152l64-64V512a192 192 0 0 1-287.68 166.528l47.808-47.808zM314.88 779.968l46.144-46.08A222.976 222.976 0 0 0 480 768h64a224 224 0 0 0 224-224v-32a32 32 0 1 1 64 0v32a288 288 0 0 1-288 288v64h64a32 32 0 1 1 0 64H416a32 32 0 1 1 0-64h64v-64c-61.44 0-118.4-19.2-165.12-52.032zM266.752 737.6A286.976 286.976 0 0 1 192 544v-32a32 32 0 0 1 64 0v32c0 56.832 21.184 108.8 56.064 148.288L266.752 737.6z"},null,-1),SSe=I("path",{fill:"currentColor",d:"M150.72 859.072a32 32 0 0 1-45.44-45.056l704-708.544a32 32 0 0 1 45.44 45.056l-704 708.544z"},null,-1),CSe=[xSe,SSe];function kSe(t,e,n,s,r,o){return S(),E("svg",$Se,CSe)}var TSe=ae(_Se,[["render",kSe],["__file","mute.vue"]]),NSe={name:"NoSmoking"},ISe={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},ESe=I("path",{fill:"currentColor",d:"M440.256 576H256v128h56.256l-64 64H224a32 32 0 0 1-32-32V544a32 32 0 0 1 32-32h280.256l-64 64zm143.488 128H704V583.744L775.744 512H928a32 32 0 0 1 32 32v192a32 32 0 0 1-32 32H519.744l64-64zM768 576v128h128V576H768zm-29.696-207.552 45.248 45.248-497.856 497.856-45.248-45.248zM256 64h64v320h-64zM128 192h64v192h-64zM64 512h64v256H64z"},null,-1),ASe=[ESe];function OSe(t,e,n,s,r,o){return S(),E("svg",ISe,ASe)}var RSe=ae(NSe,[["render",OSe],["__file","no-smoking.vue"]]),DSe={name:"Notebook"},FSe={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},MSe=I("path",{fill:"currentColor",d:"M192 128v768h640V128H192zm-32-64h704a32 32 0 0 1 32 32v832a32 32 0 0 1-32 32H160a32 32 0 0 1-32-32V96a32 32 0 0 1 32-32z"},null,-1),PSe=I("path",{fill:"currentColor",d:"M672 128h64v768h-64zM96 192h128q32 0 32 32t-32 32H96q-32 0-32-32t32-32zm0 192h128q32 0 32 32t-32 32H96q-32 0-32-32t32-32zm0 192h128q32 0 32 32t-32 32H96q-32 0-32-32t32-32zm0 192h128q32 0 32 32t-32 32H96q-32 0-32-32t32-32z"},null,-1),LSe=[MSe,PSe];function zSe(t,e,n,s,r,o){return S(),E("svg",FSe,LSe)}var BSe=ae(DSe,[["render",zSe],["__file","notebook.vue"]]),VSe={name:"Notification"},HSe={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},WSe=I("path",{fill:"currentColor",d:"M512 128v64H256a64 64 0 0 0-64 64v512a64 64 0 0 0 64 64h512a64 64 0 0 0 64-64V512h64v256a128 128 0 0 1-128 128H256a128 128 0 0 1-128-128V256a128 128 0 0 1 128-128h256z"},null,-1),USe=I("path",{fill:"currentColor",d:"M768 384a128 128 0 1 0 0-256 128 128 0 0 0 0 256zm0 64a192 192 0 1 1 0-384 192 192 0 0 1 0 384z"},null,-1),GSe=[WSe,USe];function jSe(t,e,n,s,r,o){return S(),E("svg",HSe,GSe)}var KSe=ae(VSe,[["render",jSe],["__file","notification.vue"]]),qSe={name:"Odometer"},XSe={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},YSe=I("path",{fill:"currentColor",d:"M512 896a384 384 0 1 0 0-768 384 384 0 0 0 0 768zm0 64a448 448 0 1 1 0-896 448 448 0 0 1 0 896z"},null,-1),ZSe=I("path",{fill:"currentColor",d:"M192 512a320 320 0 1 1 640 0 32 32 0 1 1-64 0 256 256 0 1 0-512 0 32 32 0 0 1-64 0z"},null,-1),JSe=I("path",{fill:"currentColor",d:"M570.432 627.84A96 96 0 1 1 509.568 608l60.992-187.776A32 32 0 1 1 631.424 440l-60.992 187.776zM502.08 734.464a32 32 0 1 0 19.84-60.928 32 32 0 0 0-19.84 60.928z"},null,-1),QSe=[YSe,ZSe,JSe];function eCe(t,e,n,s,r,o){return S(),E("svg",XSe,QSe)}var tCe=ae(qSe,[["render",eCe],["__file","odometer.vue"]]),nCe={name:"OfficeBuilding"},sCe={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},rCe=I("path",{fill:"currentColor",d:"M192 128v704h384V128H192zm-32-64h448a32 32 0 0 1 32 32v768a32 32 0 0 1-32 32H160a32 32 0 0 1-32-32V96a32 32 0 0 1 32-32z"},null,-1),oCe=I("path",{fill:"currentColor",d:"M256 256h256v64H256v-64zm0 192h256v64H256v-64zm0 192h256v64H256v-64zm384-128h128v64H640v-64zm0 128h128v64H640v-64zM64 832h896v64H64v-64z"},null,-1),aCe=I("path",{fill:"currentColor",d:"M640 384v448h192V384H640zm-32-64h256a32 32 0 0 1 32 32v512a32 32 0 0 1-32 32H608a32 32 0 0 1-32-32V352a32 32 0 0 1 32-32z"},null,-1),iCe=[rCe,oCe,aCe];function lCe(t,e,n,s,r,o){return S(),E("svg",sCe,iCe)}var uCe=ae(nCe,[["render",lCe],["__file","office-building.vue"]]),cCe={name:"Open"},dCe={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},fCe=I("path",{fill:"currentColor",d:"M329.956 257.138a254.862 254.862 0 0 0 0 509.724h364.088a254.862 254.862 0 0 0 0-509.724H329.956zm0-72.818h364.088a327.68 327.68 0 1 1 0 655.36H329.956a327.68 327.68 0 1 1 0-655.36z"},null,-1),hCe=I("path",{fill:"currentColor",d:"M694.044 621.227a109.227 109.227 0 1 0 0-218.454 109.227 109.227 0 0 0 0 218.454zm0 72.817a182.044 182.044 0 1 1 0-364.088 182.044 182.044 0 0 1 0 364.088z"},null,-1),pCe=[fCe,hCe];function mCe(t,e,n,s,r,o){return S(),E("svg",dCe,pCe)}var gCe=ae(cCe,[["render",mCe],["__file","open.vue"]]),vCe={name:"Operation"},yCe={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},bCe=I("path",{fill:"currentColor",d:"M389.44 768a96.064 96.064 0 0 1 181.12 0H896v64H570.56a96.064 96.064 0 0 1-181.12 0H128v-64h261.44zm192-288a96.064 96.064 0 0 1 181.12 0H896v64H762.56a96.064 96.064 0 0 1-181.12 0H128v-64h453.44zm-320-288a96.064 96.064 0 0 1 181.12 0H896v64H442.56a96.064 96.064 0 0 1-181.12 0H128v-64h133.44z"},null,-1),wCe=[bCe];function _Ce(t,e,n,s,r,o){return S(),E("svg",yCe,wCe)}var $Ce=ae(vCe,[["render",_Ce],["__file","operation.vue"]]),xCe={name:"Opportunity"},SCe={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},CCe=I("path",{fill:"currentColor",d:"M384 960v-64h192.064v64H384zm448-544a350.656 350.656 0 0 1-128.32 271.424C665.344 719.04 640 763.776 640 813.504V832H320v-14.336c0-48-19.392-95.36-57.216-124.992a351.552 351.552 0 0 1-128.448-344.256c25.344-136.448 133.888-248.128 269.76-276.48A352.384 352.384 0 0 1 832 416zm-544 32c0-132.288 75.904-224 192-224v-64c-154.432 0-256 122.752-256 288h64z"},null,-1),kCe=[CCe];function TCe(t,e,n,s,r,o){return S(),E("svg",SCe,kCe)}var NCe=ae(xCe,[["render",TCe],["__file","opportunity.vue"]]),ICe={name:"Orange"},ECe={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},ACe=I("path",{fill:"currentColor",d:"M544 894.72a382.336 382.336 0 0 0 215.936-89.472L577.024 622.272c-10.24 6.016-21.248 10.688-33.024 13.696v258.688zm261.248-134.784A382.336 382.336 0 0 0 894.656 544H635.968c-3.008 11.776-7.68 22.848-13.696 33.024l182.976 182.912zM894.656 480a382.336 382.336 0 0 0-89.408-215.936L622.272 446.976c6.016 10.24 10.688 21.248 13.696 33.024h258.688zm-134.72-261.248A382.336 382.336 0 0 0 544 129.344v258.688c11.776 3.008 22.848 7.68 33.024 13.696l182.912-182.976zM480 129.344a382.336 382.336 0 0 0-215.936 89.408l182.912 182.976c10.24-6.016 21.248-10.688 33.024-13.696V129.344zm-261.248 134.72A382.336 382.336 0 0 0 129.344 480h258.688c3.008-11.776 7.68-22.848 13.696-33.024L218.752 264.064zM129.344 544a382.336 382.336 0 0 0 89.408 215.936l182.976-182.912A127.232 127.232 0 0 1 388.032 544H129.344zm134.72 261.248A382.336 382.336 0 0 0 480 894.656V635.968a127.232 127.232 0 0 1-33.024-13.696L264.064 805.248zM512 960a448 448 0 1 1 0-896 448 448 0 0 1 0 896zm0-384a64 64 0 1 0 0-128 64 64 0 0 0 0 128z"},null,-1),OCe=[ACe];function RCe(t,e,n,s,r,o){return S(),E("svg",ECe,OCe)}var DCe=ae(ICe,[["render",RCe],["__file","orange.vue"]]),FCe={name:"Paperclip"},MCe={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},PCe=I("path",{fill:"currentColor",d:"M602.496 240.448A192 192 0 1 1 874.048 512l-316.8 316.8A256 256 0 0 1 195.2 466.752L602.496 59.456l45.248 45.248L240.448 512A192 192 0 0 0 512 783.552l316.8-316.8a128 128 0 1 0-181.056-181.056L353.6 579.904a32 32 0 1 0 45.248 45.248l294.144-294.144 45.312 45.248L444.096 670.4a96 96 0 1 1-135.744-135.744l294.144-294.208z"},null,-1),LCe=[PCe];function zCe(t,e,n,s,r,o){return S(),E("svg",MCe,LCe)}var BCe=ae(FCe,[["render",zCe],["__file","paperclip.vue"]]),VCe={name:"PartlyCloudy"},HCe={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},WCe=I("path",{fill:"currentColor",d:"M598.4 895.872H328.192a256 256 0 0 1-34.496-510.528A352 352 0 1 1 598.4 895.872zm-271.36-64h272.256a288 288 0 1 0-248.512-417.664L335.04 445.44l-34.816 3.584a192 192 0 0 0 26.88 382.848z"},null,-1),UCe=I("path",{fill:"currentColor",d:"M139.84 501.888a256 256 0 1 1 417.856-277.12c-17.728 2.176-38.208 8.448-61.504 18.816A192 192 0 1 0 189.12 460.48a6003.84 6003.84 0 0 0-49.28 41.408z"},null,-1),GCe=[WCe,UCe];function jCe(t,e,n,s,r,o){return S(),E("svg",HCe,GCe)}var KCe=ae(VCe,[["render",jCe],["__file","partly-cloudy.vue"]]),qCe={name:"Pear"},XCe={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},YCe=I("path",{fill:"currentColor",d:"M542.336 258.816a443.255 443.255 0 0 0-9.024 25.088 32 32 0 1 1-60.8-20.032l1.088-3.328a162.688 162.688 0 0 0-122.048 131.392l-17.088 102.72-20.736 15.36C256.192 552.704 224 610.88 224 672c0 120.576 126.4 224 288 224s288-103.424 288-224c0-61.12-32.192-119.296-89.728-161.92l-20.736-15.424-17.088-102.72a162.688 162.688 0 0 0-130.112-133.12zm-40.128-66.56c7.936-15.552 16.576-30.08 25.92-43.776 23.296-33.92 49.408-59.776 78.528-77.12a32 32 0 1 1 32.704 55.04c-20.544 12.224-40.064 31.552-58.432 58.304a316.608 316.608 0 0 0-9.792 15.104 226.688 226.688 0 0 1 164.48 181.568l12.8 77.248C819.456 511.36 864 587.392 864 672c0 159.04-157.568 288-352 288S160 831.04 160 672c0-84.608 44.608-160.64 115.584-213.376l12.8-77.248a226.624 226.624 0 0 1 213.76-189.184z"},null,-1),ZCe=[YCe];function JCe(t,e,n,s,r,o){return S(),E("svg",XCe,ZCe)}var QCe=ae(qCe,[["render",JCe],["__file","pear.vue"]]),eke={name:"PhoneFilled"},tke={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},nke=I("path",{fill:"currentColor",d:"M199.232 125.568 90.624 379.008a32 32 0 0 0 6.784 35.2l512.384 512.384a32 32 0 0 0 35.2 6.784l253.44-108.608a32 32 0 0 0 10.048-52.032L769.6 633.92a32 32 0 0 0-36.928-5.952l-130.176 65.088-271.488-271.552 65.024-130.176a32 32 0 0 0-5.952-36.928L251.2 115.52a32 32 0 0 0-51.968 10.048z"},null,-1),ske=[nke];function rke(t,e,n,s,r,o){return S(),E("svg",tke,ske)}var oke=ae(eke,[["render",rke],["__file","phone-filled.vue"]]),ake={name:"Phone"},ike={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},lke=I("path",{fill:"currentColor",d:"M79.36 432.256 591.744 944.64a32 32 0 0 0 35.2 6.784l253.44-108.544a32 32 0 0 0 9.984-52.032l-153.856-153.92a32 32 0 0 0-36.928-6.016l-69.888 34.944L358.08 394.24l35.008-69.888a32 32 0 0 0-5.952-36.928L233.152 133.568a32 32 0 0 0-52.032 10.048L72.512 397.056a32 32 0 0 0 6.784 35.2zm60.48-29.952 81.536-190.08L325.568 316.48l-24.64 49.216-20.608 41.216 32.576 32.64 271.552 271.552 32.64 32.64 41.216-20.672 49.28-24.576 104.192 104.128-190.08 81.472L139.84 402.304zM512 320v-64a256 256 0 0 1 256 256h-64a192 192 0 0 0-192-192zm0-192V64a448 448 0 0 1 448 448h-64a384 384 0 0 0-384-384z"},null,-1),uke=[lke];function cke(t,e,n,s,r,o){return S(),E("svg",ike,uke)}var dke=ae(ake,[["render",cke],["__file","phone.vue"]]),fke={name:"PictureFilled"},hke={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},pke=I("path",{fill:"currentColor",d:"M96 896a32 32 0 0 1-32-32V160a32 32 0 0 1 32-32h832a32 32 0 0 1 32 32v704a32 32 0 0 1-32 32H96zm315.52-228.48-68.928-68.928a32 32 0 0 0-45.248 0L128 768.064h778.688l-242.112-290.56a32 32 0 0 0-49.216 0L458.752 665.408a32 32 0 0 1-47.232 2.112zM256 384a96 96 0 1 0 192.064-.064A96 96 0 0 0 256 384z"},null,-1),mke=[pke];function gke(t,e,n,s,r,o){return S(),E("svg",hke,mke)}var wP=ae(fke,[["render",gke],["__file","picture-filled.vue"]]),vke={name:"PictureRounded"},yke={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},bke=I("path",{fill:"currentColor",d:"M512 128a384 384 0 1 0 0 768 384 384 0 0 0 0-768zm0-64a448 448 0 1 1 0 896 448 448 0 0 1 0-896z"},null,-1),wke=I("path",{fill:"currentColor",d:"M640 288q64 0 64 64t-64 64q-64 0-64-64t64-64zM214.656 790.656l-45.312-45.312 185.664-185.6a96 96 0 0 1 123.712-10.24l138.24 98.688a32 32 0 0 0 39.872-2.176L906.688 422.4l42.624 47.744L699.52 693.696a96 96 0 0 1-119.808 6.592l-138.24-98.752a32 32 0 0 0-41.152 3.456l-185.664 185.6z"},null,-1),_ke=[bke,wke];function $ke(t,e,n,s,r,o){return S(),E("svg",yke,_ke)}var xke=ae(vke,[["render",$ke],["__file","picture-rounded.vue"]]),Ske={name:"Picture"},Cke={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},kke=I("path",{fill:"currentColor",d:"M160 160v704h704V160H160zm-32-64h768a32 32 0 0 1 32 32v768a32 32 0 0 1-32 32H128a32 32 0 0 1-32-32V128a32 32 0 0 1 32-32z"},null,-1),Tke=I("path",{fill:"currentColor",d:"M384 288q64 0 64 64t-64 64q-64 0-64-64t64-64zM185.408 876.992l-50.816-38.912L350.72 556.032a96 96 0 0 1 134.592-17.856l1.856 1.472 122.88 99.136a32 32 0 0 0 44.992-4.864l216-269.888 49.92 39.936-215.808 269.824-.256.32a96 96 0 0 1-135.04 14.464l-122.88-99.072-.64-.512a32 32 0 0 0-44.8 5.952L185.408 876.992z"},null,-1),Nke=[kke,Tke];function Ike(t,e,n,s,r,o){return S(),E("svg",Cke,Nke)}var Eke=ae(Ske,[["render",Ike],["__file","picture.vue"]]),Ake={name:"PieChart"},Oke={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},Rke=I("path",{fill:"currentColor",d:"M448 68.48v64.832A384.128 384.128 0 0 0 512 896a384.128 384.128 0 0 0 378.688-320h64.768A448.128 448.128 0 0 1 64 512 448.128 448.128 0 0 1 448 68.48z"},null,-1),Dke=I("path",{fill:"currentColor",d:"M576 97.28V448h350.72A384.064 384.064 0 0 0 576 97.28zM512 64V33.152A448 448 0 0 1 990.848 512H512V64z"},null,-1),Fke=[Rke,Dke];function Mke(t,e,n,s,r,o){return S(),E("svg",Oke,Fke)}var Pke=ae(Ake,[["render",Mke],["__file","pie-chart.vue"]]),Lke={name:"Place"},zke={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},Bke=I("path",{fill:"currentColor",d:"M512 512a192 192 0 1 0 0-384 192 192 0 0 0 0 384zm0 64a256 256 0 1 1 0-512 256 256 0 0 1 0 512z"},null,-1),Vke=I("path",{fill:"currentColor",d:"M512 512a32 32 0 0 1 32 32v256a32 32 0 1 1-64 0V544a32 32 0 0 1 32-32z"},null,-1),Hke=I("path",{fill:"currentColor",d:"M384 649.088v64.96C269.76 732.352 192 771.904 192 800c0 37.696 139.904 96 320 96s320-58.304 320-96c0-28.16-77.76-67.648-192-85.952v-64.96C789.12 671.04 896 730.368 896 800c0 88.32-171.904 160-384 160s-384-71.68-384-160c0-69.696 106.88-128.96 256-150.912z"},null,-1),Wke=[Bke,Vke,Hke];function Uke(t,e,n,s,r,o){return S(),E("svg",zke,Wke)}var Gke=ae(Lke,[["render",Uke],["__file","place.vue"]]),jke={name:"Platform"},Kke={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},qke=I("path",{fill:"currentColor",d:"M448 832v-64h128v64h192v64H256v-64h192zM128 704V128h768v576H128z"},null,-1),Xke=[qke];function Yke(t,e,n,s,r,o){return S(),E("svg",Kke,Xke)}var Zke=ae(jke,[["render",Yke],["__file","platform.vue"]]),Jke={name:"Plus"},Qke={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},e8e=I("path",{fill:"currentColor",d:"M480 480V128a32 32 0 0 1 64 0v352h352a32 32 0 1 1 0 64H544v352a32 32 0 1 1-64 0V544H128a32 32 0 0 1 0-64h352z"},null,-1),t8e=[e8e];function n8e(t,e,n,s,r,o){return S(),E("svg",Qke,t8e)}var OC=ae(Jke,[["render",n8e],["__file","plus.vue"]]),s8e={name:"Pointer"},r8e={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},o8e=I("path",{fill:"currentColor",d:"M511.552 128c-35.584 0-64.384 28.8-64.384 64.448v516.48L274.048 570.88a94.272 94.272 0 0 0-112.896-3.456 44.416 44.416 0 0 0-8.96 62.208L332.8 870.4A64 64 0 0 0 384 896h512V575.232a64 64 0 0 0-45.632-61.312l-205.952-61.76A96 96 0 0 1 576 360.192V192.448C576 156.8 547.2 128 511.552 128zM359.04 556.8l24.128 19.2V192.448a128.448 128.448 0 1 1 256.832 0v167.744a32 32 0 0 0 22.784 30.656l206.016 61.76A128 128 0 0 1 960 575.232V896a64 64 0 0 1-64 64H384a128 128 0 0 1-102.4-51.2L101.056 668.032A108.416 108.416 0 0 1 128 512.512a158.272 158.272 0 0 1 185.984 8.32L359.04 556.8z"},null,-1),a8e=[o8e];function i8e(t,e,n,s,r,o){return S(),E("svg",r8e,a8e)}var l8e=ae(s8e,[["render",i8e],["__file","pointer.vue"]]),u8e={name:"Position"},c8e={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},d8e=I("path",{fill:"currentColor",d:"m249.6 417.088 319.744 43.072 39.168 310.272L845.12 178.88 249.6 417.088zm-129.024 47.168a32 32 0 0 1-7.68-61.44l777.792-311.04a32 32 0 0 1 41.6 41.6l-310.336 775.68a32 32 0 0 1-61.44-7.808L512 516.992l-391.424-52.736z"},null,-1),f8e=[d8e];function h8e(t,e,n,s,r,o){return S(),E("svg",c8e,f8e)}var p8e=ae(u8e,[["render",h8e],["__file","position.vue"]]),m8e={name:"Postcard"},g8e={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},v8e=I("path",{fill:"currentColor",d:"M160 224a32 32 0 0 0-32 32v512a32 32 0 0 0 32 32h704a32 32 0 0 0 32-32V256a32 32 0 0 0-32-32H160zm0-64h704a96 96 0 0 1 96 96v512a96 96 0 0 1-96 96H160a96 96 0 0 1-96-96V256a96 96 0 0 1 96-96z"},null,-1),y8e=I("path",{fill:"currentColor",d:"M704 320a64 64 0 1 1 0 128 64 64 0 0 1 0-128zM288 448h256q32 0 32 32t-32 32H288q-32 0-32-32t32-32zm0 128h256q32 0 32 32t-32 32H288q-32 0-32-32t32-32z"},null,-1),b8e=[v8e,y8e];function w8e(t,e,n,s,r,o){return S(),E("svg",g8e,b8e)}var _8e=ae(m8e,[["render",w8e],["__file","postcard.vue"]]),$8e={name:"Pouring"},x8e={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},S8e=I("path",{fill:"currentColor",d:"m739.328 291.328-35.2-6.592-12.8-33.408a192.064 192.064 0 0 0-365.952 23.232l-9.92 40.896-41.472 7.04a176.32 176.32 0 0 0-146.24 173.568c0 97.28 78.72 175.936 175.808 175.936h400a192 192 0 0 0 35.776-380.672zM959.552 480a256 256 0 0 1-256 256h-400A239.808 239.808 0 0 1 63.744 496.192a240.32 240.32 0 0 1 199.488-236.8 256.128 256.128 0 0 1 487.872-30.976A256.064 256.064 0 0 1 959.552 480zM224 800a32 32 0 0 1 32 32v96a32 32 0 1 1-64 0v-96a32 32 0 0 1 32-32zm192 0a32 32 0 0 1 32 32v96a32 32 0 1 1-64 0v-96a32 32 0 0 1 32-32zm192 0a32 32 0 0 1 32 32v96a32 32 0 1 1-64 0v-96a32 32 0 0 1 32-32zm192 0a32 32 0 0 1 32 32v96a32 32 0 1 1-64 0v-96a32 32 0 0 1 32-32z"},null,-1),C8e=[S8e];function k8e(t,e,n,s,r,o){return S(),E("svg",x8e,C8e)}var T8e=ae($8e,[["render",k8e],["__file","pouring.vue"]]),N8e={name:"Present"},I8e={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},E8e=I("path",{fill:"currentColor",d:"M480 896V640H192v-64h288V320H192v576h288zm64 0h288V320H544v256h288v64H544v256zM128 256h768v672a32 32 0 0 1-32 32H160a32 32 0 0 1-32-32V256z"},null,-1),A8e=I("path",{fill:"currentColor",d:"M96 256h832q32 0 32 32t-32 32H96q-32 0-32-32t32-32z"},null,-1),O8e=I("path",{fill:"currentColor",d:"M416 256a64 64 0 1 0 0-128 64 64 0 0 0 0 128zm0 64a128 128 0 1 1 0-256 128 128 0 0 1 0 256z"},null,-1),R8e=I("path",{fill:"currentColor",d:"M608 256a64 64 0 1 0 0-128 64 64 0 0 0 0 128zm0 64a128 128 0 1 1 0-256 128 128 0 0 1 0 256z"},null,-1),D8e=[E8e,A8e,O8e,R8e];function F8e(t,e,n,s,r,o){return S(),E("svg",I8e,D8e)}var M8e=ae(N8e,[["render",F8e],["__file","present.vue"]]),P8e={name:"PriceTag"},L8e={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},z8e=I("path",{fill:"currentColor",d:"M224 318.336V896h576V318.336L552.512 115.84a64 64 0 0 0-81.024 0L224 318.336zM593.024 66.304l259.2 212.096A32 32 0 0 1 864 303.168V928a32 32 0 0 1-32 32H192a32 32 0 0 1-32-32V303.168a32 32 0 0 1 11.712-24.768l259.2-212.096a128 128 0 0 1 162.112 0z"},null,-1),B8e=I("path",{fill:"currentColor",d:"M512 448a64 64 0 1 0 0-128 64 64 0 0 0 0 128zm0 64a128 128 0 1 1 0-256 128 128 0 0 1 0 256z"},null,-1),V8e=[z8e,B8e];function H8e(t,e,n,s,r,o){return S(),E("svg",L8e,V8e)}var W8e=ae(P8e,[["render",H8e],["__file","price-tag.vue"]]),U8e={name:"Printer"},G8e={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},j8e=I("path",{fill:"currentColor",d:"M256 768H105.024c-14.272 0-19.456-1.472-24.64-4.288a29.056 29.056 0 0 1-12.16-12.096C65.536 746.432 64 741.248 64 727.04V379.072c0-42.816 4.48-58.304 12.8-73.984 8.384-15.616 20.672-27.904 36.288-36.288 15.68-8.32 31.168-12.8 73.984-12.8H256V64h512v192h68.928c42.816 0 58.304 4.48 73.984 12.8 15.616 8.384 27.904 20.672 36.288 36.288 8.32 15.68 12.8 31.168 12.8 73.984v347.904c0 14.272-1.472 19.456-4.288 24.64a29.056 29.056 0 0 1-12.096 12.16c-5.184 2.752-10.368 4.224-24.64 4.224H768v192H256V768zm64-192v320h384V576H320zm-64 128V512h512v192h128V379.072c0-29.376-1.408-36.48-5.248-43.776a23.296 23.296 0 0 0-10.048-10.048c-7.232-3.84-14.4-5.248-43.776-5.248H187.072c-29.376 0-36.48 1.408-43.776 5.248a23.296 23.296 0 0 0-10.048 10.048c-3.84 7.232-5.248 14.4-5.248 43.776V704h128zm64-448h384V128H320v128zm-64 128h64v64h-64v-64zm128 0h64v64h-64v-64z"},null,-1),K8e=[j8e];function q8e(t,e,n,s,r,o){return S(),E("svg",G8e,K8e)}var X8e=ae(U8e,[["render",q8e],["__file","printer.vue"]]),Y8e={name:"Promotion"},Z8e={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},J8e=I("path",{fill:"currentColor",d:"m64 448 832-320-128 704-446.08-243.328L832 192 242.816 545.472 64 448zm256 512V657.024L512 768 320 960z"},null,-1),Q8e=[J8e];function eTe(t,e,n,s,r,o){return S(),E("svg",Z8e,Q8e)}var tTe=ae(Y8e,[["render",eTe],["__file","promotion.vue"]]),nTe={name:"QuartzWatch"},sTe={xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 1024 1024",style:{"enable-background":"new 0 0 1024 1024"},"xml:space":"preserve"},rTe=I("path",{d:"M422.02 602.01v-.03c-6.68-5.99-14.35-8.83-23.01-8.51-8.67.32-16.17 3.66-22.5 10.02-6.33 6.36-9.5 13.7-9.5 22.02s3 15.82 8.99 22.5c8.68 8.68 19.02 11.35 31.01 8s19.49-10.85 22.5-22.5c3.01-11.65.51-22.15-7.49-31.49v-.01zM384 512c0-9.35-3-17.02-8.99-23.01-6-5.99-13.66-8.99-23.01-8.99-9.35 0-17.02 3-23.01 8.99-5.99 6-8.99 13.66-8.99 23.01s3 17.02 8.99 23.01c6 5.99 13.66 8.99 23.01 8.99 9.35 0 17.02-3 23.01-8.99 5.99-6 8.99-13.67 8.99-23.01zm6.53-82.49c11.65 3.01 22.15.51 31.49-7.49h.04c5.99-6.68 8.83-14.34 8.51-23.01-.32-8.67-3.66-16.16-10.02-22.5-6.36-6.33-13.7-9.5-22.02-9.5s-15.82 3-22.5 8.99c-8.68 8.69-11.35 19.02-8 31.01 3.35 11.99 10.85 19.49 22.5 22.5zm242.94 0c11.67-3.03 19.01-10.37 22.02-22.02 3.01-11.65.51-22.15-7.49-31.49h.01c-6.68-5.99-14.18-8.99-22.5-8.99s-15.66 3.16-22.02 9.5c-6.36 6.34-9.7 13.84-10.02 22.5-.32 8.66 2.52 16.33 8.51 23.01 9.32 8.02 19.82 10.52 31.49 7.49zM512 640c-9.35 0-17.02 3-23.01 8.99-5.99 6-8.99 13.66-8.99 23.01s3 17.02 8.99 23.01c6 5.99 13.67 8.99 23.01 8.99 9.35 0 17.02-3 23.01-8.99 5.99-6 8.99-13.66 8.99-23.01s-3-17.02-8.99-23.01c-6-5.99-13.66-8.99-23.01-8.99zm183.01-151.01c-6-5.99-13.66-8.99-23.01-8.99s-17.02 3-23.01 8.99c-5.99 6-8.99 13.66-8.99 23.01s3 17.02 8.99 23.01c6 5.99 13.66 8.99 23.01 8.99s17.02-3 23.01-8.99c5.99-6 8.99-13.67 8.99-23.01 0-9.35-3-17.02-8.99-23.01z",fill:"currentColor"},null,-1),oTe=I("path",{d:"M832 512c-2-90.67-33.17-166.17-93.5-226.5-20.43-20.42-42.6-37.49-66.5-51.23V64H352v170.26c-23.9 13.74-46.07 30.81-66.5 51.24-60.33 60.33-91.49 135.83-93.5 226.5 2 90.67 33.17 166.17 93.5 226.5 20.43 20.43 42.6 37.5 66.5 51.24V960h320V789.74c23.9-13.74 46.07-30.81 66.5-51.24 60.33-60.34 91.49-135.83 93.5-226.5zM416 128h192v78.69c-29.85-9.03-61.85-13.93-96-14.69-34.15.75-66.15 5.65-96 14.68V128zm192 768H416v-78.68c29.85 9.03 61.85 13.93 96 14.68 34.15-.75 66.15-5.65 96-14.68V896zm-96-128c-72.66-2.01-132.99-27.01-180.99-75.01S258.01 584.66 256 512c2.01-72.66 27.01-132.99 75.01-180.99S439.34 258.01 512 256c72.66 2.01 132.99 27.01 180.99 75.01S765.99 439.34 768 512c-2.01 72.66-27.01 132.99-75.01 180.99S584.66 765.99 512 768z",fill:"currentColor"},null,-1),aTe=I("path",{d:"M512 320c-9.35 0-17.02 3-23.01 8.99-5.99 6-8.99 13.66-8.99 23.01 0 9.35 3 17.02 8.99 23.01 6 5.99 13.67 8.99 23.01 8.99 9.35 0 17.02-3 23.01-8.99 5.99-6 8.99-13.66 8.99-23.01 0-9.35-3-17.02-8.99-23.01-6-5.99-13.66-8.99-23.01-8.99zm112.99 273.5c-8.66-.32-16.33 2.52-23.01 8.51-7.98 9.32-10.48 19.82-7.49 31.49s10.49 19.17 22.5 22.5 22.35.66 31.01-8v.04c5.99-6.68 8.99-14.18 8.99-22.5s-3.16-15.66-9.5-22.02-13.84-9.7-22.5-10.02z",fill:"currentColor"},null,-1),iTe=[rTe,oTe,aTe];function lTe(t,e,n,s,r,o){return S(),E("svg",sTe,iTe)}var uTe=ae(nTe,[["render",lTe],["__file","quartz-watch.vue"]]),cTe={name:"QuestionFilled"},dTe={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},fTe=I("path",{fill:"currentColor",d:"M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896zm23.744 191.488c-52.096 0-92.928 14.784-123.2 44.352-30.976 29.568-45.76 70.4-45.76 122.496h80.256c0-29.568 5.632-52.8 17.6-68.992 13.376-19.712 35.2-28.864 66.176-28.864 23.936 0 42.944 6.336 56.32 19.712 12.672 13.376 19.712 31.68 19.712 54.912 0 17.6-6.336 34.496-19.008 49.984l-8.448 9.856c-45.76 40.832-73.216 70.4-82.368 89.408-9.856 19.008-14.08 42.24-14.08 68.992v9.856h80.96v-9.856c0-16.896 3.52-31.68 10.56-45.76 6.336-12.672 15.488-24.64 28.16-35.2 33.792-29.568 54.208-48.576 60.544-55.616 16.896-22.528 26.048-51.392 26.048-86.592 0-42.944-14.08-76.736-42.24-101.376-28.16-25.344-65.472-37.312-111.232-37.312zm-12.672 406.208a54.272 54.272 0 0 0-38.72 14.784 49.408 49.408 0 0 0-15.488 38.016c0 15.488 4.928 28.16 15.488 38.016A54.848 54.848 0 0 0 523.072 768c15.488 0 28.16-4.928 38.72-14.784a51.52 51.52 0 0 0 16.192-38.72 51.968 51.968 0 0 0-15.488-38.016 55.936 55.936 0 0 0-39.424-14.784z"},null,-1),hTe=[fTe];function pTe(t,e,n,s,r,o){return S(),E("svg",dTe,hTe)}var _P=ae(cTe,[["render",pTe],["__file","question-filled.vue"]]),mTe={name:"Rank"},gTe={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},vTe=I("path",{fill:"currentColor",d:"m186.496 544 41.408 41.344a32 32 0 1 1-45.248 45.312l-96-96a32 32 0 0 1 0-45.312l96-96a32 32 0 1 1 45.248 45.312L186.496 480h290.816V186.432l-41.472 41.472a32 32 0 1 1-45.248-45.184l96-96.128a32 32 0 0 1 45.312 0l96 96.064a32 32 0 0 1-45.248 45.184l-41.344-41.28V480H832l-41.344-41.344a32 32 0 0 1 45.248-45.312l96 96a32 32 0 0 1 0 45.312l-96 96a32 32 0 0 1-45.248-45.312L832 544H541.312v293.44l41.344-41.28a32 32 0 1 1 45.248 45.248l-96 96a32 32 0 0 1-45.312 0l-96-96a32 32 0 1 1 45.312-45.248l41.408 41.408V544H186.496z"},null,-1),yTe=[vTe];function bTe(t,e,n,s,r,o){return S(),E("svg",gTe,yTe)}var wTe=ae(mTe,[["render",bTe],["__file","rank.vue"]]),_Te={name:"ReadingLamp"},$Te={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},xTe=I("path",{fill:"currentColor",d:"M352 896h320q32 0 32 32t-32 32H352q-32 0-32-32t32-32zm-44.672-768-99.52 448h608.384l-99.52-448H307.328zm-25.6-64h460.608a32 32 0 0 1 31.232 25.088l113.792 512A32 32 0 0 1 856.128 640H167.872a32 32 0 0 1-31.232-38.912l113.792-512A32 32 0 0 1 281.664 64z"},null,-1),STe=I("path",{fill:"currentColor",d:"M672 576q32 0 32 32v128q0 32-32 32t-32-32V608q0-32 32-32zm-192-.064h64V960h-64z"},null,-1),CTe=[xTe,STe];function kTe(t,e,n,s,r,o){return S(),E("svg",$Te,CTe)}var TTe=ae(_Te,[["render",kTe],["__file","reading-lamp.vue"]]),NTe={name:"Reading"},ITe={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},ETe=I("path",{fill:"currentColor",d:"m512 863.36 384-54.848v-638.72L525.568 222.72a96 96 0 0 1-27.136 0L128 169.792v638.72l384 54.848zM137.024 106.432l370.432 52.928a32 32 0 0 0 9.088 0l370.432-52.928A64 64 0 0 1 960 169.792v638.72a64 64 0 0 1-54.976 63.36l-388.48 55.488a32 32 0 0 1-9.088 0l-388.48-55.488A64 64 0 0 1 64 808.512v-638.72a64 64 0 0 1 73.024-63.36z"},null,-1),ATe=I("path",{fill:"currentColor",d:"M480 192h64v704h-64z"},null,-1),OTe=[ETe,ATe];function RTe(t,e,n,s,r,o){return S(),E("svg",ITe,OTe)}var DTe=ae(NTe,[["render",RTe],["__file","reading.vue"]]),FTe={name:"RefreshLeft"},MTe={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},PTe=I("path",{fill:"currentColor",d:"M289.088 296.704h92.992a32 32 0 0 1 0 64H232.96a32 32 0 0 1-32-32V179.712a32 32 0 0 1 64 0v50.56a384 384 0 0 1 643.84 282.88 384 384 0 0 1-383.936 384 384 384 0 0 1-384-384h64a320 320 0 1 0 640 0 320 320 0 0 0-555.712-216.448z"},null,-1),LTe=[PTe];function zTe(t,e,n,s,r,o){return S(),E("svg",MTe,LTe)}var $P=ae(FTe,[["render",zTe],["__file","refresh-left.vue"]]),BTe={name:"RefreshRight"},VTe={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},HTe=I("path",{fill:"currentColor",d:"M784.512 230.272v-50.56a32 32 0 1 1 64 0v149.056a32 32 0 0 1-32 32H667.52a32 32 0 1 1 0-64h92.992A320 320 0 1 0 524.8 833.152a320 320 0 0 0 320-320h64a384 384 0 0 1-384 384 384 384 0 0 1-384-384 384 384 0 0 1 643.712-282.88z"},null,-1),WTe=[HTe];function UTe(t,e,n,s,r,o){return S(),E("svg",VTe,WTe)}var xP=ae(BTe,[["render",UTe],["__file","refresh-right.vue"]]),GTe={name:"Refresh"},jTe={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},KTe=I("path",{fill:"currentColor",d:"M771.776 794.88A384 384 0 0 1 128 512h64a320 320 0 0 0 555.712 216.448H654.72a32 32 0 1 1 0-64h149.056a32 32 0 0 1 32 32v148.928a32 32 0 1 1-64 0v-50.56zM276.288 295.616h92.992a32 32 0 0 1 0 64H220.16a32 32 0 0 1-32-32V178.56a32 32 0 0 1 64 0v50.56A384 384 0 0 1 896.128 512h-64a320 320 0 0 0-555.776-216.384z"},null,-1),qTe=[KTe];function XTe(t,e,n,s,r,o){return S(),E("svg",jTe,qTe)}var YTe=ae(GTe,[["render",XTe],["__file","refresh.vue"]]),ZTe={name:"Refrigerator"},JTe={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},QTe=I("path",{fill:"currentColor",d:"M256 448h512V160a32 32 0 0 0-32-32H288a32 32 0 0 0-32 32v288zm0 64v352a32 32 0 0 0 32 32h448a32 32 0 0 0 32-32V512H256zm32-448h448a96 96 0 0 1 96 96v704a96 96 0 0 1-96 96H288a96 96 0 0 1-96-96V160a96 96 0 0 1 96-96zm32 224h64v96h-64v-96zm0 288h64v96h-64v-96z"},null,-1),eNe=[QTe];function tNe(t,e,n,s,r,o){return S(),E("svg",JTe,eNe)}var nNe=ae(ZTe,[["render",tNe],["__file","refrigerator.vue"]]),sNe={name:"RemoveFilled"},rNe={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},oNe=I("path",{fill:"currentColor",d:"M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896zM288 512a38.4 38.4 0 0 0 38.4 38.4h371.2a38.4 38.4 0 0 0 0-76.8H326.4A38.4 38.4 0 0 0 288 512z"},null,-1),aNe=[oNe];function iNe(t,e,n,s,r,o){return S(),E("svg",rNe,aNe)}var lNe=ae(sNe,[["render",iNe],["__file","remove-filled.vue"]]),uNe={name:"Remove"},cNe={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},dNe=I("path",{fill:"currentColor",d:"M352 480h320a32 32 0 1 1 0 64H352a32 32 0 0 1 0-64z"},null,-1),fNe=I("path",{fill:"currentColor",d:"M512 896a384 384 0 1 0 0-768 384 384 0 0 0 0 768zm0 64a448 448 0 1 1 0-896 448 448 0 0 1 0 896z"},null,-1),hNe=[dNe,fNe];function pNe(t,e,n,s,r,o){return S(),E("svg",cNe,hNe)}var mNe=ae(uNe,[["render",pNe],["__file","remove.vue"]]),gNe={name:"Right"},vNe={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},yNe=I("path",{fill:"currentColor",d:"M754.752 480H160a32 32 0 1 0 0 64h594.752L521.344 777.344a32 32 0 0 0 45.312 45.312l288-288a32 32 0 0 0 0-45.312l-288-288a32 32 0 1 0-45.312 45.312L754.752 480z"},null,-1),bNe=[yNe];function wNe(t,e,n,s,r,o){return S(),E("svg",vNe,bNe)}var _Ne=ae(gNe,[["render",wNe],["__file","right.vue"]]),$Ne={name:"ScaleToOriginal"},xNe={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},SNe=I("path",{fill:"currentColor",d:"M813.176 180.706a60.235 60.235 0 0 1 60.236 60.235v481.883a60.235 60.235 0 0 1-60.236 60.235H210.824a60.235 60.235 0 0 1-60.236-60.235V240.94a60.235 60.235 0 0 1 60.236-60.235h602.352zm0-60.235H210.824A120.47 120.47 0 0 0 90.353 240.94v481.883a120.47 120.47 0 0 0 120.47 120.47h602.353a120.47 120.47 0 0 0 120.471-120.47V240.94a120.47 120.47 0 0 0-120.47-120.47zm-120.47 180.705a30.118 30.118 0 0 0-30.118 30.118v301.177a30.118 30.118 0 0 0 60.236 0V331.294a30.118 30.118 0 0 0-30.118-30.118zm-361.412 0a30.118 30.118 0 0 0-30.118 30.118v301.177a30.118 30.118 0 1 0 60.236 0V331.294a30.118 30.118 0 0 0-30.118-30.118zM512 361.412a30.118 30.118 0 0 0-30.118 30.117v30.118a30.118 30.118 0 0 0 60.236 0V391.53A30.118 30.118 0 0 0 512 361.412zM512 512a30.118 30.118 0 0 0-30.118 30.118v30.117a30.118 30.118 0 0 0 60.236 0v-30.117A30.118 30.118 0 0 0 512 512z"},null,-1),CNe=[SNe];function kNe(t,e,n,s,r,o){return S(),E("svg",xNe,CNe)}var SP=ae($Ne,[["render",kNe],["__file","scale-to-original.vue"]]),TNe={name:"School"},NNe={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},INe=I("path",{fill:"currentColor",d:"M224 128v704h576V128H224zm-32-64h640a32 32 0 0 1 32 32v768a32 32 0 0 1-32 32H192a32 32 0 0 1-32-32V96a32 32 0 0 1 32-32z"},null,-1),ENe=I("path",{fill:"currentColor",d:"M64 832h896v64H64zm256-640h128v96H320z"},null,-1),ANe=I("path",{fill:"currentColor",d:"M384 832h256v-64a128 128 0 1 0-256 0v64zm128-256a192 192 0 0 1 192 192v128H320V768a192 192 0 0 1 192-192zM320 384h128v96H320zm256-192h128v96H576zm0 192h128v96H576z"},null,-1),ONe=[INe,ENe,ANe];function RNe(t,e,n,s,r,o){return S(),E("svg",NNe,ONe)}var DNe=ae(TNe,[["render",RNe],["__file","school.vue"]]),FNe={name:"Scissor"},MNe={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},PNe=I("path",{fill:"currentColor",d:"m512.064 578.368-106.88 152.768a160 160 0 1 1-23.36-78.208L472.96 522.56 196.864 128.256a32 32 0 1 1 52.48-36.736l393.024 561.344a160 160 0 1 1-23.36 78.208l-106.88-152.704zm54.4-189.248 208.384-297.6a32 32 0 0 1 52.48 36.736l-221.76 316.672-39.04-55.808zm-376.32 425.856a96 96 0 1 0 110.144-157.248 96 96 0 0 0-110.08 157.248zm643.84 0a96 96 0 1 0-110.08-157.248 96 96 0 0 0 110.08 157.248z"},null,-1),LNe=[PNe];function zNe(t,e,n,s,r,o){return S(),E("svg",MNe,LNe)}var BNe=ae(FNe,[["render",zNe],["__file","scissor.vue"]]),VNe={name:"Search"},HNe={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},WNe=I("path",{fill:"currentColor",d:"m795.904 750.72 124.992 124.928a32 32 0 0 1-45.248 45.248L750.656 795.904a416 416 0 1 1 45.248-45.248zM480 832a352 352 0 1 0 0-704 352 352 0 0 0 0 704z"},null,-1),UNe=[WNe];function GNe(t,e,n,s,r,o){return S(),E("svg",HNe,UNe)}var CP=ae(VNe,[["render",GNe],["__file","search.vue"]]),jNe={name:"Select"},KNe={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},qNe=I("path",{fill:"currentColor",d:"M77.248 415.04a64 64 0 0 1 90.496 0l226.304 226.304L846.528 188.8a64 64 0 1 1 90.56 90.496l-543.04 543.04-316.8-316.8a64 64 0 0 1 0-90.496z"},null,-1),XNe=[qNe];function YNe(t,e,n,s,r,o){return S(),E("svg",KNe,XNe)}var ZNe=ae(jNe,[["render",YNe],["__file","select.vue"]]),JNe={name:"Sell"},QNe={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},eIe=I("path",{fill:"currentColor",d:"M704 288h131.072a32 32 0 0 1 31.808 28.8L886.4 512h-64.384l-16-160H704v96a32 32 0 1 1-64 0v-96H384v96a32 32 0 0 1-64 0v-96H217.92l-51.2 512H512v64H131.328a32 32 0 0 1-31.808-35.2l57.6-576a32 32 0 0 1 31.808-28.8H320v-22.336C320 154.688 405.504 64 512 64s192 90.688 192 201.664v22.4zm-64 0v-22.336C640 189.248 582.272 128 512 128c-70.272 0-128 61.248-128 137.664v22.4h256zm201.408 483.84L768 698.496V928a32 32 0 1 1-64 0V698.496l-73.344 73.344a32 32 0 1 1-45.248-45.248l128-128a32 32 0 0 1 45.248 0l128 128a32 32 0 1 1-45.248 45.248z"},null,-1),tIe=[eIe];function nIe(t,e,n,s,r,o){return S(),E("svg",QNe,tIe)}var sIe=ae(JNe,[["render",nIe],["__file","sell.vue"]]),rIe={name:"SemiSelect"},oIe={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},aIe=I("path",{fill:"currentColor",d:"M128 448h768q64 0 64 64t-64 64H128q-64 0-64-64t64-64z"},null,-1),iIe=[aIe];function lIe(t,e,n,s,r,o){return S(),E("svg",oIe,iIe)}var uIe=ae(rIe,[["render",lIe],["__file","semi-select.vue"]]),cIe={name:"Service"},dIe={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},fIe=I("path",{fill:"currentColor",d:"M864 409.6a192 192 0 0 1-37.888 349.44A256.064 256.064 0 0 1 576 960h-96a32 32 0 1 1 0-64h96a192.064 192.064 0 0 0 181.12-128H736a32 32 0 0 1-32-32V416a32 32 0 0 1 32-32h32c10.368 0 20.544.832 30.528 2.432a288 288 0 0 0-573.056 0A193.235 193.235 0 0 1 256 384h32a32 32 0 0 1 32 32v320a32 32 0 0 1-32 32h-32a192 192 0 0 1-96-358.4 352 352 0 0 1 704 0zM256 448a128 128 0 1 0 0 256V448zm640 128a128 128 0 0 0-128-128v256a128 128 0 0 0 128-128z"},null,-1),hIe=[fIe];function pIe(t,e,n,s,r,o){return S(),E("svg",dIe,hIe)}var mIe=ae(cIe,[["render",pIe],["__file","service.vue"]]),gIe={name:"SetUp"},vIe={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},yIe=I("path",{fill:"currentColor",d:"M224 160a64 64 0 0 0-64 64v576a64 64 0 0 0 64 64h576a64 64 0 0 0 64-64V224a64 64 0 0 0-64-64H224zm0-64h576a128 128 0 0 1 128 128v576a128 128 0 0 1-128 128H224A128 128 0 0 1 96 800V224A128 128 0 0 1 224 96z"},null,-1),bIe=I("path",{fill:"currentColor",d:"M384 416a64 64 0 1 0 0-128 64 64 0 0 0 0 128zm0 64a128 128 0 1 1 0-256 128 128 0 0 1 0 256z"},null,-1),wIe=I("path",{fill:"currentColor",d:"M480 320h256q32 0 32 32t-32 32H480q-32 0-32-32t32-32zm160 416a64 64 0 1 0 0-128 64 64 0 0 0 0 128zm0 64a128 128 0 1 1 0-256 128 128 0 0 1 0 256z"},null,-1),_Ie=I("path",{fill:"currentColor",d:"M288 640h256q32 0 32 32t-32 32H288q-32 0-32-32t32-32z"},null,-1),$Ie=[yIe,bIe,wIe,_Ie];function xIe(t,e,n,s,r,o){return S(),E("svg",vIe,$Ie)}var SIe=ae(gIe,[["render",xIe],["__file","set-up.vue"]]),CIe={name:"Setting"},kIe={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},TIe=I("path",{fill:"currentColor",d:"M600.704 64a32 32 0 0 1 30.464 22.208l35.2 109.376c14.784 7.232 28.928 15.36 42.432 24.512l112.384-24.192a32 32 0 0 1 34.432 15.36L944.32 364.8a32 32 0 0 1-4.032 37.504l-77.12 85.12a357.12 357.12 0 0 1 0 49.024l77.12 85.248a32 32 0 0 1 4.032 37.504l-88.704 153.6a32 32 0 0 1-34.432 15.296L708.8 803.904c-13.44 9.088-27.648 17.28-42.368 24.512l-35.264 109.376A32 32 0 0 1 600.704 960H423.296a32 32 0 0 1-30.464-22.208L357.696 828.48a351.616 351.616 0 0 1-42.56-24.64l-112.32 24.256a32 32 0 0 1-34.432-15.36L79.68 659.2a32 32 0 0 1 4.032-37.504l77.12-85.248a357.12 357.12 0 0 1 0-48.896l-77.12-85.248A32 32 0 0 1 79.68 364.8l88.704-153.6a32 32 0 0 1 34.432-15.296l112.32 24.256c13.568-9.152 27.776-17.408 42.56-24.64l35.2-109.312A32 32 0 0 1 423.232 64H600.64zm-23.424 64H446.72l-36.352 113.088-24.512 11.968a294.113 294.113 0 0 0-34.816 20.096l-22.656 15.36-116.224-25.088-65.28 113.152 79.68 88.192-1.92 27.136a293.12 293.12 0 0 0 0 40.192l1.92 27.136-79.808 88.192 65.344 113.152 116.224-25.024 22.656 15.296a294.113 294.113 0 0 0 34.816 20.096l24.512 11.968L446.72 896h130.688l36.48-113.152 24.448-11.904a288.282 288.282 0 0 0 34.752-20.096l22.592-15.296 116.288 25.024 65.28-113.152-79.744-88.192 1.92-27.136a293.12 293.12 0 0 0 0-40.256l-1.92-27.136 79.808-88.128-65.344-113.152-116.288 24.96-22.592-15.232a287.616 287.616 0 0 0-34.752-20.096l-24.448-11.904L577.344 128zM512 320a192 192 0 1 1 0 384 192 192 0 0 1 0-384zm0 64a128 128 0 1 0 0 256 128 128 0 0 0 0-256z"},null,-1),NIe=[TIe];function IIe(t,e,n,s,r,o){return S(),E("svg",kIe,NIe)}var EIe=ae(CIe,[["render",IIe],["__file","setting.vue"]]),AIe={name:"Share"},OIe={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},RIe=I("path",{fill:"currentColor",d:"m679.872 348.8-301.76 188.608a127.808 127.808 0 0 1 5.12 52.16l279.936 104.96a128 128 0 1 1-22.464 59.904l-279.872-104.96a128 128 0 1 1-16.64-166.272l301.696-188.608a128 128 0 1 1 33.92 54.272z"},null,-1),DIe=[RIe];function FIe(t,e,n,s,r,o){return S(),E("svg",OIe,DIe)}var MIe=ae(AIe,[["render",FIe],["__file","share.vue"]]),PIe={name:"Ship"},LIe={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},zIe=I("path",{fill:"currentColor",d:"M512 386.88V448h405.568a32 32 0 0 1 30.72 40.768l-76.48 267.968A192 192 0 0 1 687.168 896H336.832a192 192 0 0 1-184.64-139.264L75.648 488.768A32 32 0 0 1 106.368 448H448V117.888a32 32 0 0 1 47.36-28.096l13.888 7.616L512 96v2.88l231.68 126.4a32 32 0 0 1-2.048 57.216L512 386.88zm0-70.272 144.768-65.792L512 171.84v144.768zM512 512H148.864l18.24 64H856.96l18.24-64H512zM185.408 640l28.352 99.2A128 128 0 0 0 336.832 832h350.336a128 128 0 0 0 123.072-92.8l28.352-99.2H185.408z"},null,-1),BIe=[zIe];function VIe(t,e,n,s,r,o){return S(),E("svg",LIe,BIe)}var HIe=ae(PIe,[["render",VIe],["__file","ship.vue"]]),WIe={name:"Shop"},UIe={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},GIe=I("path",{fill:"currentColor",d:"M704 704h64v192H256V704h64v64h384v-64zm188.544-152.192C894.528 559.616 896 567.616 896 576a96 96 0 1 1-192 0 96 96 0 1 1-192 0 96 96 0 1 1-192 0 96 96 0 1 1-192 0c0-8.384 1.408-16.384 3.392-24.192L192 128h640l60.544 423.808z"},null,-1),jIe=[GIe];function KIe(t,e,n,s,r,o){return S(),E("svg",UIe,jIe)}var qIe=ae(WIe,[["render",KIe],["__file","shop.vue"]]),XIe={name:"ShoppingBag"},YIe={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},ZIe=I("path",{fill:"currentColor",d:"M704 320v96a32 32 0 0 1-32 32h-32V320H384v128h-32a32 32 0 0 1-32-32v-96H192v576h640V320H704zm-384-64a192 192 0 1 1 384 0h160a32 32 0 0 1 32 32v640a32 32 0 0 1-32 32H160a32 32 0 0 1-32-32V288a32 32 0 0 1 32-32h160zm64 0h256a128 128 0 1 0-256 0z"},null,-1),JIe=I("path",{fill:"currentColor",d:"M192 704h640v64H192z"},null,-1),QIe=[ZIe,JIe];function eEe(t,e,n,s,r,o){return S(),E("svg",YIe,QIe)}var tEe=ae(XIe,[["render",eEe],["__file","shopping-bag.vue"]]),nEe={name:"ShoppingCartFull"},sEe={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},rEe=I("path",{fill:"currentColor",d:"M432 928a48 48 0 1 1 0-96 48 48 0 0 1 0 96zm320 0a48 48 0 1 1 0-96 48 48 0 0 1 0 96zM96 128a32 32 0 0 1 0-64h160a32 32 0 0 1 31.36 25.728L320.64 256H928a32 32 0 0 1 31.296 38.72l-96 448A32 32 0 0 1 832 768H384a32 32 0 0 1-31.36-25.728L229.76 128H96zm314.24 576h395.904l82.304-384H333.44l76.8 384z"},null,-1),oEe=I("path",{fill:"currentColor",d:"M699.648 256 608 145.984 516.352 256h183.296zm-140.8-151.04a64 64 0 0 1 98.304 0L836.352 320H379.648l179.2-215.04z"},null,-1),aEe=[rEe,oEe];function iEe(t,e,n,s,r,o){return S(),E("svg",sEe,aEe)}var lEe=ae(nEe,[["render",iEe],["__file","shopping-cart-full.vue"]]),uEe={name:"ShoppingCart"},cEe={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},dEe=I("path",{fill:"currentColor",d:"M432 928a48 48 0 1 1 0-96 48 48 0 0 1 0 96zm320 0a48 48 0 1 1 0-96 48 48 0 0 1 0 96zM96 128a32 32 0 0 1 0-64h160a32 32 0 0 1 31.36 25.728L320.64 256H928a32 32 0 0 1 31.296 38.72l-96 448A32 32 0 0 1 832 768H384a32 32 0 0 1-31.36-25.728L229.76 128H96zm314.24 576h395.904l82.304-384H333.44l76.8 384z"},null,-1),fEe=[dEe];function hEe(t,e,n,s,r,o){return S(),E("svg",cEe,fEe)}var pEe=ae(uEe,[["render",hEe],["__file","shopping-cart.vue"]]),mEe={name:"ShoppingTrolley"},gEe={xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 1024 1024",style:{"enable-background":"new 0 0 1024 1024"},"xml:space":"preserve"},vEe=I("path",{d:"M368 833c-13.3 0-24.5 4.5-33.5 13.5S321 866.7 321 880s4.5 24.5 13.5 33.5 20.2 13.8 33.5 14.5c13.3-.7 24.5-5.5 33.5-14.5S415 893.3 415 880s-4.5-24.5-13.5-33.5S381.3 833 368 833zm439-193c7.4 0 13.8-2.2 19.5-6.5S836 623.3 838 616l112-448c2-10-.2-19.2-6.5-27.5S929 128 919 128H96c-9.3 0-17 3-23 9s-9 13.7-9 23 3 17 9 23 13.7 9 23 9h96v576h672c9.3 0 17-3 23-9s9-13.7 9-23-3-17-9-23-13.7-9-23-9H256v-64h551zM256 192h622l-96 384H256V192zm432 641c-13.3 0-24.5 4.5-33.5 13.5S641 866.7 641 880s4.5 24.5 13.5 33.5 20.2 13.8 33.5 14.5c13.3-.7 24.5-5.5 33.5-14.5S735 893.3 735 880s-4.5-24.5-13.5-33.5S701.3 833 688 833z",fill:"currentColor"},null,-1),yEe=[vEe];function bEe(t,e,n,s,r,o){return S(),E("svg",gEe,yEe)}var wEe=ae(mEe,[["render",bEe],["__file","shopping-trolley.vue"]]),_Ee={name:"Smoking"},$Ee={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},xEe=I("path",{fill:"currentColor",d:"M256 576v128h640V576H256zm-32-64h704a32 32 0 0 1 32 32v192a32 32 0 0 1-32 32H224a32 32 0 0 1-32-32V544a32 32 0 0 1 32-32z"},null,-1),SEe=I("path",{fill:"currentColor",d:"M704 576h64v128h-64zM256 64h64v320h-64zM128 192h64v192h-64zM64 512h64v256H64z"},null,-1),CEe=[xEe,SEe];function kEe(t,e,n,s,r,o){return S(),E("svg",$Ee,CEe)}var TEe=ae(_Ee,[["render",kEe],["__file","smoking.vue"]]),NEe={name:"Soccer"},IEe={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},EEe=I("path",{fill:"currentColor",d:"M418.496 871.04 152.256 604.8c-16.512 94.016-2.368 178.624 42.944 224 44.928 44.928 129.344 58.752 223.296 42.24zm72.32-18.176a573.056 573.056 0 0 0 224.832-137.216 573.12 573.12 0 0 0 137.216-224.832L533.888 171.84a578.56 578.56 0 0 0-227.52 138.496A567.68 567.68 0 0 0 170.432 532.48l320.384 320.384zM871.04 418.496c16.512-93.952 2.688-178.368-42.24-223.296-44.544-44.544-128.704-58.048-222.592-41.536L871.04 418.496zM149.952 874.048c-112.96-112.96-88.832-408.96 111.168-608.96C461.056 65.152 760.96 36.928 874.048 149.952c113.024 113.024 86.784 411.008-113.152 610.944-199.936 199.936-497.92 226.112-610.944 113.152zm452.544-497.792 22.656-22.656a32 32 0 0 1 45.248 45.248l-22.656 22.656 45.248 45.248A32 32 0 1 1 647.744 512l-45.248-45.248L557.248 512l45.248 45.248a32 32 0 1 1-45.248 45.248L512 557.248l-45.248 45.248L512 647.744a32 32 0 1 1-45.248 45.248l-45.248-45.248-22.656 22.656a32 32 0 1 1-45.248-45.248l22.656-22.656-45.248-45.248A32 32 0 1 1 376.256 512l45.248 45.248L466.752 512l-45.248-45.248a32 32 0 1 1 45.248-45.248L512 466.752l45.248-45.248L512 376.256a32 32 0 0 1 45.248-45.248l45.248 45.248z"},null,-1),AEe=[EEe];function OEe(t,e,n,s,r,o){return S(),E("svg",IEe,AEe)}var REe=ae(NEe,[["render",OEe],["__file","soccer.vue"]]),DEe={name:"SoldOut"},FEe={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},MEe=I("path",{fill:"currentColor",d:"M704 288h131.072a32 32 0 0 1 31.808 28.8L886.4 512h-64.384l-16-160H704v96a32 32 0 1 1-64 0v-96H384v96a32 32 0 0 1-64 0v-96H217.92l-51.2 512H512v64H131.328a32 32 0 0 1-31.808-35.2l57.6-576a32 32 0 0 1 31.808-28.8H320v-22.336C320 154.688 405.504 64 512 64s192 90.688 192 201.664v22.4zm-64 0v-22.336C640 189.248 582.272 128 512 128c-70.272 0-128 61.248-128 137.664v22.4h256zm201.408 476.16a32 32 0 1 1 45.248 45.184l-128 128a32 32 0 0 1-45.248 0l-128-128a32 32 0 1 1 45.248-45.248L704 837.504V608a32 32 0 1 1 64 0v229.504l73.408-73.408z"},null,-1),PEe=[MEe];function LEe(t,e,n,s,r,o){return S(),E("svg",FEe,PEe)}var zEe=ae(DEe,[["render",LEe],["__file","sold-out.vue"]]),BEe={name:"SortDown"},VEe={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},HEe=I("path",{fill:"currentColor",d:"M576 96v709.568L333.312 562.816A32 32 0 1 0 288 608l297.408 297.344A32 32 0 0 0 640 882.688V96a32 32 0 0 0-64 0z"},null,-1),WEe=[HEe];function UEe(t,e,n,s,r,o){return S(),E("svg",VEe,WEe)}var kP=ae(BEe,[["render",UEe],["__file","sort-down.vue"]]),GEe={name:"SortUp"},jEe={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},KEe=I("path",{fill:"currentColor",d:"M384 141.248V928a32 32 0 1 0 64 0V218.56l242.688 242.688A32 32 0 1 0 736 416L438.592 118.656A32 32 0 0 0 384 141.248z"},null,-1),qEe=[KEe];function XEe(t,e,n,s,r,o){return S(),E("svg",jEe,qEe)}var TP=ae(GEe,[["render",XEe],["__file","sort-up.vue"]]),YEe={name:"Sort"},ZEe={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},JEe=I("path",{fill:"currentColor",d:"M384 96a32 32 0 0 1 64 0v786.752a32 32 0 0 1-54.592 22.656L95.936 608a32 32 0 0 1 0-45.312h.128a32 32 0 0 1 45.184 0L384 805.632V96zm192 45.248a32 32 0 0 1 54.592-22.592L928.064 416a32 32 0 0 1 0 45.312h-.128a32 32 0 0 1-45.184 0L640 218.496V928a32 32 0 1 1-64 0V141.248z"},null,-1),QEe=[JEe];function e5e(t,e,n,s,r,o){return S(),E("svg",ZEe,QEe)}var t5e=ae(YEe,[["render",e5e],["__file","sort.vue"]]),n5e={name:"Stamp"},s5e={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},r5e=I("path",{fill:"currentColor",d:"M624 475.968V640h144a128 128 0 0 1 128 128H128a128 128 0 0 1 128-128h144V475.968a192 192 0 1 1 224 0zM128 896v-64h768v64H128z"},null,-1),o5e=[r5e];function a5e(t,e,n,s,r,o){return S(),E("svg",s5e,o5e)}var i5e=ae(n5e,[["render",a5e],["__file","stamp.vue"]]),l5e={name:"StarFilled"},u5e={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},c5e=I("path",{fill:"currentColor",d:"M283.84 867.84 512 747.776l228.16 119.936a6.4 6.4 0 0 0 9.28-6.72l-43.52-254.08 184.512-179.904a6.4 6.4 0 0 0-3.52-10.88l-255.104-37.12L517.76 147.904a6.4 6.4 0 0 0-11.52 0L392.192 379.072l-255.104 37.12a6.4 6.4 0 0 0-3.52 10.88L318.08 606.976l-43.584 254.08a6.4 6.4 0 0 0 9.28 6.72z"},null,-1),d5e=[c5e];function f5e(t,e,n,s,r,o){return S(),E("svg",u5e,d5e)}var Hm=ae(l5e,[["render",f5e],["__file","star-filled.vue"]]),h5e={name:"Star"},p5e={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},m5e=I("path",{fill:"currentColor",d:"m512 747.84 228.16 119.936a6.4 6.4 0 0 0 9.28-6.72l-43.52-254.08 184.512-179.904a6.4 6.4 0 0 0-3.52-10.88l-255.104-37.12L517.76 147.904a6.4 6.4 0 0 0-11.52 0L392.192 379.072l-255.104 37.12a6.4 6.4 0 0 0-3.52 10.88L318.08 606.976l-43.584 254.08a6.4 6.4 0 0 0 9.28 6.72L512 747.84zM313.6 924.48a70.4 70.4 0 0 1-102.144-74.24l37.888-220.928L88.96 472.96A70.4 70.4 0 0 1 128 352.896l221.76-32.256 99.2-200.96a70.4 70.4 0 0 1 126.208 0l99.2 200.96 221.824 32.256a70.4 70.4 0 0 1 39.04 120.064L774.72 629.376l37.888 220.928a70.4 70.4 0 0 1-102.144 74.24L512 820.096l-198.4 104.32z"},null,-1),g5e=[m5e];function v5e(t,e,n,s,r,o){return S(),E("svg",p5e,g5e)}var NP=ae(h5e,[["render",v5e],["__file","star.vue"]]),y5e={name:"Stopwatch"},b5e={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},w5e=I("path",{fill:"currentColor",d:"M512 896a384 384 0 1 0 0-768 384 384 0 0 0 0 768zm0 64a448 448 0 1 1 0-896 448 448 0 0 1 0 896z"},null,-1),_5e=I("path",{fill:"currentColor",d:"M672 234.88c-39.168 174.464-80 298.624-122.688 372.48-64 110.848-202.624 30.848-138.624-80C453.376 453.44 540.48 355.968 672 234.816z"},null,-1),$5e=[w5e,_5e];function x5e(t,e,n,s,r,o){return S(),E("svg",b5e,$5e)}var S5e=ae(y5e,[["render",x5e],["__file","stopwatch.vue"]]),C5e={name:"SuccessFilled"},k5e={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},T5e=I("path",{fill:"currentColor",d:"M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896zm-55.808 536.384-99.52-99.584a38.4 38.4 0 1 0-54.336 54.336l126.72 126.72a38.272 38.272 0 0 0 54.336 0l262.4-262.464a38.4 38.4 0 1 0-54.272-54.336L456.192 600.384z"},null,-1),N5e=[T5e];function I5e(t,e,n,s,r,o){return S(),E("svg",k5e,N5e)}var RC=ae(C5e,[["render",I5e],["__file","success-filled.vue"]]),E5e={name:"Sugar"},A5e={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},O5e=I("path",{fill:"currentColor",d:"m801.728 349.184 4.48 4.48a128 128 0 0 1 0 180.992L534.656 806.144a128 128 0 0 1-181.056 0l-4.48-4.48-19.392 109.696a64 64 0 0 1-108.288 34.176L78.464 802.56a64 64 0 0 1 34.176-108.288l109.76-19.328-4.544-4.544a128 128 0 0 1 0-181.056l271.488-271.488a128 128 0 0 1 181.056 0l4.48 4.48 19.392-109.504a64 64 0 0 1 108.352-34.048l142.592 143.04a64 64 0 0 1-34.24 108.16l-109.248 19.2zm-548.8 198.72h447.168v2.24l60.8-60.8a63.808 63.808 0 0 0 18.752-44.416h-426.88l-89.664 89.728a64.064 64.064 0 0 0-10.24 13.248zm0 64c2.752 4.736 6.144 9.152 10.176 13.248l135.744 135.744a64 64 0 0 0 90.496 0L638.4 611.904H252.928zm490.048-230.976L625.152 263.104a64 64 0 0 0-90.496 0L416.768 380.928h326.208zM123.712 757.312l142.976 142.976 24.32-137.6a25.6 25.6 0 0 0-29.696-29.632l-137.6 24.256zm633.6-633.344-24.32 137.472a25.6 25.6 0 0 0 29.632 29.632l137.28-24.064-142.656-143.04z"},null,-1),R5e=[O5e];function D5e(t,e,n,s,r,o){return S(),E("svg",A5e,R5e)}var F5e=ae(E5e,[["render",D5e],["__file","sugar.vue"]]),M5e={name:"SuitcaseLine"},P5e={xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 1024 1024",style:{"enable-background":"new 0 0 1024 1024"},"xml:space":"preserve"},L5e=I("path",{d:"M922.5 229.5c-24.32-24.34-54.49-36.84-90.5-37.5H704v-64c-.68-17.98-7.02-32.98-19.01-44.99S658.01 64.66 640 64H384c-17.98.68-32.98 7.02-44.99 19.01S320.66 110 320 128v64H192c-35.99.68-66.16 13.18-90.5 37.5C77.16 253.82 64.66 283.99 64 320v448c.68 35.99 13.18 66.16 37.5 90.5s54.49 36.84 90.5 37.5h640c35.99-.68 66.16-13.18 90.5-37.5s36.84-54.49 37.5-90.5V320c-.68-35.99-13.18-66.16-37.5-90.5zM384 128h256v64H384v-64zM256 832h-64c-17.98-.68-32.98-7.02-44.99-19.01S128.66 786.01 128 768V448h128v384zm448 0H320V448h384v384zm192-64c-.68 17.98-7.02 32.98-19.01 44.99S850.01 831.34 832 832h-64V448h128v320zm0-384H128v-64c.69-17.98 7.02-32.98 19.01-44.99S173.99 256.66 192 256h640c17.98.69 32.98 7.02 44.99 19.01S895.34 301.99 896 320v64z",fill:"currentColor"},null,-1),z5e=[L5e];function B5e(t,e,n,s,r,o){return S(),E("svg",P5e,z5e)}var V5e=ae(M5e,[["render",B5e],["__file","suitcase-line.vue"]]),H5e={name:"Suitcase"},W5e={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},U5e=I("path",{fill:"currentColor",d:"M128 384h768v-64a64 64 0 0 0-64-64H192a64 64 0 0 0-64 64v64zm0 64v320a64 64 0 0 0 64 64h640a64 64 0 0 0 64-64V448H128zm64-256h640a128 128 0 0 1 128 128v448a128 128 0 0 1-128 128H192A128 128 0 0 1 64 768V320a128 128 0 0 1 128-128z"},null,-1),G5e=I("path",{fill:"currentColor",d:"M384 128v64h256v-64H384zm0-64h256a64 64 0 0 1 64 64v64a64 64 0 0 1-64 64H384a64 64 0 0 1-64-64v-64a64 64 0 0 1 64-64z"},null,-1),j5e=[U5e,G5e];function K5e(t,e,n,s,r,o){return S(),E("svg",W5e,j5e)}var q5e=ae(H5e,[["render",K5e],["__file","suitcase.vue"]]),X5e={name:"Sunny"},Y5e={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},Z5e=I("path",{fill:"currentColor",d:"M512 704a192 192 0 1 0 0-384 192 192 0 0 0 0 384zm0 64a256 256 0 1 1 0-512 256 256 0 0 1 0 512zm0-704a32 32 0 0 1 32 32v64a32 32 0 0 1-64 0V96a32 32 0 0 1 32-32zm0 768a32 32 0 0 1 32 32v64a32 32 0 1 1-64 0v-64a32 32 0 0 1 32-32zM195.2 195.2a32 32 0 0 1 45.248 0l45.248 45.248a32 32 0 1 1-45.248 45.248L195.2 240.448a32 32 0 0 1 0-45.248zm543.104 543.104a32 32 0 0 1 45.248 0l45.248 45.248a32 32 0 0 1-45.248 45.248l-45.248-45.248a32 32 0 0 1 0-45.248zM64 512a32 32 0 0 1 32-32h64a32 32 0 0 1 0 64H96a32 32 0 0 1-32-32zm768 0a32 32 0 0 1 32-32h64a32 32 0 1 1 0 64h-64a32 32 0 0 1-32-32zM195.2 828.8a32 32 0 0 1 0-45.248l45.248-45.248a32 32 0 0 1 45.248 45.248L240.448 828.8a32 32 0 0 1-45.248 0zm543.104-543.104a32 32 0 0 1 0-45.248l45.248-45.248a32 32 0 0 1 45.248 45.248l-45.248 45.248a32 32 0 0 1-45.248 0z"},null,-1),J5e=[Z5e];function Q5e(t,e,n,s,r,o){return S(),E("svg",Y5e,J5e)}var eAe=ae(X5e,[["render",Q5e],["__file","sunny.vue"]]),tAe={name:"Sunrise"},nAe={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},sAe=I("path",{fill:"currentColor",d:"M32 768h960a32 32 0 1 1 0 64H32a32 32 0 1 1 0-64zm129.408-96a352 352 0 0 1 701.184 0h-64.32a288 288 0 0 0-572.544 0h-64.32zM512 128a32 32 0 0 1 32 32v96a32 32 0 0 1-64 0v-96a32 32 0 0 1 32-32zm407.296 168.704a32 32 0 0 1 0 45.248l-67.84 67.84a32 32 0 1 1-45.248-45.248l67.84-67.84a32 32 0 0 1 45.248 0zm-814.592 0a32 32 0 0 1 45.248 0l67.84 67.84a32 32 0 1 1-45.248 45.248l-67.84-67.84a32 32 0 0 1 0-45.248z"},null,-1),rAe=[sAe];function oAe(t,e,n,s,r,o){return S(),E("svg",nAe,rAe)}var aAe=ae(tAe,[["render",oAe],["__file","sunrise.vue"]]),iAe={name:"Sunset"},lAe={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},uAe=I("path",{fill:"currentColor",d:"M82.56 640a448 448 0 1 1 858.88 0h-67.2a384 384 0 1 0-724.288 0H82.56zM32 704h960q32 0 32 32t-32 32H32q-32 0-32-32t32-32zm256 128h448q32 0 32 32t-32 32H288q-32 0-32-32t32-32z"},null,-1),cAe=[uAe];function dAe(t,e,n,s,r,o){return S(),E("svg",lAe,cAe)}var fAe=ae(iAe,[["render",dAe],["__file","sunset.vue"]]),hAe={name:"SwitchButton"},pAe={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},mAe=I("path",{fill:"currentColor",d:"M352 159.872V230.4a352 352 0 1 0 320 0v-70.528A416.128 416.128 0 0 1 512 960a416 416 0 0 1-160-800.128z"},null,-1),gAe=I("path",{fill:"currentColor",d:"M512 64q32 0 32 32v320q0 32-32 32t-32-32V96q0-32 32-32z"},null,-1),vAe=[mAe,gAe];function yAe(t,e,n,s,r,o){return S(),E("svg",pAe,vAe)}var bAe=ae(hAe,[["render",yAe],["__file","switch-button.vue"]]),wAe={name:"SwitchFilled"},_Ae={xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 1024 1024",style:{"enable-background":"new 0 0 1024 1024"},"xml:space":"preserve"},$Ae=I("path",{d:"M247.47 358.4v.04c.07 19.17 7.72 37.53 21.27 51.09s31.92 21.2 51.09 21.27c39.86 0 72.41-32.6 72.41-72.4s-32.6-72.36-72.41-72.36-72.36 32.55-72.36 72.36z",fill:"currentColor"},null,-1),xAe=I("path",{d:"M492.38 128H324.7c-52.16 0-102.19 20.73-139.08 57.61a196.655 196.655 0 0 0-57.61 139.08V698.7c-.01 25.84 5.08 51.42 14.96 75.29s24.36 45.56 42.63 63.83 39.95 32.76 63.82 42.65a196.67 196.67 0 0 0 75.28 14.98h167.68c3.03 0 5.46-2.43 5.46-5.42V133.42c.6-2.99-1.83-5.42-5.46-5.42zm-56.11 705.88H324.7c-17.76.13-35.36-3.33-51.75-10.18s-31.22-16.94-43.61-29.67c-25.3-25.35-39.81-59.1-39.81-95.32V324.69c-.13-17.75 3.33-35.35 10.17-51.74a131.695 131.695 0 0 1 29.64-43.62c25.39-25.3 59.14-39.81 95.36-39.81h111.57v644.36zm402.12-647.67a196.655 196.655 0 0 0-139.08-57.61H580.48c-3.03 0-4.82 2.43-4.82 4.82v757.16c-.6 2.99 1.79 5.42 5.42 5.42h118.23a196.69 196.69 0 0 0 139.08-57.61A196.655 196.655 0 0 0 896 699.31V325.29a196.69 196.69 0 0 0-57.61-139.08zm-111.3 441.92c-42.83 0-77.82-34.99-77.82-77.82s34.98-77.82 77.82-77.82c42.83 0 77.82 34.99 77.82 77.82s-34.99 77.82-77.82 77.82z",fill:"currentColor"},null,-1),SAe=[$Ae,xAe];function CAe(t,e,n,s,r,o){return S(),E("svg",_Ae,SAe)}var kAe=ae(wAe,[["render",CAe],["__file","switch-filled.vue"]]),TAe={name:"Switch"},NAe={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},IAe=I("path",{fill:"currentColor",d:"M118.656 438.656a32 32 0 0 1 0-45.248L416 96l4.48-3.776A32 32 0 0 1 461.248 96l3.712 4.48a32.064 32.064 0 0 1-3.712 40.832L218.56 384H928a32 32 0 1 1 0 64H141.248a32 32 0 0 1-22.592-9.344zM64 608a32 32 0 0 1 32-32h786.752a32 32 0 0 1 22.656 54.592L608 928l-4.48 3.776a32.064 32.064 0 0 1-40.832-49.024L805.632 640H96a32 32 0 0 1-32-32z"},null,-1),EAe=[IAe];function AAe(t,e,n,s,r,o){return S(),E("svg",NAe,EAe)}var OAe=ae(TAe,[["render",AAe],["__file","switch.vue"]]),RAe={name:"TakeawayBox"},DAe={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},FAe=I("path",{fill:"currentColor",d:"M832 384H192v448h640V384zM96 320h832V128H96v192zm800 64v480a32 32 0 0 1-32 32H160a32 32 0 0 1-32-32V384H64a32 32 0 0 1-32-32V96a32 32 0 0 1 32-32h896a32 32 0 0 1 32 32v256a32 32 0 0 1-32 32h-64zM416 512h192a32 32 0 0 1 0 64H416a32 32 0 0 1 0-64z"},null,-1),MAe=[FAe];function PAe(t,e,n,s,r,o){return S(),E("svg",DAe,MAe)}var LAe=ae(RAe,[["render",PAe],["__file","takeaway-box.vue"]]),zAe={name:"Ticket"},BAe={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},VAe=I("path",{fill:"currentColor",d:"M640 832H64V640a128 128 0 1 0 0-256V192h576v160h64V192h256v192a128 128 0 1 0 0 256v192H704V672h-64v160zm0-416v192h64V416h-64z"},null,-1),HAe=[VAe];function WAe(t,e,n,s,r,o){return S(),E("svg",BAe,HAe)}var UAe=ae(zAe,[["render",WAe],["__file","ticket.vue"]]),GAe={name:"Tickets"},jAe={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},KAe=I("path",{fill:"currentColor",d:"M192 128v768h640V128H192zm-32-64h704a32 32 0 0 1 32 32v832a32 32 0 0 1-32 32H160a32 32 0 0 1-32-32V96a32 32 0 0 1 32-32zm160 448h384v64H320v-64zm0-192h192v64H320v-64zm0 384h384v64H320v-64z"},null,-1),qAe=[KAe];function XAe(t,e,n,s,r,o){return S(),E("svg",jAe,qAe)}var YAe=ae(GAe,[["render",XAe],["__file","tickets.vue"]]),ZAe={name:"Timer"},JAe={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},QAe=I("path",{fill:"currentColor",d:"M512 896a320 320 0 1 0 0-640 320 320 0 0 0 0 640zm0 64a384 384 0 1 1 0-768 384 384 0 0 1 0 768z"},null,-1),eOe=I("path",{fill:"currentColor",d:"M512 320a32 32 0 0 1 32 32l-.512 224a32 32 0 1 1-64 0L480 352a32 32 0 0 1 32-32z"},null,-1),tOe=I("path",{fill:"currentColor",d:"M448 576a64 64 0 1 0 128 0 64 64 0 1 0-128 0zm96-448v128h-64V128h-96a32 32 0 0 1 0-64h256a32 32 0 1 1 0 64h-96z"},null,-1),nOe=[QAe,eOe,tOe];function sOe(t,e,n,s,r,o){return S(),E("svg",JAe,nOe)}var rOe=ae(ZAe,[["render",sOe],["__file","timer.vue"]]),oOe={name:"ToiletPaper"},aOe={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},iOe=I("path",{fill:"currentColor",d:"M595.2 128H320a192 192 0 0 0-192 192v576h384V352c0-90.496 32.448-171.2 83.2-224zM736 64c123.712 0 224 128.96 224 288S859.712 640 736 640H576v320H64V320A256 256 0 0 1 320 64h416zM576 352v224h160c84.352 0 160-97.28 160-224s-75.648-224-160-224-160 97.28-160 224z"},null,-1),lOe=I("path",{fill:"currentColor",d:"M736 448c-35.328 0-64-43.008-64-96s28.672-96 64-96 64 43.008 64 96-28.672 96-64 96z"},null,-1),uOe=[iOe,lOe];function cOe(t,e,n,s,r,o){return S(),E("svg",aOe,uOe)}var dOe=ae(oOe,[["render",cOe],["__file","toilet-paper.vue"]]),fOe={name:"Tools"},hOe={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},pOe=I("path",{fill:"currentColor",d:"M764.416 254.72a351.68 351.68 0 0 1 86.336 149.184H960v192.064H850.752a351.68 351.68 0 0 1-86.336 149.312l54.72 94.72-166.272 96-54.592-94.72a352.64 352.64 0 0 1-172.48 0L371.136 936l-166.272-96 54.72-94.72a351.68 351.68 0 0 1-86.336-149.312H64v-192h109.248a351.68 351.68 0 0 1 86.336-149.312L204.8 160l166.208-96h.192l54.656 94.592a352.64 352.64 0 0 1 172.48 0L652.8 64h.128L819.2 160l-54.72 94.72zM704 499.968a192 192 0 1 0-384 0 192 192 0 0 0 384 0z"},null,-1),mOe=[pOe];function gOe(t,e,n,s,r,o){return S(),E("svg",hOe,mOe)}var vOe=ae(fOe,[["render",gOe],["__file","tools.vue"]]),yOe={name:"TopLeft"},bOe={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},wOe=I("path",{fill:"currentColor",d:"M256 256h416a32 32 0 1 0 0-64H224a32 32 0 0 0-32 32v448a32 32 0 0 0 64 0V256z"},null,-1),_Oe=I("path",{fill:"currentColor",d:"M246.656 201.344a32 32 0 0 0-45.312 45.312l544 544a32 32 0 0 0 45.312-45.312l-544-544z"},null,-1),$Oe=[wOe,_Oe];function xOe(t,e,n,s,r,o){return S(),E("svg",bOe,$Oe)}var SOe=ae(yOe,[["render",xOe],["__file","top-left.vue"]]),COe={name:"TopRight"},kOe={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},TOe=I("path",{fill:"currentColor",d:"M768 256H353.6a32 32 0 1 1 0-64H800a32 32 0 0 1 32 32v448a32 32 0 0 1-64 0V256z"},null,-1),NOe=I("path",{fill:"currentColor",d:"M777.344 201.344a32 32 0 0 1 45.312 45.312l-544 544a32 32 0 0 1-45.312-45.312l544-544z"},null,-1),IOe=[TOe,NOe];function EOe(t,e,n,s,r,o){return S(),E("svg",kOe,IOe)}var AOe=ae(COe,[["render",EOe],["__file","top-right.vue"]]),OOe={name:"Top"},ROe={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},DOe=I("path",{fill:"currentColor",d:"M572.235 205.282v600.365a30.118 30.118 0 1 1-60.235 0V205.282L292.382 438.633a28.913 28.913 0 0 1-42.646 0 33.43 33.43 0 0 1 0-45.236l271.058-288.045a28.913 28.913 0 0 1 42.647 0L834.5 393.397a33.43 33.43 0 0 1 0 45.176 28.913 28.913 0 0 1-42.647 0l-219.618-233.23z"},null,-1),FOe=[DOe];function MOe(t,e,n,s,r,o){return S(),E("svg",ROe,FOe)}var POe=ae(OOe,[["render",MOe],["__file","top.vue"]]),LOe={name:"TrendCharts"},zOe={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},BOe=I("path",{fill:"currentColor",d:"M128 896V128h768v768H128zm291.712-327.296 128 102.4 180.16-201.792-47.744-42.624-139.84 156.608-128-102.4-180.16 201.792 47.744 42.624 139.84-156.608zM816 352a48 48 0 1 0-96 0 48 48 0 0 0 96 0z"},null,-1),VOe=[BOe];function HOe(t,e,n,s,r,o){return S(),E("svg",zOe,VOe)}var WOe=ae(LOe,[["render",HOe],["__file","trend-charts.vue"]]),UOe={name:"TrophyBase"},GOe={xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 1024 1024",style:{"enable-background":"new 0 0 1024 1024"},"xml:space":"preserve"},jOe=I("path",{d:"M918.4 201.6c-6.4-6.4-12.8-9.6-22.4-9.6H768V96c0-9.6-3.2-16-9.6-22.4C752 67.2 745.6 64 736 64H288c-9.6 0-16 3.2-22.4 9.6C259.2 80 256 86.4 256 96v96H128c-9.6 0-16 3.2-22.4 9.6-6.4 6.4-9.6 16-9.6 22.4 3.2 108.8 25.6 185.6 64 224 34.4 34.4 77.56 55.65 127.65 61.99 10.91 20.44 24.78 39.25 41.95 56.41 40.86 40.86 91 65.47 150.4 71.9V768h-96c-9.6 0-16 3.2-22.4 9.6-6.4 6.4-9.6 12.8-9.6 22.4s3.2 16 9.6 22.4c6.4 6.4 12.8 9.6 22.4 9.6h256c9.6 0 16-3.2 22.4-9.6 6.4-6.4 9.6-12.8 9.6-22.4s-3.2-16-9.6-22.4c-6.4-6.4-12.8-9.6-22.4-9.6h-96V637.26c59.4-7.71 109.54-30.01 150.4-70.86 17.2-17.2 31.51-36.06 42.81-56.55 48.93-6.51 90.02-27.7 126.79-61.85 38.4-38.4 60.8-112 64-224 0-6.4-3.2-16-9.6-22.4zM256 438.4c-19.2-6.4-35.2-19.2-51.2-35.2-22.4-22.4-35.2-70.4-41.6-147.2H256v182.4zm390.4 80C608 553.6 566.4 576 512 576s-99.2-19.2-134.4-57.6C342.4 480 320 438.4 320 384V128h384v256c0 54.4-19.2 99.2-57.6 134.4zm172.8-115.2c-16 16-32 25.6-51.2 35.2V256h92.8c-6.4 76.8-19.2 124.8-41.6 147.2zM768 896H256c-9.6 0-16 3.2-22.4 9.6-6.4 6.4-9.6 12.8-9.6 22.4s3.2 16 9.6 22.4c6.4 6.4 12.8 9.6 22.4 9.6h512c9.6 0 16-3.2 22.4-9.6 6.4-6.4 9.6-12.8 9.6-22.4s-3.2-16-9.6-22.4c-6.4-6.4-12.8-9.6-22.4-9.6z",fill:"currentColor"},null,-1),KOe=[jOe];function qOe(t,e,n,s,r,o){return S(),E("svg",GOe,KOe)}var XOe=ae(UOe,[["render",qOe],["__file","trophy-base.vue"]]),YOe={name:"Trophy"},ZOe={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},JOe=I("path",{fill:"currentColor",d:"M480 896V702.08A256.256 256.256 0 0 1 264.064 512h-32.64a96 96 0 0 1-91.968-68.416L93.632 290.88a76.8 76.8 0 0 1 73.6-98.88H256V96a32 32 0 0 1 32-32h448a32 32 0 0 1 32 32v96h88.768a76.8 76.8 0 0 1 73.6 98.88L884.48 443.52A96 96 0 0 1 792.576 512h-32.64A256.256 256.256 0 0 1 544 702.08V896h128a32 32 0 1 1 0 64H352a32 32 0 1 1 0-64h128zm224-448V128H320v320a192 192 0 1 0 384 0zm64 0h24.576a32 32 0 0 0 30.656-22.784l45.824-152.768A12.8 12.8 0 0 0 856.768 256H768v192zm-512 0V256h-88.768a12.8 12.8 0 0 0-12.288 16.448l45.824 152.768A32 32 0 0 0 231.424 448H256z"},null,-1),QOe=[JOe];function eRe(t,e,n,s,r,o){return S(),E("svg",ZOe,QOe)}var tRe=ae(YOe,[["render",eRe],["__file","trophy.vue"]]),nRe={name:"TurnOff"},sRe={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},rRe=I("path",{fill:"currentColor",d:"M329.956 257.138a254.862 254.862 0 0 0 0 509.724h364.088a254.862 254.862 0 0 0 0-509.724H329.956zm0-72.818h364.088a327.68 327.68 0 1 1 0 655.36H329.956a327.68 327.68 0 1 1 0-655.36z"},null,-1),oRe=I("path",{fill:"currentColor",d:"M329.956 621.227a109.227 109.227 0 1 0 0-218.454 109.227 109.227 0 0 0 0 218.454zm0 72.817a182.044 182.044 0 1 1 0-364.088 182.044 182.044 0 0 1 0 364.088z"},null,-1),aRe=[rRe,oRe];function iRe(t,e,n,s,r,o){return S(),E("svg",sRe,aRe)}var lRe=ae(nRe,[["render",iRe],["__file","turn-off.vue"]]),uRe={name:"Umbrella"},cRe={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},dRe=I("path",{fill:"currentColor",d:"M320 768a32 32 0 1 1 64 0 64 64 0 0 0 128 0V512H64a448 448 0 1 1 896 0H576v256a128 128 0 1 1-256 0zm570.688-320a384.128 384.128 0 0 0-757.376 0h757.376z"},null,-1),fRe=[dRe];function hRe(t,e,n,s,r,o){return S(),E("svg",cRe,fRe)}var pRe=ae(uRe,[["render",hRe],["__file","umbrella.vue"]]),mRe={name:"Unlock"},gRe={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},vRe=I("path",{fill:"currentColor",d:"M224 448a32 32 0 0 0-32 32v384a32 32 0 0 0 32 32h576a32 32 0 0 0 32-32V480a32 32 0 0 0-32-32H224zm0-64h576a96 96 0 0 1 96 96v384a96 96 0 0 1-96 96H224a96 96 0 0 1-96-96V480a96 96 0 0 1 96-96z"},null,-1),yRe=I("path",{fill:"currentColor",d:"M512 544a32 32 0 0 1 32 32v192a32 32 0 1 1-64 0V576a32 32 0 0 1 32-32zm178.304-295.296A192.064 192.064 0 0 0 320 320v64h352l96 38.4V448H256V320a256 256 0 0 1 493.76-95.104l-59.456 23.808z"},null,-1),bRe=[vRe,yRe];function wRe(t,e,n,s,r,o){return S(),E("svg",gRe,bRe)}var _Re=ae(mRe,[["render",wRe],["__file","unlock.vue"]]),$Re={name:"UploadFilled"},xRe={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},SRe=I("path",{fill:"currentColor",d:"M544 864V672h128L512 480 352 672h128v192H320v-1.6c-5.376.32-10.496 1.6-16 1.6A240 240 0 0 1 64 624c0-123.136 93.12-223.488 212.608-237.248A239.808 239.808 0 0 1 512 192a239.872 239.872 0 0 1 235.456 194.752c119.488 13.76 212.48 114.112 212.48 237.248a240 240 0 0 1-240 240c-5.376 0-10.56-1.28-16-1.6v1.6H544z"},null,-1),CRe=[SRe];function kRe(t,e,n,s,r,o){return S(),E("svg",xRe,CRe)}var TRe=ae($Re,[["render",kRe],["__file","upload-filled.vue"]]),NRe={name:"Upload"},IRe={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},ERe=I("path",{fill:"currentColor",d:"M160 832h704a32 32 0 1 1 0 64H160a32 32 0 1 1 0-64zm384-578.304V704h-64V247.296L237.248 490.048 192 444.8 508.8 128l316.8 316.8-45.312 45.248L544 253.696z"},null,-1),ARe=[ERe];function ORe(t,e,n,s,r,o){return S(),E("svg",IRe,ARe)}var RRe=ae(NRe,[["render",ORe],["__file","upload.vue"]]),DRe={name:"UserFilled"},FRe={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},MRe=I("path",{fill:"currentColor",d:"M288 320a224 224 0 1 0 448 0 224 224 0 1 0-448 0zm544 608H160a32 32 0 0 1-32-32v-96a160 160 0 0 1 160-160h448a160 160 0 0 1 160 160v96a32 32 0 0 1-32 32z"},null,-1),PRe=[MRe];function LRe(t,e,n,s,r,o){return S(),E("svg",FRe,PRe)}var zRe=ae(DRe,[["render",LRe],["__file","user-filled.vue"]]),BRe={name:"User"},VRe={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},HRe=I("path",{fill:"currentColor",d:"M512 512a192 192 0 1 0 0-384 192 192 0 0 0 0 384zm0 64a256 256 0 1 1 0-512 256 256 0 0 1 0 512zm320 320v-96a96 96 0 0 0-96-96H288a96 96 0 0 0-96 96v96a32 32 0 1 1-64 0v-96a160 160 0 0 1 160-160h448a160 160 0 0 1 160 160v96a32 32 0 1 1-64 0z"},null,-1),WRe=[HRe];function URe(t,e,n,s,r,o){return S(),E("svg",VRe,WRe)}var GRe=ae(BRe,[["render",URe],["__file","user.vue"]]),jRe={name:"Van"},KRe={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},qRe=I("path",{fill:"currentColor",d:"M128.896 736H96a32 32 0 0 1-32-32V224a32 32 0 0 1 32-32h576a32 32 0 0 1 32 32v96h164.544a32 32 0 0 1 31.616 27.136l54.144 352A32 32 0 0 1 922.688 736h-91.52a144 144 0 1 1-286.272 0H415.104a144 144 0 1 1-286.272 0zm23.36-64a143.872 143.872 0 0 1 239.488 0H568.32c17.088-25.6 42.24-45.376 71.744-55.808V256H128v416h24.256zm655.488 0h77.632l-19.648-128H704v64.896A144 144 0 0 1 807.744 672zm48.128-192-14.72-96H704v96h151.872zM688 832a80 80 0 1 0 0-160 80 80 0 0 0 0 160zm-416 0a80 80 0 1 0 0-160 80 80 0 0 0 0 160z"},null,-1),XRe=[qRe];function YRe(t,e,n,s,r,o){return S(),E("svg",KRe,XRe)}var ZRe=ae(jRe,[["render",YRe],["__file","van.vue"]]),JRe={name:"VideoCameraFilled"},QRe={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},eDe=I("path",{fill:"currentColor",d:"m768 576 192-64v320l-192-64v96a32 32 0 0 1-32 32H96a32 32 0 0 1-32-32V480a32 32 0 0 1 32-32h640a32 32 0 0 1 32 32v96zM192 768v64h384v-64H192zm192-480a160 160 0 0 1 320 0 160 160 0 0 1-320 0zm64 0a96 96 0 1 0 192.064-.064A96 96 0 0 0 448 288zm-320 32a128 128 0 1 1 256.064.064A128 128 0 0 1 128 320zm64 0a64 64 0 1 0 128 0 64 64 0 0 0-128 0z"},null,-1),tDe=[eDe];function nDe(t,e,n,s,r,o){return S(),E("svg",QRe,tDe)}var sDe=ae(JRe,[["render",nDe],["__file","video-camera-filled.vue"]]),rDe={name:"VideoCamera"},oDe={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},aDe=I("path",{fill:"currentColor",d:"M704 768V256H128v512h576zm64-416 192-96v512l-192-96v128a32 32 0 0 1-32 32H96a32 32 0 0 1-32-32V224a32 32 0 0 1 32-32h640a32 32 0 0 1 32 32v128zm0 71.552v176.896l128 64V359.552l-128 64zM192 320h192v64H192v-64z"},null,-1),iDe=[aDe];function lDe(t,e,n,s,r,o){return S(),E("svg",oDe,iDe)}var uDe=ae(rDe,[["render",lDe],["__file","video-camera.vue"]]),cDe={name:"VideoPause"},dDe={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},fDe=I("path",{fill:"currentColor",d:"M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896zm0 832a384 384 0 0 0 0-768 384 384 0 0 0 0 768zm-96-544q32 0 32 32v256q0 32-32 32t-32-32V384q0-32 32-32zm192 0q32 0 32 32v256q0 32-32 32t-32-32V384q0-32 32-32z"},null,-1),hDe=[fDe];function pDe(t,e,n,s,r,o){return S(),E("svg",dDe,hDe)}var mDe=ae(cDe,[["render",pDe],["__file","video-pause.vue"]]),gDe={name:"VideoPlay"},vDe={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},yDe=I("path",{fill:"currentColor",d:"M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896zm0 832a384 384 0 0 0 0-768 384 384 0 0 0 0 768zm-48-247.616L668.608 512 464 375.616v272.768zm10.624-342.656 249.472 166.336a48 48 0 0 1 0 79.872L474.624 718.272A48 48 0 0 1 400 678.336V345.6a48 48 0 0 1 74.624-39.936z"},null,-1),bDe=[yDe];function wDe(t,e,n,s,r,o){return S(),E("svg",vDe,bDe)}var _De=ae(gDe,[["render",wDe],["__file","video-play.vue"]]),$De={name:"View"},xDe={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},SDe=I("path",{fill:"currentColor",d:"M512 160c320 0 512 352 512 352S832 864 512 864 0 512 0 512s192-352 512-352zm0 64c-225.28 0-384.128 208.064-436.8 288 52.608 79.872 211.456 288 436.8 288 225.28 0 384.128-208.064 436.8-288-52.608-79.872-211.456-288-436.8-288zm0 64a224 224 0 1 1 0 448 224 224 0 0 1 0-448zm0 64a160.192 160.192 0 0 0-160 160c0 88.192 71.744 160 160 160s160-71.808 160-160-71.744-160-160-160z"},null,-1),CDe=[SDe];function kDe(t,e,n,s,r,o){return S(),E("svg",xDe,CDe)}var IP=ae($De,[["render",kDe],["__file","view.vue"]]),TDe={name:"WalletFilled"},NDe={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},IDe=I("path",{fill:"currentColor",d:"M688 512a112 112 0 1 0 0 224h208v160H128V352h768v160H688zm32 160h-32a48 48 0 0 1 0-96h32a48 48 0 0 1 0 96zm-80-544 128 160H384l256-160z"},null,-1),EDe=[IDe];function ADe(t,e,n,s,r,o){return S(),E("svg",NDe,EDe)}var ODe=ae(TDe,[["render",ADe],["__file","wallet-filled.vue"]]),RDe={name:"Wallet"},DDe={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},FDe=I("path",{fill:"currentColor",d:"M640 288h-64V128H128v704h384v32a32 32 0 0 0 32 32H96a32 32 0 0 1-32-32V96a32 32 0 0 1 32-32h512a32 32 0 0 1 32 32v192z"},null,-1),MDe=I("path",{fill:"currentColor",d:"M128 320v512h768V320H128zm-32-64h832a32 32 0 0 1 32 32v576a32 32 0 0 1-32 32H96a32 32 0 0 1-32-32V288a32 32 0 0 1 32-32z"},null,-1),PDe=I("path",{fill:"currentColor",d:"M704 640a64 64 0 1 1 0-128 64 64 0 0 1 0 128z"},null,-1),LDe=[FDe,MDe,PDe];function zDe(t,e,n,s,r,o){return S(),E("svg",DDe,LDe)}var BDe=ae(RDe,[["render",zDe],["__file","wallet.vue"]]),VDe={name:"WarnTriangleFilled"},HDe={xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 1024 1024",style:{"enable-background":"new 0 0 1024 1024"},"xml:space":"preserve"},WDe=I("path",{d:"M928.99 755.83 574.6 203.25c-12.89-20.16-36.76-32.58-62.6-32.58s-49.71 12.43-62.6 32.58L95.01 755.83c-12.91 20.12-12.9 44.91.01 65.03 12.92 20.12 36.78 32.51 62.59 32.49h708.78c25.82.01 49.68-12.37 62.59-32.49 12.91-20.12 12.92-44.91.01-65.03zM554.67 768h-85.33v-85.33h85.33V768zm0-426.67v298.66h-85.33V341.32l85.33.01z",fill:"currentColor"},null,-1),UDe=[WDe];function GDe(t,e,n,s,r,o){return S(),E("svg",HDe,UDe)}var jDe=ae(VDe,[["render",GDe],["__file","warn-triangle-filled.vue"]]),KDe={name:"WarningFilled"},qDe={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},XDe=I("path",{fill:"currentColor",d:"M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896zm0 192a58.432 58.432 0 0 0-58.24 63.744l23.36 256.384a35.072 35.072 0 0 0 69.76 0l23.296-256.384A58.432 58.432 0 0 0 512 256zm0 512a51.2 51.2 0 1 0 0-102.4 51.2 51.2 0 0 0 0 102.4z"},null,-1),YDe=[XDe];function ZDe(t,e,n,s,r,o){return S(),E("svg",qDe,YDe)}var Rg=ae(KDe,[["render",ZDe],["__file","warning-filled.vue"]]),JDe={name:"Warning"},QDe={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},e9e=I("path",{fill:"currentColor",d:"M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896zm0 832a384 384 0 0 0 0-768 384 384 0 0 0 0 768zm48-176a48 48 0 1 1-96 0 48 48 0 0 1 96 0zm-48-464a32 32 0 0 1 32 32v288a32 32 0 0 1-64 0V288a32 32 0 0 1 32-32z"},null,-1),t9e=[e9e];function n9e(t,e,n,s,r,o){return S(),E("svg",QDe,t9e)}var s9e=ae(JDe,[["render",n9e],["__file","warning.vue"]]),r9e={name:"Watch"},o9e={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},a9e=I("path",{fill:"currentColor",d:"M512 768a256 256 0 1 0 0-512 256 256 0 0 0 0 512zm0 64a320 320 0 1 1 0-640 320 320 0 0 1 0 640z"},null,-1),i9e=I("path",{fill:"currentColor",d:"M480 352a32 32 0 0 1 32 32v160a32 32 0 0 1-64 0V384a32 32 0 0 1 32-32z"},null,-1),l9e=I("path",{fill:"currentColor",d:"M480 512h128q32 0 32 32t-32 32H480q-32 0-32-32t32-32zm128-256V128H416v128h-64V64h320v192h-64zM416 768v128h192V768h64v192H352V768h64z"},null,-1),u9e=[a9e,i9e,l9e];function c9e(t,e,n,s,r,o){return S(),E("svg",o9e,u9e)}var d9e=ae(r9e,[["render",c9e],["__file","watch.vue"]]),f9e={name:"Watermelon"},h9e={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},p9e=I("path",{fill:"currentColor",d:"m683.072 600.32-43.648 162.816-61.824-16.512 53.248-198.528L576 493.248l-158.4 158.4-45.248-45.248 158.4-158.4-55.616-55.616-198.528 53.248-16.512-61.824 162.816-43.648L282.752 200A384 384 0 0 0 824 741.248L683.072 600.32zm231.552 141.056a448 448 0 1 1-632-632l632 632z"},null,-1),m9e=[p9e];function g9e(t,e,n,s,r,o){return S(),E("svg",h9e,m9e)}var v9e=ae(f9e,[["render",g9e],["__file","watermelon.vue"]]),y9e={name:"WindPower"},b9e={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},w9e=I("path",{fill:"currentColor",d:"M160 64q32 0 32 32v832q0 32-32 32t-32-32V96q0-32 32-32zm416 354.624 128-11.584V168.96l-128-11.52v261.12zm-64 5.824V151.552L320 134.08V160h-64V64l616.704 56.064A96 96 0 0 1 960 215.68v144.64a96 96 0 0 1-87.296 95.616L256 512V224h64v217.92l192-17.472zm256-23.232 98.88-8.96A32 32 0 0 0 896 360.32V215.68a32 32 0 0 0-29.12-31.872l-98.88-8.96v226.368z"},null,-1),_9e=[w9e];function $9e(t,e,n,s,r,o){return S(),E("svg",b9e,_9e)}var x9e=ae(y9e,[["render",$9e],["__file","wind-power.vue"]]),S9e={name:"ZoomIn"},C9e={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},k9e=I("path",{fill:"currentColor",d:"m795.904 750.72 124.992 124.928a32 32 0 0 1-45.248 45.248L750.656 795.904a416 416 0 1 1 45.248-45.248zM480 832a352 352 0 1 0 0-704 352 352 0 0 0 0 704zm-32-384v-96a32 32 0 0 1 64 0v96h96a32 32 0 0 1 0 64h-96v96a32 32 0 0 1-64 0v-96h-96a32 32 0 0 1 0-64h96z"},null,-1),T9e=[k9e];function N9e(t,e,n,s,r,o){return S(),E("svg",C9e,T9e)}var DC=ae(S9e,[["render",N9e],["__file","zoom-in.vue"]]),I9e={name:"ZoomOut"},E9e={viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg"},A9e=I("path",{fill:"currentColor",d:"m795.904 750.72 124.992 124.928a32 32 0 0 1-45.248 45.248L750.656 795.904a416 416 0 1 1 45.248-45.248zM480 832a352 352 0 1 0 0-704 352 352 0 0 0 0 704zM352 448h256a32 32 0 0 1 0 64H352a32 32 0 0 1 0-64z"},null,-1),O9e=[A9e];function R9e(t,e,n,s,r,o){return S(),E("svg",E9e,O9e)}var EP=ae(I9e,[["render",R9e],["__file","zoom-out.vue"]]);const D9e=Object.freeze(Object.defineProperty({__proto__:null,AddLocation:Xue,Aim:nce,AlarmClock:uce,Apple:mce,ArrowDown:zl,ArrowDownBold:_ce,ArrowLeft:xl,ArrowLeftBold:Oce,ArrowRight:Rr,ArrowRightBold:Wce,ArrowUp:Og,ArrowUpBold:ede,Avatar:dde,Back:cP,Baseball:Sde,Basketball:Ede,Bell:Ude,BellFilled:Mde,Bicycle:Yde,Bottom:gfe,BottomLeft:sfe,BottomRight:cfe,Bowl:$fe,Box:Efe,Briefcase:Mfe,Brush:qfe,BrushFilled:Hfe,Burger:ehe,Calendar:dP,Camera:vhe,CameraFilled:dhe,CaretBottom:xhe,CaretLeft:Ihe,CaretRight:EC,CaretTop:fP,Cellphone:Ghe,ChatDotRound:Jhe,ChatDotSquare:ope,ChatLineRound:fpe,ChatLineSquare:bpe,ChatRound:Cpe,ChatSquare:Ape,Check:Jh,Checked:Hpe,Cherry:qpe,Chicken:eme,ChromeFilled:lme,CircleCheck:lw,CircleCheckFilled:hP,CircleClose:Bl,CircleCloseFilled:uw,CirclePlus:Ume,CirclePlusFilled:Mme,Clock:AC,Close:xa,CloseBold:s0e,Cloudy:p0e,Coffee:k0e,CoffeeCup:w0e,Coin:D0e,ColdDrink:B0e,Collection:Q0e,CollectionTag:j0e,Comment:oge,Compass:fge,Connection:bge,Coordinate:kge,CopyDocument:Rge,Cpu:Bge,CreditCard:Kge,Crop:e1e,DArrowLeft:$d,DArrowRight:xd,DCaret:g1e,DataAnalysis:$1e,DataBoard:E1e,DataLine:M1e,Delete:pP,DeleteFilled:H1e,DeleteLocation:Y1e,Dessert:i2e,Discount:p2e,Dish:k2e,DishDot:w2e,Document:mP,DocumentAdd:O2e,DocumentChecked:L2e,DocumentCopy:U2e,DocumentDelete:Y2e,DocumentRemove:nve,Download:hve,Drizzling:bve,Edit:Ove,EditPen:Cve,Eleme:Uve,ElemeFilled:Lve,ElementPlus:Yve,Expand:nye,Failed:lye,Female:gye,Files:$ye,Film:Iye,Filter:Fye,Finished:Vye,FirstAidKit:qye,Flag:ebe,Fold:abe,Folder:Hbe,FolderAdd:fbe,FolderChecked:ybe,FolderDelete:Sbe,FolderOpened:Ebe,FolderRemove:Mbe,Food:qbe,Football:twe,ForkSpoon:iwe,Fries:hwe,FullScreen:gP,Goblet:Hwe,GobletFull:Swe,GobletSquare:Mwe,GobletSquareFull:Ewe,GoldMedal:Xwe,Goods:i_e,GoodsFilled:t_e,Grape:h_e,Grid:b_e,Guide:k_e,Handbag:O_e,Headset:L_e,Help:Y_e,HelpFilled:U_e,Hide:vP,Histogram:l3e,HomeFilled:p3e,HotWater:w3e,House:k3e,IceCream:U3e,IceCreamRound:O3e,IceCreamSquare:L3e,IceDrink:Y3e,IceTea:n4e,InfoFilled:cw,Iphone:h4e,Key:b4e,KnifeFork:C4e,Lightning:O4e,Link:L4e,List:U4e,Loading:Vl,Location:g$e,LocationFilled:t$e,LocationInformation:u$e,Lock:x$e,Lollipop:I$e,MagicStick:F$e,Magnet:V$e,Male:X$e,Management:t6e,MapLocation:l6e,Medal:m6e,Memo:x6e,Menu:I6e,Message:H6e,MessageBox:F6e,Mic:q6e,Microphone:exe,MilkTea:axe,Minus:yP,Money:bxe,Monitor:Cxe,Moon:Lxe,MoonNight:Oxe,More:bP,MoreFilled:f6,MostlyCloudy:eSe,Mouse:iSe,Mug:hSe,Mute:TSe,MuteNotification:wSe,NoSmoking:RSe,Notebook:BSe,Notification:KSe,Odometer:tCe,OfficeBuilding:uCe,Open:gCe,Operation:$Ce,Opportunity:NCe,Orange:DCe,Paperclip:BCe,PartlyCloudy:KCe,Pear:QCe,Phone:dke,PhoneFilled:oke,Picture:Eke,PictureFilled:wP,PictureRounded:xke,PieChart:Pke,Place:Gke,Platform:Zke,Plus:OC,Pointer:l8e,Position:p8e,Postcard:_8e,Pouring:T8e,Present:M8e,PriceTag:W8e,Printer:X8e,Promotion:tTe,QuartzWatch:uTe,QuestionFilled:_P,Rank:wTe,Reading:DTe,ReadingLamp:TTe,Refresh:YTe,RefreshLeft:$P,RefreshRight:xP,Refrigerator:nNe,Remove:mNe,RemoveFilled:lNe,Right:_Ne,ScaleToOriginal:SP,School:DNe,Scissor:BNe,Search:CP,Select:ZNe,Sell:sIe,SemiSelect:uIe,Service:mIe,SetUp:SIe,Setting:EIe,Share:MIe,Ship:HIe,Shop:qIe,ShoppingBag:tEe,ShoppingCart:pEe,ShoppingCartFull:lEe,ShoppingTrolley:wEe,Smoking:TEe,Soccer:REe,SoldOut:zEe,Sort:t5e,SortDown:kP,SortUp:TP,Stamp:i5e,Star:NP,StarFilled:Hm,Stopwatch:S5e,SuccessFilled:RC,Sugar:F5e,Suitcase:q5e,SuitcaseLine:V5e,Sunny:eAe,Sunrise:aAe,Sunset:fAe,Switch:OAe,SwitchButton:bAe,SwitchFilled:kAe,TakeawayBox:LAe,Ticket:UAe,Tickets:YAe,Timer:rOe,ToiletPaper:dOe,Tools:vOe,Top:POe,TopLeft:SOe,TopRight:AOe,TrendCharts:WOe,Trophy:tRe,TrophyBase:XOe,TurnOff:lRe,Umbrella:pRe,Unlock:_Re,Upload:RRe,UploadFilled:TRe,User:GRe,UserFilled:zRe,Van:ZRe,VideoCamera:uDe,VideoCameraFilled:sDe,VideoPause:mDe,VideoPlay:_De,View:IP,Wallet:BDe,WalletFilled:ODe,WarnTriangleFilled:jDe,Warning:s9e,WarningFilled:Rg,Watch:d9e,Watermelon:v9e,WindPower:x9e,ZoomIn:DC,ZoomOut:EP},Symbol.toStringTag,{value:"Module"})),AP="__epPropKey",Se=t=>t,F9e=t=>Bt(t)&&!!t[AP],oi=(t,e)=>{if(!Bt(t)||F9e(t))return t;const{values:n,required:s,default:r,type:o,validator:a}=t,l={type:o,required:!!s,validator:n||a?u=>{let c=!1,d=[];if(n&&(d=Array.from(n),Ut(t,"default")&&d.push(r),c||(c=d.includes(u))),a&&(c||(c=a(u))),!c&&d.length>0){const f=[...new Set(d)].map(h=>JSON.stringify(h)).join(", ");pee(`Invalid prop: validation failed${e?` for prop "${e}"`:""}. Expected one of [${f}], got value ${JSON.stringify(u)}.`)}return c}:void 0,[AP]:!0};return Ut(t,"default")&&(l.default=r),l},qe=t=>eP(Object.entries(t).map(([e,n])=>[e,oi(n,e)])),In=Se([String,Object,Function]),OP={Close:xa},FC={Close:xa,SuccessFilled:RC,InfoFilled:cw,WarningFilled:Rg,CircleCloseFilled:uw},Gu={success:RC,warning:Rg,error:uw,info:cw},RP={validating:Vl,success:lw,error:Bl},Dt=(t,e)=>{if(t.install=n=>{for(const s of[t,...Object.values(e??{})])n.component(s.name,s)},e)for(const[n,s]of Object.entries(e))t[n]=s;return t},DP=(t,e)=>(t.install=n=>{t._context=n._context,n.config.globalProperties[e]=t},t),M9e=(t,e)=>(t.install=n=>{n.directive(e,t)},t),ns=t=>(t.install=gn,t),dw=(...t)=>e=>{t.forEach(n=>{vt(n)?n(e):n.value=e})},ut={tab:"Tab",enter:"Enter",space:"Space",left:"ArrowLeft",up:"ArrowUp",right:"ArrowRight",down:"ArrowDown",esc:"Escape",delete:"Delete",backspace:"Backspace",numpadEnter:"NumpadEnter",pageUp:"PageUp",pageDown:"PageDown",home:"Home",end:"End"},P9e=["year","month","date","dates","week","datetime","datetimerange","daterange","monthrange"],U4=["sun","mon","tue","wed","thu","fri","sat"],Ot="update:modelValue",Fn="change",jr="input",VA=Symbol("INSTALLED_KEY"),Hl=["","default","small","large"],L9e={large:40,default:32,small:24},z9e=t=>L9e[t||"default"],Qh=t=>["",...Hl].includes(t);var ra=(t=>(t[t.TEXT=1]="TEXT",t[t.CLASS=2]="CLASS",t[t.STYLE=4]="STYLE",t[t.PROPS=8]="PROPS",t[t.FULL_PROPS=16]="FULL_PROPS",t[t.HYDRATE_EVENTS=32]="HYDRATE_EVENTS",t[t.STABLE_FRAGMENT=64]="STABLE_FRAGMENT",t[t.KEYED_FRAGMENT=128]="KEYED_FRAGMENT",t[t.UNKEYED_FRAGMENT=256]="UNKEYED_FRAGMENT",t[t.NEED_PATCH=512]="NEED_PATCH",t[t.DYNAMIC_SLOTS=1024]="DYNAMIC_SLOTS",t[t.HOISTED=-1]="HOISTED",t[t.BAIL=-2]="BAIL",t))(ra||{});function h6(t){return Bn(t)&&t.type===lt}function B9e(t){return Bn(t)&&t.type===Gr}function V9e(t){return Bn(t)&&!h6(t)&&!B9e(t)}const H9e=t=>{if(!Bn(t))return{};const e=t.props||{},n=(Bn(t.type)?t.type.props:void 0)||{},s={};return Object.keys(n).forEach(r=>{Ut(n[r],"default")&&(s[r]=n[r].default)}),Object.keys(e).forEach(r=>{s[wa(r)]=e[r]}),s},W9e=t=>{if(!Qe(t)||t.length>1)throw new Error("expect to receive a single Vue element child");return t[0]},Gf=t=>{const e=Qe(t)?t:[t],n=[];return e.forEach(s=>{var r;Qe(s)?n.push(...Gf(s)):Bn(s)&&Qe(s.children)?n.push(...Gf(s.children)):(n.push(s),Bn(s)&&((r=s.component)==null?void 0:r.subTree)&&n.push(...Gf(s.component.subTree)))}),n},HA=t=>t**3,U9e=t=>t<.5?HA(t*2)/2:1-HA((1-t)*2)/2,WA=t=>[...new Set(t)],vl=t=>!t&&t!==0?[]:Array.isArray(t)?t:[t],MC=()=>Kt&&/firefox/i.test(window.navigator.userAgent),fw=t=>/([(\uAC00-\uD7AF)|(\u3130-\u318F)])+/gi.test(t),PC=t=>Kt?window.requestAnimationFrame(t):setTimeout(t,16),LC=t=>Kt?window.cancelAnimationFrame(t):clearTimeout(t),hw=()=>Math.floor(Math.random()*1e4),Ln=t=>t,G9e=["class","style"],j9e=/^on[A-Z]/,zC=(t={})=>{const{excludeListeners:e=!1,excludeKeys:n}=t,s=A(()=>((n==null?void 0:n.value)||[]).concat(G9e)),r=Rt();return A(r?()=>{var o;return eP(Object.entries((o=r.proxy)==null?void 0:o.$attrs).filter(([a])=>!s.value.includes(a)&&!(e&&j9e.test(a))))}:()=>({}))},FP=Symbol("breadcrumbKey"),MP=Symbol("buttonGroupContextKey"),PP=Symbol("carouselContextKey"),ep=Symbol("checkboxGroupContextKey"),LP=Symbol("collapseContextKey"),zP=Symbol(),BP=Symbol("dialogInjectionKey"),Jd=Symbol("formContextKey"),Li=Symbol("formItemContextKey"),VP=Symbol("elPaginationKey"),HP=Symbol("radioGroupKey"),WP=Symbol("rowContextKey"),UP=Symbol("scrollbarContextKey"),GP=Symbol("sliderContextKey"),pw=Symbol("tabsRootContextKey"),jP=Symbol("uploadContextKey"),BC=Symbol("popper"),KP=Symbol("popperContent"),mw=Symbol("elTooltip"),gw=Symbol("tooltipV2"),qP=Symbol("tooltipV2Content"),G4="tooltip_v2.open",VC=Symbol(),XP=t=>{const e=Rt();return A(()=>{var n,s;return(s=((n=e.proxy)==null?void 0:n.$props)[t])!=null?s:void 0})},Iy=U();function Wl(t,e=void 0){const n=Rt()?et(zP,Iy):Iy;return t?A(()=>{var s,r;return(r=(s=n.value)==null?void 0:s[t])!=null?r:e}):n}const YP=(t,e,n=!1)=>{var s;const r=!!Rt(),o=r?Wl():void 0,a=(s=e==null?void 0:e.provide)!=null?s:r?Lt:void 0;if(!a)return;const i=A(()=>{const l=v(t);return o!=null&&o.value?K9e(o.value,l):l});return a(zP,i),(n||!Iy.value)&&(Iy.value=i.value),i},K9e=(t,e)=>{var n;const s=[...new Set([...D0(t),...D0(e)])],r={};for(const o of s)r[o]=(n=e[o])!=null?n:t[o];return r},wo=oi({type:String,values:Hl,required:!1}),ks=(t,e={})=>{const n=U(void 0),s=e.prop?n:XP("size"),r=e.global?n:Wl("size"),o=e.form?{size:void 0}:et(Jd,void 0),a=e.formItem?{size:void 0}:et(Li,void 0);return A(()=>s.value||v(t)||(a==null?void 0:a.size)||(o==null?void 0:o.size)||r.value||"")},To=t=>{const e=XP("disabled"),n=et(Jd,void 0);return A(()=>e.value||v(t)||(n==null?void 0:n.disabled)||!1)},Sl=({from:t,replacement:e,scope:n,version:s,ref:r,type:o="API"},a)=>{Me(()=>v(a),i=>{},{immediate:!0})},ZP=(t,e,n)=>{let s={offsetX:0,offsetY:0};const r=i=>{const l=i.clientX,u=i.clientY,{offsetX:c,offsetY:d}=s,f=t.value.getBoundingClientRect(),h=f.left,p=f.top,m=f.width,g=f.height,y=document.documentElement.clientWidth,w=document.documentElement.clientHeight,b=-h+c,_=-p+d,$=y-h-m+c,x=w-p-g+d,k=T=>{const N=Math.min(Math.max(c+T.clientX-l,b),$),M=Math.min(Math.max(d+T.clientY-u,_),x);s={offsetX:N,offsetY:M},t.value.style.transform=`translate(${Cs(N)}, ${Cs(M)})`},C=()=>{document.removeEventListener("mousemove",k),document.removeEventListener("mouseup",C)};document.addEventListener("mousemove",k),document.addEventListener("mouseup",C)},o=()=>{e.value&&t.value&&e.value.addEventListener("mousedown",r)},a=()=>{e.value&&t.value&&e.value.removeEventListener("mousedown",r)};It(()=>{Ho(()=>{n.value?o():a()})}),ts(()=>{a()})},q9e=t=>({focus:()=>{var e,n;(n=(e=t.value)==null?void 0:e.focus)==null||n.call(e)}}),vw="el",X9e="is-",kc=(t,e,n,s,r)=>{let o=`${t}-${e}`;return n&&(o+=`-${n}`),s&&(o+=`__${s}`),r&&(o+=`--${r}`),o},Fe=t=>{const e=Wl("namespace",vw);return{namespace:e,b:(p="")=>kc(e.value,t,p,"",""),e:p=>p?kc(e.value,t,"",p,""):"",m:p=>p?kc(e.value,t,"","",p):"",be:(p,m)=>p&&m?kc(e.value,t,p,m,""):"",em:(p,m)=>p&&m?kc(e.value,t,"",p,m):"",bm:(p,m)=>p&&m?kc(e.value,t,p,"",m):"",bem:(p,m,g)=>p&&m&&g?kc(e.value,t,p,m,g):"",is:(p,...m)=>{const g=m.length>=1?m[0]:!0;return p&&g?`${X9e}${p}`:""},cssVar:p=>{const m={};for(const g in p)p[g]&&(m[`--${e.value}-${g}`]=p[g]);return m},cssVarName:p=>`--${e.value}-${p}`,cssVarBlock:p=>{const m={};for(const g in p)p[g]&&(m[`--${e.value}-${t}-${g}`]=p[g]);return m},cssVarBlockName:p=>`--${e.value}-${t}-${p}`}},UA={prefix:Math.floor(Math.random()*1e4),current:0},Y9e=Symbol("elIdInjection"),JP=()=>Rt()?et(Y9e,UA):UA,ei=t=>{const e=JP(),n=Wl("namespace",vw);return A(()=>v(t)||`${n.value}-id-${e.prefix}-${e.current++}`)},to=()=>{const t=et(Jd,void 0),e=et(Li,void 0);return{form:t,formItem:e}},ic=(t,{formItemContext:e,disableIdGeneration:n,disableIdManagement:s})=>{n||(n=U(!1)),s||(s=U(!1));const r=U();let o;const a=A(()=>{var i;return!!(!t.label&&e&&e.inputIds&&((i=e.inputIds)==null?void 0:i.length)<=1)});return It(()=>{o=Me([Un(t,"id"),n],([i,l])=>{const u=i??(l?void 0:ei().value);u!==r.value&&(e!=null&&e.removeInputId&&(r.value&&e.removeInputId(r.value),!(s!=null&&s.value)&&!l&&u&&e.addInputId(u)),r.value=u)},{immediate:!0})}),Xd(()=>{o&&o(),e!=null&&e.removeInputId&&r.value&&e.removeInputId(r.value)}),{isLabeledByFormItem:a,inputId:r}};var Z9e={name:"en",el:{colorpicker:{confirm:"OK",clear:"Clear",defaultLabel:"color picker",description:"current color is {color}. press enter to select a new color."},datepicker:{now:"Now",today:"Today",cancel:"Cancel",clear:"Clear",confirm:"OK",dateTablePrompt:"Use the arrow keys and enter to select the day of the month",monthTablePrompt:"Use the arrow keys and enter to select the month",yearTablePrompt:"Use the arrow keys and enter to select the year",selectedDate:"Selected date",selectDate:"Select date",selectTime:"Select time",startDate:"Start Date",startTime:"Start Time",endDate:"End Date",endTime:"End Time",prevYear:"Previous Year",nextYear:"Next Year",prevMonth:"Previous Month",nextMonth:"Next Month",year:"",month1:"January",month2:"February",month3:"March",month4:"April",month5:"May",month6:"June",month7:"July",month8:"August",month9:"September",month10:"October",month11:"November",month12:"December",week:"week",weeks:{sun:"Sun",mon:"Mon",tue:"Tue",wed:"Wed",thu:"Thu",fri:"Fri",sat:"Sat"},weeksFull:{sun:"Sunday",mon:"Monday",tue:"Tuesday",wed:"Wednesday",thu:"Thursday",fri:"Friday",sat:"Saturday"},months:{jan:"Jan",feb:"Feb",mar:"Mar",apr:"Apr",may:"May",jun:"Jun",jul:"Jul",aug:"Aug",sep:"Sep",oct:"Oct",nov:"Nov",dec:"Dec"}},inputNumber:{decrease:"decrease number",increase:"increase number"},select:{loading:"Loading",noMatch:"No matching data",noData:"No data",placeholder:"Select"},dropdown:{toggleDropdown:"Toggle Dropdown"},cascader:{noMatch:"No matching data",loading:"Loading",placeholder:"Select",noData:"No data"},pagination:{goto:"Go to",pagesize:"/page",total:"Total {total}",pageClassifier:"",deprecationWarning:"Deprecated usages detected, please refer to the el-pagination documentation for more details"},dialog:{close:"Close this dialog"},drawer:{close:"Close this dialog"},messagebox:{title:"Message",confirm:"OK",cancel:"Cancel",error:"Illegal input",close:"Close this dialog"},upload:{deleteTip:"press delete to remove",delete:"Delete",preview:"Preview",continue:"Continue"},slider:{defaultLabel:"slider between {min} and {max}",defaultRangeStartLabel:"pick start value",defaultRangeEndLabel:"pick end value"},table:{emptyText:"No Data",confirmFilter:"Confirm",resetFilter:"Reset",clearFilter:"All",sumText:"Sum"},tree:{emptyText:"No Data"},transfer:{noMatch:"No matching data",noData:"No data",titles:["List 1","List 2"],filterPlaceholder:"Enter keyword",noCheckedFormat:"{total} items",hasCheckedFormat:"{checked}/{total} checked"},image:{error:"FAILED"},pageHeader:{title:"Back"},popconfirm:{confirmButtonText:"Yes",cancelButtonText:"No"}}};const J9e=t=>(e,n)=>Q9e(e,n,v(t)),Q9e=(t,e,n)=>Pn(n,t,t).replace(/\{(\w+)\}/g,(s,r)=>{var o;return`${(o=e==null?void 0:e[r])!=null?o:`{${r}}`}`}),eFe=t=>{const e=A(()=>v(t).name),n=kn(t)?t:U(t);return{lang:e,locale:n,t:J9e(t)}},nn=()=>{const t=Wl("locale");return eFe(A(()=>t.value||Z9e))},QP=t=>{kn(t)||Ls("[useLockscreen]","You need to pass a ref param to this function");const e=Fe("popup"),n=TF(()=>e.bm("parent","hidden"));if(!Kt||ja(document.body,n.value))return;let s=0,r=!1,o="0";const a=()=>{setTimeout(()=>{mo(document.body,n.value),r&&(document.body.style.width=o)},200)};Me(t,i=>{if(!i){a();return}r=!ja(document.body,n.value),r&&(o=document.body.style.width),s=lP(e.namespace.value);const l=document.documentElement.clientHeight<document.body.scrollHeight,u=dl(document.body,"overflowY");s>0&&(l||u==="scroll")&&r&&(document.body.style.width=`calc(100% - ${s}px)`),xi(document.body,n.value)}),cF(()=>a())},tFe=oi({type:Se(Boolean),default:null}),nFe=oi({type:Se(Function)}),sFe=t=>{const e=`update:${t}`,n=`onUpdate:${t}`,s=[e],r={[t]:tFe,[n]:nFe};return{useModelToggle:({indicator:a,toggleReason:i,shouldHideWhenRouteChanges:l,shouldProceed:u,onShow:c,onHide:d})=>{const f=Rt(),{emit:h}=f,p=f.props,m=A(()=>vt(p[n])),g=A(()=>p[t]===null),y=k=>{a.value!==!0&&(a.value=!0,i&&(i.value=k),vt(c)&&c(k))},w=k=>{a.value!==!1&&(a.value=!1,i&&(i.value=k),vt(d)&&d(k))},b=k=>{if(p.disabled===!0||vt(u)&&!u())return;const C=m.value&&Kt;C&&h(e,!0),(g.value||!C)&&y(k)},_=k=>{if(p.disabled===!0||!Kt)return;const C=m.value&&Kt;C&&h(e,!1),(g.value||!C)&&w(k)},$=k=>{!Rs(k)||(p.disabled&&k?m.value&&h(e,!1):a.value!==k&&(k?y():w()))},x=()=>{a.value?_():b()};return Me(()=>p[t],$),l&&f.appContext.config.globalProperties.$route!==void 0&&Me(()=>({...f.proxy.$route}),()=>{l.value&&a.value&&_()}),It(()=>{$(p[t])}),{hide:_,show:b,toggle:x,hasUpdateHandler:m}},useModelToggleProps:r,useModelToggleEmits:s}},rFe=(t,e)=>{let n;Me(()=>t.value,s=>{var r,o;s?(n=document.activeElement,kn(e)&&((o=(r=e.value).focus)==null||o.call(r))):n.focus()})},HC=t=>{if(!t)return{onClick:gn,onMousedown:gn,onMouseup:gn};let e=!1,n=!1;return{onClick:a=>{e&&n&&t(a),e=n=!1},onMousedown:a=>{e=a.target===a.currentTarget},onMouseup:a=>{n=a.target===a.currentTarget}}},oFe=(t,e=0)=>{if(e===0)return t;const n=U(!1);let s=0;const r=()=>{s&&clearTimeout(s),s=window.setTimeout(()=>{n.value=t.value},e)};return It(r),Me(()=>t.value,o=>{o?r():n.value=o}),n};function aFe(){let t;const e=(s,r)=>{n(),t=window.setTimeout(s,r)},n=()=>window.clearTimeout(t);return iw(()=>n()),{registerTimeout:e,cancelTimeout:n}}let kf=[];const GA=t=>{const e=t;e.key===ut.esc&&kf.forEach(n=>n(e))},iFe=t=>{It(()=>{kf.length===0&&document.addEventListener("keydown",GA),Kt&&kf.push(t)}),ts(()=>{kf=kf.filter(e=>e!==t),kf.length===0&&Kt&&document.removeEventListener("keydown",GA)})};let jA;const eL=()=>{const t=Wl("namespace",vw),e=JP(),n=A(()=>`${t.value}-popper-container-${e.prefix}`),s=A(()=>`#${n.value}`);return{id:n,selector:s}},lFe=t=>{const e=document.createElement("div");return e.id=t,document.body.appendChild(e),e},uFe=()=>{Xb(()=>{if(!Kt)return;const{id:t,selector:e}=eL();!jA&&!document.body.querySelector(e.value)&&(jA=lFe(t.value))})},cFe=qe({showAfter:{type:Number,default:0},hideAfter:{type:Number,default:200}}),dFe=({showAfter:t,hideAfter:e,open:n,close:s})=>{const{registerTimeout:r}=aFe();return{onOpen:i=>{r(()=>{n(i)},v(t))},onClose:i=>{r(()=>{s(i)},v(e))}}},tL=Symbol("elForwardRef"),fFe=t=>{Lt(tL,{setForwardRef:n=>{t.value=n}})},hFe=t=>({mounted(e){t(e)},updated(e){t(e)},unmounted(){t(null)}}),KA=U(0),Ul=()=>{const t=Wl("zIndex",2e3),e=A(()=>t.value+KA.value);return{initialZIndex:t,currentZIndex:e,nextZIndex:()=>(KA.value++,e.value)}};function WC(t){return t.split("-")[0]}function UC(t){return t.split("-")[1]}function GC(t){return["top","bottom"].includes(WC(t))?"x":"y"}function nL(t){return t==="y"?"height":"width"}function qA(t,e,n){let{reference:s,floating:r}=t;const o=s.x+s.width/2-r.width/2,a=s.y+s.height/2-r.height/2,i=GC(e),l=nL(i),u=s[l]/2-r[l]/2,c=WC(e),d=i==="x";let f;switch(c){case"top":f={x:o,y:s.y-r.height};break;case"bottom":f={x:o,y:s.y+s.height};break;case"right":f={x:s.x+s.width,y:a};break;case"left":f={x:s.x-r.width,y:a};break;default:f={x:s.x,y:s.y}}switch(UC(e)){case"start":f[i]-=u*(n&&d?-1:1);break;case"end":f[i]+=u*(n&&d?-1:1);break}return f}const pFe=async(t,e,n)=>{const{placement:s="bottom",strategy:r="absolute",middleware:o=[],platform:a}=n,i=o.filter(Boolean),l=await(a.isRTL==null?void 0:a.isRTL(e));let u=await a.getElementRects({reference:t,floating:e,strategy:r}),{x:c,y:d}=qA(u,s,l),f=s,h={},p=0;for(let m=0;m<i.length;m++){const{name:g,fn:y}=i[m],{x:w,y:b,data:_,reset:$}=await y({x:c,y:d,initialPlacement:s,placement:f,strategy:r,middlewareData:h,rects:u,platform:a,elements:{reference:t,floating:e}});if(c=w??c,d=b??d,h={...h,[g]:{...h[g],..._}},$&&p<=50){p++,typeof $=="object"&&($.placement&&(f=$.placement),$.rects&&(u=$.rects===!0?await a.getElementRects({reference:t,floating:e,strategy:r}):$.rects),{x:c,y:d}=qA(u,f,l)),m=-1;continue}}return{x:c,y:d,placement:f,strategy:r,middlewareData:h}};function mFe(t){return{top:0,right:0,bottom:0,left:0,...t}}function gFe(t){return typeof t!="number"?mFe(t):{top:t,right:t,bottom:t,left:t}}function XA(t){return{...t,top:t.y,left:t.x,right:t.x+t.width,bottom:t.y+t.height}}const vFe=Math.min,yFe=Math.max;function bFe(t,e,n){return yFe(t,vFe(e,n))}const wFe=t=>({name:"arrow",options:t,async fn(e){const{element:n,padding:s=0}=t??{},{x:r,y:o,placement:a,rects:i,platform:l}=e;if(n==null)return{};const u=gFe(s),c={x:r,y:o},d=GC(a),f=UC(a),h=nL(d),p=await l.getDimensions(n),m=d==="y"?"top":"left",g=d==="y"?"bottom":"right",y=i.reference[h]+i.reference[d]-c[d]-i.floating[h],w=c[d]-i.reference[d],b=await(l.getOffsetParent==null?void 0:l.getOffsetParent(n));let _=b?d==="y"?b.clientHeight||0:b.clientWidth||0:0;_===0&&(_=i.floating[h]);const $=y/2-w/2,x=u[m],k=_-p[h]-u[g],C=_/2-p[h]/2+$,T=bFe(x,C,k),R=(f==="start"?u[m]:u[g])>0&&C!==T&&i.reference[h]<=i.floating[h]?C<x?x-C:k-C:0;return{[d]:c[d]-R,data:{[d]:T,centerOffset:C-T}}}});async function _Fe(t,e){const{placement:n,platform:s,elements:r}=t,o=await(s.isRTL==null?void 0:s.isRTL(r.floating)),a=WC(n),i=UC(n),l=GC(n)==="x",u=["left","top"].includes(a)?-1:1,c=o&&l?-1:1,d=typeof e=="function"?e(t):e;let{mainAxis:f,crossAxis:h,alignmentAxis:p}=typeof d=="number"?{mainAxis:d,crossAxis:0,alignmentAxis:null}:{mainAxis:0,crossAxis:0,alignmentAxis:null,...d};return i&&typeof p=="number"&&(h=i==="end"?p*-1:p),l?{x:h*c,y:f*u}:{x:f*u,y:h*c}}const $Fe=function(t){return t===void 0&&(t=0),{name:"offset",options:t,async fn(e){const{x:n,y:s}=e,r=await _Fe(e,t);return{x:n+r.x,y:s+r.y,data:r}}}},YA=Math.min,l0=Math.max,Ey=Math.round;function yw(t,e){const n=e||t.getBoundingClientRect();return{x:t.offsetWidth>0&&Ey(n.width)/t.offsetWidth||1,y:t.offsetHeight>0&&Ey(n.height)/t.offsetHeight||1}}function Gl(t){var e;return((e=t.ownerDocument)==null?void 0:e.defaultView)||window}function Cl(t){return Gl(t).getComputedStyle(t)}function ju(t){return rL(t)?(t.nodeName||"").toLowerCase():""}function sL(){const t=navigator.userAgentData;return t&&Array.isArray(t.brands)?t.brands.map(e=>e.brand+"/"+e.version).join(" "):navigator.userAgent}function zi(t){return t instanceof Gl(t).HTMLElement}function Sd(t){return t instanceof Gl(t).Element}function rL(t){return t instanceof Gl(t).Node}function ZA(t){if(typeof ShadowRoot>"u")return!1;const e=Gl(t).ShadowRoot;return t instanceof e||t instanceof ShadowRoot}function bw(t){const{overflow:e,overflowX:n,overflowY:s,display:r}=Cl(t);return/auto|scroll|overlay|hidden/.test(e+s+n)&&!["inline","contents"].includes(r)}function xFe(t){return["table","td","th"].includes(ju(t))}function jC(t){const e=/firefox/i.test(sL()),n=Cl(t),s=n.backdropFilter||n.WebkitBackdropFilter;return n.transform!=="none"||n.perspective!=="none"||(s?s!=="none":!1)||e&&n.willChange==="filter"||e&&(n.filter?n.filter!=="none":!1)||["transform","perspective"].some(r=>n.willChange.includes(r))||["paint","layout","strict","content"].some(r=>{const o=n.contain;return o!=null?o.includes(r):!1})}function oL(){return!/^((?!chrome|android).)*safari/i.test(sL())}function KC(t){return["html","body","#document"].includes(ju(t))}function Cd(t,e,n){var s,r,o,a;e===void 0&&(e=!1),n===void 0&&(n=!1);const i=t.getBoundingClientRect();let l=i,u=t,c={x:1,y:1};!Sd(t)&&t.contextElement&&(l=t.contextElement.getBoundingClientRect(),u=t.contextElement),e&&zi(u)&&(c=yw(u,l));const d=Sd(t)?Gl(t):window,f=!oL()&&n,h=(i.left+(f&&(s=(r=d.visualViewport)==null?void 0:r.offsetLeft)!=null?s:0))/c.x,p=(i.top+(f&&(o=(a=d.visualViewport)==null?void 0:a.offsetTop)!=null?o:0))/c.y,m=i.width/c.x,g=i.height/c.y;return{width:m,height:g,top:p,right:h+m,bottom:p+g,left:h,x:h,y:p}}function lc(t){return((rL(t)?t.ownerDocument:t.document)||window.document).documentElement}function ww(t){return Sd(t)?{scrollLeft:t.scrollLeft,scrollTop:t.scrollTop}:{scrollLeft:t.pageXOffset,scrollTop:t.pageYOffset}}function aL(t){return Cd(lc(t)).left+ww(t).scrollLeft}function SFe(t){const e=Cd(t);return Ey(e.width)!==t.offsetWidth||Ey(e.height)!==t.offsetHeight}function CFe(t,e,n){const s=zi(e),r=lc(e),o=Cd(t,s&&SFe(e),n==="fixed");let a={scrollLeft:0,scrollTop:0};const i={x:0,y:0};if(s||!s&&n!=="fixed")if((ju(e)!=="body"||bw(r))&&(a=ww(e)),zi(e)){const l=Cd(e,!0);i.x=l.x+e.clientLeft,i.y=l.y+e.clientTop}else r&&(i.x=aL(r));return{x:o.left+a.scrollLeft-i.x,y:o.top+a.scrollTop-i.y,width:o.width,height:o.height}}function F0(t){if(ju(t)==="html")return t;const e=t.assignedSlot||t.parentNode||(ZA(t)?t.host:null)||lc(t);return ZA(e)?e.host:e}function JA(t){return!zi(t)||Cl(t).position==="fixed"?null:t.offsetParent}function kFe(t){let e=F0(t);for(;zi(e)&&!KC(e);){if(jC(e))return e;e=F0(e)}return null}function QA(t){const e=Gl(t);let n=JA(t);for(;n&&xFe(n)&&Cl(n).position==="static";)n=JA(n);return n&&(ju(n)==="html"||ju(n)==="body"&&Cl(n).position==="static"&&!jC(n))?e:n||kFe(t)||e}function TFe(t){if(zi(t))return{width:t.offsetWidth,height:t.offsetHeight};const e=Cd(t);return{width:e.width,height:e.height}}function NFe(t){let{rect:e,offsetParent:n,strategy:s}=t;const r=zi(n),o=lc(n);if(n===o)return e;let a={scrollLeft:0,scrollTop:0},i={x:1,y:1};const l={x:0,y:0};if((r||!r&&s!=="fixed")&&((ju(n)!=="body"||bw(o))&&(a=ww(n)),zi(n))){const u=Cd(n);i=yw(n),l.x=u.x+n.clientLeft,l.y=u.y+n.clientTop}return{width:e.width*i.x,height:e.height*i.y,x:e.x*i.x-a.scrollLeft*i.x+l.x,y:e.y*i.y-a.scrollTop*i.y+l.y}}function IFe(t,e){const n=Gl(t),s=lc(t),r=n.visualViewport;let o=s.clientWidth,a=s.clientHeight,i=0,l=0;if(r){o=r.width,a=r.height;const u=oL();(u||!u&&e==="fixed")&&(i=r.offsetLeft,l=r.offsetTop)}return{width:o,height:a,x:i,y:l}}function EFe(t){var e;const n=lc(t),s=ww(t),r=(e=t.ownerDocument)==null?void 0:e.body,o=l0(n.scrollWidth,n.clientWidth,r?r.scrollWidth:0,r?r.clientWidth:0),a=l0(n.scrollHeight,n.clientHeight,r?r.scrollHeight:0,r?r.clientHeight:0);let i=-s.scrollLeft+aL(t);const l=-s.scrollTop;return Cl(r||n).direction==="rtl"&&(i+=l0(n.clientWidth,r?r.clientWidth:0)-o),{width:o,height:a,x:i,y:l}}function iL(t){const e=F0(t);return KC(e)?t.ownerDocument.body:zi(e)&&bw(e)?e:iL(e)}function lL(t,e){var n;e===void 0&&(e=[]);const s=iL(t),r=s===((n=t.ownerDocument)==null?void 0:n.body),o=Gl(s);return r?e.concat(o,o.visualViewport||[],bw(s)?s:[]):e.concat(s,lL(s))}function AFe(t,e){const n=Cd(t,!0,e==="fixed"),s=n.top+t.clientTop,r=n.left+t.clientLeft,o=zi(t)?yw(t):{x:1,y:1},a=t.clientWidth*o.x,i=t.clientHeight*o.y,l=r*o.x,u=s*o.y;return{top:u,left:l,right:l+a,bottom:u+i,x:l,y:u,width:a,height:i}}function eO(t,e,n){return e==="viewport"?XA(IFe(t,n)):Sd(e)?AFe(e,n):XA(EFe(lc(t)))}function OFe(t){let e=lL(t).filter(o=>Sd(o)&&ju(o)!=="body"),n=null;const s=Cl(t).position==="fixed";let r=s?F0(t):t;for(;Sd(r)&&!KC(r);){const o=Cl(r),a=jC(r);(s?!a&&!n:!a&&o.position==="static"&&!!n&&["absolute","fixed"].includes(n.position))?e=e.filter(l=>l!==r):n=o,r=F0(r)}return e}function RFe(t){let{element:e,boundary:n,rootBoundary:s,strategy:r}=t;const a=[...n==="clippingAncestors"?OFe(e):[].concat(n),s],i=a[0],l=a.reduce((u,c)=>{const d=eO(e,c,r);return u.top=l0(d.top,u.top),u.right=YA(d.right,u.right),u.bottom=YA(d.bottom,u.bottom),u.left=l0(d.left,u.left),u},eO(e,i,r));return{width:l.right-l.left,height:l.bottom-l.top,x:l.left,y:l.top}}const DFe={getClippingRect:RFe,convertOffsetParentRelativeRectToViewportRelativeRect:NFe,isElement:Sd,getDimensions:TFe,getOffsetParent:QA,getDocumentElement:lc,getScale:yw,async getElementRects(t){let{reference:e,floating:n,strategy:s}=t;const r=this.getOffsetParent||QA,o=this.getDimensions;return{reference:CFe(e,await r(n),s),floating:{x:0,y:0,...await o(n)}}},getClientRects:t=>Array.from(t.getClientRects()),isRTL:t=>Cl(t).direction==="rtl"},FFe=(t,e,n)=>pFe(t,e,{platform:DFe,...n});qe({});const MFe=t=>{if(!Kt)return;if(!t)return t;const e=Mo(t);return e||(kn(t)?e:t)},PFe=({middleware:t,placement:e,strategy:n})=>{const s=U(),r=U(),o=U(),a=U(),i=U({}),l={x:o,y:a,placement:e,strategy:n,middlewareData:i},u=async()=>{if(!Kt)return;const c=MFe(s),d=Mo(r);if(!c||!d)return;const f=await FFe(c,d,{placement:v(e),strategy:v(n),middleware:v(t)});D0(l).forEach(h=>{l[h].value=f[h]})};return It(()=>{Ho(()=>{u()})}),{...l,update:u,referenceRef:s,contentRef:r}},LFe=({arrowRef:t,padding:e})=>({name:"arrow",options:{element:t,padding:e},fn(n){const s=v(t);return s?wFe({element:s,padding:e}).fn(n):{}}});function zFe(t){const e=U();function n(){if(t.value==null)return;const{selectionStart:r,selectionEnd:o,value:a}=t.value;if(r==null||o==null)return;const i=a.slice(0,Math.max(0,r)),l=a.slice(Math.max(0,o));e.value={selectionStart:r,selectionEnd:o,value:a,beforeTxt:i,afterTxt:l}}function s(){if(t.value==null||e.value==null)return;const{value:r}=t.value,{beforeTxt:o,afterTxt:a,selectionStart:i}=e.value;if(o==null||a==null||i==null)return;let l=r.length;if(r.endsWith(a))l=r.length-a.length;else if(r.startsWith(o))l=o.length;else{const u=o[i-1],c=r.indexOf(u,i-1);c!==-1&&(l=c+1)}t.value.setSelectionRange(l,l)}return[n,s]}const BFe=(t,e,n)=>Gf(t.subTree).filter(o=>{var a;return Bn(o)&&((a=o.type)==null?void 0:a.name)===e&&!!o.component}).map(o=>o.component.uid).map(o=>n[o]).filter(o=>!!o),uL=(t,e)=>{const n={},s=Nn([]);return{children:s,addChild:a=>{n[a.uid]=a,s.value=BFe(t,e,n)},removeChild:a=>{delete n[a],s.value=s.value.filter(i=>i.uid!==a)}}},VFe="2.2.26",HFe=(t=[])=>({version:VFe,install:(n,s)=>{n[VA]||(n[VA]=!0,t.forEach(r=>n.use(r)),s&&YP(s,n,!0))}}),WFe=qe({zIndex:{type:Se([Number,String]),default:100},target:{type:String,default:""},offset:{type:Number,default:0},position:{type:String,values:["top","bottom"],default:"top"}}),UFe={scroll:({scrollTop:t,fixed:e})=>Ct(t)&&Rs(e),[Fn]:t=>Rs(t)};var je=(t,e)=>{const n=t.__vccOpts||t;for(const[s,r]of e)n[s]=r;return n};const cL="ElAffix",GFe=ue({name:cL}),jFe=ue({...GFe,props:WFe,emits:UFe,setup(t,{expose:e,emit:n}){const s=t,r=Fe("affix"),o=Nn(),a=Nn(),i=Nn(),{height:l}=Due(),{height:u,width:c,top:d,bottom:f,update:h}=MA(a,{windowScroll:!1}),p=MA(o),m=U(!1),g=U(0),y=U(0),w=A(()=>({height:m.value?`${u.value}px`:"",width:m.value?`${c.value}px`:""})),b=A(()=>{if(!m.value)return{};const x=s.offset?Cs(s.offset):0;return{height:`${u.value}px`,width:`${c.value}px`,top:s.position==="top"?x:"",bottom:s.position==="bottom"?x:"",transform:y.value?`translateY(${y.value}px)`:"",zIndex:s.zIndex}}),_=()=>{if(!!i.value)if(g.value=i.value instanceof Window?document.documentElement.scrollTop:i.value.scrollTop||0,s.position==="top")if(s.target){const x=p.bottom.value-s.offset-u.value;m.value=s.offset>d.value&&p.bottom.value>0,y.value=x<0?x:0}else m.value=s.offset>d.value;else if(s.target){const x=l.value-p.top.value-s.offset-u.value;m.value=l.value-s.offset<f.value&&l.value>p.top.value,y.value=x<0?-x:0}else m.value=l.value-s.offset<f.value},$=()=>{h(),n("scroll",{scrollTop:g.value,fixed:m.value})};return Me(m,x=>n("change",x)),It(()=>{var x;s.target?(o.value=(x=document.querySelector(s.target))!=null?x:void 0,o.value||Ls(cL,`Target is not existed: ${s.target}`)):o.value=document.documentElement,i.value=IC(a.value,!0),h()}),Rn(i,"scroll",$),Ho(_),e({update:_,updateRoot:h}),(x,k)=>(S(),E("div",{ref_key:"root",ref:a,class:P(v(r).b()),style:ot(v(w))},[I("div",{class:P({[v(r).m("fixed")]:m.value}),style:ot(v(b))},[Oe(x.$slots,"default")],6)],6))}});var KFe=je(jFe,[["__file","/home/runner/work/element-plus/element-plus/packages/components/affix/src/affix.vue"]]);const qFe=Dt(KFe),XFe=qe({size:{type:Se([Number,String])},color:{type:String}}),YFe=ue({name:"ElIcon",inheritAttrs:!1}),ZFe=ue({...YFe,props:XFe,setup(t){const e=t,n=Fe("icon"),s=A(()=>{const{size:r,color:o}=e;return!r&&!o?{}:{fontSize:er(r)?void 0:Cs(r),"--color":o}});return(r,o)=>(S(),E("i",zt({class:v(n).b(),style:v(s)},r.$attrs),[Oe(r.$slots,"default")],16))}});var JFe=je(ZFe,[["__file","/home/runner/work/element-plus/element-plus/packages/components/icon/src/icon.vue"]]);const rt=Dt(JFe),QFe=["light","dark"],eMe=qe({title:{type:String,default:""},description:{type:String,default:""},type:{type:String,values:D0(Gu),default:"info"},closable:{type:Boolean,default:!0},closeText:{type:String,default:""},showIcon:Boolean,center:Boolean,effect:{type:String,values:QFe,default:"light"}}),tMe={close:t=>t instanceof MouseEvent},nMe=ue({name:"ElAlert"}),sMe=ue({...nMe,props:eMe,emits:tMe,setup(t,{emit:e}){const n=t,{Close:s}=FC,r=ir(),o=Fe("alert"),a=U(!0),i=A(()=>Gu[n.type]),l=A(()=>[o.e("icon"),{[o.is("big")]:!!n.description||!!r.default}]),u=A(()=>({[o.is("bold")]:n.description||r.default})),c=d=>{a.value=!1,e("close",d)};return(d,f)=>(S(),$e(ms,{name:v(o).b("fade"),persisted:""},{default:ce(()=>[St(I("div",{class:P([v(o).b(),v(o).m(d.type),v(o).is("center",d.center),v(o).is(d.effect)]),role:"alert"},[d.showIcon&&v(i)?(S(),$e(v(rt),{key:0,class:P(v(l))},{default:ce(()=>[(S(),$e(Vt(v(i))))]),_:1},8,["class"])):ge("v-if",!0),I("div",{class:P(v(o).e("content"))},[d.title||d.$slots.title?(S(),E("span",{key:0,class:P([v(o).e("title"),v(u)])},[Oe(d.$slots,"title",{},()=>[Yt(Ue(d.title),1)])],2)):ge("v-if",!0),d.$slots.default||d.description?(S(),E("p",{key:1,class:P(v(o).e("description"))},[Oe(d.$slots,"default",{},()=>[Yt(Ue(d.description),1)])],2)):ge("v-if",!0),d.closable?(S(),E(lt,{key:2},[d.closeText?(S(),E("div",{key:0,class:P([v(o).e("close-btn"),v(o).is("customed")]),onClick:c},Ue(d.closeText),3)):(S(),$e(v(rt),{key:1,class:P(v(o).e("close-btn")),onClick:c},{default:ce(()=>[se(v(s))]),_:1},8,["class"]))],64)):ge("v-if",!0)],2)],2),[[Qt,a.value]])]),_:3},8,["name"]))}});var rMe=je(sMe,[["__file","/home/runner/work/element-plus/element-plus/packages/components/alert/src/alert.vue"]]);const oMe=Dt(rMe);let Oa;const aMe=`
  height:0 !important;
  visibility:hidden !important;
  overflow:hidden !important;
  position:absolute !important;
  z-index:-1000 !important;
  top:0 !important;
  right:0 !important;
`,iMe=["letter-spacing","line-height","padding-top","padding-bottom","font-family","font-weight","font-size","text-rendering","text-transform","width","text-indent","padding-left","padding-right","border-width","box-sizing"];function lMe(t){const e=window.getComputedStyle(t),n=e.getPropertyValue("box-sizing"),s=Number.parseFloat(e.getPropertyValue("padding-bottom"))+Number.parseFloat(e.getPropertyValue("padding-top")),r=Number.parseFloat(e.getPropertyValue("border-bottom-width"))+Number.parseFloat(e.getPropertyValue("border-top-width"));return{contextStyle:iMe.map(a=>`${a}:${e.getPropertyValue(a)}`).join(";"),paddingSize:s,borderSize:r,boxSizing:n}}function tO(t,e=1,n){var s;Oa||(Oa=document.createElement("textarea"),document.body.appendChild(Oa));const{paddingSize:r,borderSize:o,boxSizing:a,contextStyle:i}=lMe(t);Oa.setAttribute("style",`${i};${aMe}`),Oa.value=t.value||t.placeholder||"";let l=Oa.scrollHeight;const u={};a==="border-box"?l=l+o:a==="content-box"&&(l=l-r),Oa.value="";const c=Oa.scrollHeight-r;if(Ct(e)){let d=c*e;a==="border-box"&&(d=d+r+o),l=Math.max(d,l),u.minHeight=`${d}px`}if(Ct(n)){let d=c*n;a==="border-box"&&(d=d+r+o),l=Math.min(d,l)}return u.height=`${l}px`,(s=Oa.parentNode)==null||s.removeChild(Oa),Oa=void 0,u}const uMe=qe({id:{type:String,default:void 0},size:wo,disabled:Boolean,modelValue:{type:Se([String,Number,Object]),default:""},type:{type:String,default:"text"},resize:{type:String,values:["none","both","horizontal","vertical"]},autosize:{type:Se([Boolean,Object]),default:!1},autocomplete:{type:String,default:"off"},formatter:{type:Function},parser:{type:Function},placeholder:{type:String},form:{type:String},readonly:{type:Boolean,default:!1},clearable:{type:Boolean,default:!1},showPassword:{type:Boolean,default:!1},showWordLimit:{type:Boolean,default:!1},suffixIcon:{type:In},prefixIcon:{type:In},containerRole:{type:String,default:void 0},label:{type:String,default:void 0},tabindex:{type:[String,Number],default:0},validateEvent:{type:Boolean,default:!0},inputStyle:{type:Se([Object,Array,String]),default:()=>Ln({})}}),cMe={[Ot]:t=>wt(t),input:t=>wt(t),change:t=>wt(t),focus:t=>t instanceof FocusEvent,blur:t=>t instanceof FocusEvent,clear:()=>!0,mouseleave:t=>t instanceof MouseEvent,mouseenter:t=>t instanceof MouseEvent,keydown:t=>t instanceof Event,compositionstart:t=>t instanceof CompositionEvent,compositionupdate:t=>t instanceof CompositionEvent,compositionend:t=>t instanceof CompositionEvent},dMe=["role"],fMe=["id","type","disabled","formatter","parser","readonly","autocomplete","tabindex","aria-label","placeholder","form"],hMe=["id","tabindex","disabled","readonly","autocomplete","aria-label","placeholder","form"],pMe=ue({name:"ElInput",inheritAttrs:!1}),mMe=ue({...pMe,props:uMe,emits:cMe,setup(t,{expose:e,emit:n}){const s=t,r=Tg(),o=ir(),a=A(()=>{const me={};return s.containerRole==="combobox"&&(me["aria-haspopup"]=r["aria-haspopup"],me["aria-owns"]=r["aria-owns"],me["aria-expanded"]=r["aria-expanded"]),me}),i=A(()=>[s.type==="textarea"?g.b():m.b(),m.m(h.value),m.is("disabled",p.value),m.is("exceed",Z.value),{[m.b("group")]:o.prepend||o.append,[m.bm("group","append")]:o.append,[m.bm("group","prepend")]:o.prepend,[m.m("prefix")]:o.prefix||s.prefixIcon,[m.m("suffix")]:o.suffix||s.suffixIcon||s.clearable||s.showPassword,[m.bm("suffix","password-clear")]:O.value&&F.value},r.class]),l=A(()=>[m.e("wrapper"),m.is("focus",b.value)]),u=zC({excludeKeys:A(()=>Object.keys(a.value))}),{form:c,formItem:d}=to(),{inputId:f}=ic(s,{formItemContext:d}),h=ks(),p=To(),m=Fe("input"),g=Fe("textarea"),y=Nn(),w=Nn(),b=U(!1),_=U(!1),$=U(!1),x=U(!1),k=U(),C=Nn(s.inputStyle),T=A(()=>y.value||w.value),N=A(()=>{var me;return(me=c==null?void 0:c.statusIcon)!=null?me:!1}),M=A(()=>(d==null?void 0:d.validateState)||""),R=A(()=>M.value&&RP[M.value]),D=A(()=>x.value?IP:vP),z=A(()=>[r.style,s.inputStyle]),B=A(()=>[s.inputStyle,C.value,{resize:s.resize}]),V=A(()=>nr(s.modelValue)?"":String(s.modelValue)),O=A(()=>s.clearable&&!p.value&&!s.readonly&&!!V.value&&(b.value||_.value)),F=A(()=>s.showPassword&&!p.value&&!s.readonly&&!!V.value&&(!!V.value||b.value)),L=A(()=>s.showWordLimit&&!!u.value.maxlength&&(s.type==="text"||s.type==="textarea")&&!p.value&&!s.readonly&&!s.showPassword),G=A(()=>Array.from(V.value).length),Z=A(()=>!!L.value&&G.value>Number(u.value.maxlength)),j=A(()=>!!o.suffix||!!s.suffixIcon||O.value||s.showPassword||L.value||!!M.value&&N.value),[J,fe]=zFe(y);Dr(w,me=>{if(!L.value||s.resize!=="both")return;const Ve=me[0],{width:Ye}=Ve.contentRect;k.value={right:`calc(100% - ${Ye+15+6}px)`}});const X=()=>{const{type:me,autosize:Ve}=s;if(!(!Kt||me!=="textarea"))if(Ve){const Ye=Bt(Ve)?Ve.minRows:void 0,Je=Bt(Ve)?Ve.maxRows:void 0;C.value={...tO(w.value,Ye,Je)}}else C.value={minHeight:tO(w.value).minHeight}},oe=()=>{const me=T.value;!me||me.value===V.value||(me.value=V.value)},ee=async me=>{J();let{value:Ve}=me.target;if(s.formatter&&(Ve=s.parser?s.parser(Ve):Ve,Ve=s.formatter(Ve)),!$.value){if(Ve===V.value){oe();return}n(Ot,Ve),n("input",Ve),await nt(),oe(),fe()}},Q=me=>{n("change",me.target.value)},ie=me=>{n("compositionstart",me),$.value=!0},pe=me=>{var Ve;n("compositionupdate",me);const Ye=(Ve=me.target)==null?void 0:Ve.value,Je=Ye[Ye.length-1]||"";$.value=!fw(Je)},Re=me=>{n("compositionend",me),$.value&&($.value=!1,ee(me))},K=()=>{x.value=!x.value,re()},re=async()=>{var me;await nt(),(me=T.value)==null||me.focus()},we=()=>{var me;return(me=T.value)==null?void 0:me.blur()},Ee=me=>{b.value=!0,n("focus",me)},De=me=>{var Ve;b.value=!1,n("blur",me),s.validateEvent&&((Ve=d==null?void 0:d.validate)==null||Ve.call(d,"blur").catch(Ye=>void 0))},_e=me=>{_.value=!1,n("mouseleave",me)},ze=me=>{_.value=!0,n("mouseenter",me)},Ae=me=>{n("keydown",me)},he=()=>{var me;(me=T.value)==null||me.select()},ve=()=>{n(Ot,""),n("change",""),n("clear"),n("input","")};return Me(()=>s.modelValue,()=>{var me;nt(()=>X()),s.validateEvent&&((me=d==null?void 0:d.validate)==null||me.call(d,"change").catch(Ve=>void 0))}),Me(V,()=>oe()),Me(()=>s.type,async()=>{await nt(),oe(),X()}),It(()=>{!s.formatter&&s.parser,oe(),nt(X)}),e({input:y,textarea:w,ref:T,textareaStyle:B,autosize:Un(s,"autosize"),focus:re,blur:we,select:he,clear:ve,resizeTextarea:X}),(me,Ve)=>St((S(),E("div",zt(v(a),{class:v(i),style:v(z),role:me.containerRole,onMouseenter:ze,onMouseleave:_e}),[ge(" input "),me.type!=="textarea"?(S(),E(lt,{key:0},[ge(" prepend slot "),me.$slots.prepend?(S(),E("div",{key:0,class:P(v(m).be("group","prepend"))},[Oe(me.$slots,"prepend")],2)):ge("v-if",!0),I("div",{class:P(v(l))},[ge(" prefix slot "),me.$slots.prefix||me.prefixIcon?(S(),E("span",{key:0,class:P(v(m).e("prefix"))},[I("span",{class:P(v(m).e("prefix-inner")),onClick:re},[Oe(me.$slots,"prefix"),me.prefixIcon?(S(),$e(v(rt),{key:0,class:P(v(m).e("icon"))},{default:ce(()=>[(S(),$e(Vt(me.prefixIcon)))]),_:1},8,["class"])):ge("v-if",!0)],2)],2)):ge("v-if",!0),I("input",zt({id:v(f),ref_key:"input",ref:y,class:v(m).e("inner")},v(u),{type:me.showPassword?x.value?"text":"password":me.type,disabled:v(p),formatter:me.formatter,parser:me.parser,readonly:me.readonly,autocomplete:me.autocomplete,tabindex:me.tabindex,"aria-label":me.label,placeholder:me.placeholder,style:me.inputStyle,form:s.form,onCompositionstart:ie,onCompositionupdate:pe,onCompositionend:Re,onInput:ee,onFocus:Ee,onBlur:De,onChange:Q,onKeydown:Ae}),null,16,fMe),ge(" suffix slot "),v(j)?(S(),E("span",{key:1,class:P(v(m).e("suffix"))},[I("span",{class:P(v(m).e("suffix-inner")),onClick:re},[!v(O)||!v(F)||!v(L)?(S(),E(lt,{key:0},[Oe(me.$slots,"suffix"),me.suffixIcon?(S(),$e(v(rt),{key:0,class:P(v(m).e("icon"))},{default:ce(()=>[(S(),$e(Vt(me.suffixIcon)))]),_:1},8,["class"])):ge("v-if",!0)],64)):ge("v-if",!0),v(O)?(S(),$e(v(rt),{key:1,class:P([v(m).e("icon"),v(m).e("clear")]),onMousedown:yt(v(gn),["prevent"]),onClick:ve},{default:ce(()=>[se(v(Bl))]),_:1},8,["class","onMousedown"])):ge("v-if",!0),v(F)?(S(),$e(v(rt),{key:2,class:P([v(m).e("icon"),v(m).e("password")]),onClick:K},{default:ce(()=>[(S(),$e(Vt(v(D))))]),_:1},8,["class"])):ge("v-if",!0),v(L)?(S(),E("span",{key:3,class:P(v(m).e("count"))},[I("span",{class:P(v(m).e("count-inner"))},Ue(v(G))+" / "+Ue(v(u).maxlength),3)],2)):ge("v-if",!0),v(M)&&v(R)&&v(N)?(S(),$e(v(rt),{key:4,class:P([v(m).e("icon"),v(m).e("validateIcon"),v(m).is("loading",v(M)==="validating")])},{default:ce(()=>[(S(),$e(Vt(v(R))))]),_:1},8,["class"])):ge("v-if",!0)],2)],2)):ge("v-if",!0)],2),ge(" append slot "),me.$slots.append?(S(),E("div",{key:1,class:P(v(m).be("group","append"))},[Oe(me.$slots,"append")],2)):ge("v-if",!0)],64)):(S(),E(lt,{key:1},[ge(" textarea "),I("textarea",zt({id:v(f),ref_key:"textarea",ref:w,class:v(g).e("inner")},v(u),{tabindex:me.tabindex,disabled:v(p),readonly:me.readonly,autocomplete:me.autocomplete,style:v(B),"aria-label":me.label,placeholder:me.placeholder,form:s.form,onCompositionstart:ie,onCompositionupdate:pe,onCompositionend:Re,onInput:ee,onFocus:Ee,onBlur:De,onChange:Q,onKeydown:Ae}),null,16,hMe),v(L)?(S(),E("span",{key:0,style:ot(k.value),class:P(v(m).e("count"))},Ue(v(G))+" / "+Ue(v(u).maxlength),7)):ge("v-if",!0)],64))],16,dMe)),[[Qt,me.type!=="hidden"]])}});var gMe=je(mMe,[["__file","/home/runner/work/element-plus/element-plus/packages/components/input/src/input.vue"]]);const Or=Dt(gMe),Df=4,dL={vertical:{offset:"offsetHeight",scroll:"scrollTop",scrollSize:"scrollHeight",size:"height",key:"vertical",axis:"Y",client:"clientY",direction:"top"},horizontal:{offset:"offsetWidth",scroll:"scrollLeft",scrollSize:"scrollWidth",size:"width",key:"horizontal",axis:"X",client:"clientX",direction:"left"}},vMe=({move:t,size:e,bar:n})=>({[n.size]:e,transform:`translate${n.axis}(${t}%)`}),yMe=qe({vertical:Boolean,size:String,move:Number,ratio:{type:Number,required:!0},always:Boolean}),bMe="Thumb",wMe=ue({__name:"thumb",props:yMe,setup(t){const e=t,n=et(UP),s=Fe("scrollbar");n||Ls(bMe,"can not inject scrollbar context");const r=U(),o=U(),a=U({}),i=U(!1);let l=!1,u=!1,c=Kt?document.onselectstart:null;const d=A(()=>dL[e.vertical?"vertical":"horizontal"]),f=A(()=>vMe({size:e.size,move:e.move,bar:d.value})),h=A(()=>r.value[d.value.offset]**2/n.wrapElement[d.value.scrollSize]/e.ratio/o.value[d.value.offset]),p=x=>{var k;if(x.stopPropagation(),x.ctrlKey||[1,2].includes(x.button))return;(k=window.getSelection())==null||k.removeAllRanges(),g(x);const C=x.currentTarget;!C||(a.value[d.value.axis]=C[d.value.offset]-(x[d.value.client]-C.getBoundingClientRect()[d.value.direction]))},m=x=>{if(!o.value||!r.value||!n.wrapElement)return;const k=Math.abs(x.target.getBoundingClientRect()[d.value.direction]-x[d.value.client]),C=o.value[d.value.offset]/2,T=(k-C)*100*h.value/r.value[d.value.offset];n.wrapElement[d.value.scroll]=T*n.wrapElement[d.value.scrollSize]/100},g=x=>{x.stopImmediatePropagation(),l=!0,document.addEventListener("mousemove",y),document.addEventListener("mouseup",w),c=document.onselectstart,document.onselectstart=()=>!1},y=x=>{if(!r.value||!o.value||l===!1)return;const k=a.value[d.value.axis];if(!k)return;const C=(r.value.getBoundingClientRect()[d.value.direction]-x[d.value.client])*-1,T=o.value[d.value.offset]-k,N=(C-T)*100*h.value/r.value[d.value.offset];n.wrapElement[d.value.scroll]=N*n.wrapElement[d.value.scrollSize]/100},w=()=>{l=!1,a.value[d.value.axis]=0,document.removeEventListener("mousemove",y),document.removeEventListener("mouseup",w),$(),u&&(i.value=!1)},b=()=>{u=!1,i.value=!!e.size},_=()=>{u=!0,i.value=l};ts(()=>{$(),document.removeEventListener("mouseup",w)});const $=()=>{document.onselectstart!==c&&(document.onselectstart=c)};return Rn(Un(n,"scrollbarElement"),"mousemove",b),Rn(Un(n,"scrollbarElement"),"mouseleave",_),(x,k)=>(S(),$e(ms,{name:v(s).b("fade"),persisted:""},{default:ce(()=>[St(I("div",{ref_key:"instance",ref:r,class:P([v(s).e("bar"),v(s).is(v(d).key)]),onMousedown:m},[I("div",{ref_key:"thumb",ref:o,class:P(v(s).e("thumb")),style:ot(v(f)),onMousedown:p},null,38)],34),[[Qt,x.always||i.value]])]),_:1},8,["name"]))}});var nO=je(wMe,[["__file","/home/runner/work/element-plus/element-plus/packages/components/scrollbar/src/thumb.vue"]]);const _Me=qe({always:{type:Boolean,default:!0},width:String,height:String,ratioX:{type:Number,default:1},ratioY:{type:Number,default:1}}),$Me=ue({__name:"bar",props:_Me,setup(t,{expose:e}){const n=t,s=U(0),r=U(0);return e({handleScroll:a=>{if(a){const i=a.offsetHeight-Df,l=a.offsetWidth-Df;r.value=a.scrollTop*100/i*n.ratioY,s.value=a.scrollLeft*100/l*n.ratioX}}}),(a,i)=>(S(),E(lt,null,[se(nO,{move:s.value,ratio:a.ratioX,size:a.width,always:a.always},null,8,["move","ratio","size","always"]),se(nO,{move:r.value,ratio:a.ratioY,size:a.height,vertical:"",always:a.always},null,8,["move","ratio","size","always"])],64))}});var xMe=je($Me,[["__file","/home/runner/work/element-plus/element-plus/packages/components/scrollbar/src/bar.vue"]]);const SMe=qe({height:{type:[String,Number],default:""},maxHeight:{type:[String,Number],default:""},native:{type:Boolean,default:!1},wrapStyle:{type:Se([String,Object,Array]),default:""},wrapClass:{type:[String,Array],default:""},viewClass:{type:[String,Array],default:""},viewStyle:{type:[String,Array,Object],default:""},noresize:Boolean,tag:{type:String,default:"div"},always:Boolean,minSize:{type:Number,default:20}}),CMe={scroll:({scrollTop:t,scrollLeft:e})=>[t,e].every(Ct)},kMe="ElScrollbar",TMe=ue({name:kMe}),NMe=ue({...TMe,props:SMe,emits:CMe,setup(t,{expose:e,emit:n}){const s=t,r=Fe("scrollbar");let o,a;const i=U(),l=U(),u=U(),c=U("0"),d=U("0"),f=U(),h=U(1),p=U(1),m=A(()=>{const k={};return s.height&&(k.height=Cs(s.height)),s.maxHeight&&(k.maxHeight=Cs(s.maxHeight)),[s.wrapStyle,k]}),g=A(()=>[s.wrapClass,r.e("wrap"),{[r.em("wrap","hidden-default")]:!s.native}]),y=A(()=>[r.e("view"),s.viewClass]),w=()=>{var k;l.value&&((k=f.value)==null||k.handleScroll(l.value),n("scroll",{scrollTop:l.value.scrollTop,scrollLeft:l.value.scrollLeft}))};function b(k,C){Bt(k)?l.value.scrollTo(k):Ct(k)&&Ct(C)&&l.value.scrollTo(k,C)}const _=k=>{!Ct(k)||(l.value.scrollTop=k)},$=k=>{!Ct(k)||(l.value.scrollLeft=k)},x=()=>{if(!l.value)return;const k=l.value.offsetHeight-Df,C=l.value.offsetWidth-Df,T=k**2/l.value.scrollHeight,N=C**2/l.value.scrollWidth,M=Math.max(T,s.minSize),R=Math.max(N,s.minSize);h.value=T/(k-T)/(M/(k-M)),p.value=N/(C-N)/(R/(C-R)),d.value=M+Df<k?`${M}px`:"",c.value=R+Df<C?`${R}px`:""};return Me(()=>s.noresize,k=>{k?(o==null||o(),a==null||a()):({stop:o}=Dr(u,x),a=Rn("resize",x))},{immediate:!0}),Me(()=>[s.maxHeight,s.height],()=>{s.native||nt(()=>{var k;x(),l.value&&((k=f.value)==null||k.handleScroll(l.value))})}),Lt(UP,on({scrollbarElement:i,wrapElement:l})),It(()=>{s.native||nt(()=>{x()})}),Ml(()=>x()),e({wrapRef:l,update:x,scrollTo:b,setScrollTop:_,setScrollLeft:$,handleScroll:w}),(k,C)=>(S(),E("div",{ref_key:"scrollbarRef",ref:i,class:P(v(r).b())},[I("div",{ref_key:"wrapRef",ref:l,class:P(v(g)),style:ot(v(m)),onScroll:w},[(S(),$e(Vt(k.tag),{ref_key:"resizeRef",ref:u,class:P(v(y)),style:ot(k.viewStyle)},{default:ce(()=>[Oe(k.$slots,"default")]),_:3},8,["class","style"]))],38),k.native?ge("v-if",!0):(S(),$e(xMe,{key:0,ref_key:"barRef",ref:f,height:d.value,width:c.value,always:k.always,"ratio-x":p.value,"ratio-y":h.value},null,8,["height","width","always","ratio-x","ratio-y"]))],2))}});var IMe=je(NMe,[["__file","/home/runner/work/element-plus/element-plus/packages/components/scrollbar/src/scrollbar.vue"]]);const jl=Dt(IMe),EMe=["dialog","grid","group","listbox","menu","navigation","tooltip","tree"],fL=qe({role:{type:String,values:EMe,default:"tooltip"}}),AMe=ue({name:"ElPopperRoot",inheritAttrs:!1}),OMe=ue({...AMe,props:fL,setup(t,{expose:e}){const n=t,s=U(),r=U(),o=U(),a=U(),i=A(()=>n.role),l={triggerRef:s,popperInstanceRef:r,contentRef:o,referenceRef:a,role:i};return e(l),Lt(BC,l),(u,c)=>Oe(u.$slots,"default")}});var RMe=je(OMe,[["__file","/home/runner/work/element-plus/element-plus/packages/components/popper/src/popper.vue"]]);const hL=qe({arrowOffset:{type:Number,default:5}}),DMe=ue({name:"ElPopperArrow",inheritAttrs:!1}),FMe=ue({...DMe,props:hL,setup(t,{expose:e}){const n=t,s=Fe("popper"),{arrowOffset:r,arrowRef:o}=et(KP,void 0);return Me(()=>n.arrowOffset,a=>{r.value=a}),ts(()=>{o.value=void 0}),e({arrowRef:o}),(a,i)=>(S(),E("span",{ref_key:"arrowRef",ref:o,class:P(v(s).e("arrow")),"data-popper-arrow":""},null,2))}});var MMe=je(FMe,[["__file","/home/runner/work/element-plus/element-plus/packages/components/popper/src/arrow.vue"]]);const PMe="ElOnlyChild",pL=ue({name:PMe,setup(t,{slots:e,attrs:n}){var s;const r=et(tL),o=hFe((s=r==null?void 0:r.setForwardRef)!=null?s:gn);return()=>{var a;const i=(a=e.default)==null?void 0:a.call(e,n);if(!i||i.length>1)return null;const l=mL(i);return l?St(_l(l,n),[[o]]):null}}});function mL(t){if(!t)return null;const e=t;for(const n of e){if(Bt(n))switch(n.type){case Gr:continue;case Xh:case"svg":return sO(n);case lt:return mL(n.children);default:return n}return sO(n)}return null}function sO(t){const e=Fe("only-child");return se("span",{class:e.e("content")},[t])}const gL=qe({virtualRef:{type:Se(Object)},virtualTriggering:Boolean,onMouseenter:{type:Se(Function)},onMouseleave:{type:Se(Function)},onClick:{type:Se(Function)},onKeydown:{type:Se(Function)},onFocus:{type:Se(Function)},onBlur:{type:Se(Function)},onContextmenu:{type:Se(Function)},id:String,open:Boolean}),LMe=ue({name:"ElPopperTrigger",inheritAttrs:!1}),zMe=ue({...LMe,props:gL,setup(t,{expose:e}){const n=t,{role:s,triggerRef:r}=et(BC,void 0);fFe(r);const o=A(()=>i.value?n.id:void 0),a=A(()=>{if(s&&s.value==="tooltip")return n.open&&n.id?n.id:void 0}),i=A(()=>{if(s&&s.value!=="tooltip")return s.value}),l=A(()=>i.value?`${n.open}`:void 0);let u;return It(()=>{Me(()=>n.virtualRef,c=>{c&&(r.value=Mo(c))},{immediate:!0}),Me(r,(c,d)=>{u==null||u(),u=void 0,Qa(c)&&(["onMouseenter","onMouseleave","onClick","onKeydown","onFocus","onBlur","onContextmenu"].forEach(f=>{var h;const p=n[f];p&&(c.addEventListener(f.slice(2).toLowerCase(),p),(h=d==null?void 0:d.removeEventListener)==null||h.call(d,f.slice(2).toLowerCase(),p))}),u=Me([o,a,i,l],f=>{["aria-controls","aria-describedby","aria-haspopup","aria-expanded"].forEach((h,p)=>{nr(f[p])?c.removeAttribute(h):c.setAttribute(h,f[p])})},{immediate:!0})),Qa(d)&&["aria-controls","aria-describedby","aria-haspopup","aria-expanded"].forEach(f=>d.removeAttribute(f))},{immediate:!0})}),ts(()=>{u==null||u(),u=void 0}),e({triggerRef:r}),(c,d)=>c.virtualTriggering?ge("v-if",!0):(S(),$e(v(pL),zt({key:0},c.$attrs,{"aria-controls":v(o),"aria-describedby":v(a),"aria-expanded":v(l),"aria-haspopup":v(i)}),{default:ce(()=>[Oe(c.$slots,"default")]),_:3},16,["aria-controls","aria-describedby","aria-expanded","aria-haspopup"]))}});var BMe=je(zMe,[["__file","/home/runner/work/element-plus/element-plus/packages/components/popper/src/trigger.vue"]]),go="top",Sa="bottom",Ca="right",vo="left",qC="auto",Dg=[go,Sa,Ca,vo],fh="start",M0="end",VMe="clippingParents",vL="viewport",Em="popper",HMe="reference",rO=Dg.reduce(function(t,e){return t.concat([e+"-"+fh,e+"-"+M0])},[]),Qd=[].concat(Dg,[qC]).reduce(function(t,e){return t.concat([e,e+"-"+fh,e+"-"+M0])},[]),WMe="beforeRead",UMe="read",GMe="afterRead",jMe="beforeMain",KMe="main",qMe="afterMain",XMe="beforeWrite",YMe="write",ZMe="afterWrite",JMe=[WMe,UMe,GMe,jMe,KMe,qMe,XMe,YMe,ZMe];function Bi(t){return t?(t.nodeName||"").toLowerCase():null}function ai(t){if(t==null)return window;if(t.toString()!=="[object Window]"){var e=t.ownerDocument;return e&&e.defaultView||window}return t}function hh(t){var e=ai(t).Element;return t instanceof e||t instanceof Element}function ya(t){var e=ai(t).HTMLElement;return t instanceof e||t instanceof HTMLElement}function XC(t){if(typeof ShadowRoot>"u")return!1;var e=ai(t).ShadowRoot;return t instanceof e||t instanceof ShadowRoot}function QMe(t){var e=t.state;Object.keys(e.elements).forEach(function(n){var s=e.styles[n]||{},r=e.attributes[n]||{},o=e.elements[n];!ya(o)||!Bi(o)||(Object.assign(o.style,s),Object.keys(r).forEach(function(a){var i=r[a];i===!1?o.removeAttribute(a):o.setAttribute(a,i===!0?"":i)}))})}function ePe(t){var e=t.state,n={popper:{position:e.options.strategy,left:"0",top:"0",margin:"0"},arrow:{position:"absolute"},reference:{}};return Object.assign(e.elements.popper.style,n.popper),e.styles=n,e.elements.arrow&&Object.assign(e.elements.arrow.style,n.arrow),function(){Object.keys(e.elements).forEach(function(s){var r=e.elements[s],o=e.attributes[s]||{},a=Object.keys(e.styles.hasOwnProperty(s)?e.styles[s]:n[s]),i=a.reduce(function(l,u){return l[u]="",l},{});!ya(r)||!Bi(r)||(Object.assign(r.style,i),Object.keys(o).forEach(function(l){r.removeAttribute(l)}))})}}var yL={name:"applyStyles",enabled:!0,phase:"write",fn:QMe,effect:ePe,requires:["computeStyles"]};function Ai(t){return t.split("-")[0]}var od=Math.max,Ay=Math.min,ph=Math.round;function mh(t,e){e===void 0&&(e=!1);var n=t.getBoundingClientRect(),s=1,r=1;if(ya(t)&&e){var o=t.offsetHeight,a=t.offsetWidth;a>0&&(s=ph(n.width)/a||1),o>0&&(r=ph(n.height)/o||1)}return{width:n.width/s,height:n.height/r,top:n.top/r,right:n.right/s,bottom:n.bottom/r,left:n.left/s,x:n.left/s,y:n.top/r}}function YC(t){var e=mh(t),n=t.offsetWidth,s=t.offsetHeight;return Math.abs(e.width-n)<=1&&(n=e.width),Math.abs(e.height-s)<=1&&(s=e.height),{x:t.offsetLeft,y:t.offsetTop,width:n,height:s}}function bL(t,e){var n=e.getRootNode&&e.getRootNode();if(t.contains(e))return!0;if(n&&XC(n)){var s=e;do{if(s&&t.isSameNode(s))return!0;s=s.parentNode||s.host}while(s)}return!1}function kl(t){return ai(t).getComputedStyle(t)}function tPe(t){return["table","td","th"].indexOf(Bi(t))>=0}function uc(t){return((hh(t)?t.ownerDocument:t.document)||window.document).documentElement}function _w(t){return Bi(t)==="html"?t:t.assignedSlot||t.parentNode||(XC(t)?t.host:null)||uc(t)}function oO(t){return!ya(t)||kl(t).position==="fixed"?null:t.offsetParent}function nPe(t){var e=navigator.userAgent.toLowerCase().indexOf("firefox")!==-1,n=navigator.userAgent.indexOf("Trident")!==-1;if(n&&ya(t)){var s=kl(t);if(s.position==="fixed")return null}var r=_w(t);for(XC(r)&&(r=r.host);ya(r)&&["html","body"].indexOf(Bi(r))<0;){var o=kl(r);if(o.transform!=="none"||o.perspective!=="none"||o.contain==="paint"||["transform","perspective"].indexOf(o.willChange)!==-1||e&&o.willChange==="filter"||e&&o.filter&&o.filter!=="none")return r;r=r.parentNode}return null}function Fg(t){for(var e=ai(t),n=oO(t);n&&tPe(n)&&kl(n).position==="static";)n=oO(n);return n&&(Bi(n)==="html"||Bi(n)==="body"&&kl(n).position==="static")?e:n||nPe(t)||e}function ZC(t){return["top","bottom"].indexOf(t)>=0?"x":"y"}function u0(t,e,n){return od(t,Ay(e,n))}function sPe(t,e,n){var s=u0(t,e,n);return s>n?n:s}function wL(){return{top:0,right:0,bottom:0,left:0}}function _L(t){return Object.assign({},wL(),t)}function $L(t,e){return e.reduce(function(n,s){return n[s]=t,n},{})}var rPe=function(t,e){return t=typeof t=="function"?t(Object.assign({},e.rects,{placement:e.placement})):t,_L(typeof t!="number"?t:$L(t,Dg))};function oPe(t){var e,n=t.state,s=t.name,r=t.options,o=n.elements.arrow,a=n.modifiersData.popperOffsets,i=Ai(n.placement),l=ZC(i),u=[vo,Ca].indexOf(i)>=0,c=u?"height":"width";if(!(!o||!a)){var d=rPe(r.padding,n),f=YC(o),h=l==="y"?go:vo,p=l==="y"?Sa:Ca,m=n.rects.reference[c]+n.rects.reference[l]-a[l]-n.rects.popper[c],g=a[l]-n.rects.reference[l],y=Fg(o),w=y?l==="y"?y.clientHeight||0:y.clientWidth||0:0,b=m/2-g/2,_=d[h],$=w-f[c]-d[p],x=w/2-f[c]/2+b,k=u0(_,x,$),C=l;n.modifiersData[s]=(e={},e[C]=k,e.centerOffset=k-x,e)}}function aPe(t){var e=t.state,n=t.options,s=n.element,r=s===void 0?"[data-popper-arrow]":s;r!=null&&(typeof r=="string"&&(r=e.elements.popper.querySelector(r),!r)||!bL(e.elements.popper,r)||(e.elements.arrow=r))}var iPe={name:"arrow",enabled:!0,phase:"main",fn:oPe,effect:aPe,requires:["popperOffsets"],requiresIfExists:["preventOverflow"]};function gh(t){return t.split("-")[1]}var lPe={top:"auto",right:"auto",bottom:"auto",left:"auto"};function uPe(t){var e=t.x,n=t.y,s=window,r=s.devicePixelRatio||1;return{x:ph(e*r)/r||0,y:ph(n*r)/r||0}}function aO(t){var e,n=t.popper,s=t.popperRect,r=t.placement,o=t.variation,a=t.offsets,i=t.position,l=t.gpuAcceleration,u=t.adaptive,c=t.roundOffsets,d=t.isFixed,f=a.x,h=f===void 0?0:f,p=a.y,m=p===void 0?0:p,g=typeof c=="function"?c({x:h,y:m}):{x:h,y:m};h=g.x,m=g.y;var y=a.hasOwnProperty("x"),w=a.hasOwnProperty("y"),b=vo,_=go,$=window;if(u){var x=Fg(n),k="clientHeight",C="clientWidth";if(x===ai(n)&&(x=uc(n),kl(x).position!=="static"&&i==="absolute"&&(k="scrollHeight",C="scrollWidth")),x=x,r===go||(r===vo||r===Ca)&&o===M0){_=Sa;var T=d&&x===$&&$.visualViewport?$.visualViewport.height:x[k];m-=T-s.height,m*=l?1:-1}if(r===vo||(r===go||r===Sa)&&o===M0){b=Ca;var N=d&&x===$&&$.visualViewport?$.visualViewport.width:x[C];h-=N-s.width,h*=l?1:-1}}var M=Object.assign({position:i},u&&lPe),R=c===!0?uPe({x:h,y:m}):{x:h,y:m};if(h=R.x,m=R.y,l){var D;return Object.assign({},M,(D={},D[_]=w?"0":"",D[b]=y?"0":"",D.transform=($.devicePixelRatio||1)<=1?"translate("+h+"px, "+m+"px)":"translate3d("+h+"px, "+m+"px, 0)",D))}return Object.assign({},M,(e={},e[_]=w?m+"px":"",e[b]=y?h+"px":"",e.transform="",e))}function cPe(t){var e=t.state,n=t.options,s=n.gpuAcceleration,r=s===void 0?!0:s,o=n.adaptive,a=o===void 0?!0:o,i=n.roundOffsets,l=i===void 0?!0:i,u={placement:Ai(e.placement),variation:gh(e.placement),popper:e.elements.popper,popperRect:e.rects.popper,gpuAcceleration:r,isFixed:e.options.strategy==="fixed"};e.modifiersData.popperOffsets!=null&&(e.styles.popper=Object.assign({},e.styles.popper,aO(Object.assign({},u,{offsets:e.modifiersData.popperOffsets,position:e.options.strategy,adaptive:a,roundOffsets:l})))),e.modifiersData.arrow!=null&&(e.styles.arrow=Object.assign({},e.styles.arrow,aO(Object.assign({},u,{offsets:e.modifiersData.arrow,position:"absolute",adaptive:!1,roundOffsets:l})))),e.attributes.popper=Object.assign({},e.attributes.popper,{"data-popper-placement":e.placement})}var xL={name:"computeStyles",enabled:!0,phase:"beforeWrite",fn:cPe,data:{}},tv={passive:!0};function dPe(t){var e=t.state,n=t.instance,s=t.options,r=s.scroll,o=r===void 0?!0:r,a=s.resize,i=a===void 0?!0:a,l=ai(e.elements.popper),u=[].concat(e.scrollParents.reference,e.scrollParents.popper);return o&&u.forEach(function(c){c.addEventListener("scroll",n.update,tv)}),i&&l.addEventListener("resize",n.update,tv),function(){o&&u.forEach(function(c){c.removeEventListener("scroll",n.update,tv)}),i&&l.removeEventListener("resize",n.update,tv)}}var SL={name:"eventListeners",enabled:!0,phase:"write",fn:function(){},effect:dPe,data:{}},fPe={left:"right",right:"left",bottom:"top",top:"bottom"};function Uv(t){return t.replace(/left|right|bottom|top/g,function(e){return fPe[e]})}var hPe={start:"end",end:"start"};function iO(t){return t.replace(/start|end/g,function(e){return hPe[e]})}function JC(t){var e=ai(t),n=e.pageXOffset,s=e.pageYOffset;return{scrollLeft:n,scrollTop:s}}function QC(t){return mh(uc(t)).left+JC(t).scrollLeft}function pPe(t){var e=ai(t),n=uc(t),s=e.visualViewport,r=n.clientWidth,o=n.clientHeight,a=0,i=0;return s&&(r=s.width,o=s.height,/^((?!chrome|android).)*safari/i.test(navigator.userAgent)||(a=s.offsetLeft,i=s.offsetTop)),{width:r,height:o,x:a+QC(t),y:i}}function mPe(t){var e,n=uc(t),s=JC(t),r=(e=t.ownerDocument)==null?void 0:e.body,o=od(n.scrollWidth,n.clientWidth,r?r.scrollWidth:0,r?r.clientWidth:0),a=od(n.scrollHeight,n.clientHeight,r?r.scrollHeight:0,r?r.clientHeight:0),i=-s.scrollLeft+QC(t),l=-s.scrollTop;return kl(r||n).direction==="rtl"&&(i+=od(n.clientWidth,r?r.clientWidth:0)-o),{width:o,height:a,x:i,y:l}}function ek(t){var e=kl(t),n=e.overflow,s=e.overflowX,r=e.overflowY;return/auto|scroll|overlay|hidden/.test(n+r+s)}function CL(t){return["html","body","#document"].indexOf(Bi(t))>=0?t.ownerDocument.body:ya(t)&&ek(t)?t:CL(_w(t))}function c0(t,e){var n;e===void 0&&(e=[]);var s=CL(t),r=s===((n=t.ownerDocument)==null?void 0:n.body),o=ai(s),a=r?[o].concat(o.visualViewport||[],ek(s)?s:[]):s,i=e.concat(a);return r?i:i.concat(c0(_w(a)))}function p6(t){return Object.assign({},t,{left:t.x,top:t.y,right:t.x+t.width,bottom:t.y+t.height})}function gPe(t){var e=mh(t);return e.top=e.top+t.clientTop,e.left=e.left+t.clientLeft,e.bottom=e.top+t.clientHeight,e.right=e.left+t.clientWidth,e.width=t.clientWidth,e.height=t.clientHeight,e.x=e.left,e.y=e.top,e}function lO(t,e){return e===vL?p6(pPe(t)):hh(e)?gPe(e):p6(mPe(uc(t)))}function vPe(t){var e=c0(_w(t)),n=["absolute","fixed"].indexOf(kl(t).position)>=0,s=n&&ya(t)?Fg(t):t;return hh(s)?e.filter(function(r){return hh(r)&&bL(r,s)&&Bi(r)!=="body"}):[]}function yPe(t,e,n){var s=e==="clippingParents"?vPe(t):[].concat(e),r=[].concat(s,[n]),o=r[0],a=r.reduce(function(i,l){var u=lO(t,l);return i.top=od(u.top,i.top),i.right=Ay(u.right,i.right),i.bottom=Ay(u.bottom,i.bottom),i.left=od(u.left,i.left),i},lO(t,o));return a.width=a.right-a.left,a.height=a.bottom-a.top,a.x=a.left,a.y=a.top,a}function kL(t){var e=t.reference,n=t.element,s=t.placement,r=s?Ai(s):null,o=s?gh(s):null,a=e.x+e.width/2-n.width/2,i=e.y+e.height/2-n.height/2,l;switch(r){case go:l={x:a,y:e.y-n.height};break;case Sa:l={x:a,y:e.y+e.height};break;case Ca:l={x:e.x+e.width,y:i};break;case vo:l={x:e.x-n.width,y:i};break;default:l={x:e.x,y:e.y}}var u=r?ZC(r):null;if(u!=null){var c=u==="y"?"height":"width";switch(o){case fh:l[u]=l[u]-(e[c]/2-n[c]/2);break;case M0:l[u]=l[u]+(e[c]/2-n[c]/2);break}}return l}function P0(t,e){e===void 0&&(e={});var n=e,s=n.placement,r=s===void 0?t.placement:s,o=n.boundary,a=o===void 0?VMe:o,i=n.rootBoundary,l=i===void 0?vL:i,u=n.elementContext,c=u===void 0?Em:u,d=n.altBoundary,f=d===void 0?!1:d,h=n.padding,p=h===void 0?0:h,m=_L(typeof p!="number"?p:$L(p,Dg)),g=c===Em?HMe:Em,y=t.rects.popper,w=t.elements[f?g:c],b=yPe(hh(w)?w:w.contextElement||uc(t.elements.popper),a,l),_=mh(t.elements.reference),$=kL({reference:_,element:y,strategy:"absolute",placement:r}),x=p6(Object.assign({},y,$)),k=c===Em?x:_,C={top:b.top-k.top+m.top,bottom:k.bottom-b.bottom+m.bottom,left:b.left-k.left+m.left,right:k.right-b.right+m.right},T=t.modifiersData.offset;if(c===Em&&T){var N=T[r];Object.keys(C).forEach(function(M){var R=[Ca,Sa].indexOf(M)>=0?1:-1,D=[go,Sa].indexOf(M)>=0?"y":"x";C[M]+=N[D]*R})}return C}function bPe(t,e){e===void 0&&(e={});var n=e,s=n.placement,r=n.boundary,o=n.rootBoundary,a=n.padding,i=n.flipVariations,l=n.allowedAutoPlacements,u=l===void 0?Qd:l,c=gh(s),d=c?i?rO:rO.filter(function(p){return gh(p)===c}):Dg,f=d.filter(function(p){return u.indexOf(p)>=0});f.length===0&&(f=d);var h=f.reduce(function(p,m){return p[m]=P0(t,{placement:m,boundary:r,rootBoundary:o,padding:a})[Ai(m)],p},{});return Object.keys(h).sort(function(p,m){return h[p]-h[m]})}function wPe(t){if(Ai(t)===qC)return[];var e=Uv(t);return[iO(t),e,iO(e)]}function _Pe(t){var e=t.state,n=t.options,s=t.name;if(!e.modifiersData[s]._skip){for(var r=n.mainAxis,o=r===void 0?!0:r,a=n.altAxis,i=a===void 0?!0:a,l=n.fallbackPlacements,u=n.padding,c=n.boundary,d=n.rootBoundary,f=n.altBoundary,h=n.flipVariations,p=h===void 0?!0:h,m=n.allowedAutoPlacements,g=e.options.placement,y=Ai(g),w=y===g,b=l||(w||!p?[Uv(g)]:wPe(g)),_=[g].concat(b).reduce(function(fe,X){return fe.concat(Ai(X)===qC?bPe(e,{placement:X,boundary:c,rootBoundary:d,padding:u,flipVariations:p,allowedAutoPlacements:m}):X)},[]),$=e.rects.reference,x=e.rects.popper,k=new Map,C=!0,T=_[0],N=0;N<_.length;N++){var M=_[N],R=Ai(M),D=gh(M)===fh,z=[go,Sa].indexOf(R)>=0,B=z?"width":"height",V=P0(e,{placement:M,boundary:c,rootBoundary:d,altBoundary:f,padding:u}),O=z?D?Ca:vo:D?Sa:go;$[B]>x[B]&&(O=Uv(O));var F=Uv(O),L=[];if(o&&L.push(V[R]<=0),i&&L.push(V[O]<=0,V[F]<=0),L.every(function(fe){return fe})){T=M,C=!1;break}k.set(M,L)}if(C)for(var G=p?3:1,Z=function(fe){var X=_.find(function(oe){var ee=k.get(oe);if(ee)return ee.slice(0,fe).every(function(Q){return Q})});if(X)return T=X,"break"},j=G;j>0;j--){var J=Z(j);if(J==="break")break}e.placement!==T&&(e.modifiersData[s]._skip=!0,e.placement=T,e.reset=!0)}}var $Pe={name:"flip",enabled:!0,phase:"main",fn:_Pe,requiresIfExists:["offset"],data:{_skip:!1}};function uO(t,e,n){return n===void 0&&(n={x:0,y:0}),{top:t.top-e.height-n.y,right:t.right-e.width+n.x,bottom:t.bottom-e.height+n.y,left:t.left-e.width-n.x}}function cO(t){return[go,Ca,Sa,vo].some(function(e){return t[e]>=0})}function xPe(t){var e=t.state,n=t.name,s=e.rects.reference,r=e.rects.popper,o=e.modifiersData.preventOverflow,a=P0(e,{elementContext:"reference"}),i=P0(e,{altBoundary:!0}),l=uO(a,s),u=uO(i,r,o),c=cO(l),d=cO(u);e.modifiersData[n]={referenceClippingOffsets:l,popperEscapeOffsets:u,isReferenceHidden:c,hasPopperEscaped:d},e.attributes.popper=Object.assign({},e.attributes.popper,{"data-popper-reference-hidden":c,"data-popper-escaped":d})}var SPe={name:"hide",enabled:!0,phase:"main",requiresIfExists:["preventOverflow"],fn:xPe};function CPe(t,e,n){var s=Ai(t),r=[vo,go].indexOf(s)>=0?-1:1,o=typeof n=="function"?n(Object.assign({},e,{placement:t})):n,a=o[0],i=o[1];return a=a||0,i=(i||0)*r,[vo,Ca].indexOf(s)>=0?{x:i,y:a}:{x:a,y:i}}function kPe(t){var e=t.state,n=t.options,s=t.name,r=n.offset,o=r===void 0?[0,0]:r,a=Qd.reduce(function(c,d){return c[d]=CPe(d,e.rects,o),c},{}),i=a[e.placement],l=i.x,u=i.y;e.modifiersData.popperOffsets!=null&&(e.modifiersData.popperOffsets.x+=l,e.modifiersData.popperOffsets.y+=u),e.modifiersData[s]=a}var TPe={name:"offset",enabled:!0,phase:"main",requires:["popperOffsets"],fn:kPe};function NPe(t){var e=t.state,n=t.name;e.modifiersData[n]=kL({reference:e.rects.reference,element:e.rects.popper,strategy:"absolute",placement:e.placement})}var TL={name:"popperOffsets",enabled:!0,phase:"read",fn:NPe,data:{}};function IPe(t){return t==="x"?"y":"x"}function EPe(t){var e=t.state,n=t.options,s=t.name,r=n.mainAxis,o=r===void 0?!0:r,a=n.altAxis,i=a===void 0?!1:a,l=n.boundary,u=n.rootBoundary,c=n.altBoundary,d=n.padding,f=n.tether,h=f===void 0?!0:f,p=n.tetherOffset,m=p===void 0?0:p,g=P0(e,{boundary:l,rootBoundary:u,padding:d,altBoundary:c}),y=Ai(e.placement),w=gh(e.placement),b=!w,_=ZC(y),$=IPe(_),x=e.modifiersData.popperOffsets,k=e.rects.reference,C=e.rects.popper,T=typeof m=="function"?m(Object.assign({},e.rects,{placement:e.placement})):m,N=typeof T=="number"?{mainAxis:T,altAxis:T}:Object.assign({mainAxis:0,altAxis:0},T),M=e.modifiersData.offset?e.modifiersData.offset[e.placement]:null,R={x:0,y:0};if(x){if(o){var D,z=_==="y"?go:vo,B=_==="y"?Sa:Ca,V=_==="y"?"height":"width",O=x[_],F=O+g[z],L=O-g[B],G=h?-C[V]/2:0,Z=w===fh?k[V]:C[V],j=w===fh?-C[V]:-k[V],J=e.elements.arrow,fe=h&&J?YC(J):{width:0,height:0},X=e.modifiersData["arrow#persistent"]?e.modifiersData["arrow#persistent"].padding:wL(),oe=X[z],ee=X[B],Q=u0(0,k[V],fe[V]),ie=b?k[V]/2-G-Q-oe-N.mainAxis:Z-Q-oe-N.mainAxis,pe=b?-k[V]/2+G+Q+ee+N.mainAxis:j+Q+ee+N.mainAxis,Re=e.elements.arrow&&Fg(e.elements.arrow),K=Re?_==="y"?Re.clientTop||0:Re.clientLeft||0:0,re=(D=M==null?void 0:M[_])!=null?D:0,we=O+ie-re-K,Ee=O+pe-re,De=u0(h?Ay(F,we):F,O,h?od(L,Ee):L);x[_]=De,R[_]=De-O}if(i){var _e,ze=_==="x"?go:vo,Ae=_==="x"?Sa:Ca,he=x[$],ve=$==="y"?"height":"width",me=he+g[ze],Ve=he-g[Ae],Ye=[go,vo].indexOf(y)!==-1,Je=(_e=M==null?void 0:M[$])!=null?_e:0,ct=Ye?me:he-k[ve]-C[ve]-Je+N.altAxis,xt=Ye?he+k[ve]+C[ve]-Je-N.altAxis:Ve,dt=h&&Ye?sPe(ct,he,xt):u0(h?ct:me,he,h?xt:Ve);x[$]=dt,R[$]=dt-he}e.modifiersData[s]=R}}var APe={name:"preventOverflow",enabled:!0,phase:"main",fn:EPe,requiresIfExists:["offset"]};function OPe(t){return{scrollLeft:t.scrollLeft,scrollTop:t.scrollTop}}function RPe(t){return t===ai(t)||!ya(t)?JC(t):OPe(t)}function DPe(t){var e=t.getBoundingClientRect(),n=ph(e.width)/t.offsetWidth||1,s=ph(e.height)/t.offsetHeight||1;return n!==1||s!==1}function FPe(t,e,n){n===void 0&&(n=!1);var s=ya(e),r=ya(e)&&DPe(e),o=uc(e),a=mh(t,r),i={scrollLeft:0,scrollTop:0},l={x:0,y:0};return(s||!s&&!n)&&((Bi(e)!=="body"||ek(o))&&(i=RPe(e)),ya(e)?(l=mh(e,!0),l.x+=e.clientLeft,l.y+=e.clientTop):o&&(l.x=QC(o))),{x:a.left+i.scrollLeft-l.x,y:a.top+i.scrollTop-l.y,width:a.width,height:a.height}}function MPe(t){var e=new Map,n=new Set,s=[];t.forEach(function(o){e.set(o.name,o)});function r(o){n.add(o.name);var a=[].concat(o.requires||[],o.requiresIfExists||[]);a.forEach(function(i){if(!n.has(i)){var l=e.get(i);l&&r(l)}}),s.push(o)}return t.forEach(function(o){n.has(o.name)||r(o)}),s}function PPe(t){var e=MPe(t);return JMe.reduce(function(n,s){return n.concat(e.filter(function(r){return r.phase===s}))},[])}function LPe(t){var e;return function(){return e||(e=new Promise(function(n){Promise.resolve().then(function(){e=void 0,n(t())})})),e}}function zPe(t){var e=t.reduce(function(n,s){var r=n[s.name];return n[s.name]=r?Object.assign({},r,s,{options:Object.assign({},r.options,s.options),data:Object.assign({},r.data,s.data)}):s,n},{});return Object.keys(e).map(function(n){return e[n]})}var dO={placement:"bottom",modifiers:[],strategy:"absolute"};function fO(){for(var t=arguments.length,e=new Array(t),n=0;n<t;n++)e[n]=arguments[n];return!e.some(function(s){return!(s&&typeof s.getBoundingClientRect=="function")})}function tk(t){t===void 0&&(t={});var e=t,n=e.defaultModifiers,s=n===void 0?[]:n,r=e.defaultOptions,o=r===void 0?dO:r;return function(a,i,l){l===void 0&&(l=o);var u={placement:"bottom",orderedModifiers:[],options:Object.assign({},dO,o),modifiersData:{},elements:{reference:a,popper:i},attributes:{},styles:{}},c=[],d=!1,f={state:u,setOptions:function(m){var g=typeof m=="function"?m(u.options):m;p(),u.options=Object.assign({},o,u.options,g),u.scrollParents={reference:hh(a)?c0(a):a.contextElement?c0(a.contextElement):[],popper:c0(i)};var y=PPe(zPe([].concat(s,u.options.modifiers)));return u.orderedModifiers=y.filter(function(w){return w.enabled}),h(),f.update()},forceUpdate:function(){if(!d){var m=u.elements,g=m.reference,y=m.popper;if(fO(g,y)){u.rects={reference:FPe(g,Fg(y),u.options.strategy==="fixed"),popper:YC(y)},u.reset=!1,u.placement=u.options.placement,u.orderedModifiers.forEach(function(C){return u.modifiersData[C.name]=Object.assign({},C.data)});for(var w=0;w<u.orderedModifiers.length;w++){if(u.reset===!0){u.reset=!1,w=-1;continue}var b=u.orderedModifiers[w],_=b.fn,$=b.options,x=$===void 0?{}:$,k=b.name;typeof _=="function"&&(u=_({state:u,options:x,name:k,instance:f})||u)}}}},update:LPe(function(){return new Promise(function(m){f.forceUpdate(),m(u)})}),destroy:function(){p(),d=!0}};if(!fO(a,i))return f;f.setOptions(l).then(function(m){!d&&l.onFirstUpdate&&l.onFirstUpdate(m)});function h(){u.orderedModifiers.forEach(function(m){var g=m.name,y=m.options,w=y===void 0?{}:y,b=m.effect;if(typeof b=="function"){var _=b({state:u,name:g,instance:f,options:w}),$=function(){};c.push(_||$)}})}function p(){c.forEach(function(m){return m()}),c=[]}return f}}tk();var BPe=[SL,TL,xL,yL];tk({defaultModifiers:BPe});var VPe=[SL,TL,xL,yL,TPe,$Pe,APe,iPe,SPe],NL=tk({defaultModifiers:VPe});const j4="focus-trap.focus-after-trapped",K4="focus-trap.focus-after-released",HPe="focus-trap.focusout-prevented",hO={cancelable:!0,bubbles:!1},WPe={cancelable:!0,bubbles:!1},pO="focusAfterTrapped",mO="focusAfterReleased",nk=Symbol("elFocusTrap"),sk=U(),$w=U(0),rk=U(0);let nv=0;const IL=t=>{const e=[],n=document.createTreeWalker(t,NodeFilter.SHOW_ELEMENT,{acceptNode:s=>{const r=s.tagName==="INPUT"&&s.type==="hidden";return s.disabled||s.hidden||r?NodeFilter.FILTER_SKIP:s.tabIndex>=0||s===document.activeElement?NodeFilter.FILTER_ACCEPT:NodeFilter.FILTER_SKIP}});for(;n.nextNode();)e.push(n.currentNode);return e},gO=(t,e)=>{for(const n of t)if(!UPe(n,e))return n},UPe=(t,e)=>{if(getComputedStyle(t).visibility==="hidden")return!0;for(;t;){if(e&&t===e)return!1;if(getComputedStyle(t).display==="none")return!0;t=t.parentElement}return!1},GPe=t=>{const e=IL(t),n=gO(e,t),s=gO(e.reverse(),t);return[n,s]},jPe=t=>t instanceof HTMLInputElement&&"select"in t,du=(t,e)=>{if(t&&t.focus){const n=document.activeElement;if(t.focus({preventScroll:!0}),rk.value=window.performance.now(),t!==n&&jPe(t)&&e){if(t.tagName==="INPUT"){t.setSelectionRange(t.value.length,t.value.length);return}t.select()}}};function vO(t,e){const n=[...t],s=t.indexOf(e);return s!==-1&&n.splice(s,1),n}const KPe=()=>{let t=[];return{push:s=>{const r=t[0];r&&s!==r&&r.pause(),t=vO(t,s),t.unshift(s)},remove:s=>{var r,o;t=vO(t,s),(o=(r=t[0])==null?void 0:r.resume)==null||o.call(r)}}},qPe=(t,e=!1)=>{const n=document.activeElement;for(const s of t)if(du(s,e),document.activeElement!==n)return},yO=KPe(),XPe=()=>$w.value>rk.value,sv=()=>{sk.value="pointer",$w.value=window.performance.now()},bO=()=>{sk.value="keyboard",$w.value=window.performance.now()},YPe=()=>(It(()=>{nv===0&&(document.addEventListener("mousedown",sv),document.addEventListener("touchstart",sv),document.addEventListener("keydown",bO)),nv++}),ts(()=>{nv--,nv<=0&&(document.removeEventListener("mousedown",sv),document.removeEventListener("touchstart",sv),document.removeEventListener("keydown",bO))}),{focusReason:sk,lastUserFocusTimestamp:$w,lastAutomatedFocusTimestamp:rk}),rv=t=>new CustomEvent(HPe,{...WPe,detail:t}),ZPe=ue({name:"ElFocusTrap",inheritAttrs:!1,props:{loop:Boolean,trapped:Boolean,focusTrapEl:Object,focusStartEl:{type:[Object,String],default:"first"}},emits:[pO,mO,"focusin","focusout","focusout-prevented","release-requested"],setup(t,{emit:e}){const n=U();let s,r;const{focusReason:o}=YPe();iFe(p=>{t.trapped&&!a.paused&&e("release-requested",p)});const a={paused:!1,pause(){this.paused=!0},resume(){this.paused=!1}},i=p=>{if(!t.loop&&!t.trapped||a.paused)return;const{key:m,altKey:g,ctrlKey:y,metaKey:w,currentTarget:b,shiftKey:_}=p,{loop:$}=t,x=m===ut.tab&&!g&&!y&&!w,k=document.activeElement;if(x&&k){const C=b,[T,N]=GPe(C);if(T&&N){if(!_&&k===N){const R=rv({focusReason:o.value});e("focusout-prevented",R),R.defaultPrevented||(p.preventDefault(),$&&du(T,!0))}else if(_&&[T,C].includes(k)){const R=rv({focusReason:o.value});e("focusout-prevented",R),R.defaultPrevented||(p.preventDefault(),$&&du(N,!0))}}else if(k===C){const R=rv({focusReason:o.value});e("focusout-prevented",R),R.defaultPrevented||p.preventDefault()}}};Lt(nk,{focusTrapRef:n,onKeydown:i}),Me(()=>t.focusTrapEl,p=>{p&&(n.value=p)},{immediate:!0}),Me([n],([p],[m])=>{p&&(p.addEventListener("keydown",i),p.addEventListener("focusin",c),p.addEventListener("focusout",d)),m&&(m.removeEventListener("keydown",i),m.removeEventListener("focusin",c),m.removeEventListener("focusout",d))});const l=p=>{e(pO,p)},u=p=>e(mO,p),c=p=>{const m=v(n);if(!m)return;const g=p.target,y=p.relatedTarget,w=g&&m.contains(g);t.trapped||y&&m.contains(y)||(s=y),w&&e("focusin",p),!a.paused&&t.trapped&&(w?r=g:du(r,!0))},d=p=>{const m=v(n);if(!(a.paused||!m))if(t.trapped){const g=p.relatedTarget;!nr(g)&&!m.contains(g)&&setTimeout(()=>{if(!a.paused&&t.trapped){const y=rv({focusReason:o.value});e("focusout-prevented",y),y.defaultPrevented||du(r,!0)}},0)}else{const g=p.target;g&&m.contains(g)||e("focusout",p)}};async function f(){await nt();const p=v(n);if(p){yO.push(a);const m=p.contains(document.activeElement)?s:document.activeElement;if(s=m,!p.contains(m)){const y=new Event(j4,hO);p.addEventListener(j4,l),p.dispatchEvent(y),y.defaultPrevented||nt(()=>{let w=t.focusStartEl;wt(w)||(du(w),document.activeElement!==w&&(w="first")),w==="first"&&qPe(IL(p),!0),(document.activeElement===m||w==="container")&&du(p)})}}}function h(){const p=v(n);if(p){p.removeEventListener(j4,l);const m=new CustomEvent(K4,{...hO,detail:{focusReason:o.value}});p.addEventListener(K4,u),p.dispatchEvent(m),!m.defaultPrevented&&(o.value=="keyboard"||!XPe())&&du(s??document.body,!0),p.removeEventListener(K4,l),yO.remove(a)}}return It(()=>{t.trapped&&f(),Me(()=>t.trapped,p=>{p?f():h()})}),ts(()=>{t.trapped&&h()}),{onKeydown:i}}});function JPe(t,e,n,s,r,o){return Oe(t.$slots,"default",{handleKeydown:t.onKeydown})}var xw=je(ZPe,[["render",JPe],["__file","/home/runner/work/element-plus/element-plus/packages/components/focus-trap/src/focus-trap.vue"]]);const QPe=["fixed","absolute"],eLe=qe({boundariesPadding:{type:Number,default:0},fallbackPlacements:{type:Se(Array),default:void 0},gpuAcceleration:{type:Boolean,default:!0},offset:{type:Number,default:12},placement:{type:String,values:Qd,default:"bottom"},popperOptions:{type:Se(Object),default:()=>({})},strategy:{type:String,values:QPe,default:"absolute"}}),EL=qe({...eLe,id:String,style:{type:Se([String,Array,Object])},className:{type:Se([String,Array,Object])},effect:{type:String,default:"dark"},visible:Boolean,enterable:{type:Boolean,default:!0},pure:Boolean,focusOnShow:{type:Boolean,default:!1},trapping:{type:Boolean,default:!1},popperClass:{type:Se([String,Array,Object])},popperStyle:{type:Se([String,Array,Object])},referenceEl:{type:Se(Object)},triggerTargetEl:{type:Se(Object)},stopPopperMouseEvent:{type:Boolean,default:!0},ariaLabel:{type:String,default:void 0},virtualTriggering:Boolean,zIndex:Number}),tLe={mouseenter:t=>t instanceof MouseEvent,mouseleave:t=>t instanceof MouseEvent,focus:()=>!0,blur:()=>!0,close:()=>!0},wO=(t,e)=>{const{placement:n,strategy:s,popperOptions:r}=t,o={placement:n,strategy:s,...r,modifiers:sLe(t)};return rLe(o,e),oLe(o,r==null?void 0:r.modifiers),o},nLe=t=>{if(!!Kt)return Mo(t)};function sLe(t){const{offset:e,gpuAcceleration:n,fallbackPlacements:s}=t;return[{name:"offset",options:{offset:[0,e??12]}},{name:"preventOverflow",options:{padding:{top:2,bottom:2,left:5,right:5}}},{name:"flip",options:{padding:5,fallbackPlacements:s}},{name:"computeStyles",options:{gpuAcceleration:n}}]}function rLe(t,{arrowEl:e,arrowOffset:n}){t.modifiers.push({name:"arrow",options:{element:e,padding:n??5}})}function oLe(t,e){e&&(t.modifiers=[...t.modifiers,...e??[]])}const aLe=ue({name:"ElPopperContent"}),iLe=ue({...aLe,props:EL,emits:tLe,setup(t,{expose:e,emit:n}){const s=t,{popperInstanceRef:r,contentRef:o,triggerRef:a,role:i}=et(BC,void 0),l=et(Li,void 0),{nextZIndex:u}=Ul(),c=Fe("popper"),d=U(),f=U("first"),h=U(),p=U();Lt(KP,{arrowRef:h,arrowOffset:p}),l&&(l.addInputId||l.removeInputId)&&Lt(Li,{...l,addInputId:gn,removeInputId:gn});const m=U(s.zIndex||u()),g=U(!1);let y;const w=A(()=>nLe(s.referenceEl)||v(a)),b=A(()=>[{zIndex:v(m)},s.popperStyle]),_=A(()=>[c.b(),c.is("pure",s.pure),c.is(s.effect),s.popperClass]),$=A(()=>i&&i.value==="dialog"?"false":void 0),x=({referenceEl:z,popperContentEl:B,arrowEl:V})=>{const O=wO(s,{arrowEl:V,arrowOffset:v(p)});return NL(z,B,O)},k=(z=!0)=>{var B;(B=v(r))==null||B.update(),z&&(m.value=s.zIndex||u())},C=()=>{var z,B;const V={name:"eventListeners",enabled:s.visible};(B=(z=v(r))==null?void 0:z.setOptions)==null||B.call(z,O=>({...O,modifiers:[...O.modifiers||[],V]})),k(!1),s.visible&&s.focusOnShow?g.value=!0:s.visible===!1&&(g.value=!1)},T=()=>{n("focus")},N=z=>{var B;((B=z.detail)==null?void 0:B.focusReason)!=="pointer"&&(f.value="first",n("blur"))},M=z=>{s.visible&&!g.value&&(z.target&&(f.value=z.target),g.value=!0)},R=z=>{s.trapping||(z.detail.focusReason==="pointer"&&z.preventDefault(),g.value=!1)},D=()=>{g.value=!1,n("close")};return It(()=>{let z;Me(w,B=>{var V;z==null||z();const O=v(r);if((V=O==null?void 0:O.destroy)==null||V.call(O),B){const F=v(d);o.value=F,r.value=x({referenceEl:B,popperContentEl:F,arrowEl:v(h)}),z=Me(()=>B.getBoundingClientRect(),()=>k(),{immediate:!0})}else r.value=void 0},{immediate:!0}),Me(()=>s.triggerTargetEl,(B,V)=>{y==null||y(),y=void 0;const O=v(B||d.value),F=v(V||d.value);Qa(O)&&(y=Me([i,()=>s.ariaLabel,$,()=>s.id],L=>{["role","aria-label","aria-modal","id"].forEach((G,Z)=>{nr(L[Z])?O.removeAttribute(G):O.setAttribute(G,L[Z])})},{immediate:!0})),F!==O&&Qa(F)&&["role","aria-label","aria-modal","id"].forEach(L=>{F.removeAttribute(L)})},{immediate:!0}),Me(()=>s.visible,C,{immediate:!0}),Me(()=>wO(s,{arrowEl:v(h),arrowOffset:v(p)}),B=>{var V;return(V=r.value)==null?void 0:V.setOptions(B)})}),ts(()=>{y==null||y(),y=void 0}),e({popperContentRef:d,popperInstanceRef:r,updatePopper:k,contentStyle:b}),(z,B)=>(S(),E("div",{ref_key:"popperContentRef",ref:d,style:ot(v(b)),class:P(v(_)),tabindex:"-1",onMouseenter:B[0]||(B[0]=V=>z.$emit("mouseenter",V)),onMouseleave:B[1]||(B[1]=V=>z.$emit("mouseleave",V))},[se(v(xw),{trapped:g.value,"trap-on-focus-in":!0,"focus-trap-el":d.value,"focus-start-el":f.value,onFocusAfterTrapped:T,onFocusAfterReleased:N,onFocusin:M,onFocusoutPrevented:R,onReleaseRequested:D},{default:ce(()=>[Oe(z.$slots,"default")]),_:3},8,["trapped","focus-trap-el","focus-start-el"])],38))}});var lLe=je(iLe,[["__file","/home/runner/work/element-plus/element-plus/packages/components/popper/src/content.vue"]]);const AL=Dt(RMe),uLe=Fe("tooltip"),Xs=qe({...cFe,...EL,appendTo:{type:Se([String,Object])},content:{type:String,default:""},rawContent:{type:Boolean,default:!1},persistent:Boolean,ariaLabel:String,visible:{type:Se(Boolean),default:null},transition:{type:String,default:`${uLe.namespace.value}-fade-in-linear`},teleported:{type:Boolean,default:!0},disabled:{type:Boolean}}),L0=qe({...gL,disabled:Boolean,trigger:{type:Se([String,Array]),default:"hover"},triggerKeys:{type:Se(Array),default:()=>[ut.enter,ut.space]}}),{useModelToggleProps:cLe,useModelToggleEmits:dLe,useModelToggle:fLe}=sFe("visible"),hLe=qe({...fL,...cLe,...Xs,...L0,...hL,showArrow:{type:Boolean,default:!0}}),pLe=[...dLe,"before-show","before-hide","show","hide","open","close"],mLe=(t,e)=>Qe(t)?t.includes(e):t===e,bf=(t,e,n)=>s=>{mLe(v(t),e)&&n(s)},gLe=ue({name:"ElTooltipTrigger"}),vLe=ue({...gLe,props:L0,setup(t,{expose:e}){const n=t,s=Fe("tooltip"),{controlled:r,id:o,open:a,onOpen:i,onClose:l,onToggle:u}=et(mw,void 0),c=U(null),d=()=>{if(v(r)||n.disabled)return!0},f=Un(n,"trigger"),h=Xn(d,bf(f,"hover",i)),p=Xn(d,bf(f,"hover",l)),m=Xn(d,bf(f,"click",_=>{_.button===0&&u(_)})),g=Xn(d,bf(f,"focus",i)),y=Xn(d,bf(f,"focus",l)),w=Xn(d,bf(f,"contextmenu",_=>{_.preventDefault(),u(_)})),b=Xn(d,_=>{const{code:$}=_;n.triggerKeys.includes($)&&(_.preventDefault(),u(_))});return e({triggerRef:c}),(_,$)=>(S(),$e(v(BMe),{id:v(o),"virtual-ref":_.virtualRef,open:v(a),"virtual-triggering":_.virtualTriggering,class:P(v(s).e("trigger")),onBlur:v(y),onClick:v(m),onContextmenu:v(w),onFocus:v(g),onMouseenter:v(h),onMouseleave:v(p),onKeydown:v(b)},{default:ce(()=>[Oe(_.$slots,"default")]),_:3},8,["id","virtual-ref","open","virtual-triggering","class","onBlur","onClick","onContextmenu","onFocus","onMouseenter","onMouseleave","onKeydown"]))}});var yLe=je(vLe,[["__file","/home/runner/work/element-plus/element-plus/packages/components/tooltip/src/trigger.vue"]]);const bLe=ue({name:"ElTooltipContent",inheritAttrs:!1}),wLe=ue({...bLe,props:Xs,setup(t,{expose:e}){const n=t,{selector:s}=eL(),r=U(null),o=U(!1),{controlled:a,id:i,open:l,trigger:u,onClose:c,onOpen:d,onShow:f,onHide:h,onBeforeShow:p,onBeforeHide:m}=et(mw,void 0),g=A(()=>n.persistent);ts(()=>{o.value=!0});const y=A(()=>v(g)?!0:v(l)),w=A(()=>n.disabled?!1:v(l)),b=A(()=>n.appendTo||s.value),_=A(()=>{var B;return(B=n.style)!=null?B:{}}),$=A(()=>!v(l)),x=()=>{h()},k=()=>{if(v(a))return!0},C=Xn(k,()=>{n.enterable&&v(u)==="hover"&&d()}),T=Xn(k,()=>{v(u)==="hover"&&c()}),N=()=>{var B,V;(V=(B=r.value)==null?void 0:B.updatePopper)==null||V.call(B),p==null||p()},M=()=>{m==null||m()},R=()=>{f(),z=TC(A(()=>{var B;return(B=r.value)==null?void 0:B.popperContentRef}),()=>{if(v(a))return;v(u)!=="hover"&&c()})},D=()=>{n.virtualTriggering||c()};let z;return Me(()=>v(l),B=>{B||z==null||z()},{flush:"post"}),Me(()=>n.content,()=>{var B,V;(V=(B=r.value)==null?void 0:B.updatePopper)==null||V.call(B)}),e({contentRef:r}),(B,V)=>(S(),$e(kg,{disabled:!B.teleported,to:v(b)},[se(ms,{name:B.transition,onAfterLeave:x,onBeforeEnter:N,onAfterEnter:R,onBeforeLeave:M},{default:ce(()=>[v(y)?St((S(),$e(v(lLe),zt({key:0,id:v(i),ref_key:"contentRef",ref:r},B.$attrs,{"aria-label":B.ariaLabel,"aria-hidden":v($),"boundaries-padding":B.boundariesPadding,"fallback-placements":B.fallbackPlacements,"gpu-acceleration":B.gpuAcceleration,offset:B.offset,placement:B.placement,"popper-options":B.popperOptions,strategy:B.strategy,effect:B.effect,enterable:B.enterable,pure:B.pure,"popper-class":B.popperClass,"popper-style":[B.popperStyle,v(_)],"reference-el":B.referenceEl,"trigger-target-el":B.triggerTargetEl,visible:v(w),"z-index":B.zIndex,onMouseenter:v(C),onMouseleave:v(T),onBlur:D,onClose:v(c)}),{default:ce(()=>[o.value?ge("v-if",!0):Oe(B.$slots,"default",{key:0})]),_:3},16,["id","aria-label","aria-hidden","boundaries-padding","fallback-placements","gpu-acceleration","offset","placement","popper-options","strategy","effect","enterable","pure","popper-class","popper-style","reference-el","trigger-target-el","visible","z-index","onMouseenter","onMouseleave","onClose"])),[[Qt,v(w)]]):ge("v-if",!0)]),_:3},8,["name"])],8,["disabled","to"]))}});var _Le=je(wLe,[["__file","/home/runner/work/element-plus/element-plus/packages/components/tooltip/src/content.vue"]]);const $Le=["innerHTML"],xLe={key:1},SLe=ue({name:"ElTooltip"}),CLe=ue({...SLe,props:hLe,emits:pLe,setup(t,{expose:e,emit:n}){const s=t;uFe();const r=ei(),o=U(),a=U(),i=()=>{var y;const w=v(o);w&&((y=w.popperInstanceRef)==null||y.update())},l=U(!1),u=U(),{show:c,hide:d,hasUpdateHandler:f}=fLe({indicator:l,toggleReason:u}),{onOpen:h,onClose:p}=dFe({showAfter:Un(s,"showAfter"),hideAfter:Un(s,"hideAfter"),open:c,close:d}),m=A(()=>Rs(s.visible)&&!f.value);Lt(mw,{controlled:m,id:r,open:Cg(l),trigger:Un(s,"trigger"),onOpen:y=>{h(y)},onClose:y=>{p(y)},onToggle:y=>{v(l)?p(y):h(y)},onShow:()=>{n("show",u.value)},onHide:()=>{n("hide",u.value)},onBeforeShow:()=>{n("before-show",u.value)},onBeforeHide:()=>{n("before-hide",u.value)},updatePopper:i}),Me(()=>s.disabled,y=>{y&&l.value&&(l.value=!1)});const g=()=>{var y,w;const b=(w=(y=a.value)==null?void 0:y.contentRef)==null?void 0:w.popperContentRef;return b&&b.contains(document.activeElement)};return PF(()=>l.value&&d()),e({popperRef:o,contentRef:a,isFocusInsideContent:g,updatePopper:i,onOpen:h,onClose:p,hide:d}),(y,w)=>(S(),$e(v(AL),{ref_key:"popperRef",ref:o,role:y.role},{default:ce(()=>[se(yLe,{disabled:y.disabled,trigger:y.trigger,"trigger-keys":y.triggerKeys,"virtual-ref":y.virtualRef,"virtual-triggering":y.virtualTriggering},{default:ce(()=>[y.$slots.default?Oe(y.$slots,"default",{key:0}):ge("v-if",!0)]),_:3},8,["disabled","trigger","trigger-keys","virtual-ref","virtual-triggering"]),se(_Le,{ref_key:"contentRef",ref:a,"aria-label":y.ariaLabel,"boundaries-padding":y.boundariesPadding,content:y.content,disabled:y.disabled,effect:y.effect,enterable:y.enterable,"fallback-placements":y.fallbackPlacements,"hide-after":y.hideAfter,"gpu-acceleration":y.gpuAcceleration,offset:y.offset,persistent:y.persistent,"popper-class":y.popperClass,"popper-style":y.popperStyle,placement:y.placement,"popper-options":y.popperOptions,pure:y.pure,"raw-content":y.rawContent,"reference-el":y.referenceEl,"trigger-target-el":y.triggerTargetEl,"show-after":y.showAfter,strategy:y.strategy,teleported:y.teleported,transition:y.transition,"virtual-triggering":y.virtualTriggering,"z-index":y.zIndex,"append-to":y.appendTo},{default:ce(()=>[Oe(y.$slots,"content",{},()=>[y.rawContent?(S(),E("span",{key:0,innerHTML:y.content},null,8,$Le)):(S(),E("span",xLe,Ue(y.content),1))]),y.showArrow?(S(),$e(v(MMe),{key:0,"arrow-offset":y.arrowOffset},null,8,["arrow-offset"])):ge("v-if",!0)]),_:3},8,["aria-label","boundaries-padding","content","disabled","effect","enterable","fallback-placements","hide-after","gpu-acceleration","offset","persistent","popper-class","popper-style","placement","popper-options","pure","raw-content","reference-el","trigger-target-el","show-after","strategy","teleported","transition","virtual-triggering","z-index","append-to"])]),_:3},8,["role"]))}});var kLe=je(CLe,[["__file","/home/runner/work/element-plus/element-plus/packages/components/tooltip/src/tooltip.vue"]]);const No=Dt(kLe),TLe=qe({valueKey:{type:String,default:"value"},modelValue:{type:[String,Number],default:""},debounce:{type:Number,default:300},placement:{type:Se(String),values:["top","top-start","top-end","bottom","bottom-start","bottom-end"],default:"bottom-start"},fetchSuggestions:{type:Se([Function,Array]),default:gn},popperClass:{type:String,default:""},triggerOnFocus:{type:Boolean,default:!0},selectWhenUnmatched:{type:Boolean,default:!1},hideLoading:{type:Boolean,default:!1},label:{type:String},teleported:Xs.teleported,highlightFirstItem:{type:Boolean,default:!1},fitInputWidth:{type:Boolean,default:!1}}),NLe={[Ot]:t=>wt(t),[jr]:t=>wt(t),[Fn]:t=>wt(t),focus:t=>t instanceof FocusEvent,blur:t=>t instanceof FocusEvent,clear:()=>!0,select:t=>Bt(t)},ILe=["aria-expanded","aria-owns"],ELe={key:0},ALe=["id","aria-selected","onClick"],OL="ElAutocomplete",OLe=ue({name:OL,inheritAttrs:!1}),RLe=ue({...OLe,props:TLe,emits:NLe,setup(t,{expose:e,emit:n}){const s=t,r=zC(),o=Tg(),a=To(),i=Fe("autocomplete"),l=U(),u=U(),c=U(),d=U();let f=!1,h=!1;const p=U([]),m=U(-1),g=U(""),y=U(!1),w=U(!1),b=U(!1),_=A(()=>i.b(String(hw()))),$=A(()=>o.style),x=A(()=>(p.value.length>0||b.value)&&y.value),k=A(()=>!s.hideLoading&&b.value),C=A(()=>l.value?Array.from(l.value.$el.querySelectorAll("input")):[]),T=async()=>{await nt(),x.value&&(g.value=`${l.value.$el.offsetWidth}px`)},N=()=>{h=!0},M=()=>{h=!1,m.value=-1},D=Xr(async ee=>{if(w.value)return;const Q=ie=>{b.value=!1,!w.value&&(Qe(ie)?(p.value=ie,m.value=s.highlightFirstItem?0:-1):Ls(OL,"autocomplete suggestions must be an array"))};if(b.value=!0,Qe(s.fetchSuggestions))Q(s.fetchSuggestions);else{const ie=await s.fetchSuggestions(ee,Q);Qe(ie)&&Q(ie)}},s.debounce),z=ee=>{const Q=!!ee;if(n(jr,ee),n(Ot,ee),w.value=!1,y.value||(y.value=Q),!s.triggerOnFocus&&!ee){w.value=!0,p.value=[];return}D(ee)},B=ee=>{var Q;a.value||(((Q=ee.target)==null?void 0:Q.tagName)!=="INPUT"||C.value.includes(document.activeElement))&&(y.value=!0)},V=ee=>{n(Fn,ee)},O=ee=>{h||(y.value=!0,n("focus",ee),s.triggerOnFocus&&!f&&D(String(s.modelValue)))},F=ee=>{h||n("blur",ee)},L=()=>{y.value=!1,n(Ot,""),n("clear")},G=async()=>{x.value&&m.value>=0&&m.value<p.value.length?X(p.value[m.value]):s.selectWhenUnmatched&&(n("select",{value:s.modelValue}),p.value=[],m.value=-1)},Z=ee=>{x.value&&(ee.preventDefault(),ee.stopPropagation(),j())},j=()=>{y.value=!1},J=()=>{var ee;(ee=l.value)==null||ee.focus()},fe=()=>{var ee;(ee=l.value)==null||ee.blur()},X=async ee=>{n(jr,ee[s.valueKey]),n(Ot,ee[s.valueKey]),n("select",ee),p.value=[],m.value=-1},oe=ee=>{if(!x.value||b.value)return;if(ee<0){m.value=-1;return}ee>=p.value.length&&(ee=p.value.length-1);const Q=u.value.querySelector(`.${i.be("suggestion","wrap")}`),pe=Q.querySelectorAll(`.${i.be("suggestion","list")} li`)[ee],Re=Q.scrollTop,{offsetTop:K,scrollHeight:re}=pe;K+re>Re+Q.clientHeight&&(Q.scrollTop+=re),K<Re&&(Q.scrollTop-=re),m.value=ee,l.value.ref.setAttribute("aria-activedescendant",`${_.value}-item-${m.value}`)};return TC(d,()=>{x.value&&j()}),It(()=>{l.value.ref.setAttribute("role","textbox"),l.value.ref.setAttribute("aria-autocomplete","list"),l.value.ref.setAttribute("aria-controls","id"),l.value.ref.setAttribute("aria-activedescendant",`${_.value}-item-${m.value}`),f=l.value.ref.hasAttribute("readonly")}),e({highlightedIndex:m,activated:y,loading:b,inputRef:l,popperRef:c,suggestions:p,handleSelect:X,handleKeyEnter:G,focus:J,blur:fe,close:j,highlight:oe}),(ee,Q)=>(S(),$e(v(No),{ref_key:"popperRef",ref:c,visible:v(x),placement:ee.placement,"fallback-placements":["bottom-start","top-start"],"popper-class":[v(i).e("popper"),ee.popperClass],teleported:ee.teleported,"gpu-acceleration":!1,pure:"","manual-mode":"",effect:"light",trigger:"click",transition:`${v(i).namespace.value}-zoom-in-top`,persistent:"",onBeforeShow:T,onShow:N,onHide:M},{content:ce(()=>[I("div",{ref_key:"regionRef",ref:u,class:P([v(i).b("suggestion"),v(i).is("loading",v(k))]),style:ot({[ee.fitInputWidth?"width":"minWidth"]:g.value,outline:"none"}),role:"region"},[se(v(jl),{id:v(_),tag:"ul","wrap-class":v(i).be("suggestion","wrap"),"view-class":v(i).be("suggestion","list"),role:"listbox"},{default:ce(()=>[v(k)?(S(),E("li",ELe,[se(v(rt),{class:P(v(i).is("loading"))},{default:ce(()=>[se(v(Vl))]),_:1},8,["class"])])):(S(!0),E(lt,{key:1},Gt(p.value,(ie,pe)=>(S(),E("li",{id:`${v(_)}-item-${pe}`,key:pe,class:P({highlighted:m.value===pe}),role:"option","aria-selected":m.value===pe,onClick:Re=>X(ie)},[Oe(ee.$slots,"default",{item:ie},()=>[Yt(Ue(ie[ee.valueKey]),1)])],10,ALe))),128))]),_:3},8,["id","wrap-class","view-class"])],6)]),default:ce(()=>[I("div",{ref_key:"listboxRef",ref:d,class:P([v(i).b(),ee.$attrs.class]),style:ot(v($)),role:"combobox","aria-haspopup":"listbox","aria-expanded":v(x),"aria-owns":v(_)},[se(v(Or),zt({ref_key:"inputRef",ref:l},v(r),{"model-value":ee.modelValue,onInput:z,onChange:V,onFocus:O,onBlur:F,onClear:L,onKeydown:[Q[0]||(Q[0]=qt(yt(ie=>oe(m.value-1),["prevent"]),["up"])),Q[1]||(Q[1]=qt(yt(ie=>oe(m.value+1),["prevent"]),["down"])),qt(G,["enter"]),qt(j,["tab"]),qt(Z,["esc"])],onMousedown:B}),Uu({_:2},[ee.$slots.prepend?{name:"prepend",fn:ce(()=>[Oe(ee.$slots,"prepend")])}:void 0,ee.$slots.append?{name:"append",fn:ce(()=>[Oe(ee.$slots,"append")])}:void 0,ee.$slots.prefix?{name:"prefix",fn:ce(()=>[Oe(ee.$slots,"prefix")])}:void 0,ee.$slots.suffix?{name:"suffix",fn:ce(()=>[Oe(ee.$slots,"suffix")])}:void 0]),1040,["model-value","onKeydown"])],14,ILe)]),_:3},8,["visible","placement","popper-class","teleported","transition"]))}});var DLe=je(RLe,[["__file","/home/runner/work/element-plus/element-plus/packages/components/autocomplete/src/autocomplete.vue"]]);const FLe=Dt(DLe),MLe=qe({size:{type:[Number,String],values:Hl,default:"",validator:t=>Ct(t)},shape:{type:String,values:["circle","square"],default:"circle"},icon:{type:In},src:{type:String,default:""},alt:String,srcSet:String,fit:{type:Se(String),default:"cover"}}),PLe={error:t=>t instanceof Event},LLe=["src","alt","srcset"],zLe=ue({name:"ElAvatar"}),BLe=ue({...zLe,props:MLe,emits:PLe,setup(t,{emit:e}){const n=t,s=Fe("avatar"),r=U(!1),o=A(()=>{const{size:u,icon:c,shape:d}=n,f=[s.b()];return wt(u)&&f.push(s.m(u)),c&&f.push(s.m("icon")),d&&f.push(s.m(d)),f}),a=A(()=>{const{size:u}=n;return Ct(u)?s.cssVarBlock({size:Cs(u)||""}):void 0}),i=A(()=>({objectFit:n.fit}));Me(()=>n.src,()=>r.value=!1);function l(u){r.value=!0,e("error",u)}return(u,c)=>(S(),E("span",{class:P(v(o)),style:ot(v(a))},[(u.src||u.srcSet)&&!r.value?(S(),E("img",{key:0,src:u.src,alt:u.alt,srcset:u.srcSet,style:ot(v(i)),onError:l},null,44,LLe)):u.icon?(S(),$e(v(rt),{key:1},{default:ce(()=>[(S(),$e(Vt(u.icon)))]),_:1})):Oe(u.$slots,"default",{key:2})],6))}});var VLe=je(BLe,[["__file","/home/runner/work/element-plus/element-plus/packages/components/avatar/src/avatar.vue"]]);const HLe=Dt(VLe),WLe={visibilityHeight:{type:Number,default:200},target:{type:String,default:""},right:{type:Number,default:40},bottom:{type:Number,default:40}},ULe={click:t=>t instanceof MouseEvent},GLe=(t,e,n)=>{const s=Nn(),r=Nn(),o=U(!1),a=()=>{if(!s.value)return;const c=Date.now(),d=s.value.scrollTop,f=()=>{if(!s.value)return;const h=(Date.now()-c)/500;h<1?(s.value.scrollTop=d*(1-U9e(h)),requestAnimationFrame(f)):s.value.scrollTop=0};requestAnimationFrame(f)},i=()=>{s.value&&(o.value=s.value.scrollTop>=t.visibilityHeight)},l=c=>{a(),e("click",c)},u=oP(i,300,!0);return Rn(r,"scroll",u),It(()=>{var c;r.value=document,s.value=document.documentElement,t.target&&(s.value=(c=document.querySelector(t.target))!=null?c:void 0,s.value||Ls(n,`target does not exist: ${t.target}`),r.value=s.value)}),{visible:o,handleClick:l}},RL="ElBacktop",jLe=ue({name:RL}),KLe=ue({...jLe,props:WLe,emits:ULe,setup(t,{emit:e}){const n=t,s=Fe("backtop"),{handleClick:r,visible:o}=GLe(n,e,RL),a=A(()=>({right:`${n.right}px`,bottom:`${n.bottom}px`}));return(i,l)=>(S(),$e(ms,{name:`${v(s).namespace.value}-fade-in`},{default:ce(()=>[v(o)?(S(),E("div",{key:0,style:ot(v(a)),class:P(v(s).b()),onClick:l[0]||(l[0]=yt((...u)=>v(r)&&v(r)(...u),["stop"]))},[Oe(i.$slots,"default",{},()=>[se(v(rt),{class:P(v(s).e("icon"))},{default:ce(()=>[se(v(fP))]),_:1},8,["class"])])],6)):ge("v-if",!0)]),_:3},8,["name"]))}});var qLe=je(KLe,[["__file","/home/runner/work/element-plus/element-plus/packages/components/backtop/src/backtop.vue"]]);const XLe=Dt(qLe),YLe=qe({value:{type:[String,Number],default:""},max:{type:Number,default:99},isDot:Boolean,hidden:Boolean,type:{type:String,values:["primary","success","warning","info","danger"],default:"danger"}}),ZLe=["textContent"],JLe=ue({name:"ElBadge"}),QLe=ue({...JLe,props:YLe,setup(t,{expose:e}){const n=t,s=Fe("badge"),r=A(()=>n.isDot?"":Ct(n.value)&&Ct(n.max)?n.max<n.value?`${n.max}+`:`${n.value}`:`${n.value}`);return e({content:r}),(o,a)=>(S(),E("div",{class:P(v(s).b())},[Oe(o.$slots,"default"),se(ms,{name:`${v(s).namespace.value}-zoom-in-center`,persisted:""},{default:ce(()=>[St(I("sup",{class:P([v(s).e("content"),v(s).em("content",o.type),v(s).is("fixed",!!o.$slots.default),v(s).is("dot",o.isDot)]),textContent:Ue(v(r))},null,10,ZLe),[[Qt,!o.hidden&&(v(r)||o.isDot)]])]),_:1},8,["name"])],2))}});var eze=je(QLe,[["__file","/home/runner/work/element-plus/element-plus/packages/components/badge/src/badge.vue"]]);const DL=Dt(eze),tze=qe({separator:{type:String,default:"/"},separatorIcon:{type:In}}),nze=ue({name:"ElBreadcrumb"}),sze=ue({...nze,props:tze,setup(t){const e=t,n=Fe("breadcrumb"),s=U();return Lt(FP,e),It(()=>{const r=s.value.querySelectorAll(`.${n.e("item")}`);r.length&&r[r.length-1].setAttribute("aria-current","page")}),(r,o)=>(S(),E("div",{ref_key:"breadcrumb",ref:s,class:P(v(n).b()),"aria-label":"Breadcrumb",role:"navigation"},[Oe(r.$slots,"default")],2))}});var rze=je(sze,[["__file","/home/runner/work/element-plus/element-plus/packages/components/breadcrumb/src/breadcrumb.vue"]]);const oze=qe({to:{type:Se([String,Object]),default:""},replace:{type:Boolean,default:!1}}),aze=ue({name:"ElBreadcrumbItem"}),ize=ue({...aze,props:oze,setup(t){const e=t,n=Rt(),s=et(FP,void 0),r=Fe("breadcrumb"),{separator:o,separatorIcon:a}=Ps(s),i=n.appContext.config.globalProperties.$router,l=U(),u=()=>{!e.to||!i||(e.replace?i.replace(e.to):i.push(e.to))};return(c,d)=>(S(),E("span",{class:P(v(r).e("item"))},[I("span",{ref_key:"link",ref:l,class:P([v(r).e("inner"),v(r).is("link",!!c.to)]),role:"link",onClick:u},[Oe(c.$slots,"default")],2),v(a)?(S(),$e(v(rt),{key:0,class:P(v(r).e("separator"))},{default:ce(()=>[(S(),$e(Vt(v(a))))]),_:1},8,["class"])):(S(),E("span",{key:1,class:P(v(r).e("separator")),role:"presentation"},Ue(v(o)),3))],2))}});var FL=je(ize,[["__file","/home/runner/work/element-plus/element-plus/packages/components/breadcrumb/src/breadcrumb-item.vue"]]);const lze=Dt(rze,{BreadcrumbItem:FL}),uze=ns(FL),cze=(t,e)=>{Sl({from:"type.text",replacement:"link",version:"3.0.0",scope:"props",ref:"https://element-plus.org/en-US/component/button.html#button-attributes"},A(()=>t.type==="text"));const n=et(MP,void 0),s=Wl("button"),{form:r}=to(),o=ks(A(()=>n==null?void 0:n.size)),a=To(),i=U(),l=ir(),u=A(()=>t.type||(n==null?void 0:n.type)||""),c=A(()=>{var h,p,m;return(m=(p=t.autoInsertSpace)!=null?p:(h=s.value)==null?void 0:h.autoInsertSpace)!=null?m:!1}),d=A(()=>{var h;const p=(h=l.default)==null?void 0:h.call(l);if(c.value&&(p==null?void 0:p.length)===1){const m=p[0];if((m==null?void 0:m.type)===Xh){const g=m.children;return/^\p{Unified_Ideograph}{2}$/u.test(g.trim())}}return!1});return{_disabled:a,_size:o,_type:u,_ref:i,shouldAddSpace:d,handleClick:h=>{t.nativeType==="reset"&&(r==null||r.resetFields()),e("click",h)}}},m6=["default","primary","success","warning","info","danger","text",""],dze=["button","submit","reset"],g6=qe({size:wo,disabled:Boolean,type:{type:String,values:m6,default:""},icon:{type:In},nativeType:{type:String,values:dze,default:"button"},loading:Boolean,loadingIcon:{type:In,default:()=>Vl},plain:Boolean,text:Boolean,link:Boolean,bg:Boolean,autofocus:Boolean,round:Boolean,circle:Boolean,color:String,dark:Boolean,autoInsertSpace:{type:Boolean,default:void 0}}),fze={click:t=>t instanceof MouseEvent};function yr(t,e){hze(t)&&(t="100%");var n=pze(t);return t=e===360?t:Math.min(e,Math.max(0,parseFloat(t))),n&&(t=parseInt(String(t*e),10)/100),Math.abs(t-e)<1e-6?1:(e===360?t=(t<0?t%e+e:t%e)/parseFloat(String(e)):t=t%e/parseFloat(String(e)),t)}function ov(t){return Math.min(1,Math.max(0,t))}function hze(t){return typeof t=="string"&&t.indexOf(".")!==-1&&parseFloat(t)===1}function pze(t){return typeof t=="string"&&t.indexOf("%")!==-1}function ML(t){return t=parseFloat(t),(isNaN(t)||t<0||t>1)&&(t=1),t}function av(t){return t<=1?"".concat(Number(t)*100,"%"):t}function jc(t){return t.length===1?"0"+t:String(t)}function mze(t,e,n){return{r:yr(t,255)*255,g:yr(e,255)*255,b:yr(n,255)*255}}function _O(t,e,n){t=yr(t,255),e=yr(e,255),n=yr(n,255);var s=Math.max(t,e,n),r=Math.min(t,e,n),o=0,a=0,i=(s+r)/2;if(s===r)a=0,o=0;else{var l=s-r;switch(a=i>.5?l/(2-s-r):l/(s+r),s){case t:o=(e-n)/l+(e<n?6:0);break;case e:o=(n-t)/l+2;break;case n:o=(t-e)/l+4;break}o/=6}return{h:o,s:a,l:i}}function q4(t,e,n){return n<0&&(n+=1),n>1&&(n-=1),n<1/6?t+(e-t)*(6*n):n<1/2?e:n<2/3?t+(e-t)*(2/3-n)*6:t}function gze(t,e,n){var s,r,o;if(t=yr(t,360),e=yr(e,100),n=yr(n,100),e===0)r=n,o=n,s=n;else{var a=n<.5?n*(1+e):n+e-n*e,i=2*n-a;s=q4(i,a,t+1/3),r=q4(i,a,t),o=q4(i,a,t-1/3)}return{r:s*255,g:r*255,b:o*255}}function $O(t,e,n){t=yr(t,255),e=yr(e,255),n=yr(n,255);var s=Math.max(t,e,n),r=Math.min(t,e,n),o=0,a=s,i=s-r,l=s===0?0:i/s;if(s===r)o=0;else{switch(s){case t:o=(e-n)/i+(e<n?6:0);break;case e:o=(n-t)/i+2;break;case n:o=(t-e)/i+4;break}o/=6}return{h:o,s:l,v:a}}function vze(t,e,n){t=yr(t,360)*6,e=yr(e,100),n=yr(n,100);var s=Math.floor(t),r=t-s,o=n*(1-e),a=n*(1-r*e),i=n*(1-(1-r)*e),l=s%6,u=[n,a,o,o,i,n][l],c=[i,n,n,a,o,o][l],d=[o,o,i,n,n,a][l];return{r:u*255,g:c*255,b:d*255}}function xO(t,e,n,s){var r=[jc(Math.round(t).toString(16)),jc(Math.round(e).toString(16)),jc(Math.round(n).toString(16))];return s&&r[0].startsWith(r[0].charAt(1))&&r[1].startsWith(r[1].charAt(1))&&r[2].startsWith(r[2].charAt(1))?r[0].charAt(0)+r[1].charAt(0)+r[2].charAt(0):r.join("")}function yze(t,e,n,s,r){var o=[jc(Math.round(t).toString(16)),jc(Math.round(e).toString(16)),jc(Math.round(n).toString(16)),jc(bze(s))];return r&&o[0].startsWith(o[0].charAt(1))&&o[1].startsWith(o[1].charAt(1))&&o[2].startsWith(o[2].charAt(1))&&o[3].startsWith(o[3].charAt(1))?o[0].charAt(0)+o[1].charAt(0)+o[2].charAt(0)+o[3].charAt(0):o.join("")}function bze(t){return Math.round(parseFloat(t)*255).toString(16)}function SO(t){return Oo(t)/255}function Oo(t){return parseInt(t,16)}function wze(t){return{r:t>>16,g:(t&65280)>>8,b:t&255}}var v6={aliceblue:"#f0f8ff",antiquewhite:"#faebd7",aqua:"#00ffff",aquamarine:"#7fffd4",azure:"#f0ffff",beige:"#f5f5dc",bisque:"#ffe4c4",black:"#000000",blanchedalmond:"#ffebcd",blue:"#0000ff",blueviolet:"#8a2be2",brown:"#a52a2a",burlywood:"#deb887",cadetblue:"#5f9ea0",chartreuse:"#7fff00",chocolate:"#d2691e",coral:"#ff7f50",cornflowerblue:"#6495ed",cornsilk:"#fff8dc",crimson:"#dc143c",cyan:"#00ffff",darkblue:"#00008b",darkcyan:"#008b8b",darkgoldenrod:"#b8860b",darkgray:"#a9a9a9",darkgreen:"#006400",darkgrey:"#a9a9a9",darkkhaki:"#bdb76b",darkmagenta:"#8b008b",darkolivegreen:"#556b2f",darkorange:"#ff8c00",darkorchid:"#9932cc",darkred:"#8b0000",darksalmon:"#e9967a",darkseagreen:"#8fbc8f",darkslateblue:"#483d8b",darkslategray:"#2f4f4f",darkslategrey:"#2f4f4f",darkturquoise:"#00ced1",darkviolet:"#9400d3",deeppink:"#ff1493",deepskyblue:"#00bfff",dimgray:"#696969",dimgrey:"#696969",dodgerblue:"#1e90ff",firebrick:"#b22222",floralwhite:"#fffaf0",forestgreen:"#228b22",fuchsia:"#ff00ff",gainsboro:"#dcdcdc",ghostwhite:"#f8f8ff",goldenrod:"#daa520",gold:"#ffd700",gray:"#808080",green:"#008000",greenyellow:"#adff2f",grey:"#808080",honeydew:"#f0fff0",hotpink:"#ff69b4",indianred:"#cd5c5c",indigo:"#4b0082",ivory:"#fffff0",khaki:"#f0e68c",lavenderblush:"#fff0f5",lavender:"#e6e6fa",lawngreen:"#7cfc00",lemonchiffon:"#fffacd",lightblue:"#add8e6",lightcoral:"#f08080",lightcyan:"#e0ffff",lightgoldenrodyellow:"#fafad2",lightgray:"#d3d3d3",lightgreen:"#90ee90",lightgrey:"#d3d3d3",lightpink:"#ffb6c1",lightsalmon:"#ffa07a",lightseagreen:"#20b2aa",lightskyblue:"#87cefa",lightslategray:"#778899",lightslategrey:"#778899",lightsteelblue:"#b0c4de",lightyellow:"#ffffe0",lime:"#00ff00",limegreen:"#32cd32",linen:"#faf0e6",magenta:"#ff00ff",maroon:"#800000",mediumaquamarine:"#66cdaa",mediumblue:"#0000cd",mediumorchid:"#ba55d3",mediumpurple:"#9370db",mediumseagreen:"#3cb371",mediumslateblue:"#7b68ee",mediumspringgreen:"#00fa9a",mediumturquoise:"#48d1cc",mediumvioletred:"#c71585",midnightblue:"#191970",mintcream:"#f5fffa",mistyrose:"#ffe4e1",moccasin:"#ffe4b5",navajowhite:"#ffdead",navy:"#000080",oldlace:"#fdf5e6",olive:"#808000",olivedrab:"#6b8e23",orange:"#ffa500",orangered:"#ff4500",orchid:"#da70d6",palegoldenrod:"#eee8aa",palegreen:"#98fb98",paleturquoise:"#afeeee",palevioletred:"#db7093",papayawhip:"#ffefd5",peachpuff:"#ffdab9",peru:"#cd853f",pink:"#ffc0cb",plum:"#dda0dd",powderblue:"#b0e0e6",purple:"#800080",rebeccapurple:"#663399",red:"#ff0000",rosybrown:"#bc8f8f",royalblue:"#4169e1",saddlebrown:"#8b4513",salmon:"#fa8072",sandybrown:"#f4a460",seagreen:"#2e8b57",seashell:"#fff5ee",sienna:"#a0522d",silver:"#c0c0c0",skyblue:"#87ceeb",slateblue:"#6a5acd",slategray:"#708090",slategrey:"#708090",snow:"#fffafa",springgreen:"#00ff7f",steelblue:"#4682b4",tan:"#d2b48c",teal:"#008080",thistle:"#d8bfd8",tomato:"#ff6347",turquoise:"#40e0d0",violet:"#ee82ee",wheat:"#f5deb3",white:"#ffffff",whitesmoke:"#f5f5f5",yellow:"#ffff00",yellowgreen:"#9acd32"};function _ze(t){var e={r:0,g:0,b:0},n=1,s=null,r=null,o=null,a=!1,i=!1;return typeof t=="string"&&(t=Sze(t)),typeof t=="object"&&(el(t.r)&&el(t.g)&&el(t.b)?(e=mze(t.r,t.g,t.b),a=!0,i=String(t.r).substr(-1)==="%"?"prgb":"rgb"):el(t.h)&&el(t.s)&&el(t.v)?(s=av(t.s),r=av(t.v),e=vze(t.h,s,r),a=!0,i="hsv"):el(t.h)&&el(t.s)&&el(t.l)&&(s=av(t.s),o=av(t.l),e=gze(t.h,s,o),a=!0,i="hsl"),Object.prototype.hasOwnProperty.call(t,"a")&&(n=t.a)),n=ML(n),{ok:a,format:t.format||i,r:Math.min(255,Math.max(e.r,0)),g:Math.min(255,Math.max(e.g,0)),b:Math.min(255,Math.max(e.b,0)),a:n}}var $ze="[-\\+]?\\d+%?",xze="[-\\+]?\\d*\\.\\d+%?",xu="(?:".concat(xze,")|(?:").concat($ze,")"),X4="[\\s|\\(]+(".concat(xu,")[,|\\s]+(").concat(xu,")[,|\\s]+(").concat(xu,")\\s*\\)?"),Y4="[\\s|\\(]+(".concat(xu,")[,|\\s]+(").concat(xu,")[,|\\s]+(").concat(xu,")[,|\\s]+(").concat(xu,")\\s*\\)?"),Da={CSS_UNIT:new RegExp(xu),rgb:new RegExp("rgb"+X4),rgba:new RegExp("rgba"+Y4),hsl:new RegExp("hsl"+X4),hsla:new RegExp("hsla"+Y4),hsv:new RegExp("hsv"+X4),hsva:new RegExp("hsva"+Y4),hex3:/^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,hex6:/^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,hex4:/^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,hex8:/^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/};function Sze(t){if(t=t.trim().toLowerCase(),t.length===0)return!1;var e=!1;if(v6[t])t=v6[t],e=!0;else if(t==="transparent")return{r:0,g:0,b:0,a:0,format:"name"};var n=Da.rgb.exec(t);return n?{r:n[1],g:n[2],b:n[3]}:(n=Da.rgba.exec(t),n?{r:n[1],g:n[2],b:n[3],a:n[4]}:(n=Da.hsl.exec(t),n?{h:n[1],s:n[2],l:n[3]}:(n=Da.hsla.exec(t),n?{h:n[1],s:n[2],l:n[3],a:n[4]}:(n=Da.hsv.exec(t),n?{h:n[1],s:n[2],v:n[3]}:(n=Da.hsva.exec(t),n?{h:n[1],s:n[2],v:n[3],a:n[4]}:(n=Da.hex8.exec(t),n?{r:Oo(n[1]),g:Oo(n[2]),b:Oo(n[3]),a:SO(n[4]),format:e?"name":"hex8"}:(n=Da.hex6.exec(t),n?{r:Oo(n[1]),g:Oo(n[2]),b:Oo(n[3]),format:e?"name":"hex"}:(n=Da.hex4.exec(t),n?{r:Oo(n[1]+n[1]),g:Oo(n[2]+n[2]),b:Oo(n[3]+n[3]),a:SO(n[4]+n[4]),format:e?"name":"hex8"}:(n=Da.hex3.exec(t),n?{r:Oo(n[1]+n[1]),g:Oo(n[2]+n[2]),b:Oo(n[3]+n[3]),format:e?"name":"hex"}:!1)))))))))}function el(t){return Boolean(Da.CSS_UNIT.exec(String(t)))}var PL=function(){function t(e,n){e===void 0&&(e=""),n===void 0&&(n={});var s;if(e instanceof t)return e;typeof e=="number"&&(e=wze(e)),this.originalInput=e;var r=_ze(e);this.originalInput=e,this.r=r.r,this.g=r.g,this.b=r.b,this.a=r.a,this.roundA=Math.round(100*this.a)/100,this.format=(s=n.format)!==null&&s!==void 0?s:r.format,this.gradientType=n.gradientType,this.r<1&&(this.r=Math.round(this.r)),this.g<1&&(this.g=Math.round(this.g)),this.b<1&&(this.b=Math.round(this.b)),this.isValid=r.ok}return t.prototype.isDark=function(){return this.getBrightness()<128},t.prototype.isLight=function(){return!this.isDark()},t.prototype.getBrightness=function(){var e=this.toRgb();return(e.r*299+e.g*587+e.b*114)/1e3},t.prototype.getLuminance=function(){var e=this.toRgb(),n,s,r,o=e.r/255,a=e.g/255,i=e.b/255;return o<=.03928?n=o/12.92:n=Math.pow((o+.055)/1.055,2.4),a<=.03928?s=a/12.92:s=Math.pow((a+.055)/1.055,2.4),i<=.03928?r=i/12.92:r=Math.pow((i+.055)/1.055,2.4),.2126*n+.7152*s+.0722*r},t.prototype.getAlpha=function(){return this.a},t.prototype.setAlpha=function(e){return this.a=ML(e),this.roundA=Math.round(100*this.a)/100,this},t.prototype.isMonochrome=function(){var e=this.toHsl().s;return e===0},t.prototype.toHsv=function(){var e=$O(this.r,this.g,this.b);return{h:e.h*360,s:e.s,v:e.v,a:this.a}},t.prototype.toHsvString=function(){var e=$O(this.r,this.g,this.b),n=Math.round(e.h*360),s=Math.round(e.s*100),r=Math.round(e.v*100);return this.a===1?"hsv(".concat(n,", ").concat(s,"%, ").concat(r,"%)"):"hsva(".concat(n,", ").concat(s,"%, ").concat(r,"%, ").concat(this.roundA,")")},t.prototype.toHsl=function(){var e=_O(this.r,this.g,this.b);return{h:e.h*360,s:e.s,l:e.l,a:this.a}},t.prototype.toHslString=function(){var e=_O(this.r,this.g,this.b),n=Math.round(e.h*360),s=Math.round(e.s*100),r=Math.round(e.l*100);return this.a===1?"hsl(".concat(n,", ").concat(s,"%, ").concat(r,"%)"):"hsla(".concat(n,", ").concat(s,"%, ").concat(r,"%, ").concat(this.roundA,")")},t.prototype.toHex=function(e){return e===void 0&&(e=!1),xO(this.r,this.g,this.b,e)},t.prototype.toHexString=function(e){return e===void 0&&(e=!1),"#"+this.toHex(e)},t.prototype.toHex8=function(e){return e===void 0&&(e=!1),yze(this.r,this.g,this.b,this.a,e)},t.prototype.toHex8String=function(e){return e===void 0&&(e=!1),"#"+this.toHex8(e)},t.prototype.toRgb=function(){return{r:Math.round(this.r),g:Math.round(this.g),b:Math.round(this.b),a:this.a}},t.prototype.toRgbString=function(){var e=Math.round(this.r),n=Math.round(this.g),s=Math.round(this.b);return this.a===1?"rgb(".concat(e,", ").concat(n,", ").concat(s,")"):"rgba(".concat(e,", ").concat(n,", ").concat(s,", ").concat(this.roundA,")")},t.prototype.toPercentageRgb=function(){var e=function(n){return"".concat(Math.round(yr(n,255)*100),"%")};return{r:e(this.r),g:e(this.g),b:e(this.b),a:this.a}},t.prototype.toPercentageRgbString=function(){var e=function(n){return Math.round(yr(n,255)*100)};return this.a===1?"rgb(".concat(e(this.r),"%, ").concat(e(this.g),"%, ").concat(e(this.b),"%)"):"rgba(".concat(e(this.r),"%, ").concat(e(this.g),"%, ").concat(e(this.b),"%, ").concat(this.roundA,")")},t.prototype.toName=function(){if(this.a===0)return"transparent";if(this.a<1)return!1;for(var e="#"+xO(this.r,this.g,this.b,!1),n=0,s=Object.entries(v6);n<s.length;n++){var r=s[n],o=r[0],a=r[1];if(e===a)return o}return!1},t.prototype.toString=function(e){var n=Boolean(e);e=e??this.format;var s=!1,r=this.a<1&&this.a>=0,o=!n&&r&&(e.startsWith("hex")||e==="name");return o?e==="name"&&this.a===0?this.toName():this.toRgbString():(e==="rgb"&&(s=this.toRgbString()),e==="prgb"&&(s=this.toPercentageRgbString()),(e==="hex"||e==="hex6")&&(s=this.toHexString()),e==="hex3"&&(s=this.toHexString(!0)),e==="hex4"&&(s=this.toHex8String(!0)),e==="hex8"&&(s=this.toHex8String()),e==="name"&&(s=this.toName()),e==="hsl"&&(s=this.toHslString()),e==="hsv"&&(s=this.toHsvString()),s||this.toHexString())},t.prototype.toNumber=function(){return(Math.round(this.r)<<16)+(Math.round(this.g)<<8)+Math.round(this.b)},t.prototype.clone=function(){return new t(this.toString())},t.prototype.lighten=function(e){e===void 0&&(e=10);var n=this.toHsl();return n.l+=e/100,n.l=ov(n.l),new t(n)},t.prototype.brighten=function(e){e===void 0&&(e=10);var n=this.toRgb();return n.r=Math.max(0,Math.min(255,n.r-Math.round(255*-(e/100)))),n.g=Math.max(0,Math.min(255,n.g-Math.round(255*-(e/100)))),n.b=Math.max(0,Math.min(255,n.b-Math.round(255*-(e/100)))),new t(n)},t.prototype.darken=function(e){e===void 0&&(e=10);var n=this.toHsl();return n.l-=e/100,n.l=ov(n.l),new t(n)},t.prototype.tint=function(e){return e===void 0&&(e=10),this.mix("white",e)},t.prototype.shade=function(e){return e===void 0&&(e=10),this.mix("black",e)},t.prototype.desaturate=function(e){e===void 0&&(e=10);var n=this.toHsl();return n.s-=e/100,n.s=ov(n.s),new t(n)},t.prototype.saturate=function(e){e===void 0&&(e=10);var n=this.toHsl();return n.s+=e/100,n.s=ov(n.s),new t(n)},t.prototype.greyscale=function(){return this.desaturate(100)},t.prototype.spin=function(e){var n=this.toHsl(),s=(n.h+e)%360;return n.h=s<0?360+s:s,new t(n)},t.prototype.mix=function(e,n){n===void 0&&(n=50);var s=this.toRgb(),r=new t(e).toRgb(),o=n/100,a={r:(r.r-s.r)*o+s.r,g:(r.g-s.g)*o+s.g,b:(r.b-s.b)*o+s.b,a:(r.a-s.a)*o+s.a};return new t(a)},t.prototype.analogous=function(e,n){e===void 0&&(e=6),n===void 0&&(n=30);var s=this.toHsl(),r=360/n,o=[this];for(s.h=(s.h-(r*e>>1)+720)%360;--e;)s.h=(s.h+r)%360,o.push(new t(s));return o},t.prototype.complement=function(){var e=this.toHsl();return e.h=(e.h+180)%360,new t(e)},t.prototype.monochromatic=function(e){e===void 0&&(e=6);for(var n=this.toHsv(),s=n.h,r=n.s,o=n.v,a=[],i=1/e;e--;)a.push(new t({h:s,s:r,v:o})),o=(o+i)%1;return a},t.prototype.splitcomplement=function(){var e=this.toHsl(),n=e.h;return[this,new t({h:(n+72)%360,s:e.s,l:e.l}),new t({h:(n+216)%360,s:e.s,l:e.l})]},t.prototype.onBackground=function(e){var n=this.toRgb(),s=new t(e).toRgb();return new t({r:s.r+(n.r-s.r)*n.a,g:s.g+(n.g-s.g)*n.a,b:s.b+(n.b-s.b)*n.a})},t.prototype.triad=function(){return this.polyad(3)},t.prototype.tetrad=function(){return this.polyad(4)},t.prototype.polyad=function(e){for(var n=this.toHsl(),s=n.h,r=[this],o=360/e,a=1;a<e;a++)r.push(new t({h:(s+a*o)%360,s:n.s,l:n.l}));return r},t.prototype.equals=function(e){return this.toRgbString()===new t(e).toRgbString()},t}();function iu(t,e=20){return t.mix("#141414",e).toString()}function Cze(t){const e=To(),n=Fe("button");return A(()=>{let s={};const r=t.color;if(r){const o=new PL(r),a=t.dark?o.tint(20).toString():iu(o,20);if(t.plain)s=n.cssVarBlock({"bg-color":t.dark?iu(o,90):o.tint(90).toString(),"text-color":r,"border-color":t.dark?iu(o,50):o.tint(50).toString(),"hover-text-color":`var(${n.cssVarName("color-white")})`,"hover-bg-color":r,"hover-border-color":r,"active-bg-color":a,"active-text-color":`var(${n.cssVarName("color-white")})`,"active-border-color":a}),e.value&&(s[n.cssVarBlockName("disabled-bg-color")]=t.dark?iu(o,90):o.tint(90).toString(),s[n.cssVarBlockName("disabled-text-color")]=t.dark?iu(o,50):o.tint(50).toString(),s[n.cssVarBlockName("disabled-border-color")]=t.dark?iu(o,80):o.tint(80).toString());else{const i=t.dark?iu(o,30):o.tint(30).toString(),l=o.isDark()?`var(${n.cssVarName("color-white")})`:`var(${n.cssVarName("color-black")})`;if(s=n.cssVarBlock({"bg-color":r,"text-color":l,"border-color":r,"hover-bg-color":i,"hover-text-color":l,"hover-border-color":i,"active-bg-color":a,"active-border-color":a}),e.value){const u=t.dark?iu(o,50):o.tint(50).toString();s[n.cssVarBlockName("disabled-bg-color")]=u,s[n.cssVarBlockName("disabled-text-color")]=t.dark?"rgba(255, 255, 255, 0.5)":`var(${n.cssVarName("color-white")})`,s[n.cssVarBlockName("disabled-border-color")]=u}}}return s})}const kze=["aria-disabled","disabled","autofocus","type"],Tze=ue({name:"ElButton"}),Nze=ue({...Tze,props:g6,emits:fze,setup(t,{expose:e,emit:n}){const s=t,r=Cze(s),o=Fe("button"),{_ref:a,_size:i,_type:l,_disabled:u,shouldAddSpace:c,handleClick:d}=cze(s,n);return e({ref:a,size:i,type:l,disabled:u,shouldAddSpace:c}),(f,h)=>(S(),E("button",{ref_key:"_ref",ref:a,class:P([v(o).b(),v(o).m(v(l)),v(o).m(v(i)),v(o).is("disabled",v(u)),v(o).is("loading",f.loading),v(o).is("plain",f.plain),v(o).is("round",f.round),v(o).is("circle",f.circle),v(o).is("text",f.text),v(o).is("link",f.link),v(o).is("has-bg",f.bg)]),"aria-disabled":v(u)||f.loading,disabled:v(u)||f.loading,autofocus:f.autofocus,type:f.nativeType,style:ot(v(r)),onClick:h[0]||(h[0]=(...p)=>v(d)&&v(d)(...p))},[f.loading?(S(),E(lt,{key:0},[f.$slots.loading?Oe(f.$slots,"loading",{key:0}):(S(),$e(v(rt),{key:1,class:P(v(o).is("loading"))},{default:ce(()=>[(S(),$e(Vt(f.loadingIcon)))]),_:1},8,["class"]))],64)):f.icon||f.$slots.icon?(S(),$e(v(rt),{key:1},{default:ce(()=>[f.icon?(S(),$e(Vt(f.icon),{key:0})):Oe(f.$slots,"icon",{key:1})]),_:3})):ge("v-if",!0),f.$slots.default?(S(),E("span",{key:2,class:P({[v(o).em("text","expand")]:v(c)})},[Oe(f.$slots,"default")],2)):ge("v-if",!0)],14,kze))}});var Ize=je(Nze,[["__file","/home/runner/work/element-plus/element-plus/packages/components/button/src/button.vue"]]);const Eze={size:g6.size,type:g6.type},Aze=ue({name:"ElButtonGroup"}),Oze=ue({...Aze,props:Eze,setup(t){const e=t;Lt(MP,on({size:Un(e,"size"),type:Un(e,"type")}));const n=Fe("button");return(s,r)=>(S(),E("div",{class:P(`${v(n).b("group")}`)},[Oe(s.$slots,"default")],2))}});var LL=je(Oze,[["__file","/home/runner/work/element-plus/element-plus/packages/components/button/src/button-group.vue"]]);const br=Dt(Ize,{ButtonGroup:LL}),zL=ns(LL);var wn=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{};function Mg(t){var e=t.default;if(typeof e=="function"){var n=function s(){if(this instanceof s){var r=[null];r.push.apply(r,arguments);var o=Function.bind.apply(e,r);return new o}return e.apply(this,arguments)};n.prototype=e.prototype}else n={};return Object.defineProperty(n,"__esModule",{value:!0}),Object.keys(t).forEach(function(s){var r=Object.getOwnPropertyDescriptor(t,s);Object.defineProperty(n,s,r.get?r:{enumerable:!0,get:function(){return t[s]}})}),n}var BL={exports:{}};(function(t,e){(function(n,s){t.exports=s()})(wn,function(){var n=1e3,s=6e4,r=36e5,o="millisecond",a="second",i="minute",l="hour",u="day",c="week",d="month",f="quarter",h="year",p="date",m="Invalid Date",g=/^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/,y=/\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g,w={name:"en",weekdays:"Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),months:"January_February_March_April_May_June_July_August_September_October_November_December".split("_"),ordinal:function(D){var z=["th","st","nd","rd"],B=D%100;return"["+D+(z[(B-20)%10]||z[B]||z[0])+"]"}},b=function(D,z,B){var V=String(D);return!V||V.length>=z?D:""+Array(z+1-V.length).join(B)+D},_={s:b,z:function(D){var z=-D.utcOffset(),B=Math.abs(z),V=Math.floor(B/60),O=B%60;return(z<=0?"+":"-")+b(V,2,"0")+":"+b(O,2,"0")},m:function D(z,B){if(z.date()<B.date())return-D(B,z);var V=12*(B.year()-z.year())+(B.month()-z.month()),O=z.clone().add(V,d),F=B-O<0,L=z.clone().add(V+(F?-1:1),d);return+(-(V+(B-O)/(F?O-L:L-O))||0)},a:function(D){return D<0?Math.ceil(D)||0:Math.floor(D)},p:function(D){return{M:d,y:h,w:c,d:u,D:p,h:l,m:i,s:a,ms:o,Q:f}[D]||String(D||"").toLowerCase().replace(/s$/,"")},u:function(D){return D===void 0}},$="en",x={};x[$]=w;var k=function(D){return D instanceof M},C=function D(z,B,V){var O;if(!z)return $;if(typeof z=="string"){var F=z.toLowerCase();x[F]&&(O=F),B&&(x[F]=B,O=F);var L=z.split("-");if(!O&&L.length>1)return D(L[0])}else{var G=z.name;x[G]=z,O=G}return!V&&O&&($=O),O||!V&&$},T=function(D,z){if(k(D))return D.clone();var B=typeof z=="object"?z:{};return B.date=D,B.args=arguments,new M(B)},N=_;N.l=C,N.i=k,N.w=function(D,z){return T(D,{locale:z.$L,utc:z.$u,x:z.$x,$offset:z.$offset})};var M=function(){function D(B){this.$L=C(B.locale,null,!0),this.parse(B)}var z=D.prototype;return z.parse=function(B){this.$d=function(V){var O=V.date,F=V.utc;if(O===null)return new Date(NaN);if(N.u(O))return new Date;if(O instanceof Date)return new Date(O);if(typeof O=="string"&&!/Z$/i.test(O)){var L=O.match(g);if(L){var G=L[2]-1||0,Z=(L[7]||"0").substring(0,3);return F?new Date(Date.UTC(L[1],G,L[3]||1,L[4]||0,L[5]||0,L[6]||0,Z)):new Date(L[1],G,L[3]||1,L[4]||0,L[5]||0,L[6]||0,Z)}}return new Date(O)}(B),this.$x=B.x||{},this.init()},z.init=function(){var B=this.$d;this.$y=B.getFullYear(),this.$M=B.getMonth(),this.$D=B.getDate(),this.$W=B.getDay(),this.$H=B.getHours(),this.$m=B.getMinutes(),this.$s=B.getSeconds(),this.$ms=B.getMilliseconds()},z.$utils=function(){return N},z.isValid=function(){return this.$d.toString()!==m},z.isSame=function(B,V){var O=T(B);return this.startOf(V)<=O&&O<=this.endOf(V)},z.isAfter=function(B,V){return T(B)<this.startOf(V)},z.isBefore=function(B,V){return this.endOf(V)<T(B)},z.$g=function(B,V,O){return N.u(B)?this[V]:this.set(O,B)},z.unix=function(){return Math.floor(this.valueOf()/1e3)},z.valueOf=function(){return this.$d.getTime()},z.startOf=function(B,V){var O=this,F=!!N.u(V)||V,L=N.p(B),G=function(Q,ie){var pe=N.w(O.$u?Date.UTC(O.$y,ie,Q):new Date(O.$y,ie,Q),O);return F?pe:pe.endOf(u)},Z=function(Q,ie){return N.w(O.toDate()[Q].apply(O.toDate("s"),(F?[0,0,0,0]:[23,59,59,999]).slice(ie)),O)},j=this.$W,J=this.$M,fe=this.$D,X="set"+(this.$u?"UTC":"");switch(L){case h:return F?G(1,0):G(31,11);case d:return F?G(1,J):G(0,J+1);case c:var oe=this.$locale().weekStart||0,ee=(j<oe?j+7:j)-oe;return G(F?fe-ee:fe+(6-ee),J);case u:case p:return Z(X+"Hours",0);case l:return Z(X+"Minutes",1);case i:return Z(X+"Seconds",2);case a:return Z(X+"Milliseconds",3);default:return this.clone()}},z.endOf=function(B){return this.startOf(B,!1)},z.$set=function(B,V){var O,F=N.p(B),L="set"+(this.$u?"UTC":""),G=(O={},O[u]=L+"Date",O[p]=L+"Date",O[d]=L+"Month",O[h]=L+"FullYear",O[l]=L+"Hours",O[i]=L+"Minutes",O[a]=L+"Seconds",O[o]=L+"Milliseconds",O)[F],Z=F===u?this.$D+(V-this.$W):V;if(F===d||F===h){var j=this.clone().set(p,1);j.$d[G](Z),j.init(),this.$d=j.set(p,Math.min(this.$D,j.daysInMonth())).$d}else G&&this.$d[G](Z);return this.init(),this},z.set=function(B,V){return this.clone().$set(B,V)},z.get=function(B){return this[N.p(B)]()},z.add=function(B,V){var O,F=this;B=Number(B);var L=N.p(V),G=function(J){var fe=T(F);return N.w(fe.date(fe.date()+Math.round(J*B)),F)};if(L===d)return this.set(d,this.$M+B);if(L===h)return this.set(h,this.$y+B);if(L===u)return G(1);if(L===c)return G(7);var Z=(O={},O[i]=s,O[l]=r,O[a]=n,O)[L]||1,j=this.$d.getTime()+B*Z;return N.w(j,this)},z.subtract=function(B,V){return this.add(-1*B,V)},z.format=function(B){var V=this,O=this.$locale();if(!this.isValid())return O.invalidDate||m;var F=B||"YYYY-MM-DDTHH:mm:ssZ",L=N.z(this),G=this.$H,Z=this.$m,j=this.$M,J=O.weekdays,fe=O.months,X=function(ie,pe,Re,K){return ie&&(ie[pe]||ie(V,F))||Re[pe].slice(0,K)},oe=function(ie){return N.s(G%12||12,ie,"0")},ee=O.meridiem||function(ie,pe,Re){var K=ie<12?"AM":"PM";return Re?K.toLowerCase():K},Q={YY:String(this.$y).slice(-2),YYYY:this.$y,M:j+1,MM:N.s(j+1,2,"0"),MMM:X(O.monthsShort,j,fe,3),MMMM:X(fe,j),D:this.$D,DD:N.s(this.$D,2,"0"),d:String(this.$W),dd:X(O.weekdaysMin,this.$W,J,2),ddd:X(O.weekdaysShort,this.$W,J,3),dddd:J[this.$W],H:String(G),HH:N.s(G,2,"0"),h:oe(1),hh:oe(2),a:ee(G,Z,!0),A:ee(G,Z,!1),m:String(Z),mm:N.s(Z,2,"0"),s:String(this.$s),ss:N.s(this.$s,2,"0"),SSS:N.s(this.$ms,3,"0"),Z:L};return F.replace(y,function(ie,pe){return pe||Q[ie]||L.replace(":","")})},z.utcOffset=function(){return 15*-Math.round(this.$d.getTimezoneOffset()/15)},z.diff=function(B,V,O){var F,L=N.p(V),G=T(B),Z=(G.utcOffset()-this.utcOffset())*s,j=this-G,J=N.m(this,G);return J=(F={},F[h]=J/12,F[d]=J,F[f]=J/3,F[c]=(j-Z)/6048e5,F[u]=(j-Z)/864e5,F[l]=j/r,F[i]=j/s,F[a]=j/n,F)[L]||j,O?J:N.a(J)},z.daysInMonth=function(){return this.endOf(d).$D},z.$locale=function(){return x[this.$L]},z.locale=function(B,V){if(!B)return this.$L;var O=this.clone(),F=C(B,V,!0);return F&&(O.$L=F),O},z.clone=function(){return N.w(this.$d,this)},z.toDate=function(){return new Date(this.valueOf())},z.toJSON=function(){return this.isValid()?this.toISOString():null},z.toISOString=function(){return this.$d.toISOString()},z.toString=function(){return this.$d.toUTCString()},D}(),R=M.prototype;return T.prototype=R,[["$ms",o],["$s",a],["$m",i],["$H",l],["$W",u],["$M",d],["$y",h],["$D",p]].forEach(function(D){R[D[1]]=function(z){return this.$g(z,D[0],D[1])}}),T.extend=function(D,z){return D.$i||(D(z,M,T),D.$i=!0),T},T.locale=C,T.isDayjs=k,T.unix=function(D){return T(1e3*D)},T.en=x[$],T.Ls=x,T.p={},T})})(BL);const Nt=BL.exports;var VL={exports:{}};(function(t,e){(function(n,s){t.exports=s()})(wn,function(){var n={LTS:"h:mm:ss A",LT:"h:mm A",L:"MM/DD/YYYY",LL:"MMMM D, YYYY",LLL:"MMMM D, YYYY h:mm A",LLLL:"dddd, MMMM D, YYYY h:mm A"},s=/(\[[^[]*\])|([-_:/.,()\s]+)|(A|a|YYYY|YY?|MM?M?M?|Do|DD?|hh?|HH?|mm?|ss?|S{1,3}|z|ZZ?)/g,r=/\d\d/,o=/\d\d?/,a=/\d*[^-_:/,()\s\d]+/,i={},l=function(m){return(m=+m)+(m>68?1900:2e3)},u=function(m){return function(g){this[m]=+g}},c=[/[+-]\d\d:?(\d\d)?|Z/,function(m){(this.zone||(this.zone={})).offset=function(g){if(!g||g==="Z")return 0;var y=g.match(/([+-]|\d\d)/g),w=60*y[1]+(+y[2]||0);return w===0?0:y[0]==="+"?-w:w}(m)}],d=function(m){var g=i[m];return g&&(g.indexOf?g:g.s.concat(g.f))},f=function(m,g){var y,w=i.meridiem;if(w){for(var b=1;b<=24;b+=1)if(m.indexOf(w(b,0,g))>-1){y=b>12;break}}else y=m===(g?"pm":"PM");return y},h={A:[a,function(m){this.afternoon=f(m,!1)}],a:[a,function(m){this.afternoon=f(m,!0)}],S:[/\d/,function(m){this.milliseconds=100*+m}],SS:[r,function(m){this.milliseconds=10*+m}],SSS:[/\d{3}/,function(m){this.milliseconds=+m}],s:[o,u("seconds")],ss:[o,u("seconds")],m:[o,u("minutes")],mm:[o,u("minutes")],H:[o,u("hours")],h:[o,u("hours")],HH:[o,u("hours")],hh:[o,u("hours")],D:[o,u("day")],DD:[r,u("day")],Do:[a,function(m){var g=i.ordinal,y=m.match(/\d+/);if(this.day=y[0],g)for(var w=1;w<=31;w+=1)g(w).replace(/\[|\]/g,"")===m&&(this.day=w)}],M:[o,u("month")],MM:[r,u("month")],MMM:[a,function(m){var g=d("months"),y=(d("monthsShort")||g.map(function(w){return w.slice(0,3)})).indexOf(m)+1;if(y<1)throw new Error;this.month=y%12||y}],MMMM:[a,function(m){var g=d("months").indexOf(m)+1;if(g<1)throw new Error;this.month=g%12||g}],Y:[/[+-]?\d+/,u("year")],YY:[r,function(m){this.year=l(m)}],YYYY:[/\d{4}/,u("year")],Z:c,ZZ:c};function p(m){var g,y;g=m,y=i&&i.formats;for(var w=(m=g.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g,function(T,N,M){var R=M&&M.toUpperCase();return N||y[M]||n[M]||y[R].replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g,function(D,z,B){return z||B.slice(1)})})).match(s),b=w.length,_=0;_<b;_+=1){var $=w[_],x=h[$],k=x&&x[0],C=x&&x[1];w[_]=C?{regex:k,parser:C}:$.replace(/^\[|\]$/g,"")}return function(T){for(var N={},M=0,R=0;M<b;M+=1){var D=w[M];if(typeof D=="string")R+=D.length;else{var z=D.regex,B=D.parser,V=T.slice(R),O=z.exec(V)[0];B.call(N,O),T=T.replace(O,"")}}return function(F){var L=F.afternoon;if(L!==void 0){var G=F.hours;L?G<12&&(F.hours+=12):G===12&&(F.hours=0),delete F.afternoon}}(N),N}}return function(m,g,y){y.p.customParseFormat=!0,m&&m.parseTwoDigitYear&&(l=m.parseTwoDigitYear);var w=g.prototype,b=w.parse;w.parse=function(_){var $=_.date,x=_.utc,k=_.args;this.$u=x;var C=k[1];if(typeof C=="string"){var T=k[2]===!0,N=k[3]===!0,M=T||N,R=k[2];N&&(R=k[2]),i=this.$locale(),!T&&R&&(i=y.Ls[R]),this.$d=function(V,O,F){try{if(["x","X"].indexOf(O)>-1)return new Date((O==="X"?1e3:1)*V);var L=p(O)(V),G=L.year,Z=L.month,j=L.day,J=L.hours,fe=L.minutes,X=L.seconds,oe=L.milliseconds,ee=L.zone,Q=new Date,ie=j||(G||Z?1:Q.getDate()),pe=G||Q.getFullYear(),Re=0;G&&!Z||(Re=Z>0?Z-1:Q.getMonth());var K=J||0,re=fe||0,we=X||0,Ee=oe||0;return ee?new Date(Date.UTC(pe,Re,ie,K,re,we,Ee+60*ee.offset*1e3)):F?new Date(Date.UTC(pe,Re,ie,K,re,we,Ee)):new Date(pe,Re,ie,K,re,we,Ee)}catch{return new Date("")}}($,C,x),this.init(),R&&R!==!0&&(this.$L=this.locale(R).$L),M&&$!=this.format(C)&&(this.$d=new Date("")),i={}}else if(C instanceof Array)for(var D=C.length,z=1;z<=D;z+=1){k[1]=C[z-1];var B=y.apply(this,k);if(B.isValid()){this.$d=B.$d,this.$L=B.$L,this.init();break}z===D&&(this.$d=new Date(""))}else b.call(this,_)}}})})(VL);const ok=VL.exports,CO=["hours","minutes","seconds"],y6="HH:mm:ss",Tf="YYYY-MM-DD",Rze={date:Tf,dates:Tf,week:"gggg[w]ww",year:"YYYY",month:"YYYY-MM",datetime:`${Tf} ${y6}`,monthrange:"YYYY-MM",daterange:Tf,datetimerange:`${Tf} ${y6}`},Z4=(t,e)=>[t>0?t-1:void 0,t,t<e?t+1:void 0],Du=t=>Array.from(Array.from({length:t}).keys()),HL=t=>t.replace(/\W?m{1,2}|\W?ZZ/g,"").replace(/\W?h{1,2}|\W?s{1,3}|\W?a/gi,"").trim(),WL=t=>t.replace(/\W?D{1,2}|\W?Do|\W?d{1,4}|\W?M{1,4}|\W?Y{2,4}/g,"").trim(),kO=function(t,e){const n=yd(t),s=yd(e);return n&&s?t.getTime()===e.getTime():!n&&!s?t===e:!1},TO=function(t,e){const n=Qe(t),s=Qe(e);return n&&s?t.length!==e.length?!1:t.every((r,o)=>kO(r,e[o])):!n&&!s?kO(t,e):!1},NO=function(t,e,n){const s=ia(e)||e==="x"?Nt(t).locale(n):Nt(t,e).locale(n);return s.isValid()?s:void 0},IO=function(t,e,n){return ia(e)?t:e==="x"?+t:Nt(t).locale(n).format(e)},J4=(t,e)=>{var n;const s=[],r=e==null?void 0:e();for(let o=0;o<t;o++)s.push((n=r==null?void 0:r.includes(o))!=null?n:!1);return s},UL=qe({disabledHours:{type:Se(Function)},disabledMinutes:{type:Se(Function)},disabledSeconds:{type:Se(Function)}}),GL=qe({visible:Boolean,actualVisible:{type:Boolean,default:void 0},format:{type:String,default:""}}),ak=qe({id:{type:Se([Array,String])},name:{type:Se([Array,String]),default:""},popperClass:{type:String,default:""},format:String,valueFormat:String,type:{type:String,default:""},clearable:{type:Boolean,default:!0},clearIcon:{type:Se([String,Object]),default:Bl},editable:{type:Boolean,default:!0},prefixIcon:{type:Se([String,Object]),default:""},size:wo,readonly:{type:Boolean,default:!1},disabled:{type:Boolean,default:!1},placeholder:{type:String,default:""},popperOptions:{type:Se(Object),default:()=>({})},modelValue:{type:Se([Date,Array,String,Number]),default:""},rangeSeparator:{type:String,default:"-"},startPlaceholder:String,endPlaceholder:String,defaultValue:{type:Se([Date,Array])},defaultTime:{type:Se([Date,Array])},isRange:{type:Boolean,default:!1},...UL,disabledDate:{type:Function},cellClassName:{type:Function},shortcuts:{type:Array,default:()=>[]},arrowControl:{type:Boolean,default:!1},label:{type:String,default:void 0},tabindex:{type:Se([String,Number]),default:0},validateEvent:{type:Boolean,default:!0},unlinkPanels:Boolean}),Dze=["id","name","placeholder","value","disabled","readonly"],Fze=["id","name","placeholder","value","disabled","readonly"],Mze=ue({name:"Picker"}),Pze=ue({...Mze,props:ak,emits:["update:modelValue","change","focus","blur","calendar-change","panel-change","visible-change","keydown"],setup(t,{expose:e,emit:n}){const s=t,{lang:r}=nn(),o=Fe("date"),a=Fe("input"),i=Fe("range"),{form:l,formItem:u}=to(),c=et("ElPopperOptions",{}),d=U(),f=U(),h=U(!1),p=U(!1),m=U(null);let g=!1,y=!1;Me(h,Y=>{Y?nt(()=>{Y&&(m.value=s.modelValue)}):(_e.value=null,nt(()=>{w(s.modelValue)}))});const w=(Y,de)=>{(de||!TO(Y,m.value))&&(n("change",Y),s.validateEvent&&(u==null||u.validate("change").catch(Pe=>void 0)))},b=Y=>{if(!TO(s.modelValue,Y)){let de;Qe(Y)?de=Y.map(Pe=>IO(Pe,s.valueFormat,r.value)):Y&&(de=IO(Y,s.valueFormat,r.value)),n("update:modelValue",Y&&de,r.value)}},_=Y=>{n("keydown",Y)},$=A(()=>{if(f.value){const Y=re.value?f.value:f.value.$el;return Array.from(Y.querySelectorAll("input"))}return[]}),x=(Y,de,Pe)=>{const We=$.value;!We.length||(!Pe||Pe==="min"?(We[0].setSelectionRange(Y,de),We[0].focus()):Pe==="max"&&(We[1].setSelectionRange(Y,de),We[1].focus()))},k=()=>{B(!0,!0),nt(()=>{y=!1})},C=(Y="",de=!1)=>{de||(y=!0),h.value=de;let Pe;Qe(Y)?Pe=Y.map(We=>We.toDate()):Pe=Y&&Y.toDate(),_e.value=null,b(Pe)},T=()=>{p.value=!0},N=()=>{n("visible-change",!0)},M=Y=>{(Y==null?void 0:Y.key)===ut.esc&&B(!0,!0)},R=()=>{p.value=!1,h.value=!1,y=!1,n("visible-change",!1)},D=()=>{h.value=!0},z=()=>{h.value=!1},B=(Y=!0,de=!1)=>{y=de;const[Pe,We]=v($);let Ft=Pe;!Y&&re.value&&(Ft=We),Ft&&Ft.focus()},V=Y=>{s.readonly||L.value||h.value||y||(h.value=!0,n("focus",Y))};let O;const F=Y=>{const de=async()=>{setTimeout(()=>{var Pe;O===de&&(!(((Pe=d.value)==null?void 0:Pe.isFocusInsideContent())&&!g)&&$.value.filter(We=>We.contains(document.activeElement)).length===0&&(ze(),h.value=!1,n("blur",Y),s.validateEvent&&(u==null||u.validate("blur").catch(We=>void 0))),g=!1)},0)};O=de,de()},L=A(()=>s.disabled||(l==null?void 0:l.disabled)),G=A(()=>{let Y;if(Q.value?dt.value.getDefaultValue&&(Y=dt.value.getDefaultValue()):Qe(s.modelValue)?Y=s.modelValue.map(de=>NO(de,s.valueFormat,r.value)):Y=NO(s.modelValue,s.valueFormat,r.value),dt.value.getRangeAvailableTime){const de=dt.value.getRangeAvailableTime(Y);Wo(de,Y)||(Y=de,b(Qe(Y)?Y.map(Pe=>Pe.toDate()):Y.toDate()))}return Qe(Y)&&Y.some(de=>!de)&&(Y=[]),Y}),Z=A(()=>{if(!dt.value.panelReady)return"";const Y=he(G.value);return Qe(_e.value)?[_e.value[0]||Y&&Y[0]||"",_e.value[1]||Y&&Y[1]||""]:_e.value!==null?_e.value:!J.value&&Q.value||!h.value&&Q.value?"":Y?fe.value?Y.join(", "):Y:""}),j=A(()=>s.type.includes("time")),J=A(()=>s.type.startsWith("time")),fe=A(()=>s.type==="dates"),X=A(()=>s.prefixIcon||(j.value?AC:dP)),oe=U(!1),ee=Y=>{s.readonly||L.value||oe.value&&(Y.stopPropagation(),k(),b(null),w(null,!0),oe.value=!1,h.value=!1,dt.value.handleClear&&dt.value.handleClear())},Q=A(()=>{const{modelValue:Y}=s;return!Y||Qe(Y)&&!Y.filter(Boolean).length}),ie=async Y=>{var de;s.readonly||L.value||(((de=Y.target)==null?void 0:de.tagName)!=="INPUT"||$.value.includes(document.activeElement))&&(h.value=!0)},pe=()=>{s.readonly||L.value||!Q.value&&s.clearable&&(oe.value=!0)},Re=()=>{oe.value=!1},K=Y=>{var de;s.readonly||L.value||(((de=Y.touches[0].target)==null?void 0:de.tagName)!=="INPUT"||$.value.includes(document.activeElement))&&(h.value=!0)},re=A(()=>s.type.includes("range")),we=ks(),Ee=A(()=>{var Y,de;return(de=(Y=v(d))==null?void 0:Y.popperRef)==null?void 0:de.contentRef}),De=A(()=>{var Y;return v(re)?v(f):(Y=v(f))==null?void 0:Y.$el});TC(De,Y=>{const de=v(Ee),Pe=v(De);de&&(Y.target===de||Y.composedPath().includes(de))||Y.target===Pe||Y.composedPath().includes(Pe)||(h.value=!1)});const _e=U(null),ze=()=>{if(_e.value){const Y=Ae(Z.value);Y&&ve(Y)&&(b(Qe(Y)?Y.map(de=>de.toDate()):Y.toDate()),_e.value=null)}_e.value===""&&(b(null),w(null),_e.value=null)},Ae=Y=>Y?dt.value.parseUserInput(Y):null,he=Y=>Y?dt.value.formatToString(Y):null,ve=Y=>dt.value.isValidValue(Y),me=async Y=>{if(s.readonly||L.value)return;const{code:de}=Y;if(_(Y),de===ut.esc){h.value===!0&&(h.value=!1,Y.preventDefault(),Y.stopPropagation());return}if(de===ut.down&&(dt.value.handleFocusPicker&&(Y.preventDefault(),Y.stopPropagation()),h.value===!1&&(h.value=!0,await nt()),dt.value.handleFocusPicker)){dt.value.handleFocusPicker();return}if(de===ut.tab){g=!0;return}if(de===ut.enter||de===ut.numpadEnter){(_e.value===null||_e.value===""||ve(Ae(Z.value)))&&(ze(),h.value=!1),Y.stopPropagation();return}if(_e.value){Y.stopPropagation();return}dt.value.handleKeydownInput&&dt.value.handleKeydownInput(Y)},Ve=Y=>{_e.value=Y,h.value||(h.value=!0)},Ye=Y=>{const de=Y.target;_e.value?_e.value=[de.value,_e.value[1]]:_e.value=[de.value,null]},Je=Y=>{const de=Y.target;_e.value?_e.value=[_e.value[0],de.value]:_e.value=[null,de.value]},ct=()=>{var Y;const de=_e.value,Pe=Ae(de&&de[0]),We=v(G);if(Pe&&Pe.isValid()){_e.value=[he(Pe),((Y=Z.value)==null?void 0:Y[1])||null];const Ft=[Pe,We&&(We[1]||null)];ve(Ft)&&(b(Ft),_e.value=null)}},xt=()=>{var Y;const de=v(_e),Pe=Ae(de&&de[1]),We=v(G);if(Pe&&Pe.isValid()){_e.value=[((Y=v(Z))==null?void 0:Y[0])||null,he(Pe)];const Ft=[We&&We[0],Pe];ve(Ft)&&(b(Ft),_e.value=null)}},dt=U({}),xe=Y=>{dt.value[Y[0]]=Y[1],dt.value.panelReady=!0},Ke=Y=>{n("calendar-change",Y)},at=(Y,de,Pe)=>{n("panel-change",Y,de,Pe)};return Lt("EP_PICKER_BASE",{props:s}),e({focus:B,handleFocusInput:V,handleBlurInput:F,handleOpen:D,handleClose:z,onPick:C}),(Y,de)=>(S(),$e(v(No),zt({ref_key:"refPopper",ref:d,visible:h.value,effect:"light",pure:"",trigger:"click"},Y.$attrs,{role:"dialog",teleported:"",transition:`${v(o).namespace.value}-zoom-in-top`,"popper-class":[`${v(o).namespace.value}-picker__popper`,Y.popperClass],"popper-options":v(c),"fallback-placements":["bottom","top","right","left"],"gpu-acceleration":!1,"stop-popper-mouse-event":!1,"hide-after":0,persistent:"",onBeforeShow:T,onShow:N,onHide:R}),{default:ce(()=>[v(re)?(S(),E("div",{key:1,ref_key:"inputRef",ref:f,class:P([v(o).b("editor"),v(o).bm("editor",Y.type),v(a).e("wrapper"),v(o).is("disabled",v(L)),v(o).is("active",h.value),v(i).b("editor"),v(we)?v(i).bm("editor",v(we)):"",Y.$attrs.class]),style:ot(Y.$attrs.style),onClick:V,onMouseenter:pe,onMouseleave:Re,onTouchstart:K,onKeydown:me},[v(X)?(S(),$e(v(rt),{key:0,class:P([v(a).e("icon"),v(i).e("icon")]),onMousedown:yt(ie,["prevent"]),onTouchstart:K},{default:ce(()=>[(S(),$e(Vt(v(X))))]),_:1},8,["class","onMousedown"])):ge("v-if",!0),I("input",{id:Y.id&&Y.id[0],autocomplete:"off",name:Y.name&&Y.name[0],placeholder:Y.startPlaceholder,value:v(Z)&&v(Z)[0],disabled:v(L),readonly:!Y.editable||Y.readonly,class:P(v(i).b("input")),onMousedown:ie,onInput:Ye,onChange:ct,onFocus:V,onBlur:F},null,42,Dze),Oe(Y.$slots,"range-separator",{},()=>[I("span",{class:P(v(i).b("separator"))},Ue(Y.rangeSeparator),3)]),I("input",{id:Y.id&&Y.id[1],autocomplete:"off",name:Y.name&&Y.name[1],placeholder:Y.endPlaceholder,value:v(Z)&&v(Z)[1],disabled:v(L),readonly:!Y.editable||Y.readonly,class:P(v(i).b("input")),onMousedown:ie,onFocus:V,onBlur:F,onInput:Je,onChange:xt},null,42,Fze),Y.clearIcon?(S(),$e(v(rt),{key:1,class:P([v(a).e("icon"),v(i).e("close-icon"),{[v(i).e("close-icon--hidden")]:!oe.value}]),onClick:ee},{default:ce(()=>[(S(),$e(Vt(Y.clearIcon)))]),_:1},8,["class"])):ge("v-if",!0)],38)):(S(),$e(v(Or),{key:0,id:Y.id,ref_key:"inputRef",ref:f,"container-role":"combobox","model-value":v(Z),name:Y.name,size:v(we),disabled:v(L),placeholder:Y.placeholder,class:P([v(o).b("editor"),v(o).bm("editor",Y.type),Y.$attrs.class]),style:ot(Y.$attrs.style),readonly:!Y.editable||Y.readonly||v(fe)||Y.type==="week",label:Y.label,tabindex:Y.tabindex,"validate-event":!1,onInput:Ve,onFocus:V,onBlur:F,onKeydown:me,onChange:ze,onMousedown:ie,onMouseenter:pe,onMouseleave:Re,onTouchstart:K,onClick:de[0]||(de[0]=yt(()=>{},["stop"]))},{prefix:ce(()=>[v(X)?(S(),$e(v(rt),{key:0,class:P(v(a).e("icon")),onMousedown:yt(ie,["prevent"]),onTouchstart:K},{default:ce(()=>[(S(),$e(Vt(v(X))))]),_:1},8,["class","onMousedown"])):ge("v-if",!0)]),suffix:ce(()=>[oe.value&&Y.clearIcon?(S(),$e(v(rt),{key:0,class:P(`${v(a).e("icon")} clear-icon`),onClick:yt(ee,["stop"])},{default:ce(()=>[(S(),$e(Vt(Y.clearIcon)))]),_:1},8,["class","onClick"])):ge("v-if",!0)]),_:1},8,["id","model-value","name","size","disabled","placeholder","class","style","readonly","label","tabindex","onKeydown"]))]),content:ce(()=>[Oe(Y.$slots,"default",{visible:h.value,actualVisible:p.value,parsedValue:v(G),format:Y.format,unlinkPanels:Y.unlinkPanels,type:Y.type,defaultValue:Y.defaultValue,onPick:C,onSelectRange:x,onSetPickerOption:xe,onCalendarChange:Ke,onPanelChange:at,onKeydown:M,onMousedown:de[1]||(de[1]=yt(()=>{},["stop"]))})]),_:3},16,["visible","transition","popper-class","popper-options"]))}});var jL=je(Pze,[["__file","/home/runner/work/element-plus/element-plus/packages/components/time-picker/src/common/picker.vue"]]);const Lze=qe({...GL,datetimeRole:String,parsedValue:{type:Se(Object)}}),KL=({getAvailableHours:t,getAvailableMinutes:e,getAvailableSeconds:n})=>{const s=(a,i,l,u)=>{const c={hour:t,minute:e,second:n};let d=a;return["hour","minute","second"].forEach(f=>{if(c[f]){let h;const p=c[f];switch(f){case"minute":{h=p(d.hour(),i,u);break}case"second":{h=p(d.hour(),d.minute(),i,u);break}default:{h=p(i,u);break}}if((h==null?void 0:h.length)&&!h.includes(d[f]())){const m=l?0:h.length-1;d=d[f](h[m])}}}),d},r={};return{timePickerOptions:r,getAvailableTime:s,onSetOption:([a,i])=>{r[a]=i}}},Q4=t=>{const e=(s,r)=>s||r,n=s=>s!==!0;return t.map(e).filter(n)},qL=(t,e,n)=>({getHoursList:(a,i)=>J4(24,t&&(()=>t==null?void 0:t(a,i))),getMinutesList:(a,i,l)=>J4(60,e&&(()=>e==null?void 0:e(a,i,l))),getSecondsList:(a,i,l,u)=>J4(60,n&&(()=>n==null?void 0:n(a,i,l,u)))}),XL=(t,e,n)=>{const{getHoursList:s,getMinutesList:r,getSecondsList:o}=qL(t,e,n);return{getAvailableHours:(u,c)=>Q4(s(u,c)),getAvailableMinutes:(u,c,d)=>Q4(r(u,c,d)),getAvailableSeconds:(u,c,d,f)=>Q4(o(u,c,d,f))}},YL=t=>{const e=U(t.parsedValue);return Me(()=>t.visible,n=>{n||(e.value=t.parsedValue)}),e},fu=new Map;let EO;Kt&&(document.addEventListener("mousedown",t=>EO=t),document.addEventListener("mouseup",t=>{for(const e of fu.values())for(const{documentHandler:n}of e)n(t,EO)}));function AO(t,e){let n=[];return Array.isArray(e.arg)?n=e.arg:Qa(e.arg)&&n.push(e.arg),function(s,r){const o=e.instance.popperRef,a=s.target,i=r==null?void 0:r.target,l=!e||!e.instance,u=!a||!i,c=t.contains(a)||t.contains(i),d=t===a,f=n.length&&n.some(p=>p==null?void 0:p.contains(a))||n.length&&n.includes(i),h=o&&(o.contains(a)||o.contains(i));l||u||c||d||f||h||e.value(s,r)}}const Ku={beforeMount(t,e){fu.has(t)||fu.set(t,[]),fu.get(t).push({documentHandler:AO(t,e),bindingFn:e.value})},updated(t,e){fu.has(t)||fu.set(t,[]);const n=fu.get(t),s=n.findIndex(o=>o.bindingFn===e.oldValue),r={documentHandler:AO(t,e),bindingFn:e.value};s>=0?n.splice(s,1,r):n.push(r)},unmounted(t){fu.delete(t)}},zze=100,Bze=600,Oy={beforeMount(t,e){const n=e.value,{interval:s=zze,delay:r=Bze}=vt(n)?{}:n;let o,a;const i=()=>vt(n)?n():n.handler(),l=()=>{a&&(clearTimeout(a),a=void 0),o&&(clearInterval(o),o=void 0)};t.addEventListener("mousedown",u=>{u.button===0&&(l(),i(),document.addEventListener("mouseup",()=>l(),{once:!0}),a=setTimeout(()=>{o=setInterval(()=>{i()},s)},r))})}},b6="_trap-focus-children",Kc=[],OO=t=>{if(Kc.length===0)return;const e=Kc[Kc.length-1][b6];if(e.length>0&&t.code===ut.tab){if(e.length===1){t.preventDefault(),document.activeElement!==e[0]&&e[0].focus();return}const n=t.shiftKey,s=t.target===e[0],r=t.target===e[e.length-1];s&&n&&(t.preventDefault(),e[e.length-1].focus()),r&&!n&&(t.preventDefault(),e[0].focus())}},Vze={beforeMount(t){t[b6]=IA(t),Kc.push(t),Kc.length<=1&&document.addEventListener("keydown",OO)},updated(t){nt(()=>{t[b6]=IA(t)})},unmounted(){Kc.shift(),Kc.length===0&&document.removeEventListener("keydown",OO)}};var RO=!1,zc,w6,_6,Gv,jv,ZL,Kv,$6,x6,S6,JL,C6,k6,QL,ez;function so(){if(!RO){RO=!0;var t=navigator.userAgent,e=/(?:MSIE.(\d+\.\d+))|(?:(?:Firefox|GranParadiso|Iceweasel).(\d+\.\d+))|(?:Opera(?:.+Version.|.)(\d+\.\d+))|(?:AppleWebKit.(\d+(?:\.\d+)?))|(?:Trident\/\d+\.\d+.*rv:(\d+\.\d+))/.exec(t),n=/(Mac OS X)|(Windows)|(Linux)/.exec(t);if(C6=/\b(iPhone|iP[ao]d)/.exec(t),k6=/\b(iP[ao]d)/.exec(t),S6=/Android/i.exec(t),QL=/FBAN\/\w+;/i.exec(t),ez=/Mobile/i.exec(t),JL=!!/Win64/.exec(t),e){zc=e[1]?parseFloat(e[1]):e[5]?parseFloat(e[5]):NaN,zc&&document&&document.documentMode&&(zc=document.documentMode);var s=/(?:Trident\/(\d+.\d+))/.exec(t);ZL=s?parseFloat(s[1])+4:zc,w6=e[2]?parseFloat(e[2]):NaN,_6=e[3]?parseFloat(e[3]):NaN,Gv=e[4]?parseFloat(e[4]):NaN,Gv?(e=/(?:Chrome\/(\d+\.\d+))/.exec(t),jv=e&&e[1]?parseFloat(e[1]):NaN):jv=NaN}else zc=w6=_6=jv=Gv=NaN;if(n){if(n[1]){var r=/(?:Mac OS X (\d+(?:[._]\d+)?))/.exec(t);Kv=r?parseFloat(r[1].replace("_",".")):!0}else Kv=!1;$6=!!n[2],x6=!!n[3]}else Kv=$6=x6=!1}}var T6={ie:function(){return so()||zc},ieCompatibilityMode:function(){return so()||ZL>zc},ie64:function(){return T6.ie()&&JL},firefox:function(){return so()||w6},opera:function(){return so()||_6},webkit:function(){return so()||Gv},safari:function(){return T6.webkit()},chrome:function(){return so()||jv},windows:function(){return so()||$6},osx:function(){return so()||Kv},linux:function(){return so()||x6},iphone:function(){return so()||C6},mobile:function(){return so()||C6||k6||S6||ez},nativeApp:function(){return so()||QL},android:function(){return so()||S6},ipad:function(){return so()||k6}},Hze=T6,iv=!!(typeof window<"u"&&window.document&&window.document.createElement),Wze={canUseDOM:iv,canUseWorkers:typeof Worker<"u",canUseEventListeners:iv&&!!(window.addEventListener||window.attachEvent),canUseViewport:iv&&!!window.screen,isInWorker:!iv},tz=Wze,nz;tz.canUseDOM&&(nz=document.implementation&&document.implementation.hasFeature&&document.implementation.hasFeature("","")!==!0);function Uze(t,e){if(!tz.canUseDOM||e&&!("addEventListener"in document))return!1;var n="on"+t,s=n in document;if(!s){var r=document.createElement("div");r.setAttribute(n,"return;"),s=typeof r[n]=="function"}return!s&&nz&&t==="wheel"&&(s=document.implementation.hasFeature("Events.wheel","3.0")),s}var Gze=Uze,DO=10,FO=40,MO=800;function sz(t){var e=0,n=0,s=0,r=0;return"detail"in t&&(n=t.detail),"wheelDelta"in t&&(n=-t.wheelDelta/120),"wheelDeltaY"in t&&(n=-t.wheelDeltaY/120),"wheelDeltaX"in t&&(e=-t.wheelDeltaX/120),"axis"in t&&t.axis===t.HORIZONTAL_AXIS&&(e=n,n=0),s=e*DO,r=n*DO,"deltaY"in t&&(r=t.deltaY),"deltaX"in t&&(s=t.deltaX),(s||r)&&t.deltaMode&&(t.deltaMode==1?(s*=FO,r*=FO):(s*=MO,r*=MO)),s&&!e&&(e=s<1?-1:1),r&&!n&&(n=r<1?-1:1),{spinX:e,spinY:n,pixelX:s,pixelY:r}}sz.getEventType=function(){return Hze.firefox()?"DOMMouseScroll":Gze("wheel")?"wheel":"mousewheel"};var jze=sz;const Kze=function(t,e){if(t&&t.addEventListener){const n=function(s){const r=jze(s);e&&Reflect.apply(e,this,[s,r])};t.addEventListener("wheel",n,{passive:!0})}},qze={beforeMount(t,e){Kze(t,e.value)}},Xze=qe({role:{type:String,required:!0},spinnerDate:{type:Se(Object),required:!0},showSeconds:{type:Boolean,default:!0},arrowControl:Boolean,amPmMode:{type:Se(String),default:""},...UL}),Yze=["onClick"],Zze=["onMouseenter"],Jze=ue({__name:"basic-time-spinner",props:Xze,emits:["change","select-range","set-option"],setup(t,{emit:e}){const n=t,s=Fe("time"),{getHoursList:r,getMinutesList:o,getSecondsList:a}=qL(n.disabledHours,n.disabledMinutes,n.disabledSeconds);let i=!1;const l=U(),u=U(),c=U(),d=U(),f={hours:u,minutes:c,seconds:d},h=A(()=>n.showSeconds?CO:CO.slice(0,2)),p=A(()=>{const{spinnerDate:L}=n,G=L.hour(),Z=L.minute(),j=L.second();return{hours:G,minutes:Z,seconds:j}}),m=A(()=>{const{hours:L,minutes:G}=v(p);return{hours:r(n.role),minutes:o(L,n.role),seconds:a(L,G,n.role)}}),g=A(()=>{const{hours:L,minutes:G,seconds:Z}=v(p);return{hours:Z4(L,23),minutes:Z4(G,59),seconds:Z4(Z,59)}}),y=Xr(L=>{i=!1,_(L)},200),w=L=>{if(!!!n.amPmMode)return"";const Z=n.amPmMode==="A";let j=L<12?" am":" pm";return Z&&(j=j.toUpperCase()),j},b=L=>{let G;switch(L){case"hours":G=[0,2];break;case"minutes":G=[3,5];break;case"seconds":G=[6,8];break}const[Z,j]=G;e("select-range",Z,j),l.value=L},_=L=>{k(L,v(p)[L])},$=()=>{_("hours"),_("minutes"),_("seconds")},x=L=>L.querySelector(`.${s.namespace.value}-scrollbar__wrap`),k=(L,G)=>{if(n.arrowControl)return;const Z=v(f[L]);Z&&Z.$el&&(x(Z.$el).scrollTop=Math.max(0,G*C(L)))},C=L=>{const G=v(f[L]);return(G==null?void 0:G.$el.querySelector("li").offsetHeight)||0},T=()=>{M(1)},N=()=>{M(-1)},M=L=>{l.value||b("hours");const G=l.value,Z=v(p)[G],j=l.value==="hours"?24:60,J=R(G,Z,L,j);D(G,J),k(G,J),nt(()=>b(G))},R=(L,G,Z,j)=>{let J=(G+Z+j)%j;const fe=v(m)[L];for(;fe[J]&&J!==G;)J=(J+Z+j)%j;return J},D=(L,G)=>{if(v(m)[L][G])return;const{hours:J,minutes:fe,seconds:X}=v(p);let oe;switch(L){case"hours":oe=n.spinnerDate.hour(G).minute(fe).second(X);break;case"minutes":oe=n.spinnerDate.hour(J).minute(G).second(X);break;case"seconds":oe=n.spinnerDate.hour(J).minute(fe).second(G);break}e("change",oe)},z=(L,{value:G,disabled:Z})=>{Z||(D(L,G),b(L),k(L,G))},B=L=>{i=!0,y(L);const G=Math.min(Math.round((x(v(f[L]).$el).scrollTop-(V(L)*.5-10)/C(L)+3)/C(L)),L==="hours"?23:59);D(L,G)},V=L=>v(f[L]).$el.offsetHeight,O=()=>{const L=G=>{const Z=v(f[G]);Z&&Z.$el&&(x(Z.$el).onscroll=()=>{B(G)})};L("hours"),L("minutes"),L("seconds")};It(()=>{nt(()=>{!n.arrowControl&&O(),$(),n.role==="start"&&b("hours")})});const F=(L,G)=>{f[G].value=L};return e("set-option",[`${n.role}_scrollDown`,M]),e("set-option",[`${n.role}_emitSelectRange`,b]),Me(()=>n.spinnerDate,()=>{i||$()}),(L,G)=>(S(),E("div",{class:P([v(s).b("spinner"),{"has-seconds":L.showSeconds}])},[L.arrowControl?ge("v-if",!0):(S(!0),E(lt,{key:0},Gt(v(h),Z=>(S(),$e(v(jl),{key:Z,ref_for:!0,ref:j=>F(j,Z),class:P(v(s).be("spinner","wrapper")),"wrap-style":"max-height: inherit;","view-class":v(s).be("spinner","list"),noresize:"",tag:"ul",onMouseenter:j=>b(Z),onMousemove:j=>_(Z)},{default:ce(()=>[(S(!0),E(lt,null,Gt(v(m)[Z],(j,J)=>(S(),E("li",{key:J,class:P([v(s).be("spinner","item"),v(s).is("active",J===v(p)[Z]),v(s).is("disabled",j)]),onClick:fe=>z(Z,{value:J,disabled:j})},[Z==="hours"?(S(),E(lt,{key:0},[Yt(Ue(("0"+(L.amPmMode?J%12||12:J)).slice(-2))+Ue(w(J)),1)],64)):(S(),E(lt,{key:1},[Yt(Ue(("0"+J).slice(-2)),1)],64))],10,Yze))),128))]),_:2},1032,["class","view-class","onMouseenter","onMousemove"]))),128)),L.arrowControl?(S(!0),E(lt,{key:1},Gt(v(h),Z=>(S(),E("div",{key:Z,class:P([v(s).be("spinner","wrapper"),v(s).is("arrow")]),onMouseenter:j=>b(Z)},[St((S(),$e(v(rt),{class:P(["arrow-up",v(s).be("spinner","arrow")])},{default:ce(()=>[se(v(Og))]),_:1},8,["class"])),[[v(Oy),N]]),St((S(),$e(v(rt),{class:P(["arrow-down",v(s).be("spinner","arrow")])},{default:ce(()=>[se(v(zl))]),_:1},8,["class"])),[[v(Oy),T]]),I("ul",{class:P(v(s).be("spinner","list"))},[(S(!0),E(lt,null,Gt(v(g)[Z],(j,J)=>(S(),E("li",{key:J,class:P([v(s).be("spinner","item"),v(s).is("active",j===v(p)[Z]),v(s).is("disabled",v(m)[Z][j])])},[typeof j=="number"?(S(),E(lt,{key:0},[Z==="hours"?(S(),E(lt,{key:0},[Yt(Ue(("0"+(L.amPmMode?j%12||12:j)).slice(-2))+Ue(w(j)),1)],64)):(S(),E(lt,{key:1},[Yt(Ue(("0"+j).slice(-2)),1)],64))],64)):ge("v-if",!0)],2))),128))],2)],42,Zze))),128)):ge("v-if",!0)],2))}});var N6=je(Jze,[["__file","/home/runner/work/element-plus/element-plus/packages/components/time-picker/src/time-picker-com/basic-time-spinner.vue"]]);const Qze=ue({__name:"panel-time-pick",props:Lze,emits:["pick","select-range","set-picker-option"],setup(t,{emit:e}){const n=t,s=et("EP_PICKER_BASE"),{arrowControl:r,disabledHours:o,disabledMinutes:a,disabledSeconds:i,defaultValue:l}=s.props,{getAvailableHours:u,getAvailableMinutes:c,getAvailableSeconds:d}=XL(o,a,i),f=Fe("time"),{t:h,lang:p}=nn(),m=U([0,2]),g=YL(n),y=A(()=>er(n.actualVisible)?`${f.namespace.value}-zoom-in-top`:""),w=A(()=>n.format.includes("ss")),b=A(()=>n.format.includes("A")?"A":n.format.includes("a")?"a":""),_=F=>{const L=Nt(F).locale(p.value),G=z(L);return L.isSame(G)},$=()=>{e("pick",g.value,!1)},x=(F=!1,L=!1)=>{L||e("pick",n.parsedValue,F)},k=F=>{if(!n.visible)return;const L=z(F).millisecond(0);e("pick",L,!0)},C=(F,L)=>{e("select-range",F,L),m.value=[F,L]},T=F=>{const L=[0,3].concat(w.value?[6]:[]),G=["hours","minutes"].concat(w.value?["seconds"]:[]),j=(L.indexOf(m.value[0])+F+L.length)%L.length;M.start_emitSelectRange(G[j])},N=F=>{const L=F.code,{left:G,right:Z,up:j,down:J}=ut;if([G,Z].includes(L)){T(L===G?-1:1),F.preventDefault();return}if([j,J].includes(L)){const fe=L===j?-1:1;M.start_scrollDown(fe),F.preventDefault();return}},{timePickerOptions:M,onSetOption:R,getAvailableTime:D}=KL({getAvailableHours:u,getAvailableMinutes:c,getAvailableSeconds:d}),z=F=>D(F,n.datetimeRole||"",!0),B=F=>F?Nt(F,n.format).locale(p.value):null,V=F=>F?F.format(n.format):null,O=()=>Nt(l).locale(p.value);return e("set-picker-option",["isValidValue",_]),e("set-picker-option",["formatToString",V]),e("set-picker-option",["parseUserInput",B]),e("set-picker-option",["handleKeydownInput",N]),e("set-picker-option",["getRangeAvailableTime",z]),e("set-picker-option",["getDefaultValue",O]),(F,L)=>(S(),$e(ms,{name:v(y)},{default:ce(()=>[F.actualVisible||F.visible?(S(),E("div",{key:0,class:P(v(f).b("panel"))},[I("div",{class:P([v(f).be("panel","content"),{"has-seconds":v(w)}])},[se(N6,{ref:"spinner",role:F.datetimeRole||"start","arrow-control":v(r),"show-seconds":v(w),"am-pm-mode":v(b),"spinner-date":F.parsedValue,"disabled-hours":v(o),"disabled-minutes":v(a),"disabled-seconds":v(i),onChange:k,onSetOption:v(R),onSelectRange:C},null,8,["role","arrow-control","show-seconds","am-pm-mode","spinner-date","disabled-hours","disabled-minutes","disabled-seconds","onSetOption"])],2),I("div",{class:P(v(f).be("panel","footer"))},[I("button",{type:"button",class:P([v(f).be("panel","btn"),"cancel"]),onClick:$},Ue(v(h)("el.datepicker.cancel")),3),I("button",{type:"button",class:P([v(f).be("panel","btn"),"confirm"]),onClick:L[0]||(L[0]=G=>x())},Ue(v(h)("el.datepicker.confirm")),3)],2)],2)):ge("v-if",!0)]),_:1},8,["name"]))}});var Ry=je(Qze,[["__file","/home/runner/work/element-plus/element-plus/packages/components/time-picker/src/time-picker-com/panel-time-pick.vue"]]);const e7e=qe({...GL,parsedValue:{type:Se(Array)}}),t7e=["disabled"],n7e=ue({__name:"panel-time-range",props:e7e,emits:["pick","select-range","set-picker-option"],setup(t,{emit:e}){const n=t,s=(ie,pe)=>{const Re=[];for(let K=ie;K<=pe;K++)Re.push(K);return Re},{t:r,lang:o}=nn(),a=Fe("time"),i=Fe("picker"),l=et("EP_PICKER_BASE"),{arrowControl:u,disabledHours:c,disabledMinutes:d,disabledSeconds:f,defaultValue:h}=l.props,p=A(()=>n.parsedValue[0]),m=A(()=>n.parsedValue[1]),g=YL(n),y=()=>{e("pick",g.value,!1)},w=A(()=>n.format.includes("ss")),b=A(()=>n.format.includes("A")?"A":n.format.includes("a")?"a":""),_=(ie=!1)=>{e("pick",[p.value,m.value],ie)},$=ie=>{C(ie.millisecond(0),m.value)},x=ie=>{C(p.value,ie.millisecond(0))},k=ie=>{const pe=ie.map(K=>Nt(K).locale(o.value)),Re=L(pe);return pe[0].isSame(Re[0])&&pe[1].isSame(Re[1])},C=(ie,pe)=>{e("pick",[ie,pe],!0)},T=A(()=>p.value>m.value),N=U([0,2]),M=(ie,pe)=>{e("select-range",ie,pe,"min"),N.value=[ie,pe]},R=A(()=>w.value?11:8),D=(ie,pe)=>{e("select-range",ie,pe,"max");const Re=v(R);N.value=[ie+Re,pe+Re]},z=ie=>{const pe=w.value?[0,3,6,11,14,17]:[0,3,8,11],Re=["hours","minutes"].concat(w.value?["seconds"]:[]),re=(pe.indexOf(N.value[0])+ie+pe.length)%pe.length,we=pe.length/2;re<we?J.start_emitSelectRange(Re[re]):J.end_emitSelectRange(Re[re-we])},B=ie=>{const pe=ie.code,{left:Re,right:K,up:re,down:we}=ut;if([Re,K].includes(pe)){z(pe===Re?-1:1),ie.preventDefault();return}if([re,we].includes(pe)){const Ee=pe===re?-1:1,De=N.value[0]<R.value?"start":"end";J[`${De}_scrollDown`](Ee),ie.preventDefault();return}},V=(ie,pe)=>{const Re=c?c(ie):[],K=ie==="start",we=(pe||(K?m.value:p.value)).hour(),Ee=K?s(we+1,23):s(0,we-1);return W4(Re,Ee)},O=(ie,pe,Re)=>{const K=d?d(ie,pe):[],re=pe==="start",we=Re||(re?m.value:p.value),Ee=we.hour();if(ie!==Ee)return K;const De=we.minute(),_e=re?s(De+1,59):s(0,De-1);return W4(K,_e)},F=(ie,pe,Re,K)=>{const re=f?f(ie,pe,Re):[],we=Re==="start",Ee=K||(we?m.value:p.value),De=Ee.hour(),_e=Ee.minute();if(ie!==De||pe!==_e)return re;const ze=Ee.second(),Ae=we?s(ze+1,59):s(0,ze-1);return W4(re,Ae)},L=([ie,pe])=>[fe(ie,"start",!0,pe),fe(pe,"end",!1,ie)],{getAvailableHours:G,getAvailableMinutes:Z,getAvailableSeconds:j}=XL(V,O,F),{timePickerOptions:J,getAvailableTime:fe,onSetOption:X}=KL({getAvailableHours:G,getAvailableMinutes:Z,getAvailableSeconds:j}),oe=ie=>ie?Qe(ie)?ie.map(pe=>Nt(pe,n.format).locale(o.value)):Nt(ie,n.format).locale(o.value):null,ee=ie=>ie?Qe(ie)?ie.map(pe=>pe.format(n.format)):ie.format(n.format):null,Q=()=>{if(Qe(h))return h.map(pe=>Nt(pe).locale(o.value));const ie=Nt(h).locale(o.value);return[ie,ie.add(60,"m")]};return e("set-picker-option",["formatToString",ee]),e("set-picker-option",["parseUserInput",oe]),e("set-picker-option",["isValidValue",k]),e("set-picker-option",["handleKeydownInput",B]),e("set-picker-option",["getDefaultValue",Q]),e("set-picker-option",["getRangeAvailableTime",L]),(ie,pe)=>ie.actualVisible?(S(),E("div",{key:0,class:P([v(a).b("range-picker"),v(i).b("panel")])},[I("div",{class:P(v(a).be("range-picker","content"))},[I("div",{class:P(v(a).be("range-picker","cell"))},[I("div",{class:P(v(a).be("range-picker","header"))},Ue(v(r)("el.datepicker.startTime")),3),I("div",{class:P([v(a).be("range-picker","body"),v(a).be("panel","content"),v(a).is("arrow",v(u)),{"has-seconds":v(w)}])},[se(N6,{ref:"minSpinner",role:"start","show-seconds":v(w),"am-pm-mode":v(b),"arrow-control":v(u),"spinner-date":v(p),"disabled-hours":V,"disabled-minutes":O,"disabled-seconds":F,onChange:$,onSetOption:v(X),onSelectRange:M},null,8,["show-seconds","am-pm-mode","arrow-control","spinner-date","onSetOption"])],2)],2),I("div",{class:P(v(a).be("range-picker","cell"))},[I("div",{class:P(v(a).be("range-picker","header"))},Ue(v(r)("el.datepicker.endTime")),3),I("div",{class:P([v(a).be("range-picker","body"),v(a).be("panel","content"),v(a).is("arrow",v(u)),{"has-seconds":v(w)}])},[se(N6,{ref:"maxSpinner",role:"end","show-seconds":v(w),"am-pm-mode":v(b),"arrow-control":v(u),"spinner-date":v(m),"disabled-hours":V,"disabled-minutes":O,"disabled-seconds":F,onChange:x,onSetOption:v(X),onSelectRange:D},null,8,["show-seconds","am-pm-mode","arrow-control","spinner-date","onSetOption"])],2)],2)],2),I("div",{class:P(v(a).be("panel","footer"))},[I("button",{type:"button",class:P([v(a).be("panel","btn"),"cancel"]),onClick:pe[0]||(pe[0]=Re=>y())},Ue(v(r)("el.datepicker.cancel")),3),I("button",{type:"button",class:P([v(a).be("panel","btn"),"confirm"]),disabled:v(T),onClick:pe[1]||(pe[1]=Re=>_())},Ue(v(r)("el.datepicker.confirm")),11,t7e)],2)],2)):ge("v-if",!0)}});var s7e=je(n7e,[["__file","/home/runner/work/element-plus/element-plus/packages/components/time-picker/src/time-picker-com/panel-time-range.vue"]]);Nt.extend(ok);var r7e=ue({name:"ElTimePicker",install:null,props:{...ak,isRange:{type:Boolean,default:!1}},emits:["update:modelValue"],setup(t,e){const n=U(),[s,r]=t.isRange?["timerange",s7e]:["time",Ry],o=a=>e.emit("update:modelValue",a);return Lt("ElPopperOptions",t.popperOptions),e.expose({focus:a=>{var i;(i=n.value)==null||i.handleFocusInput(a)},blur:a=>{var i;(i=n.value)==null||i.handleBlurInput(a)},handleOpen:()=>{var a;(a=n.value)==null||a.handleOpen()},handleClose:()=>{var a;(a=n.value)==null||a.handleClose()}}),()=>{var a;const i=(a=t.format)!=null?a:y6;return se(jL,zt(t,{ref:n,type:s,format:i,"onUpdate:modelValue":o}),{default:l=>se(r,l,null)})}}});const qv=r7e;qv.install=t=>{t.component(qv.name,qv)};const o7e=qv,a7e=(t,e)=>{const n=t.subtract(1,"month").endOf("month").date();return Du(e).map((s,r)=>n-(e-r-1))},i7e=t=>{const e=t.daysInMonth();return Du(e).map((n,s)=>s+1)},l7e=t=>Du(t.length/7).map(e=>{const n=e*7;return t.slice(n,n+7)}),u7e=qe({selectedDay:{type:Se(Object)},range:{type:Se(Array)},date:{type:Se(Object),required:!0},hideHeader:{type:Boolean}}),c7e={pick:t=>Bt(t)};var rz={exports:{}};(function(t,e){(function(n,s){t.exports=s()})(wn,function(){return function(n,s,r){var o=s.prototype,a=function(d){return d&&(d.indexOf?d:d.s)},i=function(d,f,h,p,m){var g=d.name?d:d.$locale(),y=a(g[f]),w=a(g[h]),b=y||w.map(function($){return $.slice(0,p)});if(!m)return b;var _=g.weekStart;return b.map(function($,x){return b[(x+(_||0))%7]})},l=function(){return r.Ls[r.locale()]},u=function(d,f){return d.formats[f]||function(h){return h.replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g,function(p,m,g){return m||g.slice(1)})}(d.formats[f.toUpperCase()])},c=function(){var d=this;return{months:function(f){return f?f.format("MMMM"):i(d,"months")},monthsShort:function(f){return f?f.format("MMM"):i(d,"monthsShort","months",3)},firstDayOfWeek:function(){return d.$locale().weekStart||0},weekdays:function(f){return f?f.format("dddd"):i(d,"weekdays")},weekdaysMin:function(f){return f?f.format("dd"):i(d,"weekdaysMin","weekdays",2)},weekdaysShort:function(f){return f?f.format("ddd"):i(d,"weekdaysShort","weekdays",3)},longDateFormat:function(f){return u(d.$locale(),f)},meridiem:this.$locale().meridiem,ordinal:this.$locale().ordinal}};o.localeData=function(){return c.bind(this)()},r.localeData=function(){var d=l();return{firstDayOfWeek:function(){return d.weekStart||0},weekdays:function(){return r.weekdays()},weekdaysShort:function(){return r.weekdaysShort()},weekdaysMin:function(){return r.weekdaysMin()},months:function(){return r.months()},monthsShort:function(){return r.monthsShort()},longDateFormat:function(f){return u(d,f)},meridiem:d.meridiem,ordinal:d.ordinal}},r.months=function(){return i(l(),"months")},r.monthsShort=function(){return i(l(),"monthsShort","months",3)},r.weekdays=function(d){return i(l(),"weekdays",null,null,d)},r.weekdaysShort=function(d){return i(l(),"weekdaysShort","weekdays",3,d)},r.weekdaysMin=function(d){return i(l(),"weekdaysMin","weekdays",2,d)}}})})(rz);const oz=rz.exports,d7e=(t,e)=>{Nt.extend(oz);const n=Nt.localeData().firstDayOfWeek(),{t:s,lang:r}=nn(),o=Nt().locale(r.value),a=A(()=>!!t.range&&!!t.range.length),i=A(()=>{let f=[];if(a.value){const[h,p]=t.range,m=Du(p.date()-h.date()+1).map(w=>({text:h.date()+w,type:"current"}));let g=m.length%7;g=g===0?0:7-g;const y=Du(g).map((w,b)=>({text:b+1,type:"next"}));f=m.concat(y)}else{const h=t.date.startOf("month").day(),p=a7e(t.date,(h-n+7)%7).map(w=>({text:w,type:"prev"})),m=i7e(t.date).map(w=>({text:w,type:"current"}));f=[...p,...m];const g=7-(f.length%7||7),y=Du(g).map((w,b)=>({text:b+1,type:"next"}));f=f.concat(y)}return l7e(f)}),l=A(()=>{const f=n;return f===0?U4.map(h=>s(`el.datepicker.weeks.${h}`)):U4.slice(f).concat(U4.slice(0,f)).map(h=>s(`el.datepicker.weeks.${h}`))}),u=(f,h)=>{switch(h){case"prev":return t.date.startOf("month").subtract(1,"month").date(f);case"next":return t.date.startOf("month").add(1,"month").date(f);case"current":return t.date.date(f)}};return{now:o,isInRange:a,rows:i,weekDays:l,getFormattedDate:u,handlePickDay:({text:f,type:h})=>{const p=u(f,h);e("pick",p)},getSlotData:({text:f,type:h})=>{const p=u(f,h);return{isSelected:p.isSame(t.selectedDay),type:`${h}-month`,day:p.format("YYYY-MM-DD"),date:p.toDate()}}}},f7e={key:0},h7e=["onClick"],p7e=ue({name:"DateTable"}),m7e=ue({...p7e,props:u7e,emits:c7e,setup(t,{expose:e,emit:n}){const s=t,{isInRange:r,now:o,rows:a,weekDays:i,getFormattedDate:l,handlePickDay:u,getSlotData:c}=d7e(s,n),d=Fe("calendar-table"),f=Fe("calendar-day"),h=({text:p,type:m})=>{const g=[m];if(m==="current"){const y=l(p,m);y.isSame(s.selectedDay,"day")&&g.push(f.is("selected")),y.isSame(o,"day")&&g.push(f.is("today"))}return g};return e({getFormattedDate:l}),(p,m)=>(S(),E("table",{class:P([v(d).b(),v(d).is("range",v(r))]),cellspacing:"0",cellpadding:"0"},[p.hideHeader?ge("v-if",!0):(S(),E("thead",f7e,[(S(!0),E(lt,null,Gt(v(i),g=>(S(),E("th",{key:g},Ue(g),1))),128))])),I("tbody",null,[(S(!0),E(lt,null,Gt(v(a),(g,y)=>(S(),E("tr",{key:y,class:P({[v(d).e("row")]:!0,[v(d).em("row","hide-border")]:y===0&&p.hideHeader})},[(S(!0),E(lt,null,Gt(g,(w,b)=>(S(),E("td",{key:b,class:P(h(w)),onClick:_=>v(u)(w)},[I("div",{class:P(v(f).b())},[Oe(p.$slots,"date-cell",{data:v(c)(w)},()=>[I("span",null,Ue(w.text),1)])],2)],10,h7e))),128))],2))),128))])],2))}});var PO=je(m7e,[["__file","/home/runner/work/element-plus/element-plus/packages/components/calendar/src/date-table.vue"]]);const g7e=(t,e)=>{const n=t.endOf("month"),s=e.startOf("month"),o=n.isSame(s,"week")?s.add(1,"week"):s;return[[t,n],[o.startOf("week"),e]]},v7e=(t,e)=>{const n=t.endOf("month"),s=t.add(1,"month").startOf("month"),r=n.isSame(s,"week")?s.add(1,"week"):s,o=r.endOf("month"),a=e.startOf("month"),i=o.isSame(a,"week")?a.add(1,"week"):a;return[[t,n],[r.startOf("week"),o],[i.startOf("week"),e]]},y7e=(t,e,n)=>{const s=ir(),{lang:r}=nn(),o=U(),a=Nt().locale(r.value),i=A({get(){return t.modelValue?u.value:o.value},set(y){if(!y)return;o.value=y;const w=y.toDate();e(jr,w),e(Ot,w)}}),l=A(()=>{if(!t.range)return[];const y=t.range.map(_=>Nt(_).locale(r.value)),[w,b]=y;return w.isAfter(b)?[]:w.isSame(b,"month")?p(w,b):w.add(1,"month").month()!==b.month()?[]:p(w,b)}),u=A(()=>t.modelValue?Nt(t.modelValue).locale(r.value):i.value||(l.value.length?l.value[0][0]:a)),c=A(()=>u.value.subtract(1,"month").date(1)),d=A(()=>u.value.add(1,"month").date(1)),f=A(()=>u.value.subtract(1,"year").date(1)),h=A(()=>u.value.add(1,"year").date(1)),p=(y,w)=>{const b=y.startOf("week"),_=w.endOf("week"),$=b.get("month"),x=_.get("month");return $===x?[[b,_]]:($+1)%12===x?g7e(b,_):$+2===x||($+1)%11===x?v7e(b,_):[]},m=y=>{i.value=y},g=y=>{const b={"prev-month":c.value,"next-month":d.value,"prev-year":f.value,"next-year":h.value,today:a}[y];b.isSame(u.value,"day")||m(b)};return Sl({from:'"dateCell"',replacement:'"date-cell"',scope:"ElCalendar",version:"2.3.0",ref:"https://element-plus.org/en-US/component/calendar.html#slots",type:"Slot"},A(()=>!!s.dateCell)),{calculateValidatedDateRange:p,date:u,realSelectedDay:i,pickDay:m,selectDate:g,validatedRange:l}},b7e=t=>Qe(t)&&t.length===2&&t.every(e=>yd(e)),w7e=qe({modelValue:{type:Date},range:{type:Se(Array),validator:b7e}}),_7e={[Ot]:t=>yd(t),[jr]:t=>yd(t)},$7e="ElCalendar",x7e=ue({name:$7e}),S7e=ue({...x7e,props:w7e,emits:_7e,setup(t,{expose:e,emit:n}){const s=t,r=Fe("calendar"),{calculateValidatedDateRange:o,date:a,pickDay:i,realSelectedDay:l,selectDate:u,validatedRange:c}=y7e(s,n),{t:d}=nn(),f=A(()=>{const h=`el.datepicker.month${a.value.format("M")}`;return`${a.value.year()} ${d("el.datepicker.year")} ${d(h)}`});return e({selectedDay:l,pickDay:i,selectDate:u,calculateValidatedDateRange:o}),(h,p)=>(S(),E("div",{class:P(v(r).b())},[I("div",{class:P(v(r).e("header"))},[Oe(h.$slots,"header",{date:v(f)},()=>[I("div",{class:P(v(r).e("title"))},Ue(v(f)),3),v(c).length===0?(S(),E("div",{key:0,class:P(v(r).e("button-group"))},[se(v(zL),null,{default:ce(()=>[se(v(br),{size:"small",onClick:p[0]||(p[0]=m=>v(u)("prev-month"))},{default:ce(()=>[Yt(Ue(v(d)("el.datepicker.prevMonth")),1)]),_:1}),se(v(br),{size:"small",onClick:p[1]||(p[1]=m=>v(u)("today"))},{default:ce(()=>[Yt(Ue(v(d)("el.datepicker.today")),1)]),_:1}),se(v(br),{size:"small",onClick:p[2]||(p[2]=m=>v(u)("next-month"))},{default:ce(()=>[Yt(Ue(v(d)("el.datepicker.nextMonth")),1)]),_:1})]),_:1})],2)):ge("v-if",!0)])],2),v(c).length===0?(S(),E("div",{key:0,class:P(v(r).e("body"))},[se(PO,{date:v(a),"selected-day":v(l),onPick:v(i)},Uu({_:2},[h.$slots["date-cell"]||h.$slots.dateCell?{name:"date-cell",fn:ce(m=>[h.$slots["date-cell"]?Oe(h.$slots,"date-cell",Wa(zt({key:0},m))):Oe(h.$slots,"dateCell",Wa(zt({key:1},m)))])}:void 0]),1032,["date","selected-day","onPick"])],2)):(S(),E("div",{key:1,class:P(v(r).e("body"))},[(S(!0),E(lt,null,Gt(v(c),(m,g)=>(S(),$e(PO,{key:g,date:m[0],"selected-day":v(l),range:m,"hide-header":g!==0,onPick:v(i)},Uu({_:2},[h.$slots["date-cell"]||h.$slots.dateCell?{name:"date-cell",fn:ce(y=>[h.$slots["date-cell"]?Oe(h.$slots,"date-cell",Wa(zt({key:0},y))):Oe(h.$slots,"dateCell",Wa(zt({key:1},y)))])}:void 0]),1032,["date","selected-day","range","hide-header","onPick"]))),128))],2))],2))}});var C7e=je(S7e,[["__file","/home/runner/work/element-plus/element-plus/packages/components/calendar/src/calendar.vue"]]);const k7e=Dt(C7e),T7e=qe({header:{type:String,default:""},bodyStyle:{type:Se([String,Object,Array]),default:""},shadow:{type:String,values:["always","hover","never"],default:"always"}}),N7e=ue({name:"ElCard"}),I7e=ue({...N7e,props:T7e,setup(t){const e=Fe("card");return(n,s)=>(S(),E("div",{class:P([v(e).b(),v(e).is(`${n.shadow}-shadow`)])},[n.$slots.header||n.header?(S(),E("div",{key:0,class:P(v(e).e("header"))},[Oe(n.$slots,"header",{},()=>[Yt(Ue(n.header),1)])],2)):ge("v-if",!0),I("div",{class:P(v(e).e("body")),style:ot(n.bodyStyle)},[Oe(n.$slots,"default")],6)],2))}});var E7e=je(I7e,[["__file","/home/runner/work/element-plus/element-plus/packages/components/card/src/card.vue"]]);const A7e=Dt(E7e),O7e=qe({initialIndex:{type:Number,default:0},height:{type:String,default:""},trigger:{type:String,values:["hover","click"],default:"hover"},autoplay:{type:Boolean,default:!0},interval:{type:Number,default:3e3},indicatorPosition:{type:String,values:["","none","outside"],default:""},indicator:{type:Boolean,default:!0},arrow:{type:String,values:["always","hover","never"],default:"hover"},type:{type:String,values:["","card"],default:""},loop:{type:Boolean,default:!0},direction:{type:String,values:["horizontal","vertical"],default:"horizontal"},pauseOnHover:{type:Boolean,default:!0}}),R7e={change:(t,e)=>[t,e].every(Ct)},LO=300,D7e=(t,e,n)=>{const{children:s,addChild:r,removeChild:o}=uL(Rt(),"ElCarouselItem"),a=U(-1),i=U(null),l=U(!1),u=U(),c=A(()=>t.arrow!=="never"&&!v(h)),d=A(()=>s.value.some(V=>V.props.label.toString().length>0)),f=A(()=>t.type==="card"),h=A(()=>t.direction==="vertical"),p=rd(V=>{b(V)},LO,{trailing:!0}),m=rd(V=>{M(V)},LO);function g(){i.value&&(clearInterval(i.value),i.value=null)}function y(){t.interval<=0||!t.autoplay||i.value||(i.value=setInterval(()=>w(),t.interval))}const w=()=>{a.value<s.value.length-1?a.value=a.value+1:t.loop&&(a.value=0)};function b(V){if(wt(V)){const L=s.value.filter(G=>G.props.name===V);L.length>0&&(V=s.value.indexOf(L[0]))}if(V=Number(V),Number.isNaN(V)||V!==Math.floor(V))return;const O=s.value.length,F=a.value;V<0?a.value=t.loop?O-1:0:V>=O?a.value=t.loop?0:O-1:a.value=V,F===a.value&&_(F),z()}function _(V){s.value.forEach((O,F)=>{O.translateItem(F,a.value,V)})}function $(V,O){var F,L,G,Z;const j=v(s),J=j.length;if(J===0||!V.states.inStage)return!1;const fe=O+1,X=O-1,oe=J-1,ee=j[oe].states.active,Q=j[0].states.active,ie=(L=(F=j[fe])==null?void 0:F.states)==null?void 0:L.active,pe=(Z=(G=j[X])==null?void 0:G.states)==null?void 0:Z.active;return O===oe&&Q||ie?"left":O===0&&ee||pe?"right":!1}function x(){l.value=!0,t.pauseOnHover&&g()}function k(){l.value=!1,y()}function C(V){v(h)||s.value.forEach((O,F)=>{V===$(O,F)&&(O.states.hover=!0)})}function T(){v(h)||s.value.forEach(V=>{V.states.hover=!1})}function N(V){a.value=V}function M(V){t.trigger==="hover"&&V!==a.value&&(a.value=V)}function R(){b(a.value-1)}function D(){b(a.value+1)}function z(){g(),y()}Me(()=>a.value,(V,O)=>{_(O),O>-1&&e("change",V,O)}),Me(()=>t.autoplay,V=>{V?y():g()}),Me(()=>t.loop,()=>{b(a.value)}),Me(()=>t.interval,()=>{z()}),Me(()=>s.value,()=>{s.value.length>0&&b(t.initialIndex)});const B=Nn();return It(()=>{B.value=Dr(u.value,()=>{_()}),y()}),ts(()=>{g(),u.value&&B.value&&B.value.stop()}),Lt(PP,{root:u,isCardType:f,isVertical:h,items:s,loop:t.loop,addItem:r,removeItem:o,setActiveItem:b}),{root:u,activeIndex:a,arrowDisplay:c,hasLabel:d,hover:l,isCardType:f,items:s,handleButtonEnter:C,handleButtonLeave:T,handleIndicatorClick:N,handleMouseEnter:x,handleMouseLeave:k,setActiveItem:b,prev:R,next:D,throttledArrowClick:p,throttledIndicatorHover:m}},F7e=["onMouseenter","onClick"],M7e={key:0},P7e="ElCarousel",L7e=ue({name:P7e}),z7e=ue({...L7e,props:O7e,emits:R7e,setup(t,{expose:e,emit:n}){const s=t,{root:r,activeIndex:o,arrowDisplay:a,hasLabel:i,hover:l,isCardType:u,items:c,handleButtonEnter:d,handleButtonLeave:f,handleIndicatorClick:h,handleMouseEnter:p,handleMouseLeave:m,setActiveItem:g,prev:y,next:w,throttledArrowClick:b,throttledIndicatorHover:_}=D7e(s,n),$=Fe("carousel"),x=A(()=>{const C=[$.b(),$.m(s.direction)];return v(u)&&C.push($.m("card")),C}),k=A(()=>{const C=[$.e("indicators"),$.em("indicators",s.direction)];return v(i)&&C.push($.em("indicators","labels")),(s.indicatorPosition==="outside"||v(u))&&C.push($.em("indicators","outside")),C});return e({setActiveItem:g,prev:y,next:w}),(C,T)=>(S(),E("div",{ref_key:"root",ref:r,class:P(v(x)),onMouseenter:T[6]||(T[6]=yt((...N)=>v(p)&&v(p)(...N),["stop"])),onMouseleave:T[7]||(T[7]=yt((...N)=>v(m)&&v(m)(...N),["stop"]))},[I("div",{class:P(v($).e("container")),style:ot({height:C.height})},[v(a)?(S(),$e(ms,{key:0,name:"carousel-arrow-left",persisted:""},{default:ce(()=>[St(I("button",{type:"button",class:P([v($).e("arrow"),v($).em("arrow","left")]),onMouseenter:T[0]||(T[0]=N=>v(d)("left")),onMouseleave:T[1]||(T[1]=(...N)=>v(f)&&v(f)(...N)),onClick:T[2]||(T[2]=yt(N=>v(b)(v(o)-1),["stop"]))},[se(v(rt),null,{default:ce(()=>[se(v(xl))]),_:1})],34),[[Qt,(C.arrow==="always"||v(l))&&(s.loop||v(o)>0)]])]),_:1})):ge("v-if",!0),v(a)?(S(),$e(ms,{key:1,name:"carousel-arrow-right",persisted:""},{default:ce(()=>[St(I("button",{type:"button",class:P([v($).e("arrow"),v($).em("arrow","right")]),onMouseenter:T[3]||(T[3]=N=>v(d)("right")),onMouseleave:T[4]||(T[4]=(...N)=>v(f)&&v(f)(...N)),onClick:T[5]||(T[5]=yt(N=>v(b)(v(o)+1),["stop"]))},[se(v(rt),null,{default:ce(()=>[se(v(Rr))]),_:1})],34),[[Qt,(C.arrow==="always"||v(l))&&(s.loop||v(o)<v(c).length-1)]])]),_:1})):ge("v-if",!0),Oe(C.$slots,"default")],6),C.indicatorPosition!=="none"?(S(),E("ul",{key:0,class:P(v(k))},[(S(!0),E(lt,null,Gt(v(c),(N,M)=>(S(),E("li",{key:M,class:P([v($).e("indicator"),v($).em("indicator",C.direction),v($).is("active",M===v(o))]),onMouseenter:R=>v(_)(M),onClick:yt(R=>v(h)(M),["stop"])},[I("button",{class:P(v($).e("button"))},[v(i)?(S(),E("span",M7e,Ue(N.props.label),1)):ge("v-if",!0)],2)],42,F7e))),128))],2)):ge("v-if",!0)],34))}});var B7e=je(z7e,[["__file","/home/runner/work/element-plus/element-plus/packages/components/carousel/src/carousel.vue"]]);const V7e=qe({name:{type:String,default:""},label:{type:[String,Number],default:""}}),H7e=(t,e)=>{const n=et(PP),s=Rt(),r=.83,o=U(!1),a=U(0),i=U(1),l=U(!1),u=U(!1),c=U(!1),d=U(!1),{isCardType:f,isVertical:h}=n;function p(b,_,$){const x=$-1,k=_-1,C=_+1,T=$/2;return _===0&&b===x?-1:_===x&&b===0?$:b<k&&_-b>=T?$+1:b>C&&b-_>=T?-2:b}function m(b,_){var $;const x=(($=n.root.value)==null?void 0:$.offsetWidth)||0;return c.value?x*((2-r)*(b-_)+1)/4:b<_?-(1+r)*x/4:(3+r)*x/4}function g(b,_,$){const x=n.root.value;return x?(($?x.offsetHeight:x.offsetWidth)||0)*(b-_):0}const y=(b,_,$)=>{var x;const k=v(f),C=(x=n.items.value.length)!=null?x:Number.NaN,T=b===_;!k&&!er($)&&(d.value=T||b===$),!T&&C>2&&n.loop&&(b=p(b,_,C));const N=v(h);l.value=T,k?(c.value=Math.round(Math.abs(b-_))<=1,a.value=m(b,_),i.value=v(l)?1:r):a.value=g(b,_,N),u.value=!0};function w(){if(n&&v(f)){const b=n.items.value.findIndex(({uid:_})=>_===s.uid);n.setActiveItem(b)}}return It(()=>{n.addItem({props:t,states:on({hover:o,translate:a,scale:i,active:l,ready:u,inStage:c,animating:d}),uid:s.uid,translateItem:y})}),Xd(()=>{n.removeItem(s.uid)}),{active:l,animating:d,hover:o,inStage:c,isVertical:h,translate:a,isCardType:f,scale:i,ready:u,handleItemClick:w}},W7e=ue({name:"ElCarouselItem"}),U7e=ue({...W7e,props:V7e,setup(t){const e=t,n=Fe("carousel"),{active:s,animating:r,hover:o,inStage:a,isVertical:i,translate:l,isCardType:u,scale:c,ready:d,handleItemClick:f}=H7e(e),h=A(()=>{const m=`${`translate${v(i)?"Y":"X"}`}(${v(l)}px)`,g=`scale(${v(c)})`;return{transform:[m,g].join(" ")}});return(p,m)=>St((S(),E("div",{class:P([v(n).e("item"),v(n).is("active",v(s)),v(n).is("in-stage",v(a)),v(n).is("hover",v(o)),v(n).is("animating",v(r)),{[v(n).em("item","card")]:v(u)}]),style:ot(v(h)),onClick:m[0]||(m[0]=(...g)=>v(f)&&v(f)(...g))},[v(u)?St((S(),E("div",{key:0,class:P(v(n).e("mask"))},null,2)),[[Qt,!v(s)]]):ge("v-if",!0),Oe(p.$slots,"default")],6)),[[Qt,v(d)]])}});var az=je(U7e,[["__file","/home/runner/work/element-plus/element-plus/packages/components/carousel/src/carousel-item.vue"]]);const G7e=Dt(B7e,{CarouselItem:az}),j7e=ns(az),iz={modelValue:{type:[Number,String,Boolean],default:void 0},label:{type:[String,Boolean,Number,Object]},indeterminate:Boolean,disabled:Boolean,checked:Boolean,name:{type:String,default:void 0},trueLabel:{type:[String,Number],default:void 0},falseLabel:{type:[String,Number],default:void 0},id:{type:String,default:void 0},controls:{type:String,default:void 0},border:Boolean,size:wo,tabindex:[String,Number],validateEvent:{type:Boolean,default:!0}},lz={[Ot]:t=>wt(t)||Ct(t)||Rs(t),change:t=>wt(t)||Ct(t)||Rs(t)},K7e=({model:t,isChecked:e})=>{const n=et(ep,void 0),s=A(()=>{var o,a;const i=(o=n==null?void 0:n.max)==null?void 0:o.value,l=(a=n==null?void 0:n.min)==null?void 0:a.value;return!er(i)&&t.value.length>=i&&!e.value||!er(l)&&t.value.length<=l&&e.value});return{isDisabled:To(A(()=>(n==null?void 0:n.disabled.value)||s.value)),isLimitDisabled:s}},q7e=(t,{model:e,isLimitExceeded:n,hasOwnLabel:s,isDisabled:r,isLabeledByFormItem:o})=>{const a=et(ep,void 0),{formItem:i}=to(),{emit:l}=Rt();function u(p){var m,g;return p===t.trueLabel||p===!0?(m=t.trueLabel)!=null?m:!0:(g=t.falseLabel)!=null?g:!1}function c(p,m){l("change",u(p),m)}function d(p){if(n.value)return;const m=p.target;l("change",u(m.checked),p)}async function f(p){n.value||!s.value&&!r.value&&o.value&&(p.composedPath().some(y=>y.tagName==="LABEL")||(e.value=u([!1,t.falseLabel].includes(e.value)),await nt(),c(e.value,p)))}const h=A(()=>(a==null?void 0:a.validateEvent)||t.validateEvent);return Me(()=>t.modelValue,()=>{h.value&&(i==null||i.validate("change").catch(p=>void 0))}),{handleChange:d,onClickRoot:f}},X7e=t=>{const e=U(!1),{emit:n}=Rt(),s=et(ep,void 0),r=A(()=>er(s)===!1),o=U(!1);return{model:A({get(){var i,l;return r.value?(i=s==null?void 0:s.modelValue)==null?void 0:i.value:(l=t.modelValue)!=null?l:e.value},set(i){var l,u;r.value&&Qe(i)?(o.value=((l=s==null?void 0:s.max)==null?void 0:l.value)!==void 0&&i.length>(s==null?void 0:s.max.value),o.value===!1&&((u=s==null?void 0:s.changeEvent)==null||u.call(s,i))):(n(Ot,i),e.value=i)}}),isGroup:r,isLimitExceeded:o}},Y7e=(t,e,{model:n})=>{const s=et(ep,void 0),r=U(!1),o=A(()=>{const u=n.value;return Rs(u)?u:Qe(u)?Bt(t.label)?u.map(fn).some(c=>Wo(c,t.label)):u.map(fn).includes(t.label):u!=null?u===t.trueLabel:!!u}),a=ks(A(()=>{var u;return(u=s==null?void 0:s.size)==null?void 0:u.value}),{prop:!0}),i=ks(A(()=>{var u;return(u=s==null?void 0:s.size)==null?void 0:u.value})),l=A(()=>!!(e.default||t.label));return{checkboxButtonSize:a,isChecked:o,isFocused:r,checkboxSize:i,hasOwnLabel:l}},Z7e=(t,{model:e})=>{function n(){Qe(e.value)&&!e.value.includes(t.label)?e.value.push(t.label):e.value=t.trueLabel||!0}t.checked&&n()},uz=(t,e)=>{const{formItem:n}=to(),{model:s,isGroup:r,isLimitExceeded:o}=X7e(t),{isFocused:a,isChecked:i,checkboxButtonSize:l,checkboxSize:u,hasOwnLabel:c}=Y7e(t,e,{model:s}),{isDisabled:d}=K7e({model:s,isChecked:i}),{inputId:f,isLabeledByFormItem:h}=ic(t,{formItemContext:n,disableIdGeneration:c,disableIdManagement:r}),{handleChange:p,onClickRoot:m}=q7e(t,{model:s,isLimitExceeded:o,hasOwnLabel:c,isDisabled:d,isLabeledByFormItem:h});return Z7e(t,{model:s}),{inputId:f,isLabeledByFormItem:h,isChecked:i,isDisabled:d,isFocused:a,checkboxButtonSize:l,checkboxSize:u,hasOwnLabel:c,model:s,handleChange:p,onClickRoot:m}},J7e=["tabindex","role","aria-checked"],Q7e=["id","aria-hidden","name","tabindex","disabled","true-value","false-value"],eBe=["id","aria-hidden","disabled","value","name","tabindex"],tBe=ue({name:"ElCheckbox"}),nBe=ue({...tBe,props:iz,emits:lz,setup(t){const e=t,n=ir(),{inputId:s,isLabeledByFormItem:r,isChecked:o,isDisabled:a,isFocused:i,checkboxSize:l,hasOwnLabel:u,model:c,handleChange:d,onClickRoot:f}=uz(e,n),h=Fe("checkbox");return(p,m)=>(S(),$e(Vt(!v(u)&&v(r)?"span":"label"),{class:P([v(h).b(),v(h).m(v(l)),v(h).is("disabled",v(a)),v(h).is("bordered",p.border),v(h).is("checked",v(o))]),"aria-controls":p.indeterminate?p.controls:null,onClick:v(f)},{default:ce(()=>[I("span",{class:P([v(h).e("input"),v(h).is("disabled",v(a)),v(h).is("checked",v(o)),v(h).is("indeterminate",p.indeterminate),v(h).is("focus",v(i))]),tabindex:p.indeterminate?0:void 0,role:p.indeterminate?"checkbox":void 0,"aria-checked":p.indeterminate?"mixed":void 0},[p.trueLabel||p.falseLabel?St((S(),E("input",{key:0,id:v(s),"onUpdate:modelValue":m[0]||(m[0]=g=>kn(c)?c.value=g:null),class:P(v(h).e("original")),type:"checkbox","aria-hidden":p.indeterminate?"true":"false",name:p.name,tabindex:p.tabindex,disabled:v(a),"true-value":p.trueLabel,"false-value":p.falseLabel,onChange:m[1]||(m[1]=(...g)=>v(d)&&v(d)(...g)),onFocus:m[2]||(m[2]=g=>i.value=!0),onBlur:m[3]||(m[3]=g=>i.value=!1)},null,42,Q7e)),[[Sy,v(c)]]):St((S(),E("input",{key:1,id:v(s),"onUpdate:modelValue":m[4]||(m[4]=g=>kn(c)?c.value=g:null),class:P(v(h).e("original")),type:"checkbox","aria-hidden":p.indeterminate?"true":"false",disabled:v(a),value:p.label,name:p.name,tabindex:p.tabindex,onChange:m[5]||(m[5]=(...g)=>v(d)&&v(d)(...g)),onFocus:m[6]||(m[6]=g=>i.value=!0),onBlur:m[7]||(m[7]=g=>i.value=!1)},null,42,eBe)),[[Sy,v(c)]]),I("span",{class:P(v(h).e("inner"))},null,2)],10,J7e),v(u)?(S(),E("span",{key:0,class:P(v(h).e("label"))},[Oe(p.$slots,"default"),p.$slots.default?ge("v-if",!0):(S(),E(lt,{key:0},[Yt(Ue(p.label),1)],64))],2)):ge("v-if",!0)]),_:3},8,["class","aria-controls","onClick"]))}});var sBe=je(nBe,[["__file","/home/runner/work/element-plus/element-plus/packages/components/checkbox/src/checkbox.vue"]]);const rBe=["name","tabindex","disabled","true-value","false-value"],oBe=["name","tabindex","disabled","value"],aBe=ue({name:"ElCheckboxButton"}),iBe=ue({...aBe,props:iz,emits:lz,setup(t){const e=t,n=ir(),{isFocused:s,isChecked:r,isDisabled:o,checkboxButtonSize:a,model:i,handleChange:l}=uz(e,n),u=et(ep,void 0),c=Fe("checkbox"),d=A(()=>{var f,h,p,m;const g=(h=(f=u==null?void 0:u.fill)==null?void 0:f.value)!=null?h:"";return{backgroundColor:g,borderColor:g,color:(m=(p=u==null?void 0:u.textColor)==null?void 0:p.value)!=null?m:"",boxShadow:g?`-1px 0 0 0 ${g}`:void 0}});return(f,h)=>(S(),E("label",{class:P([v(c).b("button"),v(c).bm("button",v(a)),v(c).is("disabled",v(o)),v(c).is("checked",v(r)),v(c).is("focus",v(s))])},[f.trueLabel||f.falseLabel?St((S(),E("input",{key:0,"onUpdate:modelValue":h[0]||(h[0]=p=>kn(i)?i.value=p:null),class:P(v(c).be("button","original")),type:"checkbox",name:f.name,tabindex:f.tabindex,disabled:v(o),"true-value":f.trueLabel,"false-value":f.falseLabel,onChange:h[1]||(h[1]=(...p)=>v(l)&&v(l)(...p)),onFocus:h[2]||(h[2]=p=>s.value=!0),onBlur:h[3]||(h[3]=p=>s.value=!1)},null,42,rBe)),[[Sy,v(i)]]):St((S(),E("input",{key:1,"onUpdate:modelValue":h[4]||(h[4]=p=>kn(i)?i.value=p:null),class:P(v(c).be("button","original")),type:"checkbox",name:f.name,tabindex:f.tabindex,disabled:v(o),value:f.label,onChange:h[5]||(h[5]=(...p)=>v(l)&&v(l)(...p)),onFocus:h[6]||(h[6]=p=>s.value=!0),onBlur:h[7]||(h[7]=p=>s.value=!1)},null,42,oBe)),[[Sy,v(i)]]),f.$slots.default||f.label?(S(),E("span",{key:2,class:P(v(c).be("button","inner")),style:ot(v(r)?v(d):void 0)},[Oe(f.$slots,"default",{},()=>[Yt(Ue(f.label),1)])],6)):ge("v-if",!0)],2))}});var cz=je(iBe,[["__file","/home/runner/work/element-plus/element-plus/packages/components/checkbox/src/checkbox-button.vue"]]);const lBe=qe({modelValue:{type:Se(Array),default:()=>[]},disabled:Boolean,min:Number,max:Number,size:wo,label:String,fill:String,textColor:String,tag:{type:String,default:"div"},validateEvent:{type:Boolean,default:!0}}),uBe={[Ot]:t=>Qe(t),change:t=>Qe(t)},cBe=ue({name:"ElCheckboxGroup"}),dBe=ue({...cBe,props:lBe,emits:uBe,setup(t,{emit:e}){const n=t,s=Fe("checkbox"),{formItem:r}=to(),{inputId:o,isLabeledByFormItem:a}=ic(n,{formItemContext:r}),i=async u=>{e(Ot,u),await nt(),e("change",u)},l=A({get(){return n.modelValue},set(u){i(u)}});return Lt(ep,{...gl(Ps(n),["size","min","max","disabled","validateEvent","fill","textColor"]),modelValue:l,changeEvent:i}),Me(()=>n.modelValue,()=>{n.validateEvent&&(r==null||r.validate("change").catch(u=>void 0))}),(u,c)=>{var d;return S(),$e(Vt(u.tag),{id:v(o),class:P(v(s).b("group")),role:"group","aria-label":v(a)?void 0:u.label||"checkbox-group","aria-labelledby":v(a)?(d=v(r))==null?void 0:d.labelId:void 0},{default:ce(()=>[Oe(u.$slots,"default")]),_:3},8,["id","class","aria-label","aria-labelledby"])}}});var dz=je(dBe,[["__file","/home/runner/work/element-plus/element-plus/packages/components/checkbox/src/checkbox-group.vue"]]);const ka=Dt(sBe,{CheckboxButton:cz,CheckboxGroup:dz}),fBe=ns(cz),fz=ns(dz),hz=qe({size:wo,disabled:Boolean,label:{type:[String,Number,Boolean],default:""}}),hBe=qe({...hz,modelValue:{type:[String,Number,Boolean],default:""},name:{type:String,default:""},border:Boolean}),pz={[Ot]:t=>wt(t)||Ct(t)||Rs(t),[Fn]:t=>wt(t)||Ct(t)||Rs(t)},mz=(t,e)=>{const n=U(),s=et(HP,void 0),r=A(()=>!!s),o=A({get(){return r.value?s.modelValue:t.modelValue},set(c){r.value?s.changeEvent(c):e&&e(Ot,c),n.value.checked=t.modelValue===t.label}}),a=ks(A(()=>s==null?void 0:s.size)),i=To(A(()=>s==null?void 0:s.disabled)),l=U(!1),u=A(()=>i.value||r.value&&o.value!==t.label?-1:0);return{radioRef:n,isGroup:r,radioGroup:s,focus:l,size:a,disabled:i,tabIndex:u,modelValue:o}},pBe=["value","name","disabled"],mBe=ue({name:"ElRadio"}),gBe=ue({...mBe,props:hBe,emits:pz,setup(t,{emit:e}){const n=t,s=Fe("radio"),{radioRef:r,radioGroup:o,focus:a,size:i,disabled:l,modelValue:u}=mz(n,e);function c(){nt(()=>e("change",u.value))}return(d,f)=>{var h;return S(),E("label",{class:P([v(s).b(),v(s).is("disabled",v(l)),v(s).is("focus",v(a)),v(s).is("bordered",d.border),v(s).is("checked",v(u)===d.label),v(s).m(v(i))])},[I("span",{class:P([v(s).e("input"),v(s).is("disabled",v(l)),v(s).is("checked",v(u)===d.label)])},[St(I("input",{ref_key:"radioRef",ref:r,"onUpdate:modelValue":f[0]||(f[0]=p=>kn(u)?u.value=p:null),class:P(v(s).e("original")),value:d.label,name:d.name||((h=v(o))==null?void 0:h.name),disabled:v(l),type:"radio",onFocus:f[1]||(f[1]=p=>a.value=!0),onBlur:f[2]||(f[2]=p=>a.value=!1),onChange:c},null,42,pBe),[[lM,v(u)]]),I("span",{class:P(v(s).e("inner"))},null,2)],2),I("span",{class:P(v(s).e("label")),onKeydown:f[3]||(f[3]=yt(()=>{},["stop"]))},[Oe(d.$slots,"default",{},()=>[Yt(Ue(d.label),1)])],34)],2)}}});var vBe=je(gBe,[["__file","/home/runner/work/element-plus/element-plus/packages/components/radio/src/radio.vue"]]);const yBe=qe({...hz,name:{type:String,default:""}}),bBe=["value","name","disabled"],wBe=ue({name:"ElRadioButton"}),_Be=ue({...wBe,props:yBe,setup(t){const e=t,n=Fe("radio"),{radioRef:s,focus:r,size:o,disabled:a,modelValue:i,radioGroup:l}=mz(e),u=A(()=>({backgroundColor:(l==null?void 0:l.fill)||"",borderColor:(l==null?void 0:l.fill)||"",boxShadow:l!=null&&l.fill?`-1px 0 0 0 ${l.fill}`:"",color:(l==null?void 0:l.textColor)||""}));return(c,d)=>{var f;return S(),E("label",{class:P([v(n).b("button"),v(n).is("active",v(i)===c.label),v(n).is("disabled",v(a)),v(n).is("focus",v(r)),v(n).bm("button",v(o))])},[St(I("input",{ref_key:"radioRef",ref:s,"onUpdate:modelValue":d[0]||(d[0]=h=>kn(i)?i.value=h:null),class:P(v(n).be("button","original-radio")),value:c.label,type:"radio",name:c.name||((f=v(l))==null?void 0:f.name),disabled:v(a),onFocus:d[1]||(d[1]=h=>r.value=!0),onBlur:d[2]||(d[2]=h=>r.value=!1)},null,42,bBe),[[lM,v(i)]]),I("span",{class:P(v(n).be("button","inner")),style:ot(v(i)===c.label?v(u):{}),onKeydown:d[3]||(d[3]=yt(()=>{},["stop"]))},[Oe(c.$slots,"default",{},()=>[Yt(Ue(c.label),1)])],38)],2)}}});var gz=je(_Be,[["__file","/home/runner/work/element-plus/element-plus/packages/components/radio/src/radio-button.vue"]]);const $Be=qe({id:{type:String,default:void 0},size:wo,disabled:Boolean,modelValue:{type:[String,Number,Boolean],default:""},fill:{type:String,default:""},label:{type:String,default:void 0},textColor:{type:String,default:""},name:{type:String,default:void 0},validateEvent:{type:Boolean,default:!0}}),xBe=pz,SBe=["id","aria-label","aria-labelledby"],CBe=ue({name:"ElRadioGroup"}),kBe=ue({...CBe,props:$Be,emits:xBe,setup(t,{emit:e}){const n=t,s=Fe("radio"),r=ei(),o=U(),{formItem:a}=to(),{inputId:i,isLabeledByFormItem:l}=ic(n,{formItemContext:a}),u=d=>{e(Ot,d),nt(()=>e("change",d))};It(()=>{const d=o.value.querySelectorAll("[type=radio]"),f=d[0];!Array.from(d).some(h=>h.checked)&&f&&(f.tabIndex=0)});const c=A(()=>n.name||r.value);return Lt(HP,on({...Ps(n),changeEvent:u,name:c})),Me(()=>n.modelValue,()=>{n.validateEvent&&(a==null||a.validate("change").catch(d=>void 0))}),(d,f)=>(S(),E("div",{id:v(i),ref_key:"radioGroupRef",ref:o,class:P(v(s).b("group")),role:"radiogroup","aria-label":v(l)?void 0:d.label||"radio-group","aria-labelledby":v(l)?v(a).labelId:void 0},[Oe(d.$slots,"default")],10,SBe))}});var vz=je(kBe,[["__file","/home/runner/work/element-plus/element-plus/packages/components/radio/src/radio-group.vue"]]);const yz=Dt(vBe,{RadioButton:gz,RadioGroup:vz}),TBe=ns(vz),NBe=ns(gz);var IBe=ue({name:"NodeContent",setup(){return{ns:Fe("cascader-node")}},render(){const{ns:t}=this,{node:e,panel:n}=this.$parent,{data:s,label:r}=e,{renderLabelFn:o}=n;return it("span",{class:t.e("label")},o?o({node:e,data:s}):r)}});const ik=Symbol(),EBe=ue({name:"ElCascaderNode",components:{ElCheckbox:ka,ElRadio:yz,NodeContent:IBe,ElIcon:rt,Check:Jh,Loading:Vl,ArrowRight:Rr},props:{node:{type:Object,required:!0},menuId:String},emits:["expand"],setup(t,{emit:e}){const n=et(ik),s=Fe("cascader-node"),r=A(()=>n.isHoverMenu),o=A(()=>n.config.multiple),a=A(()=>n.config.checkStrictly),i=A(()=>{var x;return(x=n.checkedNodes[0])==null?void 0:x.uid}),l=A(()=>t.node.isDisabled),u=A(()=>t.node.isLeaf),c=A(()=>a.value&&!u.value||!l.value),d=A(()=>h(n.expandingNode)),f=A(()=>a.value&&n.checkedNodes.some(h)),h=x=>{var k;const{level:C,uid:T}=t.node;return((k=x==null?void 0:x.pathNodes[C-1])==null?void 0:k.uid)===T},p=()=>{d.value||n.expandNode(t.node)},m=x=>{const{node:k}=t;x!==k.checked&&n.handleCheckChange(k,x)},g=()=>{n.lazyLoad(t.node,()=>{u.value||p()})},y=x=>{!r.value||(w(),!u.value&&e("expand",x))},w=()=>{const{node:x}=t;!c.value||x.loading||(x.loaded?p():g())},b=()=>{r.value&&!u.value||(u.value&&!l.value&&!a.value&&!o.value?$(!0):w())},_=x=>{a.value?(m(x),t.node.loaded&&p()):$(x)},$=x=>{t.node.loaded?(m(x),!a.value&&p()):g()};return{panel:n,isHoverMenu:r,multiple:o,checkStrictly:a,checkedNodeId:i,isDisabled:l,isLeaf:u,expandable:c,inExpandingPath:d,inCheckedPath:f,ns:s,handleHoverExpand:y,handleExpand:w,handleClick:b,handleCheck:$,handleSelectCheck:_}}}),ABe=["id","aria-haspopup","aria-owns","aria-expanded","tabindex"],OBe=I("span",null,null,-1);function RBe(t,e,n,s,r,o){const a=pt("el-checkbox"),i=pt("el-radio"),l=pt("check"),u=pt("el-icon"),c=pt("node-content"),d=pt("loading"),f=pt("arrow-right");return S(),E("li",{id:`${t.menuId}-${t.node.uid}`,role:"menuitem","aria-haspopup":!t.isLeaf,"aria-owns":t.isLeaf?null:t.menuId,"aria-expanded":t.inExpandingPath,tabindex:t.expandable?-1:void 0,class:P([t.ns.b(),t.ns.is("selectable",t.checkStrictly),t.ns.is("active",t.node.checked),t.ns.is("disabled",!t.expandable),t.inExpandingPath&&"in-active-path",t.inCheckedPath&&"in-checked-path"]),onMouseenter:e[2]||(e[2]=(...h)=>t.handleHoverExpand&&t.handleHoverExpand(...h)),onFocus:e[3]||(e[3]=(...h)=>t.handleHoverExpand&&t.handleHoverExpand(...h)),onClick:e[4]||(e[4]=(...h)=>t.handleClick&&t.handleClick(...h))},[ge(" prefix "),t.multiple?(S(),$e(a,{key:0,"model-value":t.node.checked,indeterminate:t.node.indeterminate,disabled:t.isDisabled,onClick:e[0]||(e[0]=yt(()=>{},["stop"])),"onUpdate:modelValue":t.handleSelectCheck},null,8,["model-value","indeterminate","disabled","onUpdate:modelValue"])):t.checkStrictly?(S(),$e(i,{key:1,"model-value":t.checkedNodeId,label:t.node.uid,disabled:t.isDisabled,"onUpdate:modelValue":t.handleSelectCheck,onClick:e[1]||(e[1]=yt(()=>{},["stop"]))},{default:ce(()=>[ge(`
        Add an empty element to avoid render label,
        do not use empty fragment here for https://github.com/vuejs/vue-next/pull/2485
      `),OBe]),_:1},8,["model-value","label","disabled","onUpdate:modelValue"])):t.isLeaf&&t.node.checked?(S(),$e(u,{key:2,class:P(t.ns.e("prefix"))},{default:ce(()=>[se(l)]),_:1},8,["class"])):ge("v-if",!0),ge(" content "),se(c),ge(" postfix "),t.isLeaf?ge("v-if",!0):(S(),E(lt,{key:3},[t.node.loading?(S(),$e(u,{key:0,class:P([t.ns.is("loading"),t.ns.e("postfix")])},{default:ce(()=>[se(d)]),_:1},8,["class"])):(S(),$e(u,{key:1,class:P(["arrow-right",t.ns.e("postfix")])},{default:ce(()=>[se(f)]),_:1},8,["class"]))],64))],42,ABe)}var DBe=je(EBe,[["render",RBe],["__file","/home/runner/work/element-plus/element-plus/packages/components/cascader-panel/src/node.vue"]]);const FBe=ue({name:"ElCascaderMenu",components:{Loading:Vl,ElIcon:rt,ElScrollbar:jl,ElCascaderNode:DBe},props:{nodes:{type:Array,required:!0},index:{type:Number,required:!0}},setup(t){const e=Rt(),n=Fe("cascader-menu"),{t:s}=nn(),r=hw();let o=null,a=null;const i=et(ik),l=U(null),u=A(()=>!t.nodes.length),c=A(()=>!i.initialLoaded),d=A(()=>`cascader-menu-${r}-${t.index}`),f=g=>{o=g.target},h=g=>{if(!(!i.isHoverMenu||!o||!l.value))if(o.contains(g.target)){p();const y=e.vnode.el,{left:w}=y.getBoundingClientRect(),{offsetWidth:b,offsetHeight:_}=y,$=g.clientX-w,x=o.offsetTop,k=x+o.offsetHeight;l.value.innerHTML=`
          <path style="pointer-events: auto;" fill="transparent" d="M${$} ${x} L${b} 0 V${x} Z" />
          <path style="pointer-events: auto;" fill="transparent" d="M${$} ${k} L${b} ${_} V${k} Z" />
        `}else a||(a=window.setTimeout(m,i.config.hoverThreshold))},p=()=>{!a||(clearTimeout(a),a=null)},m=()=>{!l.value||(l.value.innerHTML="",p())};return{ns:n,panel:i,hoverZone:l,isEmpty:u,isLoading:c,menuId:d,t:s,handleExpand:f,handleMouseMove:h,clearHoverZone:m}}});function MBe(t,e,n,s,r,o){const a=pt("el-cascader-node"),i=pt("loading"),l=pt("el-icon"),u=pt("el-scrollbar");return S(),$e(u,{key:t.menuId,tag:"ul",role:"menu",class:P(t.ns.b()),"wrap-class":t.ns.e("wrap"),"view-class":[t.ns.e("list"),t.ns.is("empty",t.isEmpty)],onMousemove:t.handleMouseMove,onMouseleave:t.clearHoverZone},{default:ce(()=>{var c;return[(S(!0),E(lt,null,Gt(t.nodes,d=>(S(),$e(a,{key:d.uid,node:d,"menu-id":t.menuId,onExpand:t.handleExpand},null,8,["node","menu-id","onExpand"]))),128)),t.isLoading?(S(),E("div",{key:0,class:P(t.ns.e("empty-text"))},[se(l,{size:"14",class:P(t.ns.is("loading"))},{default:ce(()=>[se(i)]),_:1},8,["class"]),Yt(" "+Ue(t.t("el.cascader.loading")),1)],2)):t.isEmpty?(S(),E("div",{key:1,class:P(t.ns.e("empty-text"))},Ue(t.t("el.cascader.noData")),3)):(c=t.panel)!=null&&c.isHoverMenu?(S(),E("svg",{key:2,ref:"hoverZone",class:P(t.ns.e("hover-zone"))},null,2)):ge("v-if",!0)]}),_:1},8,["class","wrap-class","view-class","onMousemove","onMouseleave"])}var PBe=je(FBe,[["render",MBe],["__file","/home/runner/work/element-plus/element-plus/packages/components/cascader-panel/src/menu.vue"]]);let LBe=0;const zBe=t=>{const e=[t];let{parent:n}=t;for(;n;)e.unshift(n),n=n.parent;return e};let z0=class{constructor(e,n,s,r=!1){this.data=e,this.config=n,this.parent=s,this.root=r,this.uid=LBe++,this.checked=!1,this.indeterminate=!1,this.loading=!1;const{value:o,label:a,children:i}=n,l=e[i],u=zBe(this);this.level=r?0:s?s.level+1:1,this.value=e[o],this.label=e[a],this.pathNodes=u,this.pathValues=u.map(c=>c.value),this.pathLabels=u.map(c=>c.label),this.childrenData=l,this.children=(l||[]).map(c=>new z0(c,n,this)),this.loaded=!n.lazy||this.isLeaf||!ia(l)}get isDisabled(){const{data:e,parent:n,config:s}=this,{disabled:r,checkStrictly:o}=s;return(vt(r)?r(e,this):!!e[r])||!o&&(n==null?void 0:n.isDisabled)}get isLeaf(){const{data:e,config:n,childrenData:s,loaded:r}=this,{lazy:o,leaf:a}=n,i=vt(a)?a(e,this):e[a];return er(i)?o&&!r?!1:!(Array.isArray(s)&&s.length):!!i}get valueByOption(){return this.config.emitPath?this.pathValues:this.value}appendChild(e){const{childrenData:n,children:s}=this,r=new z0(e,this.config,this);return Array.isArray(n)?n.push(e):this.childrenData=[e],s.push(r),r}calcText(e,n){const s=e?this.pathLabels.join(n):this.label;return this.text=s,s}broadcast(e,...n){const s=`onParent${la(e)}`;this.children.forEach(r=>{r&&(r.broadcast(e,...n),r[s]&&r[s](...n))})}emit(e,...n){const{parent:s}=this,r=`onChild${la(e)}`;s&&(s[r]&&s[r](...n),s.emit(e,...n))}onParentCheck(e){this.isDisabled||this.setCheckState(e)}onChildCheck(){const{children:e}=this,n=e.filter(r=>!r.isDisabled),s=n.length?n.every(r=>r.checked):!1;this.setCheckState(s)}setCheckState(e){const n=this.children.length,s=this.children.reduce((r,o)=>{const a=o.checked?1:o.indeterminate?.5:0;return r+a},0);this.checked=this.loaded&&this.children.filter(r=>!r.isDisabled).every(r=>r.loaded&&r.checked)&&e,this.indeterminate=this.loaded&&s!==n&&s>0}doCheck(e){if(this.checked===e)return;const{checkStrictly:n,multiple:s}=this.config;n||!s?this.checked=e:(this.broadcast("check",e),this.setCheckState(e),this.emit("check"))}};const I6=(t,e)=>t.reduce((n,s)=>(s.isLeaf?n.push(s):(!e&&n.push(s),n=n.concat(I6(s.children,e))),n),[]);class zO{constructor(e,n){this.config=n;const s=(e||[]).map(r=>new z0(r,this.config));this.nodes=s,this.allNodes=I6(s,!1),this.leafNodes=I6(s,!0)}getNodes(){return this.nodes}getFlattedNodes(e){return e?this.leafNodes:this.allNodes}appendNode(e,n){const s=n?n.appendChild(e):new z0(e,this.config);n||this.nodes.push(s),this.allNodes.push(s),s.isLeaf&&this.leafNodes.push(s)}appendNodes(e,n){e.forEach(s=>this.appendNode(s,n))}getNodeByValue(e,n=!1){return!e&&e!==0?null:this.getFlattedNodes(n).find(r=>Wo(r.value,e)||Wo(r.pathValues,e))||null}getSameNode(e){return e&&this.getFlattedNodes(!1).find(({value:s,level:r})=>Wo(e.value,s)&&e.level===r)||null}}const bz={modelValue:[Number,String,Array],options:{type:Array,default:()=>[]},props:{type:Object,default:()=>({})}},BBe={expandTrigger:"click",multiple:!1,checkStrictly:!1,emitPath:!0,lazy:!1,lazyLoad:gn,value:"value",label:"label",children:"children",leaf:"leaf",disabled:"disabled",hoverThreshold:500},VBe=t=>A(()=>({...BBe,...t.props})),BO=t=>{if(!t)return 0;const e=t.id.split("-");return Number(e[e.length-2])},HBe=t=>{if(!t)return;const e=t.querySelector("input");e?e.click():nP(t)&&t.click()},WBe=(t,e)=>{const n=e.slice(0),s=n.map(o=>o.uid),r=t.reduce((o,a)=>{const i=s.indexOf(a.uid);return i>-1&&(o.push(a),n.splice(i,1),s.splice(i,1)),o},[]);return r.push(...n),r},UBe=ue({name:"ElCascaderPanel",components:{ElCascaderMenu:PBe},props:{...bz,border:{type:Boolean,default:!0},renderLabel:Function},emits:[Ot,Fn,"close","expand-change"],setup(t,{emit:e,slots:n}){let s=!1;const r=Fe("cascader"),o=VBe(t);let a=null;const i=U(!0),l=U([]),u=U(null),c=U([]),d=U(null),f=U([]),h=A(()=>o.value.expandTrigger==="hover"),p=A(()=>t.renderLabel||n.default),m=()=>{const{options:R}=t,D=o.value;s=!1,a=new zO(R,D),c.value=[a.getNodes()],D.lazy&&ia(t.options)?(i.value=!1,g(void 0,z=>{z&&(a=new zO(z,D),c.value=[a.getNodes()]),i.value=!0,C(!1,!0)})):C(!1,!0)},g=(R,D)=>{const z=o.value;R=R||new z0({},z,void 0,!0),R.loading=!0;const B=V=>{const O=R,F=O.root?null:O;V&&(a==null||a.appendNodes(V,F)),O.loading=!1,O.loaded=!0,O.childrenData=O.childrenData||[],D&&D(V)};z.lazyLoad(R,B)},y=(R,D)=>{var z;const{level:B}=R,V=c.value.slice(0,B);let O;R.isLeaf?O=R.pathNodes[B-2]:(O=R,V.push(R.children)),((z=d.value)==null?void 0:z.uid)!==(O==null?void 0:O.uid)&&(d.value=R,c.value=V,!D&&e("expand-change",(R==null?void 0:R.pathValues)||[]))},w=(R,D,z=!0)=>{const{checkStrictly:B,multiple:V}=o.value,O=f.value[0];s=!0,!V&&(O==null||O.doCheck(!1)),R.doCheck(D),k(),z&&!V&&!B&&e("close"),!z&&!V&&!B&&b(R)},b=R=>{!R||(R=R.parent,b(R),R&&y(R))},_=R=>a==null?void 0:a.getFlattedNodes(R),$=R=>{var D;return(D=_(R))==null?void 0:D.filter(z=>z.checked!==!1)},x=()=>{f.value.forEach(R=>R.doCheck(!1)),k()},k=()=>{var R;const{checkStrictly:D,multiple:z}=o.value,B=f.value,V=$(!D),O=WBe(B,V),F=O.map(L=>L.valueByOption);f.value=O,u.value=z?F:(R=F[0])!=null?R:null},C=(R=!1,D=!1)=>{const{modelValue:z}=t,{lazy:B,multiple:V,checkStrictly:O}=o.value,F=!O;if(!(!i.value||s||!D&&Wo(z,u.value)))if(B&&!R){const G=WA(Hle(vl(z))).map(Z=>a==null?void 0:a.getNodeByValue(Z)).filter(Z=>!!Z&&!Z.loaded&&!Z.loading);G.length?G.forEach(Z=>{g(Z,()=>C(!1,D))}):C(!0,D)}else{const L=V?vl(z):[z],G=WA(L.map(Z=>a==null?void 0:a.getNodeByValue(Z,F)));T(G,D),u.value=qM(z)}},T=(R,D=!0)=>{const{checkStrictly:z}=o.value,B=f.value,V=R.filter(L=>!!L&&(z||L.isLeaf)),O=a==null?void 0:a.getSameNode(d.value),F=D&&O||V[0];F?F.pathNodes.forEach(L=>y(L,!0)):d.value=null,B.forEach(L=>L.doCheck(!1)),V.forEach(L=>L.doCheck(!0)),f.value=V,nt(N)},N=()=>{!Kt||l.value.forEach(R=>{const D=R==null?void 0:R.$el;if(D){const z=D.querySelector(`.${r.namespace.value}-scrollbar__wrap`),B=D.querySelector(`.${r.b("node")}.${r.is("active")}`)||D.querySelector(`.${r.b("node")}.in-active-path`);uP(z,B)}})},M=R=>{const D=R.target,{code:z}=R;switch(z){case ut.up:case ut.down:{R.preventDefault();const B=z===ut.up?-1:1;Hv(sP(D,B,`.${r.b("node")}[tabindex="-1"]`));break}case ut.left:{R.preventDefault();const B=l.value[BO(D)-1],V=B==null?void 0:B.$el.querySelector(`.${r.b("node")}[aria-expanded="true"]`);Hv(V);break}case ut.right:{R.preventDefault();const B=l.value[BO(D)+1],V=B==null?void 0:B.$el.querySelector(`.${r.b("node")}[tabindex="-1"]`);Hv(V);break}case ut.enter:HBe(D);break}};return Lt(ik,on({config:o,expandingNode:d,checkedNodes:f,isHoverMenu:h,initialLoaded:i,renderLabelFn:p,lazyLoad:g,expandNode:y,handleCheckChange:w})),Me([o,()=>t.options],m,{deep:!0,immediate:!0}),Me(()=>t.modelValue,()=>{s=!1,C()},{deep:!0}),Me(()=>u.value,R=>{Wo(R,t.modelValue)||(e(Ot,R),e(Fn,R))}),zF(()=>l.value=[]),It(()=>!ia(t.modelValue)&&C()),{ns:r,menuList:l,menus:c,checkedNodes:f,handleKeyDown:M,handleCheckChange:w,getFlattedNodes:_,getCheckedNodes:$,clearCheckedNodes:x,calculateCheckedValue:k,scrollToExpandingNode:N}}});function GBe(t,e,n,s,r,o){const a=pt("el-cascader-menu");return S(),E("div",{class:P([t.ns.b("panel"),t.ns.is("bordered",t.border)]),onKeydown:e[0]||(e[0]=(...i)=>t.handleKeyDown&&t.handleKeyDown(...i))},[(S(!0),E(lt,null,Gt(t.menus,(i,l)=>(S(),$e(a,{key:l,ref_for:!0,ref:u=>t.menuList[l]=u,index:l,nodes:[...i]},null,8,["index","nodes"]))),128))],34)}var Xv=je(UBe,[["render",GBe],["__file","/home/runner/work/element-plus/element-plus/packages/components/cascader-panel/src/index.vue"]]);Xv.install=t=>{t.component(Xv.name,Xv)};const wz=Xv,jBe=wz,lk=qe({closable:Boolean,type:{type:String,values:["success","info","warning","danger",""],default:""},hit:Boolean,disableTransitions:Boolean,color:{type:String,default:""},size:{type:String,values:Hl,default:""},effect:{type:String,values:["dark","light","plain"],default:"light"},round:Boolean}),KBe={close:t=>t instanceof MouseEvent,click:t=>t instanceof MouseEvent},qBe=ue({name:"ElTag"}),XBe=ue({...qBe,props:lk,emits:KBe,setup(t,{emit:e}){const n=t,s=ks(),r=Fe("tag"),o=A(()=>{const{type:l,hit:u,effect:c,closable:d,round:f}=n;return[r.b(),r.is("closable",d),r.m(l),r.m(s.value),r.m(c),r.is("hit",u),r.is("round",f)]}),a=l=>{e("close",l)},i=l=>{e("click",l)};return(l,u)=>l.disableTransitions?(S(),E("span",{key:0,class:P(v(o)),style:ot({backgroundColor:l.color}),onClick:i},[I("span",{class:P(v(r).e("content"))},[Oe(l.$slots,"default")],2),l.closable?(S(),$e(v(rt),{key:0,class:P(v(r).e("close")),onClick:yt(a,["stop"])},{default:ce(()=>[se(v(xa))]),_:1},8,["class","onClick"])):ge("v-if",!0)],6)):(S(),$e(ms,{key:1,name:`${v(r).namespace.value}-zoom-in-center`,appear:""},{default:ce(()=>[I("span",{class:P(v(o)),style:ot({backgroundColor:l.color}),onClick:i},[I("span",{class:P(v(r).e("content"))},[Oe(l.$slots,"default")],2),l.closable?(S(),$e(v(rt),{key:0,class:P(v(r).e("close")),onClick:yt(a,["stop"])},{default:ce(()=>[se(v(xa))]),_:1},8,["class","onClick"])):ge("v-if",!0)],6)]),_:3},8,["name"]))}});var YBe=je(XBe,[["__file","/home/runner/work/element-plus/element-plus/packages/components/tag/src/tag.vue"]]);const Sw=Dt(YBe),ZBe={modifiers:[{name:"arrowPosition",enabled:!0,phase:"main",fn:({state:t})=>{const{modifiersData:e,placement:n}=t;["right","left","bottom","top"].includes(n)||(e.arrow.x=35)},requires:["arrow"]}]},JBe="ElCascader",QBe=ue({name:JBe,components:{ElCascaderPanel:wz,ElInput:Or,ElTooltip:No,ElScrollbar:jl,ElTag:Sw,ElIcon:rt,CircleClose:Bl,Check:Jh,ArrowDown:zl},directives:{Clickoutside:Ku},props:{...bz,size:{type:String,validator:Qh},placeholder:{type:String},disabled:Boolean,clearable:Boolean,filterable:Boolean,filterMethod:{type:Function,default:(t,e)=>t.text.includes(e)},separator:{type:String,default:" / "},showAllLevels:{type:Boolean,default:!0},collapseTags:Boolean,collapseTagsTooltip:{type:Boolean,default:!1},debounce:{type:Number,default:300},beforeFilter:{type:Function,default:()=>!0},popperClass:{type:String,default:""},teleported:Xs.teleported,tagType:{...lk.type,default:"info"},validateEvent:{type:Boolean,default:!0}},emits:[Ot,Fn,"focus","blur","visible-change","expand-change","remove-tag"],setup(t,{emit:e}){let n=0,s=0;const r=Fe("cascader"),o=Fe("input"),{t:a}=nn(),{form:i,formItem:l}=to(),u=U(null),c=U(null),d=U(null),f=U(null),h=U(null),p=U(!1),m=U(!1),g=U(!1),y=U(""),w=U(""),b=U([]),_=U([]),$=U([]),x=U(!1),k=A(()=>t.disabled||(i==null?void 0:i.disabled)),C=A(()=>t.placeholder||a("el.cascader.placeholder")),T=A(()=>w.value||b.value.length>0?"":C.value),N=ks(),M=A(()=>["small"].includes(N.value)?"small":"default"),R=A(()=>!!t.props.multiple),D=A(()=>!t.filterable||R.value),z=A(()=>R.value?w.value:y.value),B=A(()=>{var he;return((he=f.value)==null?void 0:he.checkedNodes)||[]}),V=A(()=>!t.clearable||k.value||g.value||!m.value?!1:!!B.value.length),O=A(()=>{const{showAllLevels:he,separator:ve}=t,me=B.value;return me.length?R.value?"":me[0].calcText(he,ve):""}),F=A({get(){return qM(t.modelValue)},set(he){e(Ot,he),e(Fn,he),t.validateEvent&&(l==null||l.validate("change").catch(ve=>void 0))}}),L=A(()=>{var he,ve;return(ve=(he=u.value)==null?void 0:he.popperRef)==null?void 0:ve.contentRef}),G=he=>{var ve,me,Ve;k.value||(he=he??!p.value,he!==p.value&&(p.value=he,(me=(ve=c.value)==null?void 0:ve.input)==null||me.setAttribute("aria-expanded",`${he}`),he?(Z(),nt((Ve=f.value)==null?void 0:Ve.scrollToExpandingNode)):t.filterable&&we(),e("visible-change",he)))},Z=()=>{nt(()=>{var he;(he=u.value)==null||he.updatePopper()})},j=()=>{g.value=!1},J=he=>{const{showAllLevels:ve,separator:me}=t;return{node:he,key:he.uid,text:he.calcText(ve,me),hitState:!1,closable:!k.value&&!he.isDisabled,isCollapseTag:!1}},fe=he=>{var ve;const me=he.node;me.doCheck(!1),(ve=f.value)==null||ve.calculateCheckedValue(),e("remove-tag",me.valueByOption)},X=()=>{if(!R.value)return;const he=B.value,ve=[],me=[];if(he.forEach(Ve=>me.push(J(Ve))),_.value=me,he.length){const[Ve,...Ye]=he,Je=Ye.length;ve.push(J(Ve)),Je&&(t.collapseTags?ve.push({key:-1,text:`+ ${Je}`,closable:!1,isCollapseTag:!0}):Ye.forEach(ct=>ve.push(J(ct))))}b.value=ve},oe=()=>{var he,ve;const{filterMethod:me,showAllLevels:Ve,separator:Ye}=t,Je=(ve=(he=f.value)==null?void 0:he.getFlattedNodes(!t.props.checkStrictly))==null?void 0:ve.filter(ct=>ct.isDisabled?!1:(ct.calcText(Ve,Ye),me(ct,z.value)));R.value&&(b.value.forEach(ct=>{ct.hitState=!1}),_.value.forEach(ct=>{ct.hitState=!1})),g.value=!0,$.value=Je,Z()},ee=()=>{var he;let ve;g.value&&h.value?ve=h.value.$el.querySelector(`.${r.e("suggestion-item")}`):ve=(he=f.value)==null?void 0:he.$el.querySelector(`.${r.b("node")}[tabindex="-1"]`),ve&&(ve.focus(),!g.value&&ve.click())},Q=()=>{var he,ve;const me=(he=c.value)==null?void 0:he.input,Ve=d.value,Ye=(ve=h.value)==null?void 0:ve.$el;if(!(!Kt||!me)){if(Ye){const Je=Ye.querySelector(`.${r.e("suggestion-list")}`);Je.style.minWidth=`${me.offsetWidth}px`}if(Ve){const{offsetHeight:Je}=Ve,ct=b.value.length>0?`${Math.max(Je+6,n)}px`:`${n}px`;me.style.height=ct,Z()}}},ie=he=>{var ve;return(ve=f.value)==null?void 0:ve.getCheckedNodes(he)},pe=he=>{Z(),e("expand-change",he)},Re=he=>{var ve;const me=(ve=he.target)==null?void 0:ve.value;if(he.type==="compositionend")x.value=!1,nt(()=>Ae(me));else{const Ve=me[me.length-1]||"";x.value=!fw(Ve)}},K=he=>{if(!x.value)switch(he.code){case ut.enter:G();break;case ut.down:G(!0),nt(ee),he.preventDefault();break;case ut.esc:p.value===!0&&(he.preventDefault(),he.stopPropagation(),G(!1));break;case ut.tab:G(!1);break}},re=()=>{var he;(he=f.value)==null||he.clearCheckedNodes(),!p.value&&t.filterable&&we(),G(!1)},we=()=>{const{value:he}=O;y.value=he,w.value=he},Ee=he=>{var ve,me;const{checked:Ve}=he;R.value?(ve=f.value)==null||ve.handleCheckChange(he,!Ve,!1):(!Ve&&((me=f.value)==null||me.handleCheckChange(he,!0,!1)),G(!1))},De=he=>{const ve=he.target,{code:me}=he;switch(me){case ut.up:case ut.down:{const Ve=me===ut.up?-1:1;Hv(sP(ve,Ve,`.${r.e("suggestion-item")}[tabindex="-1"]`));break}case ut.enter:ve.click();break}},_e=()=>{const he=b.value,ve=he[he.length-1];s=w.value?0:s+1,!(!ve||!s||t.collapseTags&&he.length>1)&&(ve.hitState?fe(ve):ve.hitState=!0)},ze=Xr(()=>{const{value:he}=z;if(!he)return;const ve=t.beforeFilter(he);b0(ve)?ve.then(oe).catch(()=>{}):ve!==!1?oe():j()},t.debounce),Ae=(he,ve)=>{!p.value&&G(!0),!(ve!=null&&ve.isComposing)&&(he?ze():j())};return Me(g,Z),Me([B,k],X),Me(b,()=>{nt(()=>Q())}),Me(O,we,{immediate:!0}),It(()=>{const he=c.value.input,ve=Number.parseFloat($ue(o.cssVarName("input-height"),he).value)-2;n=he.offsetHeight||ve,Dr(he,Q)}),{popperOptions:ZBe,tooltipRef:u,popperPaneRef:L,input:c,tagWrapper:d,panel:f,suggestionPanel:h,popperVisible:p,inputHover:m,inputPlaceholder:C,currentPlaceholder:T,filtering:g,presentText:O,checkedValue:F,inputValue:y,searchInputValue:w,presentTags:b,allPresentTags:_,suggestions:$,isDisabled:k,isOnComposition:x,realSize:N,tagSize:M,multiple:R,readonly:D,clearBtnVisible:V,nsCascader:r,nsInput:o,t:a,togglePopperVisible:G,hideSuggestionPanel:j,deleteTag:fe,focusFirstNode:ee,getCheckedNodes:ie,handleExpandChange:pe,handleKeyDown:K,handleComposition:Re,handleClear:re,handleSuggestionClick:Ee,handleSuggestionKeyDown:De,handleDelete:_e,handleInput:Ae}}}),eVe={key:0},tVe=["placeholder"],nVe=["onClick"];function sVe(t,e,n,s,r,o){const a=pt("circle-close"),i=pt("el-icon"),l=pt("arrow-down"),u=pt("el-input"),c=pt("el-tag"),d=pt("el-tooltip"),f=pt("el-cascader-panel"),h=pt("check"),p=pt("el-scrollbar"),m=rh("clickoutside");return S(),$e(d,{ref:"tooltipRef",visible:t.popperVisible,teleported:t.teleported,"popper-class":[t.nsCascader.e("dropdown"),t.popperClass],"popper-options":t.popperOptions,"fallback-placements":["bottom-start","bottom","top-start","top","right","left"],"stop-popper-mouse-event":!1,"gpu-acceleration":!1,placement:"bottom-start",transition:`${t.nsCascader.namespace.value}-zoom-in-top`,effect:"light",pure:"",persistent:"",onHide:t.hideSuggestionPanel},{default:ce(()=>[St((S(),E("div",{class:P([t.nsCascader.b(),t.nsCascader.m(t.realSize),t.nsCascader.is("disabled",t.isDisabled),t.$attrs.class]),style:ot(t.$attrs.style),onClick:e[11]||(e[11]=()=>t.togglePopperVisible(t.readonly?void 0:!0)),onKeydown:e[12]||(e[12]=(...g)=>t.handleKeyDown&&t.handleKeyDown(...g)),onMouseenter:e[13]||(e[13]=g=>t.inputHover=!0),onMouseleave:e[14]||(e[14]=g=>t.inputHover=!1)},[se(u,{ref:"input",modelValue:t.inputValue,"onUpdate:modelValue":e[1]||(e[1]=g=>t.inputValue=g),placeholder:t.currentPlaceholder,readonly:t.readonly,disabled:t.isDisabled,"validate-event":!1,size:t.realSize,class:P(t.nsCascader.is("focus",t.popperVisible)),onCompositionstart:t.handleComposition,onCompositionupdate:t.handleComposition,onCompositionend:t.handleComposition,onFocus:e[2]||(e[2]=g=>t.$emit("focus",g)),onBlur:e[3]||(e[3]=g=>t.$emit("blur",g)),onInput:t.handleInput},{suffix:ce(()=>[t.clearBtnVisible?(S(),$e(i,{key:"clear",class:P([t.nsInput.e("icon"),"icon-circle-close"]),onClick:yt(t.handleClear,["stop"])},{default:ce(()=>[se(a)]),_:1},8,["class","onClick"])):(S(),$e(i,{key:"arrow-down",class:P([t.nsInput.e("icon"),"icon-arrow-down",t.nsCascader.is("reverse",t.popperVisible)]),onClick:e[0]||(e[0]=yt(g=>t.togglePopperVisible(),["stop"]))},{default:ce(()=>[se(l)]),_:1},8,["class"]))]),_:1},8,["modelValue","placeholder","readonly","disabled","size","class","onCompositionstart","onCompositionupdate","onCompositionend","onInput"]),t.multiple?(S(),E("div",{key:0,ref:"tagWrapper",class:P(t.nsCascader.e("tags"))},[(S(!0),E(lt,null,Gt(t.presentTags,g=>(S(),$e(c,{key:g.key,type:t.tagType,size:t.tagSize,hit:g.hitState,closable:g.closable,"disable-transitions":"",onClose:y=>t.deleteTag(g)},{default:ce(()=>[g.isCollapseTag===!1?(S(),E("span",eVe,Ue(g.text),1)):(S(),$e(d,{key:1,disabled:t.popperVisible||!t.collapseTagsTooltip,"fallback-placements":["bottom","top","right","left"],placement:"bottom",effect:"light"},{default:ce(()=>[I("span",null,Ue(g.text),1)]),content:ce(()=>[I("div",{class:P(t.nsCascader.e("collapse-tags"))},[(S(!0),E(lt,null,Gt(t.allPresentTags.slice(1),(y,w)=>(S(),E("div",{key:w,class:P(t.nsCascader.e("collapse-tag"))},[(S(),$e(c,{key:y.key,class:"in-tooltip",type:t.tagType,size:t.tagSize,hit:y.hitState,closable:y.closable,"disable-transitions":"",onClose:b=>t.deleteTag(y)},{default:ce(()=>[I("span",null,Ue(y.text),1)]),_:2},1032,["type","size","hit","closable","onClose"]))],2))),128))],2)]),_:2},1032,["disabled"]))]),_:2},1032,["type","size","hit","closable","onClose"]))),128)),t.filterable&&!t.isDisabled?St((S(),E("input",{key:0,"onUpdate:modelValue":e[4]||(e[4]=g=>t.searchInputValue=g),type:"text",class:P(t.nsCascader.e("search-input")),placeholder:t.presentText?"":t.inputPlaceholder,onInput:e[5]||(e[5]=g=>t.handleInput(t.searchInputValue,g)),onClick:e[6]||(e[6]=yt(g=>t.togglePopperVisible(!0),["stop"])),onKeydown:e[7]||(e[7]=qt((...g)=>t.handleDelete&&t.handleDelete(...g),["delete"])),onCompositionstart:e[8]||(e[8]=(...g)=>t.handleComposition&&t.handleComposition(...g)),onCompositionupdate:e[9]||(e[9]=(...g)=>t.handleComposition&&t.handleComposition(...g)),onCompositionend:e[10]||(e[10]=(...g)=>t.handleComposition&&t.handleComposition(...g))},null,42,tVe)),[[lC,t.searchInputValue]]):ge("v-if",!0)],2)):ge("v-if",!0)],38)),[[m,()=>t.togglePopperVisible(!1),t.popperPaneRef]])]),content:ce(()=>[St(se(f,{ref:"panel",modelValue:t.checkedValue,"onUpdate:modelValue":e[15]||(e[15]=g=>t.checkedValue=g),options:t.options,props:t.props,border:!1,"render-label":t.$slots.default,onExpandChange:t.handleExpandChange,onClose:e[16]||(e[16]=g=>t.$nextTick(()=>t.togglePopperVisible(!1)))},null,8,["modelValue","options","props","render-label","onExpandChange"]),[[Qt,!t.filtering]]),t.filterable?St((S(),$e(p,{key:0,ref:"suggestionPanel",tag:"ul",class:P(t.nsCascader.e("suggestion-panel")),"view-class":t.nsCascader.e("suggestion-list"),onKeydown:t.handleSuggestionKeyDown},{default:ce(()=>[t.suggestions.length?(S(!0),E(lt,{key:0},Gt(t.suggestions,g=>(S(),E("li",{key:g.uid,class:P([t.nsCascader.e("suggestion-item"),t.nsCascader.is("checked",g.checked)]),tabindex:-1,onClick:y=>t.handleSuggestionClick(g)},[I("span",null,Ue(g.text),1),g.checked?(S(),$e(i,{key:0},{default:ce(()=>[se(h)]),_:1})):ge("v-if",!0)],10,nVe))),128)):Oe(t.$slots,"empty",{key:1},()=>[I("li",{class:P(t.nsCascader.e("empty-text"))},Ue(t.t("el.cascader.noMatch")),3)])]),_:3},8,["class","view-class","onKeydown"])),[[Qt,t.filtering]]):ge("v-if",!0)]),_:3},8,["visible","teleported","popper-class","popper-options","transition","onHide"])}var Yv=je(QBe,[["render",sVe],["__file","/home/runner/work/element-plus/element-plus/packages/components/cascader/src/index.vue"]]);Yv.install=t=>{t.component(Yv.name,Yv)};const rVe=Yv,oVe=rVe,aVe=qe({checked:{type:Boolean,default:!1}}),iVe={"update:checked":t=>Rs(t),[Fn]:t=>Rs(t)},lVe=ue({name:"ElCheckTag"}),uVe=ue({...lVe,props:aVe,emits:iVe,setup(t,{emit:e}){const n=t,s=Fe("check-tag"),r=()=>{const o=!n.checked;e(Fn,o),e("update:checked",o)};return(o,a)=>(S(),E("span",{class:P([v(s).b(),v(s).is("checked",o.checked)]),onClick:r},[Oe(o.$slots,"default")],2))}});var cVe=je(uVe,[["__file","/home/runner/work/element-plus/element-plus/packages/components/check-tag/src/check-tag.vue"]]);const dVe=Dt(cVe),fVe=qe({tag:{type:String,default:"div"},span:{type:Number,default:24},offset:{type:Number,default:0},pull:{type:Number,default:0},push:{type:Number,default:0},xs:{type:Se([Number,Object]),default:()=>Ln({})},sm:{type:Se([Number,Object]),default:()=>Ln({})},md:{type:Se([Number,Object]),default:()=>Ln({})},lg:{type:Se([Number,Object]),default:()=>Ln({})},xl:{type:Se([Number,Object]),default:()=>Ln({})}}),hVe=ue({name:"ElCol"}),pVe=ue({...hVe,props:fVe,setup(t){const e=t,{gutter:n}=et(WP,{gutter:A(()=>0)}),s=Fe("col"),r=A(()=>{const a={};return n.value&&(a.paddingLeft=a.paddingRight=`${n.value/2}px`),a}),o=A(()=>{const a=[];return["span","offset","pull","push"].forEach(u=>{const c=e[u];Ct(c)&&(u==="span"?a.push(s.b(`${e[u]}`)):c>0&&a.push(s.b(`${u}-${e[u]}`)))}),["xs","sm","md","lg","xl"].forEach(u=>{Ct(e[u])?a.push(s.b(`${u}-${e[u]}`)):Bt(e[u])&&Object.entries(e[u]).forEach(([c,d])=>{a.push(c!=="span"?s.b(`${u}-${c}-${d}`):s.b(`${u}-${d}`))})}),n.value&&a.push(s.is("guttered")),[s.b(),a]});return(a,i)=>(S(),$e(Vt(a.tag),{class:P(v(o)),style:ot(v(r))},{default:ce(()=>[Oe(a.$slots,"default")]),_:3},8,["class","style"]))}});var mVe=je(pVe,[["__file","/home/runner/work/element-plus/element-plus/packages/components/col/src/col.vue"]]);const gVe=Dt(mVe),VO=t=>typeof Ct(t),vVe=qe({accordion:Boolean,modelValue:{type:Se([Array,String,Number]),default:()=>Ln([])}}),yVe={[Ot]:VO,[Fn]:VO},bVe=(t,e)=>{const n=U(dh(t.modelValue)),s=o=>{n.value=o;const a=t.accordion?n.value[0]:n.value;e(Ot,a),e(Fn,a)},r=o=>{if(t.accordion)s([n.value[0]===o?"":o]);else{const a=[...n.value],i=a.indexOf(o);i>-1?a.splice(i,1):a.push(o),s(a)}};return Me(()=>t.modelValue,()=>n.value=dh(t.modelValue),{deep:!0}),Lt(LP,{activeNames:n,handleItemClick:r}),{activeNames:n,setActiveNames:s}},wVe=()=>{const t=Fe("collapse");return{rootKls:A(()=>t.b())}},_Ve=ue({name:"ElCollapse"}),$Ve=ue({..._Ve,props:vVe,emits:yVe,setup(t,{expose:e,emit:n}){const s=t,{activeNames:r,setActiveNames:o}=bVe(s,n),{rootKls:a}=wVe();return e({activeNames:r,setActiveNames:o}),(i,l)=>(S(),E("div",{class:P(v(a)),role:"tablist","aria-multiselectable":"true"},[Oe(i.$slots,"default")],2))}});var xVe=je($Ve,[["__file","/home/runner/work/element-plus/element-plus/packages/components/collapse/src/collapse.vue"]]);const SVe=ue({name:"ElCollapseTransition"}),CVe=ue({...SVe,setup(t){const e=Fe("collapse-transition"),n={beforeEnter(s){s.dataset||(s.dataset={}),s.dataset.oldPaddingTop=s.style.paddingTop,s.dataset.oldPaddingBottom=s.style.paddingBottom,s.style.maxHeight=0,s.style.paddingTop=0,s.style.paddingBottom=0},enter(s){s.dataset.oldOverflow=s.style.overflow,s.scrollHeight!==0?(s.style.maxHeight=`${s.scrollHeight}px`,s.style.paddingTop=s.dataset.oldPaddingTop,s.style.paddingBottom=s.dataset.oldPaddingBottom):(s.style.maxHeight=0,s.style.paddingTop=s.dataset.oldPaddingTop,s.style.paddingBottom=s.dataset.oldPaddingBottom),s.style.overflow="hidden"},afterEnter(s){s.style.maxHeight="",s.style.overflow=s.dataset.oldOverflow},beforeLeave(s){s.dataset||(s.dataset={}),s.dataset.oldPaddingTop=s.style.paddingTop,s.dataset.oldPaddingBottom=s.style.paddingBottom,s.dataset.oldOverflow=s.style.overflow,s.style.maxHeight=`${s.scrollHeight}px`,s.style.overflow="hidden"},leave(s){s.scrollHeight!==0&&(s.style.maxHeight=0,s.style.paddingTop=0,s.style.paddingBottom=0)},afterLeave(s){s.style.maxHeight="",s.style.overflow=s.dataset.oldOverflow,s.style.paddingTop=s.dataset.oldPaddingTop,s.style.paddingBottom=s.dataset.oldPaddingBottom}};return(s,r)=>(S(),$e(ms,zt({name:v(e).b()},Lee(n)),{default:ce(()=>[Oe(s.$slots,"default")]),_:3},16,["name"]))}});var Zv=je(CVe,[["__file","/home/runner/work/element-plus/element-plus/packages/components/collapse-transition/src/collapse-transition.vue"]]);Zv.install=t=>{t.component(Zv.name,Zv)};const Cw=Zv,kVe=Cw,TVe=qe({title:{type:String,default:""},name:{type:Se([String,Number]),default:()=>hw()},disabled:Boolean}),NVe=t=>{const e=et(LP),n=U(!1),s=U(!1),r=U(hw()),o=A(()=>e==null?void 0:e.activeNames.value.includes(t.name));return{focusing:n,id:r,isActive:o,handleFocus:()=>{setTimeout(()=>{s.value?s.value=!1:n.value=!0},50)},handleHeaderClick:()=>{t.disabled||(e==null||e.handleItemClick(t.name),n.value=!1,s.value=!0)},handleEnterClick:()=>{e==null||e.handleItemClick(t.name)}}},IVe=(t,{focusing:e,isActive:n,id:s})=>{const r=Fe("collapse"),o=A(()=>[r.b("item"),r.is("active",v(n)),r.is("disabled",t.disabled)]),a=A(()=>[r.be("item","header"),r.is("active",v(n)),{focusing:v(e)&&!t.disabled}]),i=A(()=>[r.be("item","arrow"),r.is("active",v(n))]),l=A(()=>r.be("item","wrap")),u=A(()=>r.be("item","content")),c=A(()=>r.b(`content-${v(s)}`)),d=A(()=>r.b(`head-${v(s)}`));return{arrowKls:i,headKls:a,rootKls:o,itemWrapperKls:l,itemContentKls:u,scopedContentId:c,scopedHeadId:d}},EVe=["aria-expanded","aria-controls","aria-describedby"],AVe=["id","tabindex"],OVe=["id","aria-hidden","aria-labelledby"],RVe=ue({name:"ElCollapseItem"}),DVe=ue({...RVe,props:TVe,setup(t,{expose:e}){const n=t,{focusing:s,id:r,isActive:o,handleFocus:a,handleHeaderClick:i,handleEnterClick:l}=NVe(n),{arrowKls:u,headKls:c,rootKls:d,itemWrapperKls:f,itemContentKls:h,scopedContentId:p,scopedHeadId:m}=IVe(n,{focusing:s,isActive:o,id:r});return e({isActive:o}),(g,y)=>(S(),E("div",{class:P(v(d))},[I("div",{role:"tab","aria-expanded":v(o),"aria-controls":v(p),"aria-describedby":v(p)},[I("div",{id:v(m),class:P(v(c)),role:"button",tabindex:g.disabled?-1:0,onClick:y[0]||(y[0]=(...w)=>v(i)&&v(i)(...w)),onKeypress:y[1]||(y[1]=qt(yt((...w)=>v(l)&&v(l)(...w),["stop","prevent"]),["space","enter"])),onFocus:y[2]||(y[2]=(...w)=>v(a)&&v(a)(...w)),onBlur:y[3]||(y[3]=w=>s.value=!1)},[Oe(g.$slots,"title",{},()=>[Yt(Ue(g.title),1)]),se(v(rt),{class:P(v(u))},{default:ce(()=>[se(v(Rr))]),_:1},8,["class"])],42,AVe)],8,EVe),se(v(Cw),null,{default:ce(()=>[St(I("div",{id:v(p),class:P(v(f)),role:"tabpanel","aria-hidden":!v(o),"aria-labelledby":v(m)},[I("div",{class:P(v(h))},[Oe(g.$slots,"default")],2)],10,OVe),[[Qt,v(o)]])]),_:3})],2))}});var _z=je(DVe,[["__file","/home/runner/work/element-plus/element-plus/packages/components/collapse/src/collapse-item.vue"]]);const FVe=Dt(xVe,{CollapseItem:_z}),MVe=ns(_z);let e$=!1;function B0(t,e){if(!Kt)return;const n=function(o){var a;(a=e.drag)==null||a.call(e,o)},s=function(o){var a;document.removeEventListener("mousemove",n),document.removeEventListener("mouseup",s),document.removeEventListener("touchmove",n),document.removeEventListener("touchend",s),document.onselectstart=null,document.ondragstart=null,e$=!1,(a=e.end)==null||a.call(e,o)},r=function(o){var a;e$||(o.preventDefault(),document.onselectstart=()=>!1,document.ondragstart=()=>!1,document.addEventListener("mousemove",n),document.addEventListener("mouseup",s),document.addEventListener("touchmove",n),document.addEventListener("touchend",s),e$=!0,(a=e.start)==null||a.call(e,o))};t.addEventListener("mousedown",r),t.addEventListener("touchstart",r)}const PVe=ue({name:"ElColorAlphaSlider",props:{color:{type:Object,required:!0},vertical:{type:Boolean,default:!1}},setup(t){const e=Fe("color-alpha-slider"),n=Rt(),s=Nn(),r=Nn(),o=U(0),a=U(0),i=U();Me(()=>t.color.get("alpha"),()=>{h()}),Me(()=>t.color.value,()=>{h()});function l(){if(!s.value||t.vertical)return 0;const p=n.vnode.el,m=t.color.get("alpha");return p?Math.round(m*(p.offsetWidth-s.value.offsetWidth/2)/100):0}function u(){if(!s.value)return 0;const p=n.vnode.el;if(!t.vertical)return 0;const m=t.color.get("alpha");return p?Math.round(m*(p.offsetHeight-s.value.offsetHeight/2)/100):0}function c(){if(t.color&&t.color.value){const{r:p,g:m,b:g}=t.color.toRgb();return`linear-gradient(to right, rgba(${p}, ${m}, ${g}, 0) 0%, rgba(${p}, ${m}, ${g}, 1) 100%)`}return""}function d(p){p.target!==s.value&&f(p)}function f(p){if(!r.value||!s.value)return;const g=n.vnode.el.getBoundingClientRect(),{clientX:y,clientY:w}=NC(p);if(t.vertical){let b=w-g.top;b=Math.max(s.value.offsetHeight/2,b),b=Math.min(b,g.height-s.value.offsetHeight/2),t.color.set("alpha",Math.round((b-s.value.offsetHeight/2)/(g.height-s.value.offsetHeight)*100))}else{let b=y-g.left;b=Math.max(s.value.offsetWidth/2,b),b=Math.min(b,g.width-s.value.offsetWidth/2),t.color.set("alpha",Math.round((b-s.value.offsetWidth/2)/(g.width-s.value.offsetWidth)*100))}}function h(){o.value=l(),a.value=u(),i.value=c()}return It(()=>{if(!r.value||!s.value)return;const p={drag:m=>{f(m)},end:m=>{f(m)}};B0(r.value,p),B0(s.value,p),h()}),{thumb:s,bar:r,thumbLeft:o,thumbTop:a,background:i,handleClick:d,update:h,ns:e}}});function LVe(t,e,n,s,r,o){return S(),E("div",{class:P([t.ns.b(),t.ns.is("vertical",t.vertical)])},[I("div",{ref:"bar",class:P(t.ns.e("bar")),style:ot({background:t.background}),onClick:e[0]||(e[0]=(...a)=>t.handleClick&&t.handleClick(...a))},null,6),I("div",{ref:"thumb",class:P(t.ns.e("thumb")),style:ot({left:t.thumbLeft+"px",top:t.thumbTop+"px"})},null,6)],2)}var zVe=je(PVe,[["render",LVe],["__file","/home/runner/work/element-plus/element-plus/packages/components/color-picker/src/components/alpha-slider.vue"]]);const BVe=ue({name:"ElColorHueSlider",props:{color:{type:Object,required:!0},vertical:Boolean},setup(t){const e=Fe("color-hue-slider"),n=Rt(),s=U(),r=U(),o=U(0),a=U(0),i=A(()=>t.color.get("hue"));Me(()=>i.value,()=>{f()});function l(h){h.target!==s.value&&u(h)}function u(h){if(!r.value||!s.value)return;const m=n.vnode.el.getBoundingClientRect(),{clientX:g,clientY:y}=NC(h);let w;if(t.vertical){let b=y-m.top;b=Math.min(b,m.height-s.value.offsetHeight/2),b=Math.max(s.value.offsetHeight/2,b),w=Math.round((b-s.value.offsetHeight/2)/(m.height-s.value.offsetHeight)*360)}else{let b=g-m.left;b=Math.min(b,m.width-s.value.offsetWidth/2),b=Math.max(s.value.offsetWidth/2,b),w=Math.round((b-s.value.offsetWidth/2)/(m.width-s.value.offsetWidth)*360)}t.color.set("hue",w)}function c(){if(!s.value)return 0;const h=n.vnode.el;if(t.vertical)return 0;const p=t.color.get("hue");return h?Math.round(p*(h.offsetWidth-s.value.offsetWidth/2)/360):0}function d(){if(!s.value)return 0;const h=n.vnode.el;if(!t.vertical)return 0;const p=t.color.get("hue");return h?Math.round(p*(h.offsetHeight-s.value.offsetHeight/2)/360):0}function f(){o.value=c(),a.value=d()}return It(()=>{if(!r.value||!s.value)return;const h={drag:p=>{u(p)},end:p=>{u(p)}};B0(r.value,h),B0(s.value,h),f()}),{bar:r,thumb:s,thumbLeft:o,thumbTop:a,hueValue:i,handleClick:l,update:f,ns:e}}});function VVe(t,e,n,s,r,o){return S(),E("div",{class:P([t.ns.b(),t.ns.is("vertical",t.vertical)])},[I("div",{ref:"bar",class:P(t.ns.e("bar")),onClick:e[0]||(e[0]=(...a)=>t.handleClick&&t.handleClick(...a))},null,2),I("div",{ref:"thumb",class:P(t.ns.e("thumb")),style:ot({left:t.thumbLeft+"px",top:t.thumbTop+"px"})},null,6)],2)}var HVe=je(BVe,[["render",VVe],["__file","/home/runner/work/element-plus/element-plus/packages/components/color-picker/src/components/hue-slider.vue"]]);const WVe=qe({modelValue:String,id:String,showAlpha:Boolean,colorFormat:String,disabled:Boolean,size:wo,popperClass:{type:String,default:""},label:{type:String,default:void 0},tabindex:{type:[String,Number],default:0},predefine:{type:Se(Array)},validateEvent:{type:Boolean,default:!0}}),UVe={[Ot]:t=>wt(t)||nr(t),[Fn]:t=>wt(t)||nr(t),activeChange:t=>wt(t)||nr(t)},$z=Symbol("colorPickerContextKey"),HO=function(t,e,n){return[t,e*n/((t=(2-e)*n)<1?t:2-t)||0,t/2]},GVe=function(t){return typeof t=="string"&&t.includes(".")&&Number.parseFloat(t)===1},jVe=function(t){return typeof t=="string"&&t.includes("%")},jf=function(t,e){GVe(t)&&(t="100%");const n=jVe(t);return t=Math.min(e,Math.max(0,Number.parseFloat(`${t}`))),n&&(t=Number.parseInt(`${t*e}`,10)/100),Math.abs(t-e)<1e-6?1:t%e/Number.parseFloat(e)},WO={10:"A",11:"B",12:"C",13:"D",14:"E",15:"F"},Jv=t=>{t=Math.min(Math.round(t),255);const e=Math.floor(t/16),n=t%16;return`${WO[e]||e}${WO[n]||n}`},UO=function({r:t,g:e,b:n}){return Number.isNaN(+t)||Number.isNaN(+e)||Number.isNaN(+n)?"":`#${Jv(t)}${Jv(e)}${Jv(n)}`},t$={A:10,B:11,C:12,D:13,E:14,F:15},Tc=function(t){return t.length===2?(t$[t[0].toUpperCase()]||+t[0])*16+(t$[t[1].toUpperCase()]||+t[1]):t$[t[1].toUpperCase()]||+t[1]},KVe=function(t,e,n){e=e/100,n=n/100;let s=e;const r=Math.max(n,.01);n*=2,e*=n<=1?n:2-n,s*=r<=1?r:2-r;const o=(n+e)/2,a=n===0?2*s/(r+s):2*e/(n+e);return{h:t,s:a*100,v:o*100}},GO=(t,e,n)=>{t=jf(t,255),e=jf(e,255),n=jf(n,255);const s=Math.max(t,e,n),r=Math.min(t,e,n);let o;const a=s,i=s-r,l=s===0?0:i/s;if(s===r)o=0;else{switch(s){case t:{o=(e-n)/i+(e<n?6:0);break}case e:{o=(n-t)/i+2;break}case n:{o=(t-e)/i+4;break}}o/=6}return{h:o*360,s:l*100,v:a*100}},Am=function(t,e,n){t=jf(t,360)*6,e=jf(e,100),n=jf(n,100);const s=Math.floor(t),r=t-s,o=n*(1-e),a=n*(1-r*e),i=n*(1-(1-r)*e),l=s%6,u=[n,a,o,o,i,n][l],c=[i,n,n,a,o,o][l],d=[o,o,i,n,n,a][l];return{r:Math.round(u*255),g:Math.round(c*255),b:Math.round(d*255)}};class d0{constructor(e={}){this._hue=0,this._saturation=100,this._value=100,this._alpha=100,this.enableAlpha=!1,this.format="hex",this.value="";for(const n in e)Ut(e,n)&&(this[n]=e[n]);e.value?this.fromString(e.value):this.doOnChange()}set(e,n){if(arguments.length===1&&typeof e=="object"){for(const s in e)Ut(e,s)&&this.set(s,e[s]);return}this[`_${e}`]=n,this.doOnChange()}get(e){return e==="alpha"?Math.floor(this[`_${e}`]):this[`_${e}`]}toRgb(){return Am(this._hue,this._saturation,this._value)}fromString(e){if(!e){this._hue=0,this._saturation=100,this._value=100,this.doOnChange();return}const n=(s,r,o)=>{this._hue=Math.max(0,Math.min(360,s)),this._saturation=Math.max(0,Math.min(100,r)),this._value=Math.max(0,Math.min(100,o)),this.doOnChange()};if(e.includes("hsl")){const s=e.replace(/hsla|hsl|\(|\)/gm,"").split(/\s|,/g).filter(r=>r!=="").map((r,o)=>o>2?Number.parseFloat(r):Number.parseInt(r,10));if(s.length===4?this._alpha=Number.parseFloat(s[3])*100:s.length===3&&(this._alpha=100),s.length>=3){const{h:r,s:o,v:a}=KVe(s[0],s[1],s[2]);n(r,o,a)}}else if(e.includes("hsv")){const s=e.replace(/hsva|hsv|\(|\)/gm,"").split(/\s|,/g).filter(r=>r!=="").map((r,o)=>o>2?Number.parseFloat(r):Number.parseInt(r,10));s.length===4?this._alpha=Number.parseFloat(s[3])*100:s.length===3&&(this._alpha=100),s.length>=3&&n(s[0],s[1],s[2])}else if(e.includes("rgb")){const s=e.replace(/rgba|rgb|\(|\)/gm,"").split(/\s|,/g).filter(r=>r!=="").map((r,o)=>o>2?Number.parseFloat(r):Number.parseInt(r,10));if(s.length===4?this._alpha=Number.parseFloat(s[3])*100:s.length===3&&(this._alpha=100),s.length>=3){const{h:r,s:o,v:a}=GO(s[0],s[1],s[2]);n(r,o,a)}}else if(e.includes("#")){const s=e.replace("#","").trim();if(!/^[0-9a-fA-F]{3}$|^[0-9a-fA-F]{6}$|^[0-9a-fA-F]{8}$/.test(s))return;let r,o,a;s.length===3?(r=Tc(s[0]+s[0]),o=Tc(s[1]+s[1]),a=Tc(s[2]+s[2])):(s.length===6||s.length===8)&&(r=Tc(s.slice(0,2)),o=Tc(s.slice(2,4)),a=Tc(s.slice(4,6))),s.length===8?this._alpha=Tc(s.slice(6))/255*100:(s.length===3||s.length===6)&&(this._alpha=100);const{h:i,s:l,v:u}=GO(r,o,a);n(i,l,u)}}compare(e){return Math.abs(e._hue-this._hue)<2&&Math.abs(e._saturation-this._saturation)<1&&Math.abs(e._value-this._value)<1&&Math.abs(e._alpha-this._alpha)<1}doOnChange(){const{_hue:e,_saturation:n,_value:s,_alpha:r,format:o}=this;if(this.enableAlpha)switch(o){case"hsl":{const a=HO(e,n/100,s/100);this.value=`hsla(${e}, ${Math.round(a[1]*100)}%, ${Math.round(a[2]*100)}%, ${this.get("alpha")/100})`;break}case"hsv":{this.value=`hsva(${e}, ${Math.round(n)}%, ${Math.round(s)}%, ${this.get("alpha")/100})`;break}case"hex":{this.value=`${UO(Am(e,n,s))}${Jv(r*255/100)}`;break}default:{const{r:a,g:i,b:l}=Am(e,n,s);this.value=`rgba(${a}, ${i}, ${l}, ${this.get("alpha")/100})`}}else switch(o){case"hsl":{const a=HO(e,n/100,s/100);this.value=`hsl(${e}, ${Math.round(a[1]*100)}%, ${Math.round(a[2]*100)}%)`;break}case"hsv":{this.value=`hsv(${e}, ${Math.round(n)}%, ${Math.round(s)}%)`;break}case"rgb":{const{r:a,g:i,b:l}=Am(e,n,s);this.value=`rgb(${a}, ${i}, ${l})`;break}default:this.value=UO(Am(e,n,s))}}}const qVe=ue({props:{colors:{type:Array,required:!0},color:{type:Object,required:!0}},setup(t){const e=Fe("color-predefine"),{currentColor:n}=et($z),s=U(o(t.colors,t.color));Me(()=>n.value,a=>{const i=new d0;i.fromString(a),s.value.forEach(l=>{l.selected=i.compare(l)})}),Ho(()=>{s.value=o(t.colors,t.color)});function r(a){t.color.fromString(t.colors[a])}function o(a,i){return a.map(l=>{const u=new d0;return u.enableAlpha=!0,u.format="rgba",u.fromString(l),u.selected=u.value===i.value,u})}return{rgbaColors:s,handleSelect:r,ns:e}}}),XVe=["onClick"];function YVe(t,e,n,s,r,o){return S(),E("div",{class:P(t.ns.b())},[I("div",{class:P(t.ns.e("colors"))},[(S(!0),E(lt,null,Gt(t.rgbaColors,(a,i)=>(S(),E("div",{key:t.colors[i],class:P([t.ns.e("color-selector"),t.ns.is("alpha",a._alpha<100),{selected:a.selected}]),onClick:l=>t.handleSelect(i)},[I("div",{style:ot({backgroundColor:a.value})},null,4)],10,XVe))),128))],2)],2)}var ZVe=je(qVe,[["render",YVe],["__file","/home/runner/work/element-plus/element-plus/packages/components/color-picker/src/components/predefine.vue"]]);const JVe=ue({name:"ElSlPanel",props:{color:{type:Object,required:!0}},setup(t){const e=Fe("color-svpanel"),n=Rt(),s=U(0),r=U(0),o=U("hsl(0, 100%, 50%)"),a=A(()=>{const u=t.color.get("hue"),c=t.color.get("value");return{hue:u,value:c}});function i(){const u=t.color.get("saturation"),c=t.color.get("value"),d=n.vnode.el,{clientWidth:f,clientHeight:h}=d;r.value=u*f/100,s.value=(100-c)*h/100,o.value=`hsl(${t.color.get("hue")}, 100%, 50%)`}function l(u){const d=n.vnode.el.getBoundingClientRect(),{clientX:f,clientY:h}=NC(u);let p=f-d.left,m=h-d.top;p=Math.max(0,p),p=Math.min(p,d.width),m=Math.max(0,m),m=Math.min(m,d.height),r.value=p,s.value=m,t.color.set({saturation:p/d.width*100,value:100-m/d.height*100})}return Me(()=>a.value,()=>{i()}),It(()=>{B0(n.vnode.el,{drag:u=>{l(u)},end:u=>{l(u)}}),i()}),{cursorTop:s,cursorLeft:r,background:o,colorValue:a,handleDrag:l,update:i,ns:e}}}),QVe=I("div",null,null,-1),eHe=[QVe];function tHe(t,e,n,s,r,o){return S(),E("div",{class:P(t.ns.b()),style:ot({backgroundColor:t.background})},[I("div",{class:P(t.ns.e("white"))},null,2),I("div",{class:P(t.ns.e("black"))},null,2),I("div",{class:P(t.ns.e("cursor")),style:ot({top:t.cursorTop+"px",left:t.cursorLeft+"px"})},eHe,6)],6)}var nHe=je(JVe,[["render",tHe],["__file","/home/runner/work/element-plus/element-plus/packages/components/color-picker/src/components/sv-panel.vue"]]);const sHe=["id","aria-label","aria-labelledby","aria-description","tabindex","onKeydown"],rHe=ue({name:"ElColorPicker"}),oHe=ue({...rHe,props:WVe,emits:UVe,setup(t,{expose:e,emit:n}){const s=t,{t:r}=nn(),o=Fe("color"),{formItem:a}=to(),i=ks(),l=To(),{inputId:u,isLabeledByFormItem:c}=ic(s,{formItemContext:a}),d=U(),f=U(),h=U(),p=U();let m=!0;const g=on(new d0({enableAlpha:s.showAlpha,format:s.colorFormat||"",value:s.modelValue})),y=U(!1),w=U(!1),b=U(""),_=A(()=>!s.modelValue&&!w.value?"transparent":C(g,s.showAlpha)),$=A(()=>!s.modelValue&&!w.value?"":g.value),x=A(()=>c.value?void 0:s.label||r("el.colorpicker.defaultLabel")),k=A(()=>c.value?a==null?void 0:a.labelId:void 0);function C(O,F){if(!(O instanceof d0))throw new TypeError("color should be instance of _color Class");const{r:L,g:G,b:Z}=O.toRgb();return F?`rgba(${L}, ${G}, ${Z}, ${O.get("alpha")/100})`:`rgb(${L}, ${G}, ${Z})`}function T(O){y.value=O}const N=Xr(T,100);function M(){N(!1),R()}function R(){nt(()=>{s.modelValue?g.fromString(s.modelValue):(g.value="",nt(()=>{w.value=!1}))})}function D(){l.value||N(!y.value)}function z(){g.fromString(b.value)}function B(){const O=g.value;n(Ot,O),n("change",O),s.validateEvent&&(a==null||a.validate("change").catch(F=>void 0)),N(!1),nt(()=>{const F=new d0({enableAlpha:s.showAlpha,format:s.colorFormat||"",value:s.modelValue});g.compare(F)||R()})}function V(){N(!1),n(Ot,null),n("change",null),s.modelValue!==null&&s.validateEvent&&(a==null||a.validate("change").catch(O=>void 0)),R()}return It(()=>{s.modelValue&&(b.value=$.value)}),Me(()=>s.modelValue,O=>{O?O&&O!==g.value&&(m=!1,g.fromString(O)):w.value=!1}),Me(()=>$.value,O=>{b.value=O,m&&n("activeChange",O),m=!0}),Me(()=>g.value,()=>{!s.modelValue&&!w.value&&(w.value=!0)}),Me(()=>y.value,()=>{nt(()=>{var O,F,L;(O=d.value)==null||O.update(),(F=f.value)==null||F.update(),(L=h.value)==null||L.update()})}),Lt($z,{currentColor:$}),e({color:g}),(O,F)=>(S(),$e(v(No),{ref_key:"popper",ref:p,visible:y.value,"show-arrow":!1,"fallback-placements":["bottom","top","right","left"],offset:0,"gpu-acceleration":!1,"popper-class":[v(o).be("picker","panel"),v(o).b("dropdown"),O.popperClass],"stop-popper-mouse-event":!1,effect:"light",trigger:"click",transition:`${v(o).namespace.value}-zoom-in-top`,persistent:""},{content:ce(()=>[St((S(),E("div",null,[I("div",{class:P(v(o).be("dropdown","main-wrapper"))},[se(HVe,{ref_key:"hue",ref:d,class:"hue-slider",color:v(g),vertical:""},null,8,["color"]),se(nHe,{ref:"svPanel",color:v(g)},null,8,["color"])],2),O.showAlpha?(S(),$e(zVe,{key:0,ref_key:"alpha",ref:h,color:v(g)},null,8,["color"])):ge("v-if",!0),O.predefine?(S(),$e(ZVe,{key:1,ref:"predefine",color:v(g),colors:O.predefine},null,8,["color","colors"])):ge("v-if",!0),I("div",{class:P(v(o).be("dropdown","btns"))},[I("span",{class:P(v(o).be("dropdown","value"))},[se(v(Or),{modelValue:b.value,"onUpdate:modelValue":F[0]||(F[0]=L=>b.value=L),"validate-event":!1,size:"small",onKeyup:qt(z,["enter"]),onBlur:z},null,8,["modelValue","onKeyup"])],2),se(v(br),{class:P(v(o).be("dropdown","link-btn")),text:"",size:"small",onClick:V},{default:ce(()=>[Yt(Ue(v(r)("el.colorpicker.clear")),1)]),_:1},8,["class"]),se(v(br),{plain:"",size:"small",class:P(v(o).be("dropdown","btn")),onClick:B},{default:ce(()=>[Yt(Ue(v(r)("el.colorpicker.confirm")),1)]),_:1},8,["class"])],2)])),[[v(Ku),M]])]),default:ce(()=>[I("div",{id:v(u),class:P([v(o).b("picker"),v(o).is("disabled",v(l)),v(o).bm("picker",v(i))]),role:"button","aria-label":v(x),"aria-labelledby":v(k),"aria-description":v(r)("el.colorpicker.description",{color:O.modelValue||""}),tabindex:O.tabindex,onKeydown:qt(D,["enter"])},[v(l)?(S(),E("div",{key:0,class:P(v(o).be("picker","mask"))},null,2)):ge("v-if",!0),I("div",{class:P(v(o).be("picker","trigger")),onClick:D},[I("span",{class:P([v(o).be("picker","color"),v(o).is("alpha",O.showAlpha)])},[I("span",{class:P(v(o).be("picker","color-inner")),style:ot({backgroundColor:v(_)})},[St(se(v(rt),{class:P([v(o).be("picker","icon"),v(o).is("icon-arrow-down")])},{default:ce(()=>[se(v(zl))]),_:1},8,["class"]),[[Qt,O.modelValue||w.value]]),!O.modelValue&&!w.value?(S(),$e(v(rt),{key:0,class:P([v(o).be("picker","empty"),v(o).is("icon-close")])},{default:ce(()=>[se(v(xa))]),_:1},8,["class"])):ge("v-if",!0)],6)],2)],2)],42,sHe)]),_:1},8,["visible","popper-class","transition"]))}});var aHe=je(oHe,[["__file","/home/runner/work/element-plus/element-plus/packages/components/color-picker/src/color-picker.vue"]]);const iHe=Dt(aHe),E6={},lHe=qe({a11y:{type:Boolean,default:!0},locale:{type:Se(Object)},size:wo,button:{type:Se(Object)},experimentalFeatures:{type:Se(Object)},keyboardNavigation:{type:Boolean,default:!0},message:{type:Se(Object)},zIndex:Number,namespace:{type:String,default:"el"}}),uHe=ue({name:"ElConfigProvider",props:lHe,setup(t,{slots:e}){Me(()=>t.message,s=>{Object.assign(E6,s??{})},{immediate:!0,deep:!0});const n=YP(t);return()=>Oe(e,"default",{config:n==null?void 0:n.value})}}),cHe=Dt(uHe),dHe=ue({name:"ElContainer"}),fHe=ue({...dHe,props:{direction:{type:String}},setup(t){const e=t,n=ir(),s=Fe("container"),r=A(()=>e.direction==="vertical"?!0:e.direction==="horizontal"?!1:n&&n.default?n.default().some(a=>{const i=a.type.name;return i==="ElHeader"||i==="ElFooter"}):!1);return(o,a)=>(S(),E("section",{class:P([v(s).b(),v(s).is("vertical",v(r))])},[Oe(o.$slots,"default")],2))}});var hHe=je(fHe,[["__file","/home/runner/work/element-plus/element-plus/packages/components/container/src/container.vue"]]);const pHe=ue({name:"ElAside"}),mHe=ue({...pHe,props:{width:{type:String,default:null}},setup(t){const e=t,n=Fe("aside"),s=A(()=>e.width?n.cssVarBlock({width:e.width}):{});return(r,o)=>(S(),E("aside",{class:P(v(n).b()),style:ot(v(s))},[Oe(r.$slots,"default")],6))}});var xz=je(mHe,[["__file","/home/runner/work/element-plus/element-plus/packages/components/container/src/aside.vue"]]);const gHe=ue({name:"ElFooter"}),vHe=ue({...gHe,props:{height:{type:String,default:null}},setup(t){const e=t,n=Fe("footer"),s=A(()=>e.height?n.cssVarBlock({height:e.height}):{});return(r,o)=>(S(),E("footer",{class:P(v(n).b()),style:ot(v(s))},[Oe(r.$slots,"default")],6))}});var Sz=je(vHe,[["__file","/home/runner/work/element-plus/element-plus/packages/components/container/src/footer.vue"]]);const yHe=ue({name:"ElHeader"}),bHe=ue({...yHe,props:{height:{type:String,default:null}},setup(t){const e=t,n=Fe("header"),s=A(()=>e.height?n.cssVarBlock({height:e.height}):{});return(r,o)=>(S(),E("header",{class:P(v(n).b()),style:ot(v(s))},[Oe(r.$slots,"default")],6))}});var Cz=je(bHe,[["__file","/home/runner/work/element-plus/element-plus/packages/components/container/src/header.vue"]]);const wHe=ue({name:"ElMain"}),_He=ue({...wHe,setup(t){const e=Fe("main");return(n,s)=>(S(),E("main",{class:P(v(e).b())},[Oe(n.$slots,"default")],2))}});var kz=je(_He,[["__file","/home/runner/work/element-plus/element-plus/packages/components/container/src/main.vue"]]);const $He=Dt(hHe,{Aside:xz,Footer:Sz,Header:Cz,Main:kz}),xHe=ns(xz),SHe=ns(Sz),CHe=ns(Cz),kHe=ns(kz);var Tz={exports:{}};(function(t,e){(function(n,s){t.exports=s()})(wn,function(){return function(n,s){var r=s.prototype,o=r.format;r.format=function(a){var i=this,l=this.$locale();if(!this.isValid())return o.bind(this)(a);var u=this.$utils(),c=(a||"YYYY-MM-DDTHH:mm:ssZ").replace(/\[([^\]]+)]|Q|wo|ww|w|WW|W|zzz|z|gggg|GGGG|Do|X|x|k{1,2}|S/g,function(d){switch(d){case"Q":return Math.ceil((i.$M+1)/3);case"Do":return l.ordinal(i.$D);case"gggg":return i.weekYear();case"GGGG":return i.isoWeekYear();case"wo":return l.ordinal(i.week(),"W");case"w":case"ww":return u.s(i.week(),d==="w"?1:2,"0");case"W":case"WW":return u.s(i.isoWeek(),d==="W"?1:2,"0");case"k":case"kk":return u.s(String(i.$H===0?24:i.$H),d==="k"?1:2,"0");case"X":return Math.floor(i.$d.getTime()/1e3);case"x":return i.$d.getTime();case"z":return"["+i.offsetName()+"]";case"zzz":return"["+i.offsetName("long")+"]";default:return d}});return o.bind(this)(c)}}})})(Tz);const THe=Tz.exports;var Nz={exports:{}};(function(t,e){(function(n,s){t.exports=s()})(wn,function(){var n="week",s="year";return function(r,o,a){var i=o.prototype;i.week=function(l){if(l===void 0&&(l=null),l!==null)return this.add(7*(l-this.week()),"day");var u=this.$locale().yearStart||1;if(this.month()===11&&this.date()>25){var c=a(this).startOf(s).add(1,s).date(u),d=a(this).endOf(n);if(c.isBefore(d))return 1}var f=a(this).startOf(s).date(u).startOf(n).subtract(1,"millisecond"),h=this.diff(f,n,!0);return h<0?a(this).startOf("week").week():Math.ceil(h)},i.weeks=function(l){return l===void 0&&(l=null),this.week(l)}}})})(Nz);const NHe=Nz.exports;var Iz={exports:{}};(function(t,e){(function(n,s){t.exports=s()})(wn,function(){return function(n,s){s.prototype.weekYear=function(){var r=this.month(),o=this.week(),a=this.year();return o===1&&r===11?a+1:r===0&&o>=52?a-1:a}}})})(Iz);const IHe=Iz.exports;var Ez={exports:{}};(function(t,e){(function(n,s){t.exports=s()})(wn,function(){return function(n,s,r){s.prototype.dayOfYear=function(o){var a=Math.round((r(this).startOf("day")-r(this).startOf("year"))/864e5)+1;return o==null?a:this.add(o-a,"day")}}})})(Ez);const EHe=Ez.exports;var Az={exports:{}};(function(t,e){(function(n,s){t.exports=s()})(wn,function(){return function(n,s){s.prototype.isSameOrAfter=function(r,o){return this.isSame(r,o)||this.isAfter(r,o)}}})})(Az);const AHe=Az.exports;var Oz={exports:{}};(function(t,e){(function(n,s){t.exports=s()})(wn,function(){return function(n,s){s.prototype.isSameOrBefore=function(r,o){return this.isSame(r,o)||this.isBefore(r,o)}}})})(Oz);const OHe=Oz.exports,RHe=qe({type:{type:Se(String),default:"date"}}),DHe=["date","dates","year","month","week","range"],uk=qe({disabledDate:{type:Se(Function)},date:{type:Se(Object),required:!0},minDate:{type:Se(Object)},maxDate:{type:Se(Object)},parsedValue:{type:Se([Object,Array])},rangeState:{type:Se(Object),default:()=>({endDate:null,selecting:!1})}}),Rz=qe({type:{type:Se(String),required:!0,values:P9e}}),Dz=qe({unlinkPanels:Boolean,parsedValue:{type:Se(Array)}}),Fz=t=>({type:String,values:DHe,default:t}),FHe=qe({...Rz,parsedValue:{type:Se([Object,Array])},visible:{type:Boolean},format:{type:String,default:""}}),MHe=qe({...uk,cellClassName:{type:Se(Function)},showWeekNumber:Boolean,selectionMode:Fz("date")}),A6=t=>{if(!Qe(t))return!1;const[e,n]=t;return Nt.isDayjs(e)&&Nt.isDayjs(n)&&e.isSameOrBefore(n)},Mz=(t,{lang:e,unit:n,unlinkPanels:s})=>{let r;if(Qe(t)){let[o,a]=t.map(i=>Nt(i).locale(e));return s||(a=o.add(1,n)),[o,a]}else t?r=Nt(t):r=Nt();return r=r.locale(e),[r,r.add(1,n)]},PHe=(t,e,{columnIndexOffset:n,startDate:s,nextEndDate:r,now:o,unit:a,relativeDateGetter:i,setCellMetadata:l,setRowMetadata:u})=>{for(let c=0;c<t.row;c++){const d=e[c];for(let f=0;f<t.column;f++){let h=d[f+n];h||(h={row:c,column:f,type:"normal",inRange:!1,start:!1,end:!1});const p=c*t.column+f,m=i(p);h.dayjs=m,h.date=m.toDate(),h.timestamp=m.valueOf(),h.type="normal",h.inRange=!!(s&&m.isSameOrAfter(s,a)&&r&&m.isSameOrBefore(r,a))||!!(s&&m.isSameOrBefore(s,a)&&r&&m.isSameOrAfter(r,a)),s!=null&&s.isSameOrAfter(r)?(h.start=!!r&&m.isSame(r,a),h.end=s&&m.isSame(s,a)):(h.start=!!s&&m.isSame(s,a),h.end=!!r&&m.isSame(r,a)),m.isSame(o,a)&&(h.type="today"),l==null||l(h,{rowIndex:c,columnIndex:f}),d[f+n]=h}u==null||u(d)}},LHe=qe({cell:{type:Se(Object)}});var zHe=ue({name:"ElDatePickerCell",props:LHe,setup(t){const e=Fe("date-table-cell"),{slots:n}=et(VC);return()=>{const{cell:s}=t;if(n.default){const r=n.default(s).filter(o=>o.patchFlag!==-2&&o.type.toString()!=="Symbol(Comment)");if(r.length)return r}return se("div",{class:e.b()},[se("span",{class:e.e("text")},[s==null?void 0:s.text])])}}});const BHe=["aria-label"],VHe={key:0,scope:"col"},HHe=["aria-label"],WHe=["aria-current","aria-selected","tabindex"],UHe=ue({__name:"basic-date-table",props:MHe,emits:["changerange","pick","select"],setup(t,{expose:e,emit:n}){const s=t,r=Fe("date-table"),{t:o,lang:a}=nn(),i=U(),l=U(),u=U(),c=U(),d=U([[],[],[],[],[],[]]);let f=!1;const h=s.date.$locale().weekStart||7,p=s.date.locale("en").localeData().weekdaysShort().map(j=>j.toLowerCase()),m=A(()=>h>3?7-h:-h),g=A(()=>{const j=s.date.startOf("month");return j.subtract(j.day()||7,"day")}),y=A(()=>p.concat(p).slice(h,h+7)),w=A(()=>zM(C.value).some(j=>j.isCurrent)),b=A(()=>{const j=s.date.startOf("month"),J=j.day()||7,fe=j.daysInMonth(),X=j.subtract(1,"month").daysInMonth();return{startOfMonthDay:J,dateCountOfMonth:fe,dateCountOfLastMonth:X}}),_=A(()=>s.selectionMode==="dates"?vl(s.parsedValue):[]),$=(j,{count:J,rowIndex:fe,columnIndex:X})=>{const{startOfMonthDay:oe,dateCountOfMonth:ee,dateCountOfLastMonth:Q}=v(b),ie=v(m);if(fe>=0&&fe<=1){const pe=oe+ie<0?7+oe+ie:oe+ie;if(X+fe*7>=pe)return j.text=J,!0;j.text=Q-(pe-X%7)+1+fe*7,j.type="prev-month"}else return J<=ee?j.text=J:(j.text=J-ee,j.type="next-month"),!0;return!1},x=(j,{columnIndex:J,rowIndex:fe},X)=>{const{disabledDate:oe,cellClassName:ee}=s,Q=v(_),ie=$(j,{count:X,rowIndex:fe,columnIndex:J}),pe=j.dayjs.toDate();return j.selected=Q.find(Re=>Re.valueOf()===j.dayjs.valueOf()),j.isSelected=!!j.selected,j.isCurrent=M(j),j.disabled=oe==null?void 0:oe(pe),j.customClass=ee==null?void 0:ee(pe),ie},k=j=>{if(s.selectionMode==="week"){const[J,fe]=s.showWeekNumber?[1,7]:[0,6],X=Z(j[J+1]);j[J].inRange=X,j[J].start=X,j[fe].inRange=X,j[fe].end=X}},C=A(()=>{const{minDate:j,maxDate:J,rangeState:fe,showWeekNumber:X}=s,oe=m.value,ee=d.value,Q="day";let ie=1;if(X)for(let pe=0;pe<6;pe++)ee[pe][0]||(ee[pe][0]={type:"week",text:g.value.add(pe*7+1,Q).week()});return PHe({row:6,column:7},ee,{startDate:j,columnIndexOffset:X?1:0,nextEndDate:fe.endDate||J||fe.selecting&&j||null,now:Nt().locale(v(a)).startOf(Q),unit:Q,relativeDateGetter:pe=>g.value.add(pe-oe,Q),setCellMetadata:(...pe)=>{x(...pe,ie)&&(ie+=1)},setRowMetadata:k}),ee});Me(()=>s.date,async()=>{var j,J;(j=i.value)!=null&&j.contains(document.activeElement)&&(await nt(),(J=l.value)==null||J.focus())});const T=async()=>{var j;(j=l.value)==null||j.focus()},N=(j="")=>["normal","today"].includes(j),M=j=>s.selectionMode==="date"&&N(j.type)&&R(j,s.parsedValue),R=(j,J)=>J?Nt(J).locale(a.value).isSame(s.date.date(Number(j.text)),"day"):!1,D=j=>{const J=[];return N(j.type)&&!j.disabled?(J.push("available"),j.type==="today"&&J.push("today")):J.push(j.type),M(j)&&J.push("current"),j.inRange&&(N(j.type)||s.selectionMode==="week")&&(J.push("in-range"),j.start&&J.push("start-date"),j.end&&J.push("end-date")),j.disabled&&J.push("disabled"),j.selected&&J.push("selected"),j.customClass&&J.push(j.customClass),J.join(" ")},z=(j,J)=>{const fe=j*7+(J-(s.showWeekNumber?1:0))-m.value;return g.value.add(fe,"day")},B=j=>{var J;if(!s.rangeState.selecting)return;let fe=j.target;if(fe.tagName==="SPAN"&&(fe=(J=fe.parentNode)==null?void 0:J.parentNode),fe.tagName==="DIV"&&(fe=fe.parentNode),fe.tagName!=="TD")return;const X=fe.parentNode.rowIndex-1,oe=fe.cellIndex;C.value[X][oe].disabled||(X!==u.value||oe!==c.value)&&(u.value=X,c.value=oe,n("changerange",{selecting:!0,endDate:z(X,oe)}))},V=j=>!w.value&&(j==null?void 0:j.text)===1&&j.type==="normal"||j.isCurrent,O=j=>{f||w.value||s.selectionMode!=="date"||G(j,!0)},F=j=>{!j.target.closest("td")||(f=!0)},L=j=>{!j.target.closest("td")||(f=!1)},G=(j,J=!1)=>{const fe=j.target.closest("td");if(!fe)return;const X=fe.parentNode.rowIndex-1,oe=fe.cellIndex,ee=C.value[X][oe];if(ee.disabled||ee.type==="week")return;const Q=z(X,oe);if(s.selectionMode==="range")!s.rangeState.selecting||!s.minDate?(n("pick",{minDate:Q,maxDate:null}),n("select",!0)):(Q>=s.minDate?n("pick",{minDate:s.minDate,maxDate:Q}):n("pick",{minDate:Q,maxDate:s.minDate}),n("select",!1));else if(s.selectionMode==="date")n("pick",Q,J);else if(s.selectionMode==="week"){const ie=Q.week(),pe=`${Q.year()}w${ie}`;n("pick",{year:Q.year(),week:ie,value:pe,date:Q.startOf("week")})}else if(s.selectionMode==="dates"){const ie=ee.selected?vl(s.parsedValue).filter(pe=>(pe==null?void 0:pe.valueOf())!==Q.valueOf()):vl(s.parsedValue).concat([Q]);n("pick",ie)}},Z=j=>{if(s.selectionMode!=="week")return!1;let J=s.date.startOf("day");if(j.type==="prev-month"&&(J=J.subtract(1,"month")),j.type==="next-month"&&(J=J.add(1,"month")),J=J.date(Number.parseInt(j.text,10)),s.parsedValue&&!Array.isArray(s.parsedValue)){const fe=(s.parsedValue.day()-h+7)%7-1;return s.parsedValue.subtract(fe,"day").isSame(J,"day")}return!1};return e({focus:T}),(j,J)=>(S(),E("table",{role:"grid","aria-label":v(o)("el.datepicker.dateTablePrompt"),cellspacing:"0",cellpadding:"0",class:P([v(r).b(),{"is-week-mode":j.selectionMode==="week"}]),onClick:G,onMousemove:B,onMousedown:F,onMouseup:L},[I("tbody",{ref_key:"tbodyRef",ref:i},[I("tr",null,[j.showWeekNumber?(S(),E("th",VHe,Ue(v(o)("el.datepicker.week")),1)):ge("v-if",!0),(S(!0),E(lt,null,Gt(v(y),(fe,X)=>(S(),E("th",{key:X,scope:"col","aria-label":v(o)("el.datepicker.weeksFull."+fe)},Ue(v(o)("el.datepicker.weeks."+fe)),9,HHe))),128))]),(S(!0),E(lt,null,Gt(v(C),(fe,X)=>(S(),E("tr",{key:X,class:P([v(r).e("row"),{current:Z(fe[1])}])},[(S(!0),E(lt,null,Gt(fe,(oe,ee)=>(S(),E("td",{key:`${X}.${ee}`,ref_for:!0,ref:Q=>V(oe)&&(l.value=Q),class:P(D(oe)),"aria-current":oe.isCurrent?"date":void 0,"aria-selected":oe.isCurrent,tabindex:V(oe)?0:-1,onFocus:O},[se(v(zHe),{cell:oe},null,8,["cell"])],42,WHe))),128))],2))),128))],512)],42,BHe))}});var O6=je(UHe,[["__file","/home/runner/work/element-plus/element-plus/packages/components/date-picker/src/date-picker-com/basic-date-table.vue"]]);const GHe=qe({...uk,selectionMode:Fz("month")}),jHe=["aria-label"],KHe=["aria-selected","aria-label","tabindex","onKeydown"],qHe={class:"cell"},XHe=ue({__name:"basic-month-table",props:GHe,emits:["changerange","pick","select"],setup(t,{expose:e,emit:n}){const s=t,r=(_,$,x)=>{const k=Nt().locale(x).startOf("month").month($).year(_),C=k.daysInMonth();return Du(C).map(T=>k.add(T,"day").toDate())},o=Fe("month-table"),{t:a,lang:i}=nn(),l=U(),u=U(),c=U(s.date.locale("en").localeData().monthsShort().map(_=>_.toLowerCase())),d=U([[],[],[]]),f=U(),h=U(),p=A(()=>{var _,$;const x=d.value,k=Nt().locale(i.value).startOf("month");for(let C=0;C<3;C++){const T=x[C];for(let N=0;N<4;N++){const M=T[N]||(T[N]={row:C,column:N,type:"normal",inRange:!1,start:!1,end:!1,text:-1,disabled:!1});M.type="normal";const R=C*4+N,D=s.date.startOf("year").month(R),z=s.rangeState.endDate||s.maxDate||s.rangeState.selecting&&s.minDate||null;M.inRange=!!(s.minDate&&D.isSameOrAfter(s.minDate,"month")&&z&&D.isSameOrBefore(z,"month"))||!!(s.minDate&&D.isSameOrBefore(s.minDate,"month")&&z&&D.isSameOrAfter(z,"month")),(_=s.minDate)!=null&&_.isSameOrAfter(z)?(M.start=!!(z&&D.isSame(z,"month")),M.end=s.minDate&&D.isSame(s.minDate,"month")):(M.start=!!(s.minDate&&D.isSame(s.minDate,"month")),M.end=!!(z&&D.isSame(z,"month"))),k.isSame(D)&&(M.type="today"),M.text=R,M.disabled=(($=s.disabledDate)==null?void 0:$.call(s,D.toDate()))||!1}}return x}),m=()=>{var _;(_=u.value)==null||_.focus()},g=_=>{const $={},x=s.date.year(),k=new Date,C=_.text;return $.disabled=s.disabledDate?r(x,C,i.value).every(s.disabledDate):!1,$.current=vl(s.parsedValue).findIndex(T=>Nt.isDayjs(T)&&T.year()===x&&T.month()===C)>=0,$.today=k.getFullYear()===x&&k.getMonth()===C,_.inRange&&($["in-range"]=!0,_.start&&($["start-date"]=!0),_.end&&($["end-date"]=!0)),$},y=_=>{const $=s.date.year(),x=_.text;return vl(s.date).findIndex(k=>k.year()===$&&k.month()===x)>=0},w=_=>{var $;if(!s.rangeState.selecting)return;let x=_.target;if(x.tagName==="A"&&(x=($=x.parentNode)==null?void 0:$.parentNode),x.tagName==="DIV"&&(x=x.parentNode),x.tagName!=="TD")return;const k=x.parentNode.rowIndex,C=x.cellIndex;p.value[k][C].disabled||(k!==f.value||C!==h.value)&&(f.value=k,h.value=C,n("changerange",{selecting:!0,endDate:s.date.startOf("year").month(k*4+C)}))},b=_=>{var $;const x=($=_.target)==null?void 0:$.closest("td");if((x==null?void 0:x.tagName)!=="TD"||ja(x,"disabled"))return;const k=x.cellIndex,T=x.parentNode.rowIndex*4+k,N=s.date.startOf("year").month(T);s.selectionMode==="range"?s.rangeState.selecting?(s.minDate&&N>=s.minDate?n("pick",{minDate:s.minDate,maxDate:N}):n("pick",{minDate:N,maxDate:s.minDate}),n("select",!1)):(n("pick",{minDate:N,maxDate:null}),n("select",!0)):n("pick",T)};return Me(()=>s.date,async()=>{var _,$;(_=l.value)!=null&&_.contains(document.activeElement)&&(await nt(),($=u.value)==null||$.focus())}),e({focus:m}),(_,$)=>(S(),E("table",{role:"grid","aria-label":v(a)("el.datepicker.monthTablePrompt"),class:P(v(o).b()),onClick:b,onMousemove:w},[I("tbody",{ref_key:"tbodyRef",ref:l},[(S(!0),E(lt,null,Gt(v(p),(x,k)=>(S(),E("tr",{key:k},[(S(!0),E(lt,null,Gt(x,(C,T)=>(S(),E("td",{key:T,ref_for:!0,ref:N=>y(C)&&(u.value=N),class:P(g(C)),"aria-selected":`${y(C)}`,"aria-label":v(a)(`el.datepicker.month${+C.text+1}`),tabindex:y(C)?0:-1,onKeydown:[qt(yt(b,["prevent","stop"]),["space"]),qt(yt(b,["prevent","stop"]),["enter"])]},[I("div",null,[I("span",qHe,Ue(v(a)("el.datepicker.months."+c.value[C.text])),1)])],42,KHe))),128))]))),128))],512)],42,jHe))}});var R6=je(XHe,[["__file","/home/runner/work/element-plus/element-plus/packages/components/date-picker/src/date-picker-com/basic-month-table.vue"]]);const{date:YHe,disabledDate:ZHe,parsedValue:JHe}=uk,QHe=qe({date:YHe,disabledDate:ZHe,parsedValue:JHe}),eWe=["aria-label"],tWe=["aria-selected","tabindex","onKeydown"],nWe={class:"cell"},sWe={key:1},rWe=ue({__name:"basic-year-table",props:QHe,emits:["pick"],setup(t,{expose:e,emit:n}){const s=t,r=(m,g)=>{const y=Nt(String(m)).locale(g).startOf("year"),b=y.endOf("year").dayOfYear();return Du(b).map(_=>y.add(_,"day").toDate())},o=Fe("year-table"),{t:a,lang:i}=nn(),l=U(),u=U(),c=A(()=>Math.floor(s.date.year()/10)*10),d=()=>{var m;(m=u.value)==null||m.focus()},f=m=>{const g={},y=Nt().locale(i.value);return g.disabled=s.disabledDate?r(m,i.value).every(s.disabledDate):!1,g.current=vl(s.parsedValue).findIndex(w=>w.year()===m)>=0,g.today=y.year()===m,g},h=m=>m===c.value&&s.date.year()<c.value&&s.date.year()>c.value+9||vl(s.date).findIndex(g=>g.year()===m)>=0,p=m=>{const y=m.target.closest("td");if(y&&y.textContent){if(ja(y,"disabled"))return;const w=y.textContent||y.innerText;n("pick",Number(w))}};return Me(()=>s.date,async()=>{var m,g;(m=l.value)!=null&&m.contains(document.activeElement)&&(await nt(),(g=u.value)==null||g.focus())}),e({focus:d}),(m,g)=>(S(),E("table",{role:"grid","aria-label":v(a)("el.datepicker.yearTablePrompt"),class:P(v(o).b()),onClick:p},[I("tbody",{ref_key:"tbodyRef",ref:l},[(S(),E(lt,null,Gt(3,(y,w)=>I("tr",{key:w},[(S(),E(lt,null,Gt(4,(b,_)=>(S(),E(lt,{key:w+"_"+_},[w*4+_<10?(S(),E("td",{key:0,ref_for:!0,ref:$=>h(v(c)+w*4+_)&&(u.value=$),class:P(["available",f(v(c)+w*4+_)]),"aria-selected":`${h(v(c)+w*4+_)}`,tabindex:h(v(c)+w*4+_)?0:-1,onKeydown:[qt(yt(p,["prevent","stop"]),["space"]),qt(yt(p,["prevent","stop"]),["enter"])]},[I("span",nWe,Ue(v(c)+w*4+_),1)],42,tWe)):(S(),E("td",sWe))],64))),64))])),64))],512)],10,eWe))}});var oWe=je(rWe,[["__file","/home/runner/work/element-plus/element-plus/packages/components/date-picker/src/date-picker-com/basic-year-table.vue"]]);const aWe=["onClick"],iWe=["aria-label"],lWe=["aria-label"],uWe=["aria-label"],cWe=["aria-label"],dWe=ue({__name:"panel-date-pick",props:FHe,emits:["pick","set-picker-option","panel-change"],setup(t,{emit:e}){const n=t,s=(xe,Ke,at)=>!0,r=Fe("picker-panel"),o=Fe("date-picker"),a=Tg(),i=ir(),{t:l,lang:u}=nn(),c=et("EP_PICKER_BASE"),d=et(mw),{shortcuts:f,disabledDate:h,cellClassName:p,defaultTime:m,arrowControl:g}=c.props,y=Un(c.props,"defaultValue"),w=U(),b=U(Nt().locale(u.value)),_=U(!1),$=A(()=>Nt(m).locale(u.value)),x=A(()=>b.value.month()),k=A(()=>b.value.year()),C=U([]),T=U(null),N=U(null),M=xe=>C.value.length>0?s(xe,C.value,n.format||"HH:mm:ss"):!0,R=xe=>m&&!K.value&&!_.value?$.value.year(xe.year()).month(xe.month()).date(xe.date()):oe.value?xe.millisecond(0):xe.startOf("day"),D=(xe,...Ke)=>{if(!xe)e("pick",xe,...Ke);else if(Qe(xe)){const at=xe.map(R);e("pick",at,...Ke)}else e("pick",R(xe),...Ke);T.value=null,N.value=null,_.value=!1},z=(xe,Ke)=>{if(G.value==="date"){xe=xe;let at=n.parsedValue?n.parsedValue.year(xe.year()).month(xe.month()).date(xe.date()):xe;M(at)||(at=C.value[0][0].year(xe.year()).month(xe.month()).date(xe.date())),b.value=at,D(at,oe.value||Ke)}else G.value==="week"?D(xe.date):G.value==="dates"&&D(xe,!0)},B=xe=>{const Ke=xe?"add":"subtract";b.value=b.value[Ke](1,"month"),dt("month")},V=xe=>{const Ke=b.value,at=xe?"add":"subtract";b.value=O.value==="year"?Ke[at](10,"year"):Ke[at](1,"year"),dt("year")},O=U("date"),F=A(()=>{const xe=l("el.datepicker.year");if(O.value==="year"){const Ke=Math.floor(k.value/10)*10;return xe?`${Ke} ${xe} - ${Ke+9} ${xe}`:`${Ke} - ${Ke+9}`}return`${k.value} ${xe}`}),L=xe=>{const Ke=vt(xe.value)?xe.value():xe.value;if(Ke){D(Nt(Ke).locale(u.value));return}xe.onClick&&xe.onClick({attrs:a,slots:i,emit:e})},G=A(()=>{const{type:xe}=n;return["week","month","year","dates"].includes(xe)?xe:"date"}),Z=A(()=>G.value==="date"?O.value:G.value),j=A(()=>!!f.length),J=async xe=>{b.value=b.value.startOf("month").month(xe),G.value==="month"?D(b.value,!1):(O.value="date",["month","year","date","week"].includes(G.value)&&(D(b.value,!0),await nt(),Je())),dt("month")},fe=async xe=>{G.value==="year"?(b.value=b.value.startOf("year").year(xe),D(b.value,!1)):(b.value=b.value.year(xe),O.value="month",["month","year","date","week"].includes(G.value)&&(D(b.value,!0),await nt(),Je())),dt("year")},X=async xe=>{O.value=xe,await nt(),Je()},oe=A(()=>n.type==="datetime"||n.type==="datetimerange"),ee=A(()=>oe.value||G.value==="dates"),Q=()=>{if(G.value==="dates")D(n.parsedValue);else{let xe=n.parsedValue;if(!xe){const Ke=Nt(m).locale(u.value),at=Ye();xe=Ke.year(at.year()).month(at.month()).date(at.date())}b.value=xe,D(xe)}},ie=()=>{const Ke=Nt().locale(u.value).toDate();_.value=!0,(!h||!h(Ke))&&M(Ke)&&(b.value=Nt().locale(u.value),D(b.value))},pe=A(()=>WL(n.format)),Re=A(()=>HL(n.format)),K=A(()=>{if(N.value)return N.value;if(!(!n.parsedValue&&!y.value))return(n.parsedValue||b.value).format(pe.value)}),re=A(()=>{if(T.value)return T.value;if(!(!n.parsedValue&&!y.value))return(n.parsedValue||b.value).format(Re.value)}),we=U(!1),Ee=()=>{we.value=!0},De=()=>{we.value=!1},_e=xe=>({hour:xe.hour(),minute:xe.minute(),second:xe.second(),year:xe.year(),month:xe.month(),date:xe.date()}),ze=(xe,Ke,at)=>{const{hour:Y,minute:de,second:Pe}=_e(xe),We=n.parsedValue?n.parsedValue.hour(Y).minute(de).second(Pe):xe;b.value=We,D(b.value,!0),at||(we.value=Ke)},Ae=xe=>{const Ke=Nt(xe,pe.value).locale(u.value);if(Ke.isValid()&&M(Ke)){const{year:at,month:Y,date:de}=_e(b.value);b.value=Ke.year(at).month(Y).date(de),N.value=null,we.value=!1,D(b.value,!0)}},he=xe=>{const Ke=Nt(xe,Re.value).locale(u.value);if(Ke.isValid()){if(h&&h(Ke.toDate()))return;const{hour:at,minute:Y,second:de}=_e(b.value);b.value=Ke.hour(at).minute(Y).second(de),T.value=null,D(b.value,!0)}},ve=xe=>Nt.isDayjs(xe)&&xe.isValid()&&(h?!h(xe.toDate()):!0),me=xe=>G.value==="dates"?xe.map(Ke=>Ke.format(n.format)):xe.format(n.format),Ve=xe=>Nt(xe,n.format).locale(u.value),Ye=()=>{const xe=Nt(y.value).locale(u.value);if(!y.value){const Ke=$.value;return Nt().hour(Ke.hour()).minute(Ke.minute()).second(Ke.second()).locale(u.value)}return xe},Je=async()=>{var xe;["week","month","year","date"].includes(G.value)&&((xe=w.value)==null||xe.focus(),G.value==="week"&&xt(ut.down))},ct=xe=>{const{code:Ke}=xe;[ut.up,ut.down,ut.left,ut.right,ut.home,ut.end,ut.pageUp,ut.pageDown].includes(Ke)&&(xt(Ke),xe.stopPropagation(),xe.preventDefault()),[ut.enter,ut.space].includes(Ke)&&T.value===null&&N.value===null&&(xe.preventDefault(),D(b.value,!1))},xt=xe=>{var Ke;const{up:at,down:Y,left:de,right:Pe,home:We,end:Ft,pageUp:_n,pageDown:_s}=ut,qs={year:{[at]:-4,[Y]:4,[de]:-1,[Pe]:1,offset:(sn,He)=>sn.setFullYear(sn.getFullYear()+He)},month:{[at]:-4,[Y]:4,[de]:-1,[Pe]:1,offset:(sn,He)=>sn.setMonth(sn.getMonth()+He)},week:{[at]:-1,[Y]:1,[de]:-1,[Pe]:1,offset:(sn,He)=>sn.setDate(sn.getDate()+He*7)},date:{[at]:-7,[Y]:7,[de]:-1,[Pe]:1,[We]:sn=>-sn.getDay(),[Ft]:sn=>-sn.getDay()+6,[_n]:sn=>-new Date(sn.getFullYear(),sn.getMonth(),0).getDate(),[_s]:sn=>new Date(sn.getFullYear(),sn.getMonth()+1,0).getDate(),offset:(sn,He)=>sn.setDate(sn.getDate()+He)}},Sn=b.value.toDate();for(;Math.abs(b.value.diff(Sn,"year",!0))<1;){const sn=qs[Z.value];if(!sn)return;if(sn.offset(Sn,vt(sn[xe])?sn[xe](Sn):(Ke=sn[xe])!=null?Ke:0),h&&h(Sn))break;const He=Nt(Sn).locale(u.value);b.value=He,e("pick",He,!0);break}},dt=xe=>{e("panel-change",b.value.toDate(),xe,O.value)};return Me(()=>G.value,xe=>{if(["month","year"].includes(xe)){O.value=xe;return}O.value="date"},{immediate:!0}),Me(()=>O.value,()=>{d==null||d.updatePopper()}),Me(()=>y.value,xe=>{xe&&(b.value=Ye())},{immediate:!0}),Me(()=>n.parsedValue,xe=>{if(xe){if(G.value==="dates"||Array.isArray(xe))return;b.value=xe}else b.value=Ye()},{immediate:!0}),e("set-picker-option",["isValidValue",ve]),e("set-picker-option",["formatToString",me]),e("set-picker-option",["parseUserInput",Ve]),e("set-picker-option",["handleFocusPicker",Je]),(xe,Ke)=>(S(),E("div",{class:P([v(r).b(),v(o).b(),{"has-sidebar":xe.$slots.sidebar||v(j),"has-time":v(oe)}])},[I("div",{class:P(v(r).e("body-wrapper"))},[Oe(xe.$slots,"sidebar",{class:P(v(r).e("sidebar"))}),v(j)?(S(),E("div",{key:0,class:P(v(r).e("sidebar"))},[(S(!0),E(lt,null,Gt(v(f),(at,Y)=>(S(),E("button",{key:Y,type:"button",class:P(v(r).e("shortcut")),onClick:de=>L(at)},Ue(at.text),11,aWe))),128))],2)):ge("v-if",!0),I("div",{class:P(v(r).e("body"))},[v(oe)?(S(),E("div",{key:0,class:P(v(o).e("time-header"))},[I("span",{class:P(v(o).e("editor-wrap"))},[se(v(Or),{placeholder:v(l)("el.datepicker.selectDate"),"model-value":v(re),size:"small","validate-event":!1,onInput:Ke[0]||(Ke[0]=at=>T.value=at),onChange:he},null,8,["placeholder","model-value"])],2),St((S(),E("span",{class:P(v(o).e("editor-wrap"))},[se(v(Or),{placeholder:v(l)("el.datepicker.selectTime"),"model-value":v(K),size:"small","validate-event":!1,onFocus:Ee,onInput:Ke[1]||(Ke[1]=at=>N.value=at),onChange:Ae},null,8,["placeholder","model-value"]),se(v(Ry),{visible:we.value,format:v(pe),"time-arrow-control":v(g),"parsed-value":b.value,onPick:ze},null,8,["visible","format","time-arrow-control","parsed-value"])],2)),[[v(Ku),De]])],2)):ge("v-if",!0),St(I("div",{class:P([v(o).e("header"),(O.value==="year"||O.value==="month")&&v(o).e("header--bordered")])},[I("span",{class:P(v(o).e("prev-btn"))},[I("button",{type:"button","aria-label":v(l)("el.datepicker.prevYear"),class:P(["d-arrow-left",v(r).e("icon-btn")]),onClick:Ke[2]||(Ke[2]=at=>V(!1))},[se(v(rt),null,{default:ce(()=>[se(v($d))]),_:1})],10,iWe),St(I("button",{type:"button","aria-label":v(l)("el.datepicker.prevMonth"),class:P([v(r).e("icon-btn"),"arrow-left"]),onClick:Ke[3]||(Ke[3]=at=>B(!1))},[se(v(rt),null,{default:ce(()=>[se(v(xl))]),_:1})],10,lWe),[[Qt,O.value==="date"]])],2),I("span",{role:"button",class:P(v(o).e("header-label")),"aria-live":"polite",tabindex:"0",onKeydown:Ke[4]||(Ke[4]=qt(at=>X("year"),["enter"])),onClick:Ke[5]||(Ke[5]=at=>X("year"))},Ue(v(F)),35),St(I("span",{role:"button","aria-live":"polite",tabindex:"0",class:P([v(o).e("header-label"),{active:O.value==="month"}]),onKeydown:Ke[6]||(Ke[6]=qt(at=>X("month"),["enter"])),onClick:Ke[7]||(Ke[7]=at=>X("month"))},Ue(v(l)(`el.datepicker.month${v(x)+1}`)),35),[[Qt,O.value==="date"]]),I("span",{class:P(v(o).e("next-btn"))},[St(I("button",{type:"button","aria-label":v(l)("el.datepicker.nextMonth"),class:P([v(r).e("icon-btn"),"arrow-right"]),onClick:Ke[8]||(Ke[8]=at=>B(!0))},[se(v(rt),null,{default:ce(()=>[se(v(Rr))]),_:1})],10,uWe),[[Qt,O.value==="date"]]),I("button",{type:"button","aria-label":v(l)("el.datepicker.nextYear"),class:P([v(r).e("icon-btn"),"d-arrow-right"]),onClick:Ke[9]||(Ke[9]=at=>V(!0))},[se(v(rt),null,{default:ce(()=>[se(v(xd))]),_:1})],10,cWe)],2)],2),[[Qt,O.value!=="time"]]),I("div",{class:P(v(r).e("content")),onKeydown:ct},[O.value==="date"?(S(),$e(O6,{key:0,ref_key:"currentViewRef",ref:w,"selection-mode":v(G),date:b.value,"parsed-value":xe.parsedValue,"disabled-date":v(h),"cell-class-name":v(p),onPick:z},null,8,["selection-mode","date","parsed-value","disabled-date","cell-class-name"])):ge("v-if",!0),O.value==="year"?(S(),$e(oWe,{key:1,ref_key:"currentViewRef",ref:w,date:b.value,"disabled-date":v(h),"parsed-value":xe.parsedValue,onPick:fe},null,8,["date","disabled-date","parsed-value"])):ge("v-if",!0),O.value==="month"?(S(),$e(R6,{key:2,ref_key:"currentViewRef",ref:w,date:b.value,"parsed-value":xe.parsedValue,"disabled-date":v(h),onPick:J},null,8,["date","parsed-value","disabled-date"])):ge("v-if",!0)],34)],2)],2),St(I("div",{class:P(v(r).e("footer"))},[St(se(v(br),{text:"",size:"small",class:P(v(r).e("link-btn")),onClick:ie},{default:ce(()=>[Yt(Ue(v(l)("el.datepicker.now")),1)]),_:1},8,["class"]),[[Qt,v(G)!=="dates"]]),se(v(br),{plain:"",size:"small",class:P(v(r).e("link-btn")),onClick:Q},{default:ce(()=>[Yt(Ue(v(l)("el.datepicker.confirm")),1)]),_:1},8,["class"])],2),[[Qt,v(ee)&&O.value==="date"]])],2))}});var fWe=je(dWe,[["__file","/home/runner/work/element-plus/element-plus/packages/components/date-picker/src/date-picker-com/panel-date-pick.vue"]]);const hWe=qe({...Rz,...Dz}),pWe=t=>{const{emit:e}=Rt(),n=Tg(),s=ir();return o=>{const a=vt(o.value)?o.value():o.value;if(a){e("pick",[Nt(a[0]).locale(t.value),Nt(a[1]).locale(t.value)]);return}o.onClick&&o.onClick({attrs:n,slots:s,emit:e})}},Pz=(t,{defaultValue:e,leftDate:n,rightDate:s,unit:r,onParsedValueChanged:o})=>{const{emit:a}=Rt(),{pickerNs:i}=et(VC),l=Fe("date-range-picker"),{t:u,lang:c}=nn(),d=pWe(c),f=U(),h=U(),p=U({endDate:null,selecting:!1}),m=b=>{p.value=b},g=(b=!1)=>{const _=v(f),$=v(h);A6([_,$])&&a("pick",[_,$],b)},y=b=>{p.value.selecting=b,b||(p.value.endDate=null)},w=()=>{const[b,_]=Mz(v(e),{lang:v(c),unit:r,unlinkPanels:t.unlinkPanels});f.value=void 0,h.value=void 0,n.value=b,s.value=_};return Me(e,b=>{b&&w()},{immediate:!0}),Me(()=>t.parsedValue,b=>{if(Qe(b)&&b.length===2){const[_,$]=b;f.value=_,n.value=_,h.value=$,o(v(f),v(h))}else w()},{immediate:!0}),{minDate:f,maxDate:h,rangeState:p,lang:c,ppNs:i,drpNs:l,handleChangeRange:m,handleRangeConfirm:g,handleShortcutClick:d,onSelect:y,t:u}},mWe=["onClick"],gWe=["disabled"],vWe=["disabled"],yWe=["disabled"],bWe=["disabled"],lv="month",wWe=ue({__name:"panel-date-range",props:hWe,emits:["pick","set-picker-option","calendar-change","panel-change"],setup(t,{emit:e}){const n=t,s=et("EP_PICKER_BASE"),{disabledDate:r,cellClassName:o,format:a,defaultTime:i,arrowControl:l,clearable:u}=s.props,c=Un(s.props,"shortcuts"),d=Un(s.props,"defaultValue"),{lang:f}=nn(),h=U(Nt().locale(f.value)),p=U(Nt().locale(f.value).add(1,lv)),{minDate:m,maxDate:g,rangeState:y,ppNs:w,drpNs:b,handleChangeRange:_,handleRangeConfirm:$,handleShortcutClick:x,onSelect:k,t:C}=Pz(n,{defaultValue:d,leftDate:h,rightDate:p,unit:lv,onParsedValueChanged:Y}),T=U({min:null,max:null}),N=U({min:null,max:null}),M=A(()=>`${h.value.year()} ${C("el.datepicker.year")} ${C(`el.datepicker.month${h.value.month()+1}`)}`),R=A(()=>`${p.value.year()} ${C("el.datepicker.year")} ${C(`el.datepicker.month${p.value.month()+1}`)}`),D=A(()=>h.value.year()),z=A(()=>h.value.month()),B=A(()=>p.value.year()),V=A(()=>p.value.month()),O=A(()=>!!c.value.length),F=A(()=>T.value.min!==null?T.value.min:m.value?m.value.format(J.value):""),L=A(()=>T.value.max!==null?T.value.max:g.value||m.value?(g.value||m.value).format(J.value):""),G=A(()=>N.value.min!==null?N.value.min:m.value?m.value.format(j.value):""),Z=A(()=>N.value.max!==null?N.value.max:g.value||m.value?(g.value||m.value).format(j.value):""),j=A(()=>WL(a)),J=A(()=>HL(a)),fe=()=>{h.value=h.value.subtract(1,"year"),n.unlinkPanels||(p.value=h.value.add(1,"month")),K("year")},X=()=>{h.value=h.value.subtract(1,"month"),n.unlinkPanels||(p.value=h.value.add(1,"month")),K("month")},oe=()=>{n.unlinkPanels?p.value=p.value.add(1,"year"):(h.value=h.value.add(1,"year"),p.value=h.value.add(1,"month")),K("year")},ee=()=>{n.unlinkPanels?p.value=p.value.add(1,"month"):(h.value=h.value.add(1,"month"),p.value=h.value.add(1,"month")),K("month")},Q=()=>{h.value=h.value.add(1,"year"),K("year")},ie=()=>{h.value=h.value.add(1,"month"),K("month")},pe=()=>{p.value=p.value.subtract(1,"year"),K("year")},Re=()=>{p.value=p.value.subtract(1,"month"),K("month")},K=de=>{e("panel-change",[h.value.toDate(),p.value.toDate()],de)},re=A(()=>{const de=(z.value+1)%12,Pe=z.value+1>=12?1:0;return n.unlinkPanels&&new Date(D.value+Pe,de)<new Date(B.value,V.value)}),we=A(()=>n.unlinkPanels&&B.value*12+V.value-(D.value*12+z.value+1)>=12),Ee=A(()=>!(m.value&&g.value&&!y.value.selecting&&A6([m.value,g.value]))),De=A(()=>n.type==="datetime"||n.type==="datetimerange"),_e=(de,Pe)=>{if(!!de)return i?Nt(i[Pe]||i).locale(f.value).year(de.year()).month(de.month()).date(de.date()):de},ze=(de,Pe=!0)=>{const We=de.minDate,Ft=de.maxDate,_n=_e(We,0),_s=_e(Ft,1);g.value===_s&&m.value===_n||(e("calendar-change",[We.toDate(),Ft&&Ft.toDate()]),g.value=_s,m.value=_n,!(!Pe||De.value)&&$())},Ae=U(!1),he=U(!1),ve=()=>{Ae.value=!1},me=()=>{he.value=!1},Ve=(de,Pe)=>{T.value[Pe]=de;const We=Nt(de,J.value).locale(f.value);if(We.isValid()){if(r&&r(We.toDate()))return;Pe==="min"?(h.value=We,m.value=(m.value||h.value).year(We.year()).month(We.month()).date(We.date()),n.unlinkPanels||(p.value=We.add(1,"month"),g.value=m.value.add(1,"month"))):(p.value=We,g.value=(g.value||p.value).year(We.year()).month(We.month()).date(We.date()),n.unlinkPanels||(h.value=We.subtract(1,"month"),m.value=g.value.subtract(1,"month")))}},Ye=(de,Pe)=>{T.value[Pe]=null},Je=(de,Pe)=>{N.value[Pe]=de;const We=Nt(de,j.value).locale(f.value);We.isValid()&&(Pe==="min"?(Ae.value=!0,m.value=(m.value||h.value).hour(We.hour()).minute(We.minute()).second(We.second()),(!g.value||g.value.isBefore(m.value))&&(g.value=m.value)):(he.value=!0,g.value=(g.value||p.value).hour(We.hour()).minute(We.minute()).second(We.second()),p.value=g.value,g.value&&g.value.isBefore(m.value)&&(m.value=g.value)))},ct=(de,Pe)=>{N.value[Pe]=null,Pe==="min"?(h.value=m.value,Ae.value=!1):(p.value=g.value,he.value=!1)},xt=(de,Pe,We)=>{N.value.min||(de&&(h.value=de,m.value=(m.value||h.value).hour(de.hour()).minute(de.minute()).second(de.second())),We||(Ae.value=Pe),(!g.value||g.value.isBefore(m.value))&&(g.value=m.value,p.value=de))},dt=(de,Pe,We)=>{N.value.max||(de&&(p.value=de,g.value=(g.value||p.value).hour(de.hour()).minute(de.minute()).second(de.second())),We||(he.value=Pe),g.value&&g.value.isBefore(m.value)&&(m.value=g.value))},xe=()=>{h.value=Mz(v(d),{lang:v(f),unit:"month",unlinkPanels:n.unlinkPanels})[0],p.value=h.value.add(1,"month"),e("pick",null)},Ke=de=>Qe(de)?de.map(Pe=>Pe.format(a)):de.format(a),at=de=>Qe(de)?de.map(Pe=>Nt(Pe,a).locale(f.value)):Nt(de,a).locale(f.value);function Y(de,Pe){if(n.unlinkPanels&&Pe){const We=(de==null?void 0:de.year())||0,Ft=(de==null?void 0:de.month())||0,_n=Pe.year(),_s=Pe.month();p.value=We===_n&&Ft===_s?Pe.add(1,lv):Pe}else p.value=h.value.add(1,lv),Pe&&(p.value=p.value.hour(Pe.hour()).minute(Pe.minute()).second(Pe.second()))}return e("set-picker-option",["isValidValue",A6]),e("set-picker-option",["parseUserInput",at]),e("set-picker-option",["formatToString",Ke]),e("set-picker-option",["handleClear",xe]),(de,Pe)=>(S(),E("div",{class:P([v(w).b(),v(b).b(),{"has-sidebar":de.$slots.sidebar||v(O),"has-time":v(De)}])},[I("div",{class:P(v(w).e("body-wrapper"))},[Oe(de.$slots,"sidebar",{class:P(v(w).e("sidebar"))}),v(O)?(S(),E("div",{key:0,class:P(v(w).e("sidebar"))},[(S(!0),E(lt,null,Gt(v(c),(We,Ft)=>(S(),E("button",{key:Ft,type:"button",class:P(v(w).e("shortcut")),onClick:_n=>v(x)(We)},Ue(We.text),11,mWe))),128))],2)):ge("v-if",!0),I("div",{class:P(v(w).e("body"))},[v(De)?(S(),E("div",{key:0,class:P(v(b).e("time-header"))},[I("span",{class:P(v(b).e("editors-wrap"))},[I("span",{class:P(v(b).e("time-picker-wrap"))},[se(v(Or),{size:"small",disabled:v(y).selecting,placeholder:v(C)("el.datepicker.startDate"),class:P(v(b).e("editor")),"model-value":v(F),"validate-event":!1,onInput:Pe[0]||(Pe[0]=We=>Ve(We,"min")),onChange:Pe[1]||(Pe[1]=We=>Ye(We,"min"))},null,8,["disabled","placeholder","class","model-value"])],2),St((S(),E("span",{class:P(v(b).e("time-picker-wrap"))},[se(v(Or),{size:"small",class:P(v(b).e("editor")),disabled:v(y).selecting,placeholder:v(C)("el.datepicker.startTime"),"model-value":v(G),"validate-event":!1,onFocus:Pe[2]||(Pe[2]=We=>Ae.value=!0),onInput:Pe[3]||(Pe[3]=We=>Je(We,"min")),onChange:Pe[4]||(Pe[4]=We=>ct(We,"min"))},null,8,["class","disabled","placeholder","model-value"]),se(v(Ry),{visible:Ae.value,format:v(j),"datetime-role":"start","time-arrow-control":v(l),"parsed-value":h.value,onPick:xt},null,8,["visible","format","time-arrow-control","parsed-value"])],2)),[[v(Ku),ve]])],2),I("span",null,[se(v(rt),null,{default:ce(()=>[se(v(Rr))]),_:1})]),I("span",{class:P([v(b).e("editors-wrap"),"is-right"])},[I("span",{class:P(v(b).e("time-picker-wrap"))},[se(v(Or),{size:"small",class:P(v(b).e("editor")),disabled:v(y).selecting,placeholder:v(C)("el.datepicker.endDate"),"model-value":v(L),readonly:!v(m),"validate-event":!1,onInput:Pe[5]||(Pe[5]=We=>Ve(We,"max")),onChange:Pe[6]||(Pe[6]=We=>Ye(We,"max"))},null,8,["class","disabled","placeholder","model-value","readonly"])],2),St((S(),E("span",{class:P(v(b).e("time-picker-wrap"))},[se(v(Or),{size:"small",class:P(v(b).e("editor")),disabled:v(y).selecting,placeholder:v(C)("el.datepicker.endTime"),"model-value":v(Z),readonly:!v(m),"validate-event":!1,onFocus:Pe[7]||(Pe[7]=We=>v(m)&&(he.value=!0)),onInput:Pe[8]||(Pe[8]=We=>Je(We,"max")),onChange:Pe[9]||(Pe[9]=We=>ct(We,"max"))},null,8,["class","disabled","placeholder","model-value","readonly"]),se(v(Ry),{"datetime-role":"end",visible:he.value,format:v(j),"time-arrow-control":v(l),"parsed-value":p.value,onPick:dt},null,8,["visible","format","time-arrow-control","parsed-value"])],2)),[[v(Ku),me]])],2)],2)):ge("v-if",!0),I("div",{class:P([[v(w).e("content"),v(b).e("content")],"is-left"])},[I("div",{class:P(v(b).e("header"))},[I("button",{type:"button",class:P([v(w).e("icon-btn"),"d-arrow-left"]),onClick:fe},[se(v(rt),null,{default:ce(()=>[se(v($d))]),_:1})],2),I("button",{type:"button",class:P([v(w).e("icon-btn"),"arrow-left"]),onClick:X},[se(v(rt),null,{default:ce(()=>[se(v(xl))]),_:1})],2),de.unlinkPanels?(S(),E("button",{key:0,type:"button",disabled:!v(we),class:P([[v(w).e("icon-btn"),{"is-disabled":!v(we)}],"d-arrow-right"]),onClick:Q},[se(v(rt),null,{default:ce(()=>[se(v(xd))]),_:1})],10,gWe)):ge("v-if",!0),de.unlinkPanels?(S(),E("button",{key:1,type:"button",disabled:!v(re),class:P([[v(w).e("icon-btn"),{"is-disabled":!v(re)}],"arrow-right"]),onClick:ie},[se(v(rt),null,{default:ce(()=>[se(v(Rr))]),_:1})],10,vWe)):ge("v-if",!0),I("div",null,Ue(v(M)),1)],2),se(O6,{"selection-mode":"range",date:h.value,"min-date":v(m),"max-date":v(g),"range-state":v(y),"disabled-date":v(r),"cell-class-name":v(o),onChangerange:v(_),onPick:ze,onSelect:v(k)},null,8,["date","min-date","max-date","range-state","disabled-date","cell-class-name","onChangerange","onSelect"])],2),I("div",{class:P([[v(w).e("content"),v(b).e("content")],"is-right"])},[I("div",{class:P(v(b).e("header"))},[de.unlinkPanels?(S(),E("button",{key:0,type:"button",disabled:!v(we),class:P([[v(w).e("icon-btn"),{"is-disabled":!v(we)}],"d-arrow-left"]),onClick:pe},[se(v(rt),null,{default:ce(()=>[se(v($d))]),_:1})],10,yWe)):ge("v-if",!0),de.unlinkPanels?(S(),E("button",{key:1,type:"button",disabled:!v(re),class:P([[v(w).e("icon-btn"),{"is-disabled":!v(re)}],"arrow-left"]),onClick:Re},[se(v(rt),null,{default:ce(()=>[se(v(xl))]),_:1})],10,bWe)):ge("v-if",!0),I("button",{type:"button",class:P([v(w).e("icon-btn"),"d-arrow-right"]),onClick:oe},[se(v(rt),null,{default:ce(()=>[se(v(xd))]),_:1})],2),I("button",{type:"button",class:P([v(w).e("icon-btn"),"arrow-right"]),onClick:ee},[se(v(rt),null,{default:ce(()=>[se(v(Rr))]),_:1})],2),I("div",null,Ue(v(R)),1)],2),se(O6,{"selection-mode":"range",date:p.value,"min-date":v(m),"max-date":v(g),"range-state":v(y),"disabled-date":v(r),"cell-class-name":v(o),onChangerange:v(_),onPick:ze,onSelect:v(k)},null,8,["date","min-date","max-date","range-state","disabled-date","cell-class-name","onChangerange","onSelect"])],2)],2)],2),v(De)?(S(),E("div",{key:0,class:P(v(w).e("footer"))},[v(u)?(S(),$e(v(br),{key:0,text:"",size:"small",class:P(v(w).e("link-btn")),onClick:xe},{default:ce(()=>[Yt(Ue(v(C)("el.datepicker.clear")),1)]),_:1},8,["class"])):ge("v-if",!0),se(v(br),{plain:"",size:"small",class:P(v(w).e("link-btn")),disabled:v(Ee),onClick:Pe[10]||(Pe[10]=We=>v($)(!1))},{default:ce(()=>[Yt(Ue(v(C)("el.datepicker.confirm")),1)]),_:1},8,["class","disabled"])],2)):ge("v-if",!0)],2))}});var _We=je(wWe,[["__file","/home/runner/work/element-plus/element-plus/packages/components/date-picker/src/date-picker-com/panel-date-range.vue"]]);const $We=qe({...Dz}),xWe=["pick","set-picker-option"],SWe=({unlinkPanels:t,leftDate:e,rightDate:n})=>{const{t:s}=nn(),r=()=>{e.value=e.value.subtract(1,"year"),t.value||(n.value=n.value.subtract(1,"year"))},o=()=>{t.value||(e.value=e.value.add(1,"year")),n.value=n.value.add(1,"year")},a=()=>{e.value=e.value.add(1,"year")},i=()=>{n.value=n.value.subtract(1,"year")},l=A(()=>`${e.value.year()} ${s("el.datepicker.year")}`),u=A(()=>`${n.value.year()} ${s("el.datepicker.year")}`),c=A(()=>e.value.year()),d=A(()=>n.value.year()===e.value.year()?e.value.year()+1:n.value.year());return{leftPrevYear:r,rightNextYear:o,leftNextYear:a,rightPrevYear:i,leftLabel:l,rightLabel:u,leftYear:c,rightYear:d}},CWe=["onClick"],kWe=["disabled"],TWe=["disabled"],uv="year",NWe=ue({name:"DatePickerMonthRange"}),IWe=ue({...NWe,props:$We,emits:xWe,setup(t,{emit:e}){const n=t,{lang:s}=nn(),r=et("EP_PICKER_BASE"),{shortcuts:o,disabledDate:a,format:i}=r.props,l=Un(r.props,"defaultValue"),u=U(Nt().locale(s.value)),c=U(Nt().locale(s.value).add(1,uv)),{minDate:d,maxDate:f,rangeState:h,ppNs:p,drpNs:m,handleChangeRange:g,handleRangeConfirm:y,handleShortcutClick:w,onSelect:b}=Pz(n,{defaultValue:l,leftDate:u,rightDate:c,unit:uv,onParsedValueChanged:V}),_=A(()=>!!o.length),{leftPrevYear:$,rightNextYear:x,leftNextYear:k,rightPrevYear:C,leftLabel:T,rightLabel:N,leftYear:M,rightYear:R}=SWe({unlinkPanels:Un(n,"unlinkPanels"),leftDate:u,rightDate:c}),D=A(()=>n.unlinkPanels&&R.value>M.value+1),z=(O,F=!0)=>{const L=O.minDate,G=O.maxDate;f.value===G&&d.value===L||(f.value=G,d.value=L,F&&y())},B=O=>O.map(F=>F.format(i));function V(O,F){if(n.unlinkPanels&&F){const L=(O==null?void 0:O.year())||0,G=F.year();c.value=L===G?F.add(1,uv):F}else c.value=u.value.add(1,uv)}return e("set-picker-option",["formatToString",B]),(O,F)=>(S(),E("div",{class:P([v(p).b(),v(m).b(),{"has-sidebar":Boolean(O.$slots.sidebar)||v(_)}])},[I("div",{class:P(v(p).e("body-wrapper"))},[Oe(O.$slots,"sidebar",{class:P(v(p).e("sidebar"))}),v(_)?(S(),E("div",{key:0,class:P(v(p).e("sidebar"))},[(S(!0),E(lt,null,Gt(v(o),(L,G)=>(S(),E("button",{key:G,type:"button",class:P(v(p).e("shortcut")),onClick:Z=>v(w)(L)},Ue(L.text),11,CWe))),128))],2)):ge("v-if",!0),I("div",{class:P(v(p).e("body"))},[I("div",{class:P([[v(p).e("content"),v(m).e("content")],"is-left"])},[I("div",{class:P(v(m).e("header"))},[I("button",{type:"button",class:P([v(p).e("icon-btn"),"d-arrow-left"]),onClick:F[0]||(F[0]=(...L)=>v($)&&v($)(...L))},[se(v(rt),null,{default:ce(()=>[se(v($d))]),_:1})],2),O.unlinkPanels?(S(),E("button",{key:0,type:"button",disabled:!v(D),class:P([[v(p).e("icon-btn"),{[v(p).is("disabled")]:!v(D)}],"d-arrow-right"]),onClick:F[1]||(F[1]=(...L)=>v(k)&&v(k)(...L))},[se(v(rt),null,{default:ce(()=>[se(v(xd))]),_:1})],10,kWe)):ge("v-if",!0),I("div",null,Ue(v(T)),1)],2),se(R6,{"selection-mode":"range",date:u.value,"min-date":v(d),"max-date":v(f),"range-state":v(h),"disabled-date":v(a),onChangerange:v(g),onPick:z,onSelect:v(b)},null,8,["date","min-date","max-date","range-state","disabled-date","onChangerange","onSelect"])],2),I("div",{class:P([[v(p).e("content"),v(m).e("content")],"is-right"])},[I("div",{class:P(v(m).e("header"))},[O.unlinkPanels?(S(),E("button",{key:0,type:"button",disabled:!v(D),class:P([[v(p).e("icon-btn"),{"is-disabled":!v(D)}],"d-arrow-left"]),onClick:F[2]||(F[2]=(...L)=>v(C)&&v(C)(...L))},[se(v(rt),null,{default:ce(()=>[se(v($d))]),_:1})],10,TWe)):ge("v-if",!0),I("button",{type:"button",class:P([v(p).e("icon-btn"),"d-arrow-right"]),onClick:F[3]||(F[3]=(...L)=>v(x)&&v(x)(...L))},[se(v(rt),null,{default:ce(()=>[se(v(xd))]),_:1})],2),I("div",null,Ue(v(N)),1)],2),se(R6,{"selection-mode":"range",date:c.value,"min-date":v(d),"max-date":v(f),"range-state":v(h),"disabled-date":v(a),onChangerange:v(g),onPick:z,onSelect:v(b)},null,8,["date","min-date","max-date","range-state","disabled-date","onChangerange","onSelect"])],2)],2)],2)],2))}});var EWe=je(IWe,[["__file","/home/runner/work/element-plus/element-plus/packages/components/date-picker/src/date-picker-com/panel-month-range.vue"]]);const AWe=function(t){switch(t){case"daterange":case"datetimerange":return _We;case"monthrange":return EWe;default:return fWe}};Nt.extend(oz);Nt.extend(THe);Nt.extend(ok);Nt.extend(NHe);Nt.extend(IHe);Nt.extend(EHe);Nt.extend(AHe);Nt.extend(OHe);var OWe=ue({name:"ElDatePicker",install:null,props:{...ak,...RHe},emits:["update:modelValue"],setup(t,{expose:e,emit:n,slots:s}){const r=Fe("picker-panel");Lt("ElPopperOptions",on(Un(t,"popperOptions"))),Lt(VC,{slots:s,pickerNs:r});const o=U();e({focus:(l=!0)=>{var u;(u=o.value)==null||u.focus(l)},handleOpen:()=>{var l;(l=o.value)==null||l.handleOpen()},handleClose:()=>{var l;(l=o.value)==null||l.handleClose()}});const i=l=>{n("update:modelValue",l)};return()=>{var l;const u=(l=t.format)!=null?l:Rze[t.type]||Tf,c=AWe(t.type);return se(jL,zt(t,{format:u,type:t.type,ref:o,"onUpdate:modelValue":i}),{default:d=>se(c,d,null),"range-separator":s["range-separator"]})}}});const Qv=OWe;Qv.install=t=>{t.component(Qv.name,Qv)};const RWe=Qv,ck="elDescriptions";var Om=ue({name:"ElDescriptionsCell",props:{cell:{type:Object},tag:{type:String},type:{type:String}},setup(){return{descriptions:et(ck,{})}},render(){var t,e,n,s,r,o;const a=H9e(this.cell),{border:i,direction:l}=this.descriptions,u=l==="vertical",c=((n=(e=(t=this.cell)==null?void 0:t.children)==null?void 0:e.label)==null?void 0:n.call(e))||a.label,d=(o=(r=(s=this.cell)==null?void 0:s.children)==null?void 0:r.default)==null?void 0:o.call(r),f=a.span,h=a.align?`is-${a.align}`:"",p=a.labelAlign?`is-${a.labelAlign}`:h,m=a.className,g=a.labelClassName,y={width:Cs(a.width),minWidth:Cs(a.minWidth)},w=Fe("descriptions");switch(this.type){case"label":return it(this.tag,{style:y,class:[w.e("cell"),w.e("label"),w.is("bordered-label",i),w.is("vertical-label",u),p,g],colSpan:u?f:1},c);case"content":return it(this.tag,{style:y,class:[w.e("cell"),w.e("content"),w.is("bordered-content",i),w.is("vertical-content",u),h,m],colSpan:u?f:f*2-1},d);default:return it("td",{style:y,class:[w.e("cell"),h],colSpan:f},[it("span",{class:[w.e("label"),g]},c),it("span",{class:[w.e("content"),m]},d)])}}});const DWe=qe({row:{type:Array,default:()=>[]}}),FWe={key:1},MWe=ue({name:"ElDescriptionsRow"}),PWe=ue({...MWe,props:DWe,setup(t){const e=et(ck,{});return(n,s)=>v(e).direction==="vertical"?(S(),E(lt,{key:0},[I("tr",null,[(S(!0),E(lt,null,Gt(n.row,(r,o)=>(S(),$e(v(Om),{key:`tr1-${o}`,cell:r,tag:"th",type:"label"},null,8,["cell"]))),128))]),I("tr",null,[(S(!0),E(lt,null,Gt(n.row,(r,o)=>(S(),$e(v(Om),{key:`tr2-${o}`,cell:r,tag:"td",type:"content"},null,8,["cell"]))),128))])],64)):(S(),E("tr",FWe,[(S(!0),E(lt,null,Gt(n.row,(r,o)=>(S(),E(lt,{key:`tr3-${o}`},[v(e).border?(S(),E(lt,{key:0},[se(v(Om),{cell:r,tag:"td",type:"label"},null,8,["cell"]),se(v(Om),{cell:r,tag:"td",type:"content"},null,8,["cell"])],64)):(S(),$e(v(Om),{key:1,cell:r,tag:"td",type:"both"},null,8,["cell"]))],64))),128))]))}});var LWe=je(PWe,[["__file","/home/runner/work/element-plus/element-plus/packages/components/descriptions/src/descriptions-row.vue"]]);const zWe=qe({border:{type:Boolean,default:!1},column:{type:Number,default:3},direction:{type:String,values:["horizontal","vertical"],default:"horizontal"},size:wo,title:{type:String,default:""},extra:{type:String,default:""}}),BWe=ue({name:"ElDescriptions"}),VWe=ue({...BWe,props:zWe,setup(t){const e=t,n=Fe("descriptions"),s=ks(),r=ir();Lt(ck,e);const o=A(()=>[n.b(),n.m(s.value)]),a=(l,u,c,d=!1)=>(l.props||(l.props={}),u>c&&(l.props.span=c),d&&(l.props.span=u),l),i=()=>{var l;const u=Gf((l=r.default)==null?void 0:l.call(r)).filter(p=>{var m;return((m=p==null?void 0:p.type)==null?void 0:m.name)==="ElDescriptionsItem"}),c=[];let d=[],f=e.column,h=0;return u.forEach((p,m)=>{var g;const y=((g=p.props)==null?void 0:g.span)||1;if(m<u.length-1&&(h+=y>f?f:y),m===u.length-1){const w=e.column-h%e.column;d.push(a(p,w,f,!0)),c.push(d);return}y<f?(f-=y,d.push(p)):(d.push(a(p,y,f)),c.push(d),f=e.column,d=[])}),c};return(l,u)=>(S(),E("div",{class:P(v(o))},[l.title||l.extra||l.$slots.title||l.$slots.extra?(S(),E("div",{key:0,class:P(v(n).e("header"))},[I("div",{class:P(v(n).e("title"))},[Oe(l.$slots,"title",{},()=>[Yt(Ue(l.title),1)])],2),I("div",{class:P(v(n).e("extra"))},[Oe(l.$slots,"extra",{},()=>[Yt(Ue(l.extra),1)])],2)],2)):ge("v-if",!0),I("div",{class:P(v(n).e("body"))},[I("table",{class:P([v(n).e("table"),v(n).is("bordered",l.border)])},[I("tbody",null,[(S(!0),E(lt,null,Gt(i(),(c,d)=>(S(),$e(LWe,{key:d,row:c},null,8,["row"]))),128))])],2)],2)],2))}});var HWe=je(VWe,[["__file","/home/runner/work/element-plus/element-plus/packages/components/descriptions/src/description.vue"]]),Lz=ue({name:"ElDescriptionsItem",props:{label:{type:String,default:""},span:{type:Number,default:1},width:{type:[String,Number],default:""},minWidth:{type:[String,Number],default:""},align:{type:String,default:"left"},labelAlign:{type:String,default:""},className:{type:String,default:""},labelClassName:{type:String,default:""}}});const WWe=Dt(HWe,{DescriptionsItem:Lz}),UWe=ns(Lz),GWe=qe({mask:{type:Boolean,default:!0},customMaskEvent:{type:Boolean,default:!1},overlayClass:{type:Se([String,Array,Object])},zIndex:{type:Se([String,Number])}}),jWe={click:t=>t instanceof MouseEvent};var KWe=ue({name:"ElOverlay",props:GWe,emits:jWe,setup(t,{slots:e,emit:n}){const s=Fe("overlay"),r=l=>{n("click",l)},{onClick:o,onMousedown:a,onMouseup:i}=HC(t.customMaskEvent?void 0:r);return()=>t.mask?se("div",{class:[s.b(),t.overlayClass],style:{zIndex:t.zIndex},onClick:o,onMousedown:a,onMouseup:i},[Oe(e,"default")],ra.STYLE|ra.CLASS|ra.PROPS,["onClick","onMouseup","onMousedown"]):it("div",{class:t.overlayClass,style:{zIndex:t.zIndex,position:"fixed",top:"0px",right:"0px",bottom:"0px",left:"0px"}},[Oe(e,"default")])}});const dk=KWe,zz=qe({center:{type:Boolean,default:!1},alignCenter:{type:Boolean,default:!1},closeIcon:{type:In},customClass:{type:String,default:""},draggable:{type:Boolean,default:!1},fullscreen:{type:Boolean,default:!1},showClose:{type:Boolean,default:!0},title:{type:String,default:""}}),qWe={close:()=>!0},XWe=["aria-label"],YWe=["id"],ZWe=ue({name:"ElDialogContent"}),JWe=ue({...ZWe,props:zz,emits:qWe,setup(t){const e=t,{t:n}=nn(),{Close:s}=OP,{dialogRef:r,headerRef:o,bodyId:a,ns:i,style:l}=et(BP),{focusTrapRef:u}=et(nk),c=dw(u,r),d=A(()=>e.draggable);return ZP(r,o,d),(f,h)=>(S(),E("div",{ref:v(c),class:P([v(i).b(),v(i).is("fullscreen",f.fullscreen),v(i).is("draggable",v(d)),v(i).is("align-center",f.alignCenter),{[v(i).m("center")]:f.center},f.customClass]),style:ot(v(l)),tabindex:"-1"},[I("header",{ref_key:"headerRef",ref:o,class:P(v(i).e("header"))},[Oe(f.$slots,"header",{},()=>[I("span",{role:"heading",class:P(v(i).e("title"))},Ue(f.title),3)]),f.showClose?(S(),E("button",{key:0,"aria-label":v(n)("el.dialog.close"),class:P(v(i).e("headerbtn")),type:"button",onClick:h[0]||(h[0]=p=>f.$emit("close"))},[se(v(rt),{class:P(v(i).e("close"))},{default:ce(()=>[(S(),$e(Vt(f.closeIcon||v(s))))]),_:1},8,["class"])],10,XWe)):ge("v-if",!0)],2),I("div",{id:v(a),class:P(v(i).e("body"))},[Oe(f.$slots,"default")],10,YWe),f.$slots.footer?(S(),E("footer",{key:0,class:P(v(i).e("footer"))},[Oe(f.$slots,"footer")],2)):ge("v-if",!0)],6))}});var QWe=je(JWe,[["__file","/home/runner/work/element-plus/element-plus/packages/components/dialog/src/dialog-content.vue"]]);const Bz=qe({...zz,appendToBody:{type:Boolean,default:!1},beforeClose:{type:Se(Function)},destroyOnClose:{type:Boolean,default:!1},closeOnClickModal:{type:Boolean,default:!0},closeOnPressEscape:{type:Boolean,default:!0},lockScroll:{type:Boolean,default:!0},modal:{type:Boolean,default:!0},openDelay:{type:Number,default:0},closeDelay:{type:Number,default:0},top:{type:String},modelValue:{type:Boolean,default:!1},modalClass:String,width:{type:[String,Number]},zIndex:{type:Number},trapFocus:{type:Boolean,default:!1}}),Vz={open:()=>!0,opened:()=>!0,close:()=>!0,closed:()=>!0,[Ot]:t=>Rs(t),openAutoFocus:()=>!0,closeAutoFocus:()=>!0},Hz=(t,e)=>{const s=Rt().emit,{nextZIndex:r}=Ul();let o="";const a=ei(),i=ei(),l=U(!1),u=U(!1),c=U(!1),d=U(t.zIndex||r());let f,h;const p=Wl("namespace",vw),m=A(()=>{const z={},B=`--${p.value}-dialog`;return t.fullscreen||(t.top&&(z[`${B}-margin-top`]=t.top),t.width&&(z[`${B}-width`]=Cs(t.width))),z}),g=A(()=>t.alignCenter?{display:"flex"}:{});function y(){s("opened")}function w(){s("closed"),s(Ot,!1),t.destroyOnClose&&(c.value=!1)}function b(){s("close")}function _(){h==null||h(),f==null||f(),t.openDelay&&t.openDelay>0?{stop:f}=_d(()=>C(),t.openDelay):C()}function $(){f==null||f(),h==null||h(),t.closeDelay&&t.closeDelay>0?{stop:h}=_d(()=>T(),t.closeDelay):T()}function x(){function z(B){B||(u.value=!0,l.value=!1)}t.beforeClose?t.beforeClose(z):$()}function k(){t.closeOnClickModal&&x()}function C(){!Kt||(l.value=!0)}function T(){l.value=!1}function N(){s("openAutoFocus")}function M(){s("closeAutoFocus")}function R(z){var B;((B=z.detail)==null?void 0:B.focusReason)==="pointer"&&z.preventDefault()}t.lockScroll&&QP(l);function D(){t.closeOnPressEscape&&x()}return Me(()=>t.modelValue,z=>{z?(u.value=!1,_(),c.value=!0,d.value=t.zIndex?d.value++:r(),nt(()=>{s("open"),e.value&&(e.value.scrollTop=0)})):l.value&&$()}),Me(()=>t.fullscreen,z=>{!e.value||(z?(o=e.value.style.transform,e.value.style.transform=""):e.value.style.transform=o)}),It(()=>{t.modelValue&&(l.value=!0,c.value=!0,_())}),{afterEnter:y,afterLeave:w,beforeLeave:b,handleClose:x,onModalClick:k,close:$,doClose:T,onOpenAutoFocus:N,onCloseAutoFocus:M,onCloseRequested:D,onFocusoutPrevented:R,titleId:a,bodyId:i,closed:u,style:m,overlayDialogStyle:g,rendered:c,visible:l,zIndex:d}},eUe=["aria-label","aria-labelledby","aria-describedby"],tUe=ue({name:"ElDialog",inheritAttrs:!1}),nUe=ue({...tUe,props:Bz,emits:Vz,setup(t,{expose:e}){const n=t,s=ir();Sl({scope:"el-dialog",from:"the title slot",replacement:"the header slot",version:"3.0.0",ref:"https://element-plus.org/en-US/component/dialog.html#slots"},A(()=>!!s.title)),Sl({scope:"el-dialog",from:"custom-class",replacement:"class",version:"2.3.0",ref:"https://element-plus.org/en-US/component/dialog.html#attributes",type:"Attribute"},A(()=>!!n.customClass));const r=Fe("dialog"),o=U(),a=U(),i=U(),{visible:l,titleId:u,bodyId:c,style:d,overlayDialogStyle:f,rendered:h,zIndex:p,afterEnter:m,afterLeave:g,beforeLeave:y,handleClose:w,onModalClick:b,onOpenAutoFocus:_,onCloseAutoFocus:$,onCloseRequested:x,onFocusoutPrevented:k}=Hz(n,o);Lt(BP,{dialogRef:o,headerRef:a,bodyId:c,ns:r,rendered:h,style:d});const C=HC(b),T=A(()=>n.draggable&&!n.fullscreen);return e({visible:l,dialogContentRef:i}),(N,M)=>(S(),$e(kg,{to:"body",disabled:!N.appendToBody},[se(ms,{name:"dialog-fade",onAfterEnter:v(m),onAfterLeave:v(g),onBeforeLeave:v(y),persisted:""},{default:ce(()=>[St(se(v(dk),{"custom-mask-event":"",mask:N.modal,"overlay-class":N.modalClass,"z-index":v(p)},{default:ce(()=>[I("div",{role:"dialog","aria-modal":"true","aria-label":N.title||void 0,"aria-labelledby":N.title?void 0:v(u),"aria-describedby":v(c),class:P(`${v(r).namespace.value}-overlay-dialog`),style:ot(v(f)),onClick:M[0]||(M[0]=(...R)=>v(C).onClick&&v(C).onClick(...R)),onMousedown:M[1]||(M[1]=(...R)=>v(C).onMousedown&&v(C).onMousedown(...R)),onMouseup:M[2]||(M[2]=(...R)=>v(C).onMouseup&&v(C).onMouseup(...R))},[se(v(xw),{loop:"",trapped:v(l),"focus-start-el":"container",onFocusAfterTrapped:v(_),onFocusAfterReleased:v($),onFocusoutPrevented:v(k),onReleaseRequested:v(x)},{default:ce(()=>[v(h)?(S(),$e(QWe,zt({key:0,ref_key:"dialogContentRef",ref:i},N.$attrs,{"custom-class":N.customClass,center:N.center,"align-center":N.alignCenter,"close-icon":N.closeIcon,draggable:v(T),fullscreen:N.fullscreen,"show-close":N.showClose,title:N.title,onClose:v(w)}),Uu({header:ce(()=>[N.$slots.title?Oe(N.$slots,"title",{key:1}):Oe(N.$slots,"header",{key:0,close:v(w),titleId:v(u),titleClass:v(r).e("title")})]),default:ce(()=>[Oe(N.$slots,"default")]),_:2},[N.$slots.footer?{name:"footer",fn:ce(()=>[Oe(N.$slots,"footer")])}:void 0]),1040,["custom-class","center","align-center","close-icon","draggable","fullscreen","show-close","title","onClose"])):ge("v-if",!0)]),_:3},8,["trapped","onFocusAfterTrapped","onFocusAfterReleased","onFocusoutPrevented","onReleaseRequested"])],46,eUe)]),_:3},8,["mask","overlay-class","z-index"]),[[Qt,v(l)]])]),_:3},8,["onAfterEnter","onAfterLeave","onBeforeLeave"])],8,["disabled"]))}});var sUe=je(nUe,[["__file","/home/runner/work/element-plus/element-plus/packages/components/dialog/src/dialog.vue"]]);const rUe=Dt(sUe),oUe=qe({direction:{type:String,values:["horizontal","vertical"],default:"horizontal"},contentPosition:{type:String,values:["left","center","right"],default:"center"},borderStyle:{type:Se(String),default:"solid"}}),aUe=ue({name:"ElDivider"}),iUe=ue({...aUe,props:oUe,setup(t){const e=t,n=Fe("divider"),s=A(()=>n.cssVar({"border-style":e.borderStyle}));return(r,o)=>(S(),E("div",{class:P([v(n).b(),v(n).m(r.direction)]),style:ot(v(s)),role:"separator"},[r.$slots.default&&r.direction!=="vertical"?(S(),E("div",{key:0,class:P([v(n).e("text"),v(n).is(r.contentPosition)])},[Oe(r.$slots,"default")],2)):ge("v-if",!0)],6))}});var lUe=je(iUe,[["__file","/home/runner/work/element-plus/element-plus/packages/components/divider/src/divider.vue"]]);const Wz=Dt(lUe),uUe=qe({...Bz,direction:{type:String,default:"rtl",values:["ltr","rtl","ttb","btt"]},size:{type:[String,Number],default:"30%"},withHeader:{type:Boolean,default:!0},modalFade:{type:Boolean,default:!0}}),cUe=Vz,dUe=ue({name:"ElDrawer",components:{ElOverlay:dk,ElFocusTrap:xw,ElIcon:rt,Close:xa},inheritAttrs:!1,props:uUe,emits:cUe,setup(t,{slots:e}){Sl({scope:"el-drawer",from:"the title slot",replacement:"the header slot",version:"3.0.0",ref:"https://element-plus.org/en-US/component/drawer.html#slots"},A(()=>!!e.title)),Sl({scope:"el-drawer",from:"custom-class",replacement:"class",version:"2.3.0",ref:"https://element-plus.org/en-US/component/drawer.html#attributes",type:"Attribute"},A(()=>!!t.customClass));const n=U(),s=U(),r=Fe("drawer"),{t:o}=nn(),a=A(()=>t.direction==="rtl"||t.direction==="ltr"),i=A(()=>Cs(t.size));return{...Hz(t,n),drawerRef:n,focusStartRef:s,isHorizontal:a,drawerSize:i,ns:r,t:o}}}),fUe=["aria-label","aria-labelledby","aria-describedby"],hUe=["id"],pUe=["aria-label"],mUe=["id"];function gUe(t,e,n,s,r,o){const a=pt("close"),i=pt("el-icon"),l=pt("el-focus-trap"),u=pt("el-overlay");return S(),$e(kg,{to:"body",disabled:!t.appendToBody},[se(ms,{name:t.ns.b("fade"),onAfterEnter:t.afterEnter,onAfterLeave:t.afterLeave,onBeforeLeave:t.beforeLeave,persisted:""},{default:ce(()=>[St(se(u,{mask:t.modal,"overlay-class":t.modalClass,"z-index":t.zIndex,onClick:t.onModalClick},{default:ce(()=>[se(l,{loop:"",trapped:t.visible,"focus-trap-el":t.drawerRef,"focus-start-el":t.focusStartRef,onReleaseRequested:t.onCloseRequested},{default:ce(()=>[I("div",zt({ref:"drawerRef","aria-modal":"true","aria-label":t.title||void 0,"aria-labelledby":t.title?void 0:t.titleId,"aria-describedby":t.bodyId},t.$attrs,{class:[t.ns.b(),t.direction,t.visible&&"open",t.customClass],style:t.isHorizontal?"width: "+t.drawerSize:"height: "+t.drawerSize,role:"dialog",onClick:e[1]||(e[1]=yt(()=>{},["stop"]))}),[I("span",{ref:"focusStartRef",class:P(t.ns.e("sr-focus")),tabindex:"-1"},null,2),t.withHeader?(S(),E("header",{key:0,class:P(t.ns.e("header"))},[t.$slots.title?Oe(t.$slots,"title",{key:1},()=>[ge(" DEPRECATED SLOT ")]):Oe(t.$slots,"header",{key:0,close:t.handleClose,titleId:t.titleId,titleClass:t.ns.e("title")},()=>[t.$slots.title?ge("v-if",!0):(S(),E("span",{key:0,id:t.titleId,role:"heading",class:P(t.ns.e("title"))},Ue(t.title),11,hUe))]),t.showClose?(S(),E("button",{key:2,"aria-label":t.t("el.drawer.close"),class:P(t.ns.e("close-btn")),type:"button",onClick:e[0]||(e[0]=(...c)=>t.handleClose&&t.handleClose(...c))},[se(i,{class:P(t.ns.e("close"))},{default:ce(()=>[se(a)]),_:1},8,["class"])],10,pUe)):ge("v-if",!0)],2)):ge("v-if",!0),t.rendered?(S(),E("div",{key:1,id:t.bodyId,class:P(t.ns.e("body"))},[Oe(t.$slots,"default")],10,mUe)):ge("v-if",!0),t.$slots.footer?(S(),E("div",{key:2,class:P(t.ns.e("footer"))},[Oe(t.$slots,"footer")],2)):ge("v-if",!0)],16,fUe)]),_:3},8,["trapped","focus-trap-el","focus-start-el","onReleaseRequested"])]),_:3},8,["mask","overlay-class","z-index","onClick"]),[[Qt,t.visible]])]),_:3},8,["name","onAfterEnter","onAfterLeave","onBeforeLeave"])],8,["disabled"])}var vUe=je(dUe,[["render",gUe],["__file","/home/runner/work/element-plus/element-plus/packages/components/drawer/src/drawer.vue"]]);const yUe=Dt(vUe),bUe=ue({inheritAttrs:!1});function wUe(t,e,n,s,r,o){return Oe(t.$slots,"default")}var _Ue=je(bUe,[["render",wUe],["__file","/home/runner/work/element-plus/element-plus/packages/components/collection/src/collection.vue"]]);const $Ue=ue({name:"ElCollectionItem",inheritAttrs:!1});function xUe(t,e,n,s,r,o){return Oe(t.$slots,"default")}var SUe=je($Ue,[["render",xUe],["__file","/home/runner/work/element-plus/element-plus/packages/components/collection/src/collection-item.vue"]]);const Uz="data-el-collection-item",Gz=t=>{const e=`El${t}Collection`,n=`${e}Item`,s=Symbol(e),r=Symbol(n),o={..._Ue,name:e,setup(){const i=U(null),l=new Map;Lt(s,{itemMap:l,getItems:()=>{const c=v(i);if(!c)return[];const d=Array.from(c.querySelectorAll(`[${Uz}]`));return[...l.values()].sort((h,p)=>d.indexOf(h.ref)-d.indexOf(p.ref))},collectionRef:i})}},a={...SUe,name:n,setup(i,{attrs:l}){const u=U(null),c=et(s,void 0);Lt(r,{collectionItemRef:u}),It(()=>{const d=v(u);d&&c.itemMap.set(d,{ref:d,...l})}),ts(()=>{const d=v(u);c.itemMap.delete(d)})}};return{COLLECTION_INJECTION_KEY:s,COLLECTION_ITEM_INJECTION_KEY:r,ElCollection:o,ElCollectionItem:a}},CUe=qe({style:{type:Se([String,Array,Object])},currentTabId:{type:Se(String)},defaultCurrentTabId:String,loop:Boolean,dir:{type:String,values:["ltr","rtl"],default:"ltr"},orientation:{type:Se(String)},onBlur:Function,onFocus:Function,onMousedown:Function}),{ElCollection:kUe,ElCollectionItem:TUe,COLLECTION_INJECTION_KEY:fk,COLLECTION_ITEM_INJECTION_KEY:NUe}=Gz("RovingFocusGroup"),hk=Symbol("elRovingFocusGroup"),jz=Symbol("elRovingFocusGroupItem"),IUe={ArrowLeft:"prev",ArrowUp:"prev",ArrowRight:"next",ArrowDown:"next",PageUp:"first",Home:"first",PageDown:"last",End:"last"},EUe=(t,e)=>{if(e!=="rtl")return t;switch(t){case ut.right:return ut.left;case ut.left:return ut.right;default:return t}},AUe=(t,e,n)=>{const s=EUe(t.key,n);if(!(e==="vertical"&&[ut.left,ut.right].includes(s))&&!(e==="horizontal"&&[ut.up,ut.down].includes(s)))return IUe[s]},OUe=(t,e)=>t.map((n,s)=>t[(s+e)%t.length]),pk=t=>{const{activeElement:e}=document;for(const n of t)if(n===e||(n.focus(),e!==document.activeElement))return},jO="currentTabIdChange",KO="rovingFocusGroup.entryFocus",RUe={bubbles:!1,cancelable:!0},DUe=ue({name:"ElRovingFocusGroupImpl",inheritAttrs:!1,props:CUe,emits:[jO,"entryFocus"],setup(t,{emit:e}){var n;const s=U((n=t.currentTabId||t.defaultCurrentTabId)!=null?n:null),r=U(!1),o=U(!1),a=U(null),{getItems:i}=et(fk,void 0),l=A(()=>[{outline:"none"},t.style]),u=m=>{e(jO,m)},c=()=>{r.value=!0},d=Xn(m=>{var g;(g=t.onMousedown)==null||g.call(t,m)},()=>{o.value=!0}),f=Xn(m=>{var g;(g=t.onFocus)==null||g.call(t,m)},m=>{const g=!v(o),{target:y,currentTarget:w}=m;if(y===w&&g&&!v(r)){const b=new Event(KO,RUe);if(w==null||w.dispatchEvent(b),!b.defaultPrevented){const _=i().filter(T=>T.focusable),$=_.find(T=>T.active),x=_.find(T=>T.id===v(s)),C=[$,x,..._].filter(Boolean).map(T=>T.ref);pk(C)}}o.value=!1}),h=Xn(m=>{var g;(g=t.onBlur)==null||g.call(t,m)},()=>{r.value=!1}),p=(...m)=>{e("entryFocus",...m)};Lt(hk,{currentTabbedId:Cg(s),loop:Un(t,"loop"),tabIndex:A(()=>v(r)?-1:0),rovingFocusGroupRef:a,rovingFocusGroupRootStyle:l,orientation:Un(t,"orientation"),dir:Un(t,"dir"),onItemFocus:u,onItemShiftTab:c,onBlur:h,onFocus:f,onMousedown:d}),Me(()=>t.currentTabId,m=>{s.value=m??null}),Rn(a,KO,p)}});function FUe(t,e,n,s,r,o){return Oe(t.$slots,"default")}var MUe=je(DUe,[["render",FUe],["__file","/home/runner/work/element-plus/element-plus/packages/components/roving-focus-group/src/roving-focus-group-impl.vue"]]);const PUe=ue({name:"ElRovingFocusGroup",components:{ElFocusGroupCollection:kUe,ElRovingFocusGroupImpl:MUe}});function LUe(t,e,n,s,r,o){const a=pt("el-roving-focus-group-impl"),i=pt("el-focus-group-collection");return S(),$e(i,null,{default:ce(()=>[se(a,Wa(Zb(t.$attrs)),{default:ce(()=>[Oe(t.$slots,"default")]),_:3},16)]),_:3})}var zUe=je(PUe,[["render",LUe],["__file","/home/runner/work/element-plus/element-plus/packages/components/roving-focus-group/src/roving-focus-group.vue"]]);const BUe=ue({components:{ElRovingFocusCollectionItem:TUe},props:{focusable:{type:Boolean,default:!0},active:{type:Boolean,default:!1}},emits:["mousedown","focus","keydown"],setup(t,{emit:e}){const{currentTabbedId:n,loop:s,onItemFocus:r,onItemShiftTab:o}=et(hk,void 0),{getItems:a}=et(fk,void 0),i=ei(),l=U(null),u=Xn(h=>{e("mousedown",h)},h=>{t.focusable?r(v(i)):h.preventDefault()}),c=Xn(h=>{e("focus",h)},()=>{r(v(i))}),d=Xn(h=>{e("keydown",h)},h=>{const{key:p,shiftKey:m,target:g,currentTarget:y}=h;if(p===ut.tab&&m){o();return}if(g!==y)return;const w=AUe(h);if(w){h.preventDefault();let _=a().filter($=>$.focusable).map($=>$.ref);switch(w){case"last":{_.reverse();break}case"prev":case"next":{w==="prev"&&_.reverse();const $=_.indexOf(y);_=s.value?OUe(_,$+1):_.slice($+1);break}}nt(()=>{pk(_)})}}),f=A(()=>n.value===v(i));return Lt(jz,{rovingFocusGroupItemRef:l,tabIndex:A(()=>v(f)?0:-1),handleMousedown:u,handleFocus:c,handleKeydown:d}),{id:i,handleKeydown:d,handleFocus:c,handleMousedown:u}}});function VUe(t,e,n,s,r,o){const a=pt("el-roving-focus-collection-item");return S(),$e(a,{id:t.id,focusable:t.focusable,active:t.active},{default:ce(()=>[Oe(t.$slots,"default")]),_:3},8,["id","focusable","active"])}var HUe=je(BUe,[["render",VUe],["__file","/home/runner/work/element-plus/element-plus/packages/components/roving-focus-group/src/roving-focus-item.vue"]]);const ey=qe({trigger:L0.trigger,effect:{...Xs.effect,default:"light"},type:{type:Se(String)},placement:{type:Se(String),default:"bottom"},popperOptions:{type:Se(Object),default:()=>({})},id:String,size:{type:String,default:""},splitButton:Boolean,hideOnClick:{type:Boolean,default:!0},loop:{type:Boolean,default:!0},showTimeout:{type:Number,default:150},hideTimeout:{type:Number,default:150},tabindex:{type:Se([Number,String]),default:0},maxHeight:{type:Se([Number,String]),default:""},popperClass:{type:String,default:""},disabled:{type:Boolean,default:!1},role:{type:String,default:"menu"},buttonProps:{type:Se(Object)},teleported:Xs.teleported}),Kz=qe({command:{type:[Object,String,Number],default:()=>({})},disabled:Boolean,divided:Boolean,textValue:String,icon:{type:In}}),WUe=qe({onKeydown:{type:Se(Function)}}),UUe=[ut.down,ut.pageDown,ut.home],qz=[ut.up,ut.pageUp,ut.end],GUe=[...UUe,...qz],{ElCollection:jUe,ElCollectionItem:KUe,COLLECTION_INJECTION_KEY:qUe,COLLECTION_ITEM_INJECTION_KEY:XUe}=Gz("Dropdown"),kw=Symbol("elDropdown"),{ButtonGroup:YUe}=br,ZUe=ue({name:"ElDropdown",components:{ElButton:br,ElButtonGroup:YUe,ElScrollbar:jl,ElDropdownCollection:jUe,ElTooltip:No,ElRovingFocusGroup:zUe,ElOnlyChild:pL,ElIcon:rt,ArrowDown:zl},props:ey,emits:["visible-change","click","command"],setup(t,{emit:e}){const n=Rt(),s=Fe("dropdown"),{t:r}=nn(),o=U(),a=U(),i=U(null),l=U(null),u=U(null),c=U(null),d=U(!1),f=[ut.enter,ut.space,ut.down],h=A(()=>({maxHeight:Cs(t.maxHeight)})),p=A(()=>[s.m(_.value)]),m=ei().value,g=A(()=>t.id||m);function y(){w()}function w(){var B;(B=i.value)==null||B.onClose()}function b(){var B;(B=i.value)==null||B.onOpen()}const _=ks();function $(...B){e("command",...B)}function x(){}function k(){const B=v(l);B==null||B.focus(),c.value=null}function C(B){c.value=B}function T(B){d.value||(B.preventDefault(),B.stopImmediatePropagation())}function N(){e("visible-change",!0)}function M(B){(B==null?void 0:B.type)==="keydown"&&l.value.focus()}function R(){e("visible-change",!1)}return Lt(kw,{contentRef:l,role:A(()=>t.role),triggerId:g,isUsingKeyboard:d,onItemEnter:x,onItemLeave:k}),Lt("elDropdown",{instance:n,dropdownSize:_,handleClick:y,commandHandler:$,trigger:Un(t,"trigger"),hideOnClick:Un(t,"hideOnClick")}),{t:r,ns:s,scrollbar:u,wrapStyle:h,dropdownTriggerKls:p,dropdownSize:_,triggerId:g,triggerKeys:f,currentTabId:c,handleCurrentTabIdChange:C,handlerMainButtonClick:B=>{e("click",B)},handleEntryFocus:T,handleClose:w,handleOpen:b,handleBeforeShowTooltip:N,handleShowTooltip:M,handleBeforeHideTooltip:R,onFocusAfterTrapped:B=>{var V,O;B.preventDefault(),(O=(V=l.value)==null?void 0:V.focus)==null||O.call(V,{preventScroll:!0})},popperRef:i,contentRef:l,triggeringElementRef:o,referenceElementRef:a}}});function JUe(t,e,n,s,r,o){var a;const i=pt("el-dropdown-collection"),l=pt("el-roving-focus-group"),u=pt("el-scrollbar"),c=pt("el-only-child"),d=pt("el-tooltip"),f=pt("el-button"),h=pt("arrow-down"),p=pt("el-icon"),m=pt("el-button-group");return S(),E("div",{class:P([t.ns.b(),t.ns.is("disabled",t.disabled)])},[se(d,{ref:"popperRef",role:t.role,effect:t.effect,"fallback-placements":["bottom","top"],"popper-options":t.popperOptions,"gpu-acceleration":!1,"hide-after":t.trigger==="hover"?t.hideTimeout:0,"manual-mode":!0,placement:t.placement,"popper-class":[t.ns.e("popper"),t.popperClass],"reference-element":(a=t.referenceElementRef)==null?void 0:a.$el,trigger:t.trigger,"trigger-keys":t.triggerKeys,"trigger-target-el":t.contentRef,"show-after":t.trigger==="hover"?t.showTimeout:0,"stop-popper-mouse-event":!1,"virtual-ref":t.triggeringElementRef,"virtual-triggering":t.splitButton,disabled:t.disabled,transition:`${t.ns.namespace.value}-zoom-in-top`,teleported:t.teleported,pure:"",persistent:"",onBeforeShow:t.handleBeforeShowTooltip,onShow:t.handleShowTooltip,onBeforeHide:t.handleBeforeHideTooltip},Uu({content:ce(()=>[se(u,{ref:"scrollbar","wrap-style":t.wrapStyle,tag:"div","view-class":t.ns.e("list")},{default:ce(()=>[se(l,{loop:t.loop,"current-tab-id":t.currentTabId,orientation:"horizontal",onCurrentTabIdChange:t.handleCurrentTabIdChange,onEntryFocus:t.handleEntryFocus},{default:ce(()=>[se(i,null,{default:ce(()=>[Oe(t.$slots,"dropdown")]),_:3})]),_:3},8,["loop","current-tab-id","onCurrentTabIdChange","onEntryFocus"])]),_:3},8,["wrap-style","view-class"])]),_:2},[t.splitButton?void 0:{name:"default",fn:ce(()=>[se(c,{id:t.triggerId,role:"button",tabindex:t.tabindex},{default:ce(()=>[Oe(t.$slots,"default")]),_:3},8,["id","tabindex"])])}]),1032,["role","effect","popper-options","hide-after","placement","popper-class","reference-element","trigger","trigger-keys","trigger-target-el","show-after","virtual-ref","virtual-triggering","disabled","transition","teleported","onBeforeShow","onShow","onBeforeHide"]),t.splitButton?(S(),$e(m,{key:0},{default:ce(()=>[se(f,zt({ref:"referenceElementRef"},t.buttonProps,{size:t.dropdownSize,type:t.type,disabled:t.disabled,tabindex:t.tabindex,onClick:t.handlerMainButtonClick}),{default:ce(()=>[Oe(t.$slots,"default")]),_:3},16,["size","type","disabled","tabindex","onClick"]),se(f,zt({id:t.triggerId,ref:"triggeringElementRef"},t.buttonProps,{role:"button",size:t.dropdownSize,type:t.type,class:t.ns.e("caret-button"),disabled:t.disabled,tabindex:t.tabindex,"aria-label":t.t("el.dropdown.toggleDropdown")}),{default:ce(()=>[se(p,{class:P(t.ns.e("icon"))},{default:ce(()=>[se(h)]),_:1},8,["class"])]),_:1},16,["id","size","type","class","disabled","tabindex","aria-label"])]),_:3})):ge("v-if",!0)],2)}var QUe=je(ZUe,[["render",JUe],["__file","/home/runner/work/element-plus/element-plus/packages/components/dropdown/src/dropdown.vue"]]);const eGe=ue({name:"DropdownItemImpl",components:{ElIcon:rt},props:Kz,emits:["pointermove","pointerleave","click","clickimpl"],setup(t,{emit:e}){const n=Fe("dropdown"),{role:s}=et(kw,void 0),{collectionItemRef:r}=et(XUe,void 0),{collectionItemRef:o}=et(NUe,void 0),{rovingFocusGroupItemRef:a,tabIndex:i,handleFocus:l,handleKeydown:u,handleMousedown:c}=et(jz,void 0),d=dw(r,o,a),f=A(()=>s.value==="menu"?"menuitem":s.value==="navigation"?"link":"button"),h=Xn(p=>{const{code:m}=p;if(m===ut.enter||m===ut.space)return p.preventDefault(),p.stopImmediatePropagation(),e("clickimpl",p),!0},u);return{ns:n,itemRef:d,dataset:{[Uz]:""},role:f,tabIndex:i,handleFocus:l,handleKeydown:h,handleMousedown:c}}}),tGe=["aria-disabled","tabindex","role"];function nGe(t,e,n,s,r,o){const a=pt("el-icon");return S(),E(lt,null,[t.divided?(S(),E("li",zt({key:0,role:"separator",class:t.ns.bem("menu","item","divided")},t.$attrs),null,16)):ge("v-if",!0),I("li",zt({ref:t.itemRef},{...t.dataset,...t.$attrs},{"aria-disabled":t.disabled,class:[t.ns.be("menu","item"),t.ns.is("disabled",t.disabled)],tabindex:t.tabIndex,role:t.role,onClick:e[0]||(e[0]=i=>t.$emit("clickimpl",i)),onFocus:e[1]||(e[1]=(...i)=>t.handleFocus&&t.handleFocus(...i)),onKeydown:e[2]||(e[2]=(...i)=>t.handleKeydown&&t.handleKeydown(...i)),onMousedown:e[3]||(e[3]=(...i)=>t.handleMousedown&&t.handleMousedown(...i)),onPointermove:e[4]||(e[4]=i=>t.$emit("pointermove",i)),onPointerleave:e[5]||(e[5]=i=>t.$emit("pointerleave",i))}),[t.icon?(S(),$e(a,{key:0},{default:ce(()=>[(S(),$e(Vt(t.icon)))]),_:1})):ge("v-if",!0),Oe(t.$slots,"default")],16,tGe)],64)}var sGe=je(eGe,[["render",nGe],["__file","/home/runner/work/element-plus/element-plus/packages/components/dropdown/src/dropdown-item-impl.vue"]]);const Xz=()=>{const t=et("elDropdown",{}),e=A(()=>t==null?void 0:t.dropdownSize);return{elDropdown:t,_elDropdownSize:e}},rGe=ue({name:"ElDropdownItem",components:{ElDropdownCollectionItem:KUe,ElRovingFocusItem:HUe,ElDropdownItemImpl:sGe},inheritAttrs:!1,props:Kz,emits:["pointermove","pointerleave","click"],setup(t,{emit:e,attrs:n}){const{elDropdown:s}=Xz(),r=Rt(),o=U(null),a=A(()=>{var h,p;return(p=(h=v(o))==null?void 0:h.textContent)!=null?p:""}),{onItemEnter:i,onItemLeave:l}=et(kw,void 0),u=Xn(h=>(e("pointermove",h),h.defaultPrevented),EA(h=>{var p;t.disabled?l(h):(i(h),h.defaultPrevented||(p=h.currentTarget)==null||p.focus())})),c=Xn(h=>(e("pointerleave",h),h.defaultPrevented),EA(h=>{l(h)})),d=Xn(h=>{if(!t.disabled)return e("click",h),h.type!=="keydown"&&h.defaultPrevented},h=>{var p,m,g;if(t.disabled){h.stopImmediatePropagation();return}(p=s==null?void 0:s.hideOnClick)!=null&&p.value&&((m=s.handleClick)==null||m.call(s)),(g=s.commandHandler)==null||g.call(s,t.command,r,h)}),f=A(()=>({...t,...n}));return{handleClick:d,handlePointerMove:u,handlePointerLeave:c,textContent:a,propsAndAttrs:f}}});function oGe(t,e,n,s,r,o){var a;const i=pt("el-dropdown-item-impl"),l=pt("el-roving-focus-item"),u=pt("el-dropdown-collection-item");return S(),$e(u,{disabled:t.disabled,"text-value":(a=t.textValue)!=null?a:t.textContent},{default:ce(()=>[se(l,{focusable:!t.disabled},{default:ce(()=>[se(i,zt(t.propsAndAttrs,{onPointerleave:t.handlePointerLeave,onPointermove:t.handlePointerMove,onClickimpl:t.handleClick}),{default:ce(()=>[Oe(t.$slots,"default")]),_:3},16,["onPointerleave","onPointermove","onClickimpl"])]),_:3},8,["focusable"])]),_:3},8,["disabled","text-value"])}var Yz=je(rGe,[["render",oGe],["__file","/home/runner/work/element-plus/element-plus/packages/components/dropdown/src/dropdown-item.vue"]]);const aGe=ue({name:"ElDropdownMenu",props:WUe,setup(t){const e=Fe("dropdown"),{_elDropdownSize:n}=Xz(),s=n.value,{focusTrapRef:r,onKeydown:o}=et(nk,void 0),{contentRef:a,role:i,triggerId:l}=et(kw,void 0),{collectionRef:u,getItems:c}=et(qUe,void 0),{rovingFocusGroupRef:d,rovingFocusGroupRootStyle:f,tabIndex:h,onBlur:p,onFocus:m,onMousedown:g}=et(hk,void 0),{collectionRef:y}=et(fk,void 0),w=A(()=>[e.b("menu"),e.bm("menu",s==null?void 0:s.value)]),b=dw(a,u,r,d,y),_=Xn(x=>{var k;(k=t.onKeydown)==null||k.call(t,x)},x=>{const{currentTarget:k,code:C,target:T}=x;if(k.contains(T),ut.tab===C&&x.stopImmediatePropagation(),x.preventDefault(),T!==v(a)||!GUe.includes(C))return;const M=c().filter(R=>!R.disabled).map(R=>R.ref);qz.includes(C)&&M.reverse(),pk(M)});return{size:s,rovingFocusGroupRootStyle:f,tabIndex:h,dropdownKls:w,role:i,triggerId:l,dropdownListWrapperRef:b,handleKeydown:x=>{_(x),o(x)},onBlur:p,onFocus:m,onMousedown:g}}}),iGe=["role","aria-labelledby"];function lGe(t,e,n,s,r,o){return S(),E("ul",{ref:t.dropdownListWrapperRef,class:P(t.dropdownKls),style:ot(t.rovingFocusGroupRootStyle),tabindex:-1,role:t.role,"aria-labelledby":t.triggerId,onBlur:e[0]||(e[0]=(...a)=>t.onBlur&&t.onBlur(...a)),onFocus:e[1]||(e[1]=(...a)=>t.onFocus&&t.onFocus(...a)),onKeydown:e[2]||(e[2]=(...a)=>t.handleKeydown&&t.handleKeydown(...a)),onMousedown:e[3]||(e[3]=(...a)=>t.onMousedown&&t.onMousedown(...a))},[Oe(t.$slots,"default")],46,iGe)}var Zz=je(aGe,[["render",lGe],["__file","/home/runner/work/element-plus/element-plus/packages/components/dropdown/src/dropdown-menu.vue"]]);const uGe=Dt(QUe,{DropdownItem:Yz,DropdownMenu:Zz}),cGe=ns(Yz),dGe=ns(Zz);let fGe=0;const hGe=ue({name:"ImgEmpty",setup(){return{ns:Fe("empty"),id:++fGe}}}),pGe={viewBox:"0 0 79 86",version:"1.1",xmlns:"http://www.w3.org/2000/svg","xmlns:xlink":"http://www.w3.org/1999/xlink"},mGe=["id"],gGe=["stop-color"],vGe=["stop-color"],yGe=["id"],bGe=["stop-color"],wGe=["stop-color"],_Ge=["id"],$Ge={id:"Illustrations",stroke:"none","stroke-width":"1",fill:"none","fill-rule":"evenodd"},xGe={id:"B-type",transform:"translate(-1268.000000, -535.000000)"},SGe={id:"Group-2",transform:"translate(1268.000000, 535.000000)"},CGe=["fill"],kGe=["fill"],TGe={id:"Group-Copy",transform:"translate(34.500000, 31.500000) scale(-1, 1) rotate(-25.000000) translate(-34.500000, -31.500000) translate(7.000000, 10.000000)"},NGe=["fill"],IGe=["fill"],EGe=["fill"],AGe=["fill"],OGe=["fill"],RGe={id:"Rectangle-Copy-17",transform:"translate(53.000000, 45.000000)"},DGe=["fill","xlink:href"],FGe=["fill","mask"],MGe=["fill"];function PGe(t,e,n,s,r,o){return S(),E("svg",pGe,[I("defs",null,[I("linearGradient",{id:`linearGradient-1-${t.id}`,x1:"38.8503086%",y1:"0%",x2:"61.1496914%",y2:"100%"},[I("stop",{"stop-color":`var(${t.ns.cssVarBlockName("fill-color-1")})`,offset:"0%"},null,8,gGe),I("stop",{"stop-color":`var(${t.ns.cssVarBlockName("fill-color-4")})`,offset:"100%"},null,8,vGe)],8,mGe),I("linearGradient",{id:`linearGradient-2-${t.id}`,x1:"0%",y1:"9.5%",x2:"100%",y2:"90.5%"},[I("stop",{"stop-color":`var(${t.ns.cssVarBlockName("fill-color-1")})`,offset:"0%"},null,8,bGe),I("stop",{"stop-color":`var(${t.ns.cssVarBlockName("fill-color-6")})`,offset:"100%"},null,8,wGe)],8,yGe),I("rect",{id:`path-3-${t.id}`,x:"0",y:"0",width:"17",height:"36"},null,8,_Ge)]),I("g",$Ge,[I("g",xGe,[I("g",SGe,[I("path",{id:"Oval-Copy-2",d:"M39.5,86 C61.3152476,86 79,83.9106622 79,81.3333333 C79,78.7560045 57.3152476,78 35.5,78 C13.6847524,78 0,78.7560045 0,81.3333333 C0,83.9106622 17.6847524,86 39.5,86 Z",fill:`var(${t.ns.cssVarBlockName("fill-color-3")})`},null,8,CGe),I("polygon",{id:"Rectangle-Copy-14",fill:`var(${t.ns.cssVarBlockName("fill-color-7")})`,transform:"translate(27.500000, 51.500000) scale(1, -1) translate(-27.500000, -51.500000) ",points:"13 58 53 58 42 45 2 45"},null,8,kGe),I("g",TGe,[I("polygon",{id:"Rectangle-Copy-10",fill:`var(${t.ns.cssVarBlockName("fill-color-7")})`,transform:"translate(11.500000, 5.000000) scale(1, -1) translate(-11.500000, -5.000000) ",points:"2.84078316e-14 3 18 3 23 7 5 7"},null,8,NGe),I("polygon",{id:"Rectangle-Copy-11",fill:`var(${t.ns.cssVarBlockName("fill-color-5")})`,points:"-3.69149156e-15 7 38 7 38 43 -3.69149156e-15 43"},null,8,IGe),I("rect",{id:"Rectangle-Copy-12",fill:`url(#linearGradient-1-${t.id})`,transform:"translate(46.500000, 25.000000) scale(-1, 1) translate(-46.500000, -25.000000) ",x:"38",y:"7",width:"17",height:"36"},null,8,EGe),I("polygon",{id:"Rectangle-Copy-13",fill:`var(${t.ns.cssVarBlockName("fill-color-2")})`,transform:"translate(39.500000, 3.500000) scale(-1, 1) translate(-39.500000, -3.500000) ",points:"24 7 41 7 55 -3.63806207e-12 38 -3.63806207e-12"},null,8,AGe)]),I("rect",{id:"Rectangle-Copy-15",fill:`url(#linearGradient-2-${t.id})`,x:"13",y:"45",width:"40",height:"36"},null,8,OGe),I("g",RGe,[I("use",{id:"Mask",fill:`var(${t.ns.cssVarBlockName("fill-color-8")})`,transform:"translate(8.500000, 18.000000) scale(-1, 1) translate(-8.500000, -18.000000) ","xlink:href":`#path-3-${t.id}`},null,8,DGe),I("polygon",{id:"Rectangle-Copy",fill:`var(${t.ns.cssVarBlockName("fill-color-9")})`,mask:`url(#mask-4-${t.id})`,transform:"translate(12.000000, 9.000000) scale(-1, 1) translate(-12.000000, -9.000000) ",points:"7 0 24 0 20 18 7 16.5"},null,8,FGe)]),I("polygon",{id:"Rectangle-Copy-18",fill:`var(${t.ns.cssVarBlockName("fill-color-2")})`,transform:"translate(66.000000, 51.500000) scale(-1, 1) translate(-66.000000, -51.500000) ",points:"62 45 79 45 70 58 53 58"},null,8,MGe)])])])])}var LGe=je(hGe,[["render",PGe],["__file","/home/runner/work/element-plus/element-plus/packages/components/empty/src/img-empty.vue"]]);const zGe={image:{type:String,default:""},imageSize:Number,description:{type:String,default:""}},BGe=["src"],VGe={key:1},HGe=ue({name:"ElEmpty"}),WGe=ue({...HGe,props:zGe,setup(t){const e=t,{t:n}=nn(),s=Fe("empty"),r=A(()=>e.description||n("el.table.emptyText")),o=A(()=>({width:e.imageSize?`${e.imageSize}px`:""}));return(a,i)=>(S(),E("div",{class:P(v(s).b())},[I("div",{class:P(v(s).e("image")),style:ot(v(o))},[a.image?(S(),E("img",{key:0,src:a.image,ondragstart:"return false"},null,8,BGe)):Oe(a.$slots,"image",{key:1},()=>[se(LGe)])],6),I("div",{class:P(v(s).e("description"))},[a.$slots.description?Oe(a.$slots,"description",{key:0}):(S(),E("p",VGe,Ue(v(r)),1))],2),a.$slots.default?(S(),E("div",{key:0,class:P(v(s).e("bottom"))},[Oe(a.$slots,"default")],2)):ge("v-if",!0)],2))}});var UGe=je(WGe,[["__file","/home/runner/work/element-plus/element-plus/packages/components/empty/src/empty.vue"]]);const Jz=Dt(UGe),GGe=qe({model:Object,rules:{type:Se(Object)},labelPosition:{type:String,values:["left","right","top"],default:"right"},requireAsteriskPosition:{type:String,values:["left","right"],default:"left"},labelWidth:{type:[String,Number],default:""},labelSuffix:{type:String,default:""},inline:Boolean,inlineMessage:Boolean,statusIcon:Boolean,showMessage:{type:Boolean,default:!0},size:{type:String,values:Hl},disabled:Boolean,validateOnRuleChange:{type:Boolean,default:!0},hideRequiredAsterisk:{type:Boolean,default:!1},scrollToError:Boolean}),jGe={validate:(t,e,n)=>(Qe(t)||wt(t))&&Rs(e)&&wt(n)};function KGe(){const t=U([]),e=A(()=>{if(!t.value.length)return"0";const o=Math.max(...t.value);return o?`${o}px`:""});function n(o){const a=t.value.indexOf(o);return a===-1&&e.value,a}function s(o,a){if(o&&a){const i=n(a);t.value.splice(i,1,o)}else o&&t.value.push(o)}function r(o){const a=n(o);a>-1&&t.value.splice(a,1)}return{autoLabelWidth:e,registerLabelWidth:s,deregisterLabelWidth:r}}const cv=(t,e)=>{const n=dh(e);return n.length>0?t.filter(s=>s.prop&&n.includes(s.prop)):t},qGe="ElForm",XGe=ue({name:qGe}),YGe=ue({...XGe,props:GGe,emits:jGe,setup(t,{expose:e,emit:n}){const s=t,r=[],o=ks(),a=Fe("form"),i=A(()=>{const{labelPosition:w,inline:b}=s;return[a.b(),a.m(o.value||"default"),{[a.m(`label-${w}`)]:w,[a.m("inline")]:b}]}),l=w=>{r.push(w)},u=w=>{w.prop&&r.splice(r.indexOf(w),1)},c=(w=[])=>{!s.model||cv(r,w).forEach(b=>b.resetField())},d=(w=[])=>{cv(r,w).forEach(b=>b.clearValidate())},f=A(()=>!!s.model),h=w=>{if(r.length===0)return[];const b=cv(r,w);return b.length?b:[]},p=async w=>g(void 0,w),m=async(w=[])=>{if(!f.value)return!1;const b=h(w);if(b.length===0)return!0;let _={};for(const $ of b)try{await $.validate("")}catch(x){_={..._,...x}}return Object.keys(_).length===0?!0:Promise.reject(_)},g=async(w=[],b)=>{const _=!vt(b);try{const $=await m(w);return $===!0&&(b==null||b($)),$}catch($){if($ instanceof Error)throw $;const x=$;return s.scrollToError&&y(Object.keys(x)[0]),b==null||b(!1,x),_&&Promise.reject(x)}},y=w=>{var b;const _=cv(r,w)[0];_&&((b=_.$el)==null||b.scrollIntoView())};return Me(()=>s.rules,()=>{s.validateOnRuleChange&&p().catch(w=>void 0)},{deep:!0}),Lt(Jd,on({...Ps(s),emit:n,resetFields:c,clearValidate:d,validateField:g,addField:l,removeField:u,...KGe()})),e({validate:p,validateField:g,resetFields:c,clearValidate:d,scrollToField:y}),(w,b)=>(S(),E("form",{class:P(v(i))},[Oe(w.$slots,"default")],2))}});var ZGe=je(YGe,[["__file","/home/runner/work/element-plus/element-plus/packages/components/form/src/form.vue"]]);function qc(){return qc=Object.assign?Object.assign.bind():function(t){for(var e=1;e<arguments.length;e++){var n=arguments[e];for(var s in n)Object.prototype.hasOwnProperty.call(n,s)&&(t[s]=n[s])}return t},qc.apply(this,arguments)}function JGe(t,e){t.prototype=Object.create(e.prototype),t.prototype.constructor=t,V0(t,e)}function D6(t){return D6=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(n){return n.__proto__||Object.getPrototypeOf(n)},D6(t)}function V0(t,e){return V0=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(s,r){return s.__proto__=r,s},V0(t,e)}function QGe(){if(typeof Reflect>"u"||!Reflect.construct||Reflect.construct.sham)return!1;if(typeof Proxy=="function")return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],function(){})),!0}catch{return!1}}function ty(t,e,n){return QGe()?ty=Reflect.construct.bind():ty=function(r,o,a){var i=[null];i.push.apply(i,o);var l=Function.bind.apply(r,i),u=new l;return a&&V0(u,a.prototype),u},ty.apply(null,arguments)}function eje(t){return Function.toString.call(t).indexOf("[native code]")!==-1}function F6(t){var e=typeof Map=="function"?new Map:void 0;return F6=function(s){if(s===null||!eje(s))return s;if(typeof s!="function")throw new TypeError("Super expression must either be null or a function");if(typeof e<"u"){if(e.has(s))return e.get(s);e.set(s,r)}function r(){return ty(s,arguments,D6(this).constructor)}return r.prototype=Object.create(s.prototype,{constructor:{value:r,enumerable:!1,writable:!0,configurable:!0}}),V0(r,s)},F6(t)}var tje=/%[sdj%]/g,nje=function(){};typeof process<"u"&&process.env;function M6(t){if(!t||!t.length)return null;var e={};return t.forEach(function(n){var s=n.field;e[s]=e[s]||[],e[s].push(n)}),e}function Po(t){for(var e=arguments.length,n=new Array(e>1?e-1:0),s=1;s<e;s++)n[s-1]=arguments[s];var r=0,o=n.length;if(typeof t=="function")return t.apply(null,n);if(typeof t=="string"){var a=t.replace(tje,function(i){if(i==="%%")return"%";if(r>=o)return i;switch(i){case"%s":return String(n[r++]);case"%d":return Number(n[r++]);case"%j":try{return JSON.stringify(n[r++])}catch{return"[Circular]"}break;default:return i}});return a}return t}function sje(t){return t==="string"||t==="url"||t==="hex"||t==="email"||t==="date"||t==="pattern"}function Ws(t,e){return!!(t==null||e==="array"&&Array.isArray(t)&&!t.length||sje(e)&&typeof t=="string"&&!t)}function rje(t,e,n){var s=[],r=0,o=t.length;function a(i){s.push.apply(s,i||[]),r++,r===o&&n(s)}t.forEach(function(i){e(i,a)})}function qO(t,e,n){var s=0,r=t.length;function o(a){if(a&&a.length){n(a);return}var i=s;s=s+1,i<r?e(t[i],o):n([])}o([])}function oje(t){var e=[];return Object.keys(t).forEach(function(n){e.push.apply(e,t[n]||[])}),e}var XO=function(t){JGe(e,t);function e(n,s){var r;return r=t.call(this,"Async Validation Error")||this,r.errors=n,r.fields=s,r}return e}(F6(Error));function aje(t,e,n,s,r){if(e.first){var o=new Promise(function(f,h){var p=function(y){return s(y),y.length?h(new XO(y,M6(y))):f(r)},m=oje(t);qO(m,n,p)});return o.catch(function(f){return f}),o}var a=e.firstFields===!0?Object.keys(t):e.firstFields||[],i=Object.keys(t),l=i.length,u=0,c=[],d=new Promise(function(f,h){var p=function(g){if(c.push.apply(c,g),u++,u===l)return s(c),c.length?h(new XO(c,M6(c))):f(r)};i.length||(s(c),f(r)),i.forEach(function(m){var g=t[m];a.indexOf(m)!==-1?qO(g,n,p):rje(g,n,p)})});return d.catch(function(f){return f}),d}function ije(t){return!!(t&&t.message!==void 0)}function lje(t,e){for(var n=t,s=0;s<e.length;s++){if(n==null)return n;n=n[e[s]]}return n}function YO(t,e){return function(n){var s;return t.fullFields?s=lje(e,t.fullFields):s=e[n.field||t.fullField],ije(n)?(n.field=n.field||t.fullField,n.fieldValue=s,n):{message:typeof n=="function"?n():n,fieldValue:s,field:n.field||t.fullField}}}function ZO(t,e){if(e){for(var n in e)if(e.hasOwnProperty(n)){var s=e[n];typeof s=="object"&&typeof t[n]=="object"?t[n]=qc({},t[n],s):t[n]=s}}return t}var Qz=function(e,n,s,r,o,a){e.required&&(!s.hasOwnProperty(e.field)||Ws(n,a||e.type))&&r.push(Po(o.messages.required,e.fullField))},uje=function(e,n,s,r,o){(/^\s+$/.test(n)||n==="")&&r.push(Po(o.messages.whitespace,e.fullField))},dv,cje=function(){if(dv)return dv;var t="[a-fA-F\\d:]",e=function(_){return _&&_.includeBoundaries?"(?:(?<=\\s|^)(?="+t+")|(?<="+t+")(?=\\s|$))":""},n="(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}",s="[a-fA-F\\d]{1,4}",r=(`
(?:
(?:`+s+":){7}(?:"+s+`|:)|                                    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8
(?:`+s+":){6}(?:"+n+"|:"+s+`|:)|                             // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4
(?:`+s+":){5}(?::"+n+"|(?::"+s+`){1,2}|:)|                   // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4
(?:`+s+":){4}(?:(?::"+s+"){0,1}:"+n+"|(?::"+s+`){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4
(?:`+s+":){3}(?:(?::"+s+"){0,2}:"+n+"|(?::"+s+`){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4
(?:`+s+":){2}(?:(?::"+s+"){0,3}:"+n+"|(?::"+s+`){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4
(?:`+s+":){1}(?:(?::"+s+"){0,4}:"+n+"|(?::"+s+`){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4
(?::(?:(?::`+s+"){0,5}:"+n+"|(?::"+s+`){1,7}|:))             // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4
)(?:%[0-9a-zA-Z]{1,})?                                             // %eth0            %1
`).replace(/\s*\/\/.*$/gm,"").replace(/\n/g,"").trim(),o=new RegExp("(?:^"+n+"$)|(?:^"+r+"$)"),a=new RegExp("^"+n+"$"),i=new RegExp("^"+r+"$"),l=function(_){return _&&_.exact?o:new RegExp("(?:"+e(_)+n+e(_)+")|(?:"+e(_)+r+e(_)+")","g")};l.v4=function(b){return b&&b.exact?a:new RegExp(""+e(b)+n+e(b),"g")},l.v6=function(b){return b&&b.exact?i:new RegExp(""+e(b)+r+e(b),"g")};var u="(?:(?:[a-z]+:)?//)",c="(?:\\S+(?::\\S*)?@)?",d=l.v4().source,f=l.v6().source,h="(?:(?:[a-z\\u00a1-\\uffff0-9][-_]*)*[a-z\\u00a1-\\uffff0-9]+)",p="(?:\\.(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)*",m="(?:\\.(?:[a-z\\u00a1-\\uffff]{2,}))",g="(?::\\d{2,5})?",y='(?:[/?#][^\\s"]*)?',w="(?:"+u+"|www\\.)"+c+"(?:localhost|"+d+"|"+f+"|"+h+p+m+")"+g+y;return dv=new RegExp("(?:^"+w+"$)","i"),dv},JO={email:/^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+\.)+[a-zA-Z\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]{2,}))$/,hex:/^#?([a-f0-9]{6}|[a-f0-9]{3})$/i},Wm={integer:function(e){return Wm.number(e)&&parseInt(e,10)===e},float:function(e){return Wm.number(e)&&!Wm.integer(e)},array:function(e){return Array.isArray(e)},regexp:function(e){if(e instanceof RegExp)return!0;try{return!!new RegExp(e)}catch{return!1}},date:function(e){return typeof e.getTime=="function"&&typeof e.getMonth=="function"&&typeof e.getYear=="function"&&!isNaN(e.getTime())},number:function(e){return isNaN(e)?!1:typeof e=="number"},object:function(e){return typeof e=="object"&&!Wm.array(e)},method:function(e){return typeof e=="function"},email:function(e){return typeof e=="string"&&e.length<=320&&!!e.match(JO.email)},url:function(e){return typeof e=="string"&&e.length<=2048&&!!e.match(cje())},hex:function(e){return typeof e=="string"&&!!e.match(JO.hex)}},dje=function(e,n,s,r,o){if(e.required&&n===void 0){Qz(e,n,s,r,o);return}var a=["integer","float","array","regexp","object","method","email","number","date","url","hex"],i=e.type;a.indexOf(i)>-1?Wm[i](n)||r.push(Po(o.messages.types[i],e.fullField,e.type)):i&&typeof n!==e.type&&r.push(Po(o.messages.types[i],e.fullField,e.type))},fje=function(e,n,s,r,o){var a=typeof e.len=="number",i=typeof e.min=="number",l=typeof e.max=="number",u=/[\uD800-\uDBFF][\uDC00-\uDFFF]/g,c=n,d=null,f=typeof n=="number",h=typeof n=="string",p=Array.isArray(n);if(f?d="number":h?d="string":p&&(d="array"),!d)return!1;p&&(c=n.length),h&&(c=n.replace(u,"_").length),a?c!==e.len&&r.push(Po(o.messages[d].len,e.fullField,e.len)):i&&!l&&c<e.min?r.push(Po(o.messages[d].min,e.fullField,e.min)):l&&!i&&c>e.max?r.push(Po(o.messages[d].max,e.fullField,e.max)):i&&l&&(c<e.min||c>e.max)&&r.push(Po(o.messages[d].range,e.fullField,e.min,e.max))},wf="enum",hje=function(e,n,s,r,o){e[wf]=Array.isArray(e[wf])?e[wf]:[],e[wf].indexOf(n)===-1&&r.push(Po(o.messages[wf],e.fullField,e[wf].join(", ")))},pje=function(e,n,s,r,o){if(e.pattern){if(e.pattern instanceof RegExp)e.pattern.lastIndex=0,e.pattern.test(n)||r.push(Po(o.messages.pattern.mismatch,e.fullField,n,e.pattern));else if(typeof e.pattern=="string"){var a=new RegExp(e.pattern);a.test(n)||r.push(Po(o.messages.pattern.mismatch,e.fullField,n,e.pattern))}}},bn={required:Qz,whitespace:uje,type:dje,range:fje,enum:hje,pattern:pje},mje=function(e,n,s,r,o){var a=[],i=e.required||!e.required&&r.hasOwnProperty(e.field);if(i){if(Ws(n,"string")&&!e.required)return s();bn.required(e,n,r,a,o,"string"),Ws(n,"string")||(bn.type(e,n,r,a,o),bn.range(e,n,r,a,o),bn.pattern(e,n,r,a,o),e.whitespace===!0&&bn.whitespace(e,n,r,a,o))}s(a)},gje=function(e,n,s,r,o){var a=[],i=e.required||!e.required&&r.hasOwnProperty(e.field);if(i){if(Ws(n)&&!e.required)return s();bn.required(e,n,r,a,o),n!==void 0&&bn.type(e,n,r,a,o)}s(a)},vje=function(e,n,s,r,o){var a=[],i=e.required||!e.required&&r.hasOwnProperty(e.field);if(i){if(n===""&&(n=void 0),Ws(n)&&!e.required)return s();bn.required(e,n,r,a,o),n!==void 0&&(bn.type(e,n,r,a,o),bn.range(e,n,r,a,o))}s(a)},yje=function(e,n,s,r,o){var a=[],i=e.required||!e.required&&r.hasOwnProperty(e.field);if(i){if(Ws(n)&&!e.required)return s();bn.required(e,n,r,a,o),n!==void 0&&bn.type(e,n,r,a,o)}s(a)},bje=function(e,n,s,r,o){var a=[],i=e.required||!e.required&&r.hasOwnProperty(e.field);if(i){if(Ws(n)&&!e.required)return s();bn.required(e,n,r,a,o),Ws(n)||bn.type(e,n,r,a,o)}s(a)},wje=function(e,n,s,r,o){var a=[],i=e.required||!e.required&&r.hasOwnProperty(e.field);if(i){if(Ws(n)&&!e.required)return s();bn.required(e,n,r,a,o),n!==void 0&&(bn.type(e,n,r,a,o),bn.range(e,n,r,a,o))}s(a)},_je=function(e,n,s,r,o){var a=[],i=e.required||!e.required&&r.hasOwnProperty(e.field);if(i){if(Ws(n)&&!e.required)return s();bn.required(e,n,r,a,o),n!==void 0&&(bn.type(e,n,r,a,o),bn.range(e,n,r,a,o))}s(a)},$je=function(e,n,s,r,o){var a=[],i=e.required||!e.required&&r.hasOwnProperty(e.field);if(i){if(n==null&&!e.required)return s();bn.required(e,n,r,a,o,"array"),n!=null&&(bn.type(e,n,r,a,o),bn.range(e,n,r,a,o))}s(a)},xje=function(e,n,s,r,o){var a=[],i=e.required||!e.required&&r.hasOwnProperty(e.field);if(i){if(Ws(n)&&!e.required)return s();bn.required(e,n,r,a,o),n!==void 0&&bn.type(e,n,r,a,o)}s(a)},Sje="enum",Cje=function(e,n,s,r,o){var a=[],i=e.required||!e.required&&r.hasOwnProperty(e.field);if(i){if(Ws(n)&&!e.required)return s();bn.required(e,n,r,a,o),n!==void 0&&bn[Sje](e,n,r,a,o)}s(a)},kje=function(e,n,s,r,o){var a=[],i=e.required||!e.required&&r.hasOwnProperty(e.field);if(i){if(Ws(n,"string")&&!e.required)return s();bn.required(e,n,r,a,o),Ws(n,"string")||bn.pattern(e,n,r,a,o)}s(a)},Tje=function(e,n,s,r,o){var a=[],i=e.required||!e.required&&r.hasOwnProperty(e.field);if(i){if(Ws(n,"date")&&!e.required)return s();if(bn.required(e,n,r,a,o),!Ws(n,"date")){var l;n instanceof Date?l=n:l=new Date(n),bn.type(e,l,r,a,o),l&&bn.range(e,l.getTime(),r,a,o)}}s(a)},Nje=function(e,n,s,r,o){var a=[],i=Array.isArray(n)?"array":typeof n;bn.required(e,n,r,a,o,i),s(a)},n$=function(e,n,s,r,o){var a=e.type,i=[],l=e.required||!e.required&&r.hasOwnProperty(e.field);if(l){if(Ws(n,a)&&!e.required)return s();bn.required(e,n,r,i,o,a),Ws(n,a)||bn.type(e,n,r,i,o)}s(i)},Ije=function(e,n,s,r,o){var a=[],i=e.required||!e.required&&r.hasOwnProperty(e.field);if(i){if(Ws(n)&&!e.required)return s();bn.required(e,n,r,a,o)}s(a)},f0={string:mje,method:gje,number:vje,boolean:yje,regexp:bje,integer:wje,float:_je,array:$je,object:xje,enum:Cje,pattern:kje,date:Tje,url:n$,hex:n$,email:n$,required:Nje,any:Ije};function P6(){return{default:"Validation error on field %s",required:"%s is required",enum:"%s must be one of %s",whitespace:"%s cannot be empty",date:{format:"%s date %s is invalid for format %s",parse:"%s date could not be parsed, %s is invalid ",invalid:"%s date %s is invalid"},types:{string:"%s is not a %s",method:"%s is not a %s (function)",array:"%s is not an %s",object:"%s is not an %s",number:"%s is not a %s",date:"%s is not a %s",boolean:"%s is not a %s",integer:"%s is not an %s",float:"%s is not a %s",regexp:"%s is not a valid %s",email:"%s is not a valid %s",url:"%s is not a valid %s",hex:"%s is not a valid %s"},string:{len:"%s must be exactly %s characters",min:"%s must be at least %s characters",max:"%s cannot be longer than %s characters",range:"%s must be between %s and %s characters"},number:{len:"%s must equal %s",min:"%s cannot be less than %s",max:"%s cannot be greater than %s",range:"%s must be between %s and %s"},array:{len:"%s must be exactly %s in length",min:"%s cannot be less than %s in length",max:"%s cannot be greater than %s in length",range:"%s must be between %s and %s in length"},pattern:{mismatch:"%s value %s does not match pattern %s"},clone:function(){var e=JSON.parse(JSON.stringify(this));return e.clone=this.clone,e}}}var L6=P6(),Pg=function(){function t(n){this.rules=null,this._messages=L6,this.define(n)}var e=t.prototype;return e.define=function(s){var r=this;if(!s)throw new Error("Cannot configure a schema with no rules");if(typeof s!="object"||Array.isArray(s))throw new Error("Rules must be an object");this.rules={},Object.keys(s).forEach(function(o){var a=s[o];r.rules[o]=Array.isArray(a)?a:[a]})},e.messages=function(s){return s&&(this._messages=ZO(P6(),s)),this._messages},e.validate=function(s,r,o){var a=this;r===void 0&&(r={}),o===void 0&&(o=function(){});var i=s,l=r,u=o;if(typeof l=="function"&&(u=l,l={}),!this.rules||Object.keys(this.rules).length===0)return u&&u(null,i),Promise.resolve(i);function c(m){var g=[],y={};function w(_){if(Array.isArray(_)){var $;g=($=g).concat.apply($,_)}else g.push(_)}for(var b=0;b<m.length;b++)w(m[b]);g.length?(y=M6(g),u(g,y)):u(null,i)}if(l.messages){var d=this.messages();d===L6&&(d=P6()),ZO(d,l.messages),l.messages=d}else l.messages=this.messages();var f={},h=l.keys||Object.keys(this.rules);h.forEach(function(m){var g=a.rules[m],y=i[m];g.forEach(function(w){var b=w;typeof b.transform=="function"&&(i===s&&(i=qc({},i)),y=i[m]=b.transform(y)),typeof b=="function"?b={validator:b}:b=qc({},b),b.validator=a.getValidationMethod(b),b.validator&&(b.field=m,b.fullField=b.fullField||m,b.type=a.getType(b),f[m]=f[m]||[],f[m].push({rule:b,value:y,source:i,field:m}))})});var p={};return aje(f,l,function(m,g){var y=m.rule,w=(y.type==="object"||y.type==="array")&&(typeof y.fields=="object"||typeof y.defaultField=="object");w=w&&(y.required||!y.required&&m.value),y.field=m.field;function b(x,k){return qc({},k,{fullField:y.fullField+"."+x,fullFields:y.fullFields?[].concat(y.fullFields,[x]):[x]})}function _(x){x===void 0&&(x=[]);var k=Array.isArray(x)?x:[x];!l.suppressWarning&&k.length&&t.warning("async-validator:",k),k.length&&y.message!==void 0&&(k=[].concat(y.message));var C=k.map(YO(y,i));if(l.first&&C.length)return p[y.field]=1,g(C);if(!w)g(C);else{if(y.required&&!m.value)return y.message!==void 0?C=[].concat(y.message).map(YO(y,i)):l.error&&(C=[l.error(y,Po(l.messages.required,y.field))]),g(C);var T={};y.defaultField&&Object.keys(m.value).map(function(R){T[R]=y.defaultField}),T=qc({},T,m.rule.fields);var N={};Object.keys(T).forEach(function(R){var D=T[R],z=Array.isArray(D)?D:[D];N[R]=z.map(b.bind(null,R))});var M=new t(N);M.messages(l.messages),m.rule.options&&(m.rule.options.messages=l.messages,m.rule.options.error=l.error),M.validate(m.value,m.rule.options||l,function(R){var D=[];C&&C.length&&D.push.apply(D,C),R&&R.length&&D.push.apply(D,R),g(D.length?D:null)})}}var $;if(y.asyncValidator)$=y.asyncValidator(y,m.value,_,m.source,l);else if(y.validator){try{$=y.validator(y,m.value,_,m.source,l)}catch(x){console.error==null||console.error(x),l.suppressValidatorError||setTimeout(function(){throw x},0),_(x.message)}$===!0?_():$===!1?_(typeof y.message=="function"?y.message(y.fullField||y.field):y.message||(y.fullField||y.field)+" fails"):$ instanceof Array?_($):$ instanceof Error&&_($.message)}$&&$.then&&$.then(function(){return _()},function(x){return _(x)})},function(m){c(m)},i)},e.getType=function(s){if(s.type===void 0&&s.pattern instanceof RegExp&&(s.type="pattern"),typeof s.validator!="function"&&s.type&&!f0.hasOwnProperty(s.type))throw new Error(Po("Unknown rule type %s",s.type));return s.type||"string"},e.getValidationMethod=function(s){if(typeof s.validator=="function")return s.validator;var r=Object.keys(s),o=r.indexOf("message");return o!==-1&&r.splice(o,1),r.length===1&&r[0]==="required"?f0.required:f0[this.getType(s)]||void 0},t}();Pg.register=function(e,n){if(typeof n!="function")throw new Error("Cannot register a validator by type, validator is not a function");f0[e]=n};Pg.warning=nje;Pg.messages=L6;Pg.validators=f0;const Eje=["","error","validating","success"],Aje=qe({label:String,labelWidth:{type:[String,Number],default:""},prop:{type:Se([String,Array])},required:{type:Boolean,default:void 0},rules:{type:Se([Object,Array])},error:String,validateStatus:{type:String,values:Eje},for:String,inlineMessage:{type:[String,Boolean],default:""},showMessage:{type:Boolean,default:!0},size:{type:String,values:Hl}}),QO="ElLabelWrap";var Oje=ue({name:QO,props:{isAutoWidth:Boolean,updateAll:Boolean},setup(t,{slots:e}){const n=et(Jd,void 0),s=et(Li);s||Ls(QO,"usage: <el-form-item><label-wrap /></el-form-item>");const r=Fe("form"),o=U(),a=U(0),i=()=>{var c;if((c=o.value)!=null&&c.firstElementChild){const d=window.getComputedStyle(o.value.firstElementChild).width;return Math.ceil(Number.parseFloat(d))}else return 0},l=(c="update")=>{nt(()=>{e.default&&t.isAutoWidth&&(c==="update"?a.value=i():c==="remove"&&(n==null||n.deregisterLabelWidth(a.value)))})},u=()=>l("update");return It(()=>{u()}),ts(()=>{l("remove")}),Ml(()=>u()),Me(a,(c,d)=>{t.updateAll&&(n==null||n.registerLabelWidth(c,d))}),Dr(A(()=>{var c,d;return(d=(c=o.value)==null?void 0:c.firstElementChild)!=null?d:null}),u),()=>{var c,d;if(!e)return null;const{isAutoWidth:f}=t;if(f){const h=n==null?void 0:n.autoLabelWidth,p=s==null?void 0:s.hasLabel,m={};if(p&&h&&h!=="auto"){const g=Math.max(0,Number.parseInt(h,10)-a.value),y=n.labelPosition==="left"?"marginRight":"marginLeft";g&&(m[y]=`${g}px`)}return se("div",{ref:o,class:[r.be("item","label-wrap")],style:m},[(c=e.default)==null?void 0:c.call(e)])}else return se(lt,{ref:o},[(d=e.default)==null?void 0:d.call(e)])}}});const Rje=["role","aria-labelledby"],Dje=ue({name:"ElFormItem"}),Fje=ue({...Dje,props:Aje,setup(t,{expose:e}){const n=t,s=ir(),r=et(Jd,void 0),o=et(Li,void 0),a=ks(void 0,{formItem:!1}),i=Fe("form-item"),l=ei().value,u=U([]),c=U(""),d=yue(c,100),f=U(""),h=U();let p,m=!1;const g=A(()=>{if((r==null?void 0:r.labelPosition)==="top")return{};const ee=Cs(n.labelWidth||(r==null?void 0:r.labelWidth)||"");return ee?{width:ee}:{}}),y=A(()=>{if((r==null?void 0:r.labelPosition)==="top"||(r==null?void 0:r.inline))return{};if(!n.label&&!n.labelWidth&&T)return{};const ee=Cs(n.labelWidth||(r==null?void 0:r.labelWidth)||"");return!n.label&&!s.label?{marginLeft:ee}:{}}),w=A(()=>[i.b(),i.m(a.value),i.is("error",c.value==="error"),i.is("validating",c.value==="validating"),i.is("success",c.value==="success"),i.is("required",z.value||n.required),i.is("no-asterisk",r==null?void 0:r.hideRequiredAsterisk),(r==null?void 0:r.requireAsteriskPosition)==="right"?"asterisk-right":"asterisk-left",{[i.m("feedback")]:r==null?void 0:r.statusIcon}]),b=A(()=>Rs(n.inlineMessage)?n.inlineMessage:(r==null?void 0:r.inlineMessage)||!1),_=A(()=>[i.e("error"),{[i.em("error","inline")]:b.value}]),$=A(()=>n.prop?wt(n.prop)?n.prop:n.prop.join("."):""),x=A(()=>!!(n.label||s.label)),k=A(()=>n.for||u.value.length===1?u.value[0]:void 0),C=A(()=>!k.value&&x.value),T=!!o,N=A(()=>{const ee=r==null?void 0:r.model;if(!(!ee||!n.prop))return Wv(ee,n.prop).value}),M=A(()=>{const{required:ee}=n,Q=[];n.rules&&Q.push(...dh(n.rules));const ie=r==null?void 0:r.rules;if(ie&&n.prop){const pe=Wv(ie,n.prop).value;pe&&Q.push(...dh(pe))}if(ee!==void 0){const pe=Q.map((Re,K)=>[Re,K]).filter(([Re])=>Object.keys(Re).includes("required"));if(pe.length>0)for(const[Re,K]of pe)Re.required!==ee&&(Q[K]={...Re,required:ee});else Q.push({required:ee})}return Q}),R=A(()=>M.value.length>0),D=ee=>M.value.filter(ie=>!ie.trigger||!ee?!0:Array.isArray(ie.trigger)?ie.trigger.includes(ee):ie.trigger===ee).map(({trigger:ie,...pe})=>pe),z=A(()=>M.value.some(ee=>ee.required)),B=A(()=>{var ee;return d.value==="error"&&n.showMessage&&((ee=r==null?void 0:r.showMessage)!=null?ee:!0)}),V=A(()=>`${n.label||""}${(r==null?void 0:r.labelSuffix)||""}`),O=ee=>{c.value=ee},F=ee=>{var Q,ie;const{errors:pe,fields:Re}=ee;(!pe||!Re)&&console.error(ee),O("error"),f.value=pe?(ie=(Q=pe==null?void 0:pe[0])==null?void 0:Q.message)!=null?ie:`${n.prop} is required`:"",r==null||r.emit("validate",n.prop,!1,f.value)},L=()=>{O("success"),r==null||r.emit("validate",n.prop,!0,"")},G=async ee=>{const Q=$.value;return new Pg({[Q]:ee}).validate({[Q]:N.value},{firstFields:!0}).then(()=>(L(),!0)).catch(pe=>(F(pe),Promise.reject(pe)))},Z=async(ee,Q)=>{if(m||!n.prop)return!1;const ie=vt(Q);if(!R.value)return Q==null||Q(!1),!1;const pe=D(ee);return pe.length===0?(Q==null||Q(!0),!0):(O("validating"),G(pe).then(()=>(Q==null||Q(!0),!0)).catch(Re=>{const{fields:K}=Re;return Q==null||Q(!1,K),ie?!1:Promise.reject(K)}))},j=()=>{O(""),f.value="",m=!1},J=async()=>{const ee=r==null?void 0:r.model;if(!ee||!n.prop)return;const Q=Wv(ee,n.prop);m=!0,Q.value=SA(p),await nt(),j(),m=!1},fe=ee=>{u.value.includes(ee)||u.value.push(ee)},X=ee=>{u.value=u.value.filter(Q=>Q!==ee)};Me(()=>n.error,ee=>{f.value=ee||"",O(ee?"error":"")},{immediate:!0}),Me(()=>n.validateStatus,ee=>O(ee||""));const oe=on({...Ps(n),$el:h,size:a,validateState:c,labelId:l,inputIds:u,isGroup:C,hasLabel:x,addInputId:fe,removeInputId:X,resetField:J,clearValidate:j,validate:Z});return Lt(Li,oe),It(()=>{n.prop&&(r==null||r.addField(oe),p=SA(N.value))}),ts(()=>{r==null||r.removeField(oe)}),e({size:a,validateMessage:f,validateState:c,validate:Z,clearValidate:j,resetField:J}),(ee,Q)=>{var ie;return S(),E("div",{ref_key:"formItemRef",ref:h,class:P(v(w)),role:v(C)?"group":void 0,"aria-labelledby":v(C)?v(l):void 0},[se(v(Oje),{"is-auto-width":v(g).width==="auto","update-all":((ie=v(r))==null?void 0:ie.labelWidth)==="auto"},{default:ce(()=>[v(x)?(S(),$e(Vt(v(k)?"label":"div"),{key:0,id:v(l),for:v(k),class:P(v(i).e("label")),style:ot(v(g))},{default:ce(()=>[Oe(ee.$slots,"label",{label:v(V)},()=>[Yt(Ue(v(V)),1)])]),_:3},8,["id","for","class","style"])):ge("v-if",!0)]),_:3},8,["is-auto-width","update-all"]),I("div",{class:P(v(i).e("content")),style:ot(v(y))},[Oe(ee.$slots,"default"),se(ms,{name:`${v(i).namespace.value}-zoom-in-top`},{default:ce(()=>[v(B)?Oe(ee.$slots,"error",{key:0,error:f.value},()=>[I("div",{class:P(v(_))},Ue(f.value),3)]):ge("v-if",!0)]),_:3},8,["name"])],6)],10,Rje)}}});var e7=je(Fje,[["__file","/home/runner/work/element-plus/element-plus/packages/components/form/src/form-item.vue"]]);const Mje=Dt(ZGe,{FormItem:e7}),Pje=ns(e7),Lje=qe({urlList:{type:Se(Array),default:()=>Ln([])},zIndex:{type:Number},initialIndex:{type:Number,default:0},infinite:{type:Boolean,default:!0},hideOnClickModal:{type:Boolean,default:!1},teleported:{type:Boolean,default:!1},closeOnPressEscape:{type:Boolean,default:!0}}),zje={close:()=>!0,switch:t=>Ct(t)},Bje=["src"],Vje=ue({name:"ElImageViewer"}),Hje=ue({...Vje,props:Lje,emits:zje,setup(t,{expose:e,emit:n}){const s=t,r={CONTAIN:{name:"contain",icon:nd(gP)},ORIGINAL:{name:"original",icon:nd(SP)}},o=MC()?"DOMMouseScroll":"mousewheel",{t:a}=nn(),i=Fe("image-viewer"),{nextZIndex:l}=Ul(),u=U(),c=U([]),d=MQ(),f=U(!0),h=U(s.initialIndex),p=Nn(r.CONTAIN),m=U({scale:1,deg:0,offsetX:0,offsetY:0,enableTransition:!1}),g=A(()=>{const{urlList:F}=s;return F.length<=1}),y=A(()=>h.value===0),w=A(()=>h.value===s.urlList.length-1),b=A(()=>s.urlList[h.value]),_=A(()=>{const{scale:F,deg:L,offsetX:G,offsetY:Z,enableTransition:j}=m.value;let J=G/F,fe=Z/F;switch(L%360){case 90:case-270:[J,fe]=[fe,-J];break;case 180:case-180:[J,fe]=[-J,-fe];break;case 270:case-90:[J,fe]=[-fe,J];break}const X={transform:`scale(${F}) rotate(${L}deg) translate(${J}px, ${fe}px)`,transition:j?"transform .3s":""};return p.value.name===r.CONTAIN.name&&(X.maxWidth=X.maxHeight="100%"),X}),$=A(()=>Ct(s.zIndex)?s.zIndex:l());function x(){C(),n("close")}function k(){const F=rd(G=>{switch(G.code){case ut.esc:s.closeOnPressEscape&&x();break;case ut.space:D();break;case ut.left:B();break;case ut.up:O("zoomIn");break;case ut.right:V();break;case ut.down:O("zoomOut");break}}),L=rd(G=>{(G.wheelDelta?G.wheelDelta:-G.detail)>0?O("zoomIn",{zoomRate:1.2,enableTransition:!1}):O("zoomOut",{zoomRate:1.2,enableTransition:!1})});d.run(()=>{Rn(document,"keydown",F),Rn(document,o,L)})}function C(){d.stop()}function T(){f.value=!1}function N(F){f.value=!1,F.target.alt=a("el.image.error")}function M(F){if(f.value||F.button!==0||!u.value)return;m.value.enableTransition=!1;const{offsetX:L,offsetY:G}=m.value,Z=F.pageX,j=F.pageY,J=rd(X=>{m.value={...m.value,offsetX:L+X.pageX-Z,offsetY:G+X.pageY-j}}),fe=Rn(document,"mousemove",J);Rn(document,"mouseup",()=>{fe()}),F.preventDefault()}function R(){m.value={scale:1,deg:0,offsetX:0,offsetY:0,enableTransition:!1}}function D(){if(f.value)return;const F=D0(r),L=Object.values(r),G=p.value.name,j=(L.findIndex(J=>J.name===G)+1)%F.length;p.value=r[F[j]],R()}function z(F){const L=s.urlList.length;h.value=(F+L)%L}function B(){y.value&&!s.infinite||z(h.value-1)}function V(){w.value&&!s.infinite||z(h.value+1)}function O(F,L={}){if(f.value)return;const{zoomRate:G,rotateDeg:Z,enableTransition:j}={zoomRate:1.4,rotateDeg:90,enableTransition:!0,...L};switch(F){case"zoomOut":m.value.scale>.2&&(m.value.scale=Number.parseFloat((m.value.scale/G).toFixed(3)));break;case"zoomIn":m.value.scale<7&&(m.value.scale=Number.parseFloat((m.value.scale*G).toFixed(3)));break;case"clockwise":m.value.deg+=Z;break;case"anticlockwise":m.value.deg-=Z;break}m.value.enableTransition=j}return Me(b,()=>{nt(()=>{const F=c.value[0];F!=null&&F.complete||(f.value=!0)})}),Me(h,F=>{R(),n("switch",F)}),It(()=>{var F,L;k(),(L=(F=u.value)==null?void 0:F.focus)==null||L.call(F)}),e({setActiveItem:z}),(F,L)=>(S(),$e(kg,{to:"body",disabled:!F.teleported},[se(ms,{name:"viewer-fade",appear:""},{default:ce(()=>[I("div",{ref_key:"wrapper",ref:u,tabindex:-1,class:P(v(i).e("wrapper")),style:ot({zIndex:v($)})},[I("div",{class:P(v(i).e("mask")),onClick:L[0]||(L[0]=yt(G=>F.hideOnClickModal&&x(),["self"]))},null,2),ge(" CLOSE "),I("span",{class:P([v(i).e("btn"),v(i).e("close")]),onClick:x},[se(v(rt),null,{default:ce(()=>[se(v(xa))]),_:1})],2),ge(" ARROW "),v(g)?ge("v-if",!0):(S(),E(lt,{key:0},[I("span",{class:P([v(i).e("btn"),v(i).e("prev"),v(i).is("disabled",!F.infinite&&v(y))]),onClick:B},[se(v(rt),null,{default:ce(()=>[se(v(xl))]),_:1})],2),I("span",{class:P([v(i).e("btn"),v(i).e("next"),v(i).is("disabled",!F.infinite&&v(w))]),onClick:V},[se(v(rt),null,{default:ce(()=>[se(v(Rr))]),_:1})],2)],64)),ge(" ACTIONS "),I("div",{class:P([v(i).e("btn"),v(i).e("actions")])},[I("div",{class:P(v(i).e("actions__inner"))},[se(v(rt),{onClick:L[1]||(L[1]=G=>O("zoomOut"))},{default:ce(()=>[se(v(EP))]),_:1}),se(v(rt),{onClick:L[2]||(L[2]=G=>O("zoomIn"))},{default:ce(()=>[se(v(DC))]),_:1}),I("i",{class:P(v(i).e("actions__divider"))},null,2),se(v(rt),{onClick:D},{default:ce(()=>[(S(),$e(Vt(v(p).icon)))]),_:1}),I("i",{class:P(v(i).e("actions__divider"))},null,2),se(v(rt),{onClick:L[3]||(L[3]=G=>O("anticlockwise"))},{default:ce(()=>[se(v($P))]),_:1}),se(v(rt),{onClick:L[4]||(L[4]=G=>O("clockwise"))},{default:ce(()=>[se(v(xP))]),_:1})],2)],2),ge(" CANVAS "),I("div",{class:P(v(i).e("canvas"))},[(S(!0),E(lt,null,Gt(F.urlList,(G,Z)=>St((S(),E("img",{ref_for:!0,ref:j=>c.value[Z]=j,key:G,src:G,style:ot(v(_)),class:P(v(i).e("img")),onLoad:T,onError:N,onMousedown:M},null,46,Bje)),[[Qt,Z===h.value]])),128))],2),Oe(F.$slots,"default")],6)]),_:3})],8,["disabled"]))}});var Wje=je(Hje,[["__file","/home/runner/work/element-plus/element-plus/packages/components/image-viewer/src/image-viewer.vue"]]);const t7=Dt(Wje),Uje=qe({hideOnClickModal:{type:Boolean,default:!1},src:{type:String,default:""},fit:{type:String,values:["","contain","cover","fill","none","scale-down"],default:""},loading:{type:String,values:["eager","lazy"]},lazy:{type:Boolean,default:!1},scrollContainer:{type:Se([String,Object])},previewSrcList:{type:Se(Array),default:()=>Ln([])},previewTeleported:{type:Boolean,default:!1},zIndex:{type:Number},initialIndex:{type:Number,default:0},infinite:{type:Boolean,default:!0},closeOnPressEscape:{type:Boolean,default:!0}}),Gje={load:t=>t instanceof Event,error:t=>t instanceof Event,switch:t=>Ct(t),close:()=>!0,show:()=>!0},jje=["src","loading"],Kje={key:0},qje=ue({name:"ElImage",inheritAttrs:!1}),Xje=ue({...qje,props:Uje,emits:Gje,setup(t,{emit:e}){const n=t;let s="";const{t:r}=nn(),o=Fe("image"),a=Tg(),i=zC(),l=U(),u=U(!1),c=U(!0),d=U(!1),f=U(),h=U(),p=Kt&&"loading"in HTMLImageElement.prototype;let m,g;const y=A(()=>a.style),w=A(()=>{const{fit:O}=n;return Kt&&O?{objectFit:O}:{}}),b=A(()=>{const{previewSrcList:O}=n;return Array.isArray(O)&&O.length>0}),_=A(()=>{const{previewSrcList:O,initialIndex:F}=n;let L=F;return F>O.length-1&&(L=0),L}),$=A(()=>n.loading==="eager"?!1:!p&&n.loading==="lazy"||n.lazy),x=()=>{!Kt||(c.value=!0,u.value=!1,l.value=n.src)};function k(O){c.value=!1,u.value=!1,e("load",O)}function C(O){c.value=!1,u.value=!0,e("error",O)}function T(){Fue(f.value,h.value)&&(x(),R())}const N=oP(T,200);async function M(){var O;if(!Kt)return;await nt();const{scrollContainer:F}=n;Qa(F)?h.value=F:wt(F)&&F!==""?h.value=(O=document.querySelector(F))!=null?O:void 0:f.value&&(h.value=IC(f.value)),h.value&&(m=Rn(h,"scroll",N),setTimeout(()=>T(),100))}function R(){!Kt||!h.value||!N||(m==null||m(),h.value=void 0)}function D(O){if(!!O.ctrlKey){if(O.deltaY<0)return O.preventDefault(),!1;if(O.deltaY>0)return O.preventDefault(),!1}}function z(){!b.value||(g=Rn("wheel",D,{passive:!1}),s=document.body.style.overflow,document.body.style.overflow="hidden",d.value=!0,e("show"))}function B(){g==null||g(),document.body.style.overflow=s,d.value=!1,e("close")}function V(O){e("switch",O)}return Me(()=>n.src,()=>{$.value?(c.value=!0,u.value=!1,R(),M()):x()}),It(()=>{$.value?M():x()}),(O,F)=>(S(),E("div",{ref_key:"container",ref:f,class:P([v(o).b(),O.$attrs.class]),style:ot(v(y))},[l.value!==void 0&&!u.value?(S(),E("img",zt({key:0},v(i),{src:l.value,loading:O.loading,style:v(w),class:[v(o).e("inner"),v(b)&&v(o).e("preview"),c.value&&v(o).is("loading")],onClick:z,onLoad:k,onError:C}),null,16,jje)):ge("v-if",!0),c.value||u.value?(S(),E("div",{key:1,class:P(v(o).e("wrapper"))},[c.value?Oe(O.$slots,"placeholder",{key:0},()=>[I("div",{class:P(v(o).e("placeholder"))},null,2)]):u.value?Oe(O.$slots,"error",{key:1},()=>[I("div",{class:P(v(o).e("error"))},Ue(v(r)("el.image.error")),3)]):ge("v-if",!0)],2)):ge("v-if",!0),v(b)?(S(),E(lt,{key:2},[d.value?(S(),$e(v(t7),{key:0,"z-index":O.zIndex,"initial-index":v(_),infinite:O.infinite,"url-list":O.previewSrcList,"hide-on-click-modal":O.hideOnClickModal,teleported:O.previewTeleported,"close-on-press-escape":O.closeOnPressEscape,onClose:B,onSwitch:V},{default:ce(()=>[O.$slots.viewer?(S(),E("div",Kje,[Oe(O.$slots,"viewer")])):ge("v-if",!0)]),_:3},8,["z-index","initial-index","infinite","url-list","hide-on-click-modal","teleported","close-on-press-escape"])):ge("v-if",!0)],64)):ge("v-if",!0)],6))}});var Yje=je(Xje,[["__file","/home/runner/work/element-plus/element-plus/packages/components/image/src/image.vue"]]);const Zje=Dt(Yje),Jje=qe({id:{type:String,default:void 0},step:{type:Number,default:1},stepStrictly:Boolean,max:{type:Number,default:Number.POSITIVE_INFINITY},min:{type:Number,default:Number.NEGATIVE_INFINITY},modelValue:Number,readonly:Boolean,disabled:Boolean,size:wo,controls:{type:Boolean,default:!0},controlsPosition:{type:String,default:"",values:["","right"]},valueOnClear:{type:[String,Number,null],validator:t=>t===null||Ct(t)||["min","max"].includes(t),default:null},name:String,label:String,placeholder:String,precision:{type:Number,validator:t=>t>=0&&t===Number.parseInt(`${t}`,10)},validateEvent:{type:Boolean,default:!0}}),Qje={[Fn]:(t,e)=>t!==e,blur:t=>t instanceof FocusEvent,focus:t=>t instanceof FocusEvent,[jr]:t=>Ct(t)||nr(t),[Ot]:t=>Ct(t)||nr(t)},eKe=["aria-label","onKeydown"],tKe=["aria-label","onKeydown"],nKe=ue({name:"ElInputNumber"}),sKe=ue({...nKe,props:Jje,emits:Qje,setup(t,{expose:e,emit:n}){const s=t,{t:r}=nn(),o=Fe("input-number"),a=U(),i=on({currentValue:s.modelValue,userInput:null}),{formItem:l}=to(),u=A(()=>Ct(s.modelValue)&&s.modelValue<=s.min),c=A(()=>Ct(s.modelValue)&&s.modelValue>=s.max),d=A(()=>{const D=y(s.step);return er(s.precision)?Math.max(y(s.modelValue),D):(D>s.precision,s.precision)}),f=A(()=>s.controls&&s.controlsPosition==="right"),h=ks(),p=To(),m=A(()=>{if(i.userInput!==null)return i.userInput;let D=i.currentValue;if(nr(D))return"";if(Ct(D)){if(Number.isNaN(D))return"";er(s.precision)||(D=D.toFixed(s.precision))}return D}),g=(D,z)=>{if(er(z)&&(z=d.value),z===0)return Math.round(D);let B=String(D);const V=B.indexOf(".");if(V===-1||!B.replace(".","").split("")[V+z])return D;const L=B.length;return B.charAt(L-1)==="5"&&(B=`${B.slice(0,Math.max(0,L-1))}6`),Number.parseFloat(Number(B).toFixed(z))},y=D=>{if(nr(D))return 0;const z=D.toString(),B=z.indexOf(".");let V=0;return B!==-1&&(V=z.length-B-1),V},w=(D,z=1)=>Ct(D)?g(D+s.step*z):i.currentValue,b=()=>{if(s.readonly||p.value||c.value)return;const D=Number(m.value)||0,z=w(D);x(z),n(jr,i.currentValue)},_=()=>{if(s.readonly||p.value||u.value)return;const D=Number(m.value)||0,z=w(D,-1);x(z),n(jr,i.currentValue)},$=(D,z)=>{const{max:B,min:V,step:O,precision:F,stepStrictly:L,valueOnClear:G}=s;let Z=Number(D);if(nr(D)||Number.isNaN(Z))return null;if(D===""){if(G===null)return null;Z=wt(G)?{min:V,max:B}[G]:G}return L&&(Z=g(Math.round(Z/O)*O,F)),er(F)||(Z=g(Z,F)),(Z>B||Z<V)&&(Z=Z>B?B:V,z&&n(Ot,Z)),Z},x=(D,z=!0)=>{var B;const V=i.currentValue,O=$(D);if(V!==O){if(!z){n(Ot,O);return}i.userInput=null,n(Ot,O),n(Fn,O,V),s.validateEvent&&((B=l==null?void 0:l.validate)==null||B.call(l,"change").catch(F=>void 0)),i.currentValue=O}},k=D=>{i.userInput=D;const z=D===""?null:Number(D);n(jr,z),x(z,!1)},C=D=>{const z=D!==""?Number(D):"";(Ct(z)&&!Number.isNaN(z)||D==="")&&x(z),i.userInput=null},T=()=>{var D,z;(z=(D=a.value)==null?void 0:D.focus)==null||z.call(D)},N=()=>{var D,z;(z=(D=a.value)==null?void 0:D.blur)==null||z.call(D)},M=D=>{n("focus",D)},R=D=>{var z;n("blur",D),s.validateEvent&&((z=l==null?void 0:l.validate)==null||z.call(l,"blur").catch(B=>void 0))};return Me(()=>s.modelValue,D=>{const z=$(i.userInput),B=$(D,!0);(!z||z!==B)&&(i.currentValue=B,i.userInput=null)},{immediate:!0}),It(()=>{var D;const{min:z,max:B,modelValue:V}=s,O=(D=a.value)==null?void 0:D.input;if(O.setAttribute("role","spinbutton"),Number.isFinite(B)?O.setAttribute("aria-valuemax",String(B)):O.removeAttribute("aria-valuemax"),Number.isFinite(z)?O.setAttribute("aria-valuemin",String(z)):O.removeAttribute("aria-valuemin"),O.setAttribute("aria-valuenow",String(i.currentValue)),O.setAttribute("aria-disabled",String(p.value)),!Ct(V)&&V!=null){let F=Number(V);Number.isNaN(F)&&(F=null),n(Ot,F)}}),Ml(()=>{var D;const z=(D=a.value)==null?void 0:D.input;z==null||z.setAttribute("aria-valuenow",`${i.currentValue}`)}),e({focus:T,blur:N}),(D,z)=>(S(),E("div",{class:P([v(o).b(),v(o).m(v(h)),v(o).is("disabled",v(p)),v(o).is("without-controls",!D.controls),v(o).is("controls-right",v(f))]),onDragstart:z[0]||(z[0]=yt(()=>{},["prevent"]))},[D.controls?St((S(),E("span",{key:0,role:"button","aria-label":v(r)("el.inputNumber.decrease"),class:P([v(o).e("decrease"),v(o).is("disabled",v(u))]),onKeydown:qt(_,["enter"])},[se(v(rt),null,{default:ce(()=>[v(f)?(S(),$e(v(zl),{key:0})):(S(),$e(v(yP),{key:1}))]),_:1})],42,eKe)),[[v(Oy),_]]):ge("v-if",!0),D.controls?St((S(),E("span",{key:1,role:"button","aria-label":v(r)("el.inputNumber.increase"),class:P([v(o).e("increase"),v(o).is("disabled",v(c))]),onKeydown:qt(b,["enter"])},[se(v(rt),null,{default:ce(()=>[v(f)?(S(),$e(v(Og),{key:0})):(S(),$e(v(OC),{key:1}))]),_:1})],42,tKe)),[[v(Oy),b]]):ge("v-if",!0),se(v(Or),{id:D.id,ref_key:"input",ref:a,type:"number",step:D.step,"model-value":v(m),placeholder:D.placeholder,readonly:D.readonly,disabled:v(p),size:v(h),max:D.max,min:D.min,name:D.name,label:D.label,"validate-event":!1,onKeydown:[qt(yt(b,["prevent"]),["up"]),qt(yt(_,["prevent"]),["down"])],onBlur:R,onFocus:M,onInput:k,onChange:C},null,8,["id","step","model-value","placeholder","readonly","disabled","size","max","min","name","label","onKeydown"])],34))}});var rKe=je(sKe,[["__file","/home/runner/work/element-plus/element-plus/packages/components/input-number/src/input-number.vue"]]);const n7=Dt(rKe),oKe=qe({type:{type:String,values:["primary","success","warning","info","danger","default"],default:"default"},underline:{type:Boolean,default:!0},disabled:{type:Boolean,default:!1},href:{type:String,default:""},icon:{type:In}}),aKe={click:t=>t instanceof MouseEvent},iKe=["href"],lKe=ue({name:"ElLink"}),uKe=ue({...lKe,props:oKe,emits:aKe,setup(t,{emit:e}){const n=t,s=Fe("link"),r=A(()=>[s.b(),s.m(n.type),s.is("disabled",n.disabled),s.is("underline",n.underline&&!n.disabled)]);function o(a){n.disabled||e("click",a)}return(a,i)=>(S(),E("a",{class:P(v(r)),href:a.disabled||!a.href?void 0:a.href,onClick:o},[a.icon?(S(),$e(v(rt),{key:0},{default:ce(()=>[(S(),$e(Vt(a.icon)))]),_:1})):ge("v-if",!0),a.$slots.default?(S(),E("span",{key:1,class:P(v(s).e("inner"))},[Oe(a.$slots,"default")],2)):ge("v-if",!0),a.$slots.icon?Oe(a.$slots,"icon",{key:2}):ge("v-if",!0)],10,iKe))}});var cKe=je(uKe,[["__file","/home/runner/work/element-plus/element-plus/packages/components/link/src/link.vue"]]);const dKe=Dt(cKe);let fKe=class{constructor(e,n){this.parent=e,this.domNode=n,this.subIndex=0,this.subIndex=0,this.init()}init(){this.subMenuItems=this.domNode.querySelectorAll("li"),this.addListeners()}gotoSubIndex(e){e===this.subMenuItems.length?e=0:e<0&&(e=this.subMenuItems.length-1),this.subMenuItems[e].focus(),this.subIndex=e}addListeners(){const e=this.parent.domNode;Array.prototype.forEach.call(this.subMenuItems,n=>{n.addEventListener("keydown",s=>{let r=!1;switch(s.code){case ut.down:{this.gotoSubIndex(this.subIndex+1),r=!0;break}case ut.up:{this.gotoSubIndex(this.subIndex-1),r=!0;break}case ut.tab:{Vv(e,"mouseleave");break}case ut.enter:case ut.space:{r=!0,s.currentTarget.click();break}}return r&&(s.preventDefault(),s.stopPropagation()),!1})})}},hKe=class{constructor(e,n){this.domNode=e,this.submenu=null,this.submenu=null,this.init(n)}init(e){this.domNode.setAttribute("tabindex","0");const n=this.domNode.querySelector(`.${e}-menu`);n&&(this.submenu=new fKe(this,n)),this.addListeners()}addListeners(){this.domNode.addEventListener("keydown",e=>{let n=!1;switch(e.code){case ut.down:{Vv(e.currentTarget,"mouseenter"),this.submenu&&this.submenu.gotoSubIndex(0),n=!0;break}case ut.up:{Vv(e.currentTarget,"mouseenter"),this.submenu&&this.submenu.gotoSubIndex(this.submenu.subMenuItems.length-1),n=!0;break}case ut.tab:{Vv(e.currentTarget,"mouseleave");break}case ut.enter:case ut.space:{n=!0,e.currentTarget.click();break}}n&&e.preventDefault()})}},pKe=class{constructor(e,n){this.domNode=e,this.init(n)}init(e){const n=this.domNode.childNodes;Array.from(n).forEach(s=>{s.nodeType===1&&new hKe(s,e)})}};const mKe=ue({name:"ElMenuCollapseTransition",setup(){const t=Fe("menu");return{listeners:{onBeforeEnter:n=>n.style.opacity="0.2",onEnter(n,s){xi(n,`${t.namespace.value}-opacity-transition`),n.style.opacity="1",s()},onAfterEnter(n){mo(n,`${t.namespace.value}-opacity-transition`),n.style.opacity=""},onBeforeLeave(n){n.dataset||(n.dataset={}),ja(n,t.m("collapse"))?(mo(n,t.m("collapse")),n.dataset.oldOverflow=n.style.overflow,n.dataset.scrollWidth=n.clientWidth.toString(),xi(n,t.m("collapse"))):(xi(n,t.m("collapse")),n.dataset.oldOverflow=n.style.overflow,n.dataset.scrollWidth=n.clientWidth.toString(),mo(n,t.m("collapse"))),n.style.width=`${n.scrollWidth}px`,n.style.overflow="hidden"},onLeave(n){xi(n,"horizontal-collapse-transition"),n.style.width=`${n.dataset.scrollWidth}px`}}}}});function gKe(t,e,n,s,r,o){return S(),$e(ms,zt({mode:"out-in"},t.listeners),{default:ce(()=>[Oe(t.$slots,"default")]),_:3},16)}var vKe=je(mKe,[["render",gKe],["__file","/home/runner/work/element-plus/element-plus/packages/components/menu/src/menu-collapse-transition.vue"]]);function s7(t,e){const n=A(()=>{let r=t.parent;const o=[e.value];for(;r.type.name!=="ElMenu";)r.props.index&&o.unshift(r.props.index),r=r.parent;return o});return{parentMenu:A(()=>{let r=t.parent;for(;r&&!["ElMenu","ElSubMenu"].includes(r.type.name);)r=r.parent;return r}),indexPath:n}}function yKe(t){return A(()=>{const n=t.backgroundColor;return n?new PL(n).shade(20).toString():""})}const r7=(t,e)=>{const n=Fe("menu");return A(()=>n.cssVarBlock({"text-color":t.textColor||"","hover-text-color":t.textColor||"","bg-color":t.backgroundColor||"","hover-bg-color":yKe(t).value||"","active-color":t.activeTextColor||"",level:`${e}`}))},bKe=qe({index:{type:String,required:!0},showTimeout:{type:Number,default:300},hideTimeout:{type:Number,default:300},popperClass:String,disabled:Boolean,popperAppendToBody:{type:Boolean,default:void 0},popperOffset:{type:Number,default:6},expandCloseIcon:{type:In},expandOpenIcon:{type:In},collapseCloseIcon:{type:In},collapseOpenIcon:{type:In}}),s$="ElSubMenu";var mk=ue({name:s$,props:bKe,setup(t,{slots:e,expose:n}){const s=Rt(),{indexPath:r,parentMenu:o}=s7(s,A(()=>t.index)),a=Fe("menu"),i=Fe("sub-menu"),l=et("rootMenu");l||Ls(s$,"can not inject root menu");const u=et(`subMenu:${o.value.uid}`);u||Ls(s$,"can not inject sub menu");const c=U({}),d=U({});let f;const h=U(!1),p=U(),m=U(null),g=A(()=>M.value==="horizontal"&&w.value?"bottom-start":"right-start"),y=A(()=>M.value==="horizontal"&&w.value||M.value==="vertical"&&!l.props.collapse?t.expandCloseIcon&&t.expandOpenIcon?x.value?t.expandOpenIcon:t.expandCloseIcon:zl:t.collapseCloseIcon&&t.collapseOpenIcon?x.value?t.collapseOpenIcon:t.collapseCloseIcon:Rr),w=A(()=>u.level===0),b=A(()=>t.popperAppendToBody===void 0?w.value:Boolean(t.popperAppendToBody)),_=A(()=>l.props.collapse?`${a.namespace.value}-zoom-in-left`:`${a.namespace.value}-zoom-in-top`),$=A(()=>M.value==="horizontal"&&w.value?["bottom-start","bottom-end","top-start","top-end","right-start","left-start"]:["right-start","left-start","bottom-start","bottom-end","top-start","top-end"]),x=A(()=>l.openedMenus.includes(t.index)),k=A(()=>{let L=!1;return Object.values(c.value).forEach(G=>{G.active&&(L=!0)}),Object.values(d.value).forEach(G=>{G.active&&(L=!0)}),L}),C=A(()=>l.props.backgroundColor||""),T=A(()=>l.props.activeTextColor||""),N=A(()=>l.props.textColor||""),M=A(()=>l.props.mode),R=on({index:t.index,indexPath:r,active:k}),D=A(()=>M.value!=="horizontal"?{color:N.value}:{borderBottomColor:k.value?l.props.activeTextColor?T.value:"":"transparent",color:k.value?T.value:N.value}),z=()=>{var L,G,Z;return(Z=(G=(L=m.value)==null?void 0:L.popperRef)==null?void 0:G.popperInstanceRef)==null?void 0:Z.destroy()},B=L=>{L||z()},V=()=>{l.props.menuTrigger==="hover"&&l.props.mode==="horizontal"||l.props.collapse&&l.props.mode==="vertical"||t.disabled||l.handleSubMenuClick({index:t.index,indexPath:r.value,active:k.value})},O=(L,G=t.showTimeout)=>{var Z;L.type!=="focus"&&(l.props.menuTrigger==="click"&&l.props.mode==="horizontal"||!l.props.collapse&&l.props.mode==="vertical"||t.disabled||(u.mouseInChild.value=!0,f==null||f(),{stop:f}=_d(()=>{l.openMenu(t.index,r.value)},G),b.value&&((Z=o.value.vnode.el)==null||Z.dispatchEvent(new MouseEvent("mouseenter")))))},F=(L=!1)=>{var G,Z;l.props.menuTrigger==="click"&&l.props.mode==="horizontal"||!l.props.collapse&&l.props.mode==="vertical"||(f==null||f(),u.mouseInChild.value=!1,{stop:f}=_d(()=>!h.value&&l.closeMenu(t.index,r.value),t.hideTimeout),b.value&&L&&((G=s.parent)==null?void 0:G.type.name)==="ElSubMenu"&&((Z=u.handleMouseleave)==null||Z.call(u,!0)))};Me(()=>l.props.collapse,L=>B(Boolean(L)));{const L=Z=>{d.value[Z.index]=Z},G=Z=>{delete d.value[Z.index]};Lt(`subMenu:${s.uid}`,{addSubMenu:L,removeSubMenu:G,handleMouseleave:F,mouseInChild:h,level:u.level+1})}return n({opened:x}),It(()=>{l.addSubMenu(R),u.addSubMenu(R)}),ts(()=>{u.removeSubMenu(R),l.removeSubMenu(R)}),()=>{var L;const G=[(L=e.title)==null?void 0:L.call(e),it(rt,{class:i.e("icon-arrow"),style:{transform:x.value?t.expandCloseIcon&&t.expandOpenIcon||t.collapseCloseIcon&&t.collapseOpenIcon&&l.props.collapse?"none":"rotateZ(180deg)":"none"}},{default:()=>wt(y.value)?it(s.appContext.components[y.value]):it(y.value)})],Z=r7(l.props,u.level+1),j=l.isMenuPopup?it(No,{ref:m,visible:x.value,effect:"light",pure:!0,offset:t.popperOffset,showArrow:!1,persistent:!0,popperClass:t.popperClass,placement:g.value,teleported:b.value,fallbackPlacements:$.value,transition:_.value,gpuAcceleration:!1},{content:()=>{var J;return it("div",{class:[a.m(M.value),a.m("popup-container"),t.popperClass],onMouseenter:fe=>O(fe,100),onMouseleave:()=>F(!0),onFocus:fe=>O(fe,100)},[it("ul",{class:[a.b(),a.m("popup"),a.m(`popup-${g.value}`)],style:Z.value},[(J=e.default)==null?void 0:J.call(e)])])},default:()=>it("div",{class:i.e("title"),style:[D.value,{backgroundColor:C.value}],onClick:V},G)}):it(lt,{},[it("div",{class:i.e("title"),style:[D.value,{backgroundColor:C.value}],ref:p,onClick:V},G),it(Cw,{},{default:()=>{var J;return St(it("ul",{role:"menu",class:[a.b(),a.m("inline")],style:Z.value},[(J=e.default)==null?void 0:J.call(e)]),[[Qt,x.value]])}})]);return it("li",{class:[i.b(),i.is("active",k.value),i.is("opened",x.value),i.is("disabled",t.disabled)],role:"menuitem",ariaHaspopup:!0,ariaExpanded:x.value,onMouseenter:O,onMouseleave:()=>F(!0),onFocus:O},[j])}}});const wKe=qe({mode:{type:String,values:["horizontal","vertical"],default:"vertical"},defaultActive:{type:String,default:""},defaultOpeneds:{type:Se(Array),default:()=>Ln([])},uniqueOpened:Boolean,router:Boolean,menuTrigger:{type:String,values:["hover","click"],default:"hover"},collapse:Boolean,backgroundColor:String,textColor:String,activeTextColor:String,collapseTransition:{type:Boolean,default:!0},ellipsis:{type:Boolean,default:!0},popperEffect:{type:String,values:["dark","light"],default:"dark"}}),r$=t=>Array.isArray(t)&&t.every(e=>wt(e)),_Ke={close:(t,e)=>wt(t)&&r$(e),open:(t,e)=>wt(t)&&r$(e),select:(t,e,n,s)=>wt(t)&&r$(e)&&Bt(n)&&(s===void 0||s instanceof Promise)};var $Ke=ue({name:"ElMenu",props:wKe,emits:_Ke,setup(t,{emit:e,slots:n,expose:s}){const r=Rt(),o=r.appContext.config.globalProperties.$router,a=U(),i=Fe("menu"),l=Fe("sub-menu"),u=U(-1),c=U(t.defaultOpeneds&&!t.collapse?t.defaultOpeneds.slice(0):[]),d=U(t.defaultActive),f=U({}),h=U({}),p=A(()=>t.mode==="horizontal"||t.mode==="vertical"&&t.collapse),m=()=>{const N=d.value&&f.value[d.value];if(!N||t.mode==="horizontal"||t.collapse)return;N.indexPath.forEach(R=>{const D=h.value[R];D&&g(R,D.indexPath)})},g=(N,M)=>{c.value.includes(N)||(t.uniqueOpened&&(c.value=c.value.filter(R=>M.includes(R))),c.value.push(N),e("open",N,M))},y=(N,M)=>{const R=c.value.indexOf(N);R!==-1&&c.value.splice(R,1),e("close",N,M)},w=({index:N,indexPath:M})=>{c.value.includes(N)?y(N,M):g(N,M)},b=N=>{(t.mode==="horizontal"||t.collapse)&&(c.value=[]);const{index:M,indexPath:R}=N;if(!(M===void 0||R===void 0))if(t.router&&o){const D=N.route||M,z=o.push(D).then(B=>(B||(d.value=M),B));e("select",M,R,{index:M,indexPath:R,route:D},z)}else d.value=M,e("select",M,R,{index:M,indexPath:R})},_=N=>{const M=f.value,R=M[N]||d.value&&M[d.value]||M[t.defaultActive];R?d.value=R.index:d.value=N},$=()=>{var N,M;if(!a.value)return-1;const R=Array.from((M=(N=a.value)==null?void 0:N.childNodes)!=null?M:[]).filter(L=>L.nodeName!=="#text"||L.nodeValue),D=64,z=Number.parseInt(getComputedStyle(a.value).paddingLeft,10),B=Number.parseInt(getComputedStyle(a.value).paddingRight,10),V=a.value.clientWidth-z-B;let O=0,F=0;return R.forEach((L,G)=>{O+=L.offsetWidth||0,O<=V-D&&(F=G+1)}),F===R.length?-1:F},x=(N,M=33.34)=>{let R;return()=>{R&&clearTimeout(R),R=setTimeout(()=>{N()},M)}};let k=!0;const C=()=>{const N=()=>{u.value=-1,nt(()=>{u.value=$()})};k?N():x(N)(),k=!1};Me(()=>t.defaultActive,N=>{f.value[N]||(d.value=""),_(N)}),Me(()=>t.collapse,N=>{N&&(c.value=[])}),Me(f.value,m);let T;Ho(()=>{t.mode==="horizontal"&&t.ellipsis?T=Dr(a,C).stop:T==null||T()});{const N=z=>{h.value[z.index]=z},M=z=>{delete h.value[z.index]};Lt("rootMenu",on({props:t,openedMenus:c,items:f,subMenus:h,activeIndex:d,isMenuPopup:p,addMenuItem:z=>{f.value[z.index]=z},removeMenuItem:z=>{delete f.value[z.index]},addSubMenu:N,removeSubMenu:M,openMenu:g,closeMenu:y,handleMenuItemClick:b,handleSubMenuClick:w})),Lt(`subMenu:${r.uid}`,{addSubMenu:N,removeSubMenu:M,mouseInChild:U(!1),level:0})}return It(()=>{t.mode==="horizontal"&&new pKe(r.vnode.el,i.namespace.value)}),s({open:M=>{const{indexPath:R}=h.value[M];R.forEach(D=>g(D,R))},close:y,handleResize:C}),()=>{var N,M;let R=(M=(N=n.default)==null?void 0:N.call(n))!=null?M:[];const D=[];if(t.mode==="horizontal"&&a.value){const V=Gf(R),O=u.value===-1?V:V.slice(0,u.value),F=u.value===-1?[]:V.slice(u.value);(F==null?void 0:F.length)&&t.ellipsis&&(R=O,D.push(it(mk,{index:"sub-menu-more",class:l.e("hide-arrow")},{title:()=>it(rt,{class:l.e("icon-more")},{default:()=>it(bP)}),default:()=>F})))}const z=r7(t,0),B=it("ul",{key:String(t.collapse),role:"menubar",ref:a,style:z.value,class:{[i.b()]:!0,[i.m(t.mode)]:!0,[i.m("collapse")]:t.collapse}},[...R,...D]);return t.collapseTransition&&t.mode==="vertical"?it(vKe,()=>B):B}}});const xKe=qe({index:{type:Se([String,null]),default:null},route:{type:Se([String,Object])},disabled:Boolean}),SKe={click:t=>wt(t.index)&&Array.isArray(t.indexPath)},o$="ElMenuItem",CKe=ue({name:o$,components:{ElTooltip:No},props:xKe,emits:SKe,setup(t,{emit:e}){const n=Rt(),s=et("rootMenu"),r=Fe("menu"),o=Fe("menu-item");s||Ls(o$,"can not inject root menu");const{parentMenu:a,indexPath:i}=s7(n,Un(t,"index")),l=et(`subMenu:${a.value.uid}`);l||Ls(o$,"can not inject sub menu");const u=A(()=>t.index===s.activeIndex),c=on({index:t.index,indexPath:i,active:u}),d=()=>{t.disabled||(s.handleMenuItemClick({index:t.index,indexPath:i.value,route:t.route}),e("click",c))};return It(()=>{l.addSubMenu(c),s.addMenuItem(c)}),ts(()=>{l.removeSubMenu(c),s.removeMenuItem(c)}),{parentMenu:a,rootMenu:s,active:u,nsMenu:r,nsMenuItem:o,handleClick:d}}});function kKe(t,e,n,s,r,o){const a=pt("el-tooltip");return S(),E("li",{class:P([t.nsMenuItem.b(),t.nsMenuItem.is("active",t.active),t.nsMenuItem.is("disabled",t.disabled)]),role:"menuitem",tabindex:"-1",onClick:e[0]||(e[0]=(...i)=>t.handleClick&&t.handleClick(...i))},[t.parentMenu.type.name==="ElMenu"&&t.rootMenu.props.collapse&&t.$slots.title?(S(),$e(a,{key:0,effect:t.rootMenu.props.popperEffect,placement:"right","fallback-placements":["left"],persistent:""},{content:ce(()=>[Oe(t.$slots,"title")]),default:ce(()=>[I("div",{class:P(t.nsMenu.be("tooltip","trigger"))},[Oe(t.$slots,"default")],2)]),_:3},8,["effect"])):(S(),E(lt,{key:1},[Oe(t.$slots,"default"),Oe(t.$slots,"title")],64))],2)}var o7=je(CKe,[["render",kKe],["__file","/home/runner/work/element-plus/element-plus/packages/components/menu/src/menu-item.vue"]]);const TKe={title:String},NKe="ElMenuItemGroup",IKe=ue({name:NKe,props:TKe,setup(){return{ns:Fe("menu-item-group")}}});function EKe(t,e,n,s,r,o){return S(),E("li",{class:P(t.ns.b())},[I("div",{class:P(t.ns.e("title"))},[t.$slots.title?Oe(t.$slots,"title",{key:1}):(S(),E(lt,{key:0},[Yt(Ue(t.title),1)],64))],2),I("ul",null,[Oe(t.$slots,"default")])],2)}var a7=je(IKe,[["render",EKe],["__file","/home/runner/work/element-plus/element-plus/packages/components/menu/src/menu-item-group.vue"]]);const AKe=Dt($Ke,{MenuItem:o7,MenuItemGroup:a7,SubMenu:mk}),OKe=ns(o7),RKe=ns(a7);ns(mk);const DKe=qe({icon:{type:In,default:()=>cP},title:String,content:{type:String,default:""}}),FKe={back:()=>!0},MKe=["aria-label"],PKe=ue({name:"ElPageHeader"}),LKe=ue({...PKe,props:DKe,emits:FKe,setup(t,{emit:e}){const n=ir(),{t:s}=nn(),r=Fe("page-header"),o=A(()=>[r.b(),{[r.m("has-breadcrumb")]:!!n.breadcrumb,[r.m("has-extra")]:!!n.extra,[r.is("contentful")]:!!n.default}]);function a(){e("back")}return(i,l)=>(S(),E("div",{class:P(v(o))},[i.$slots.breadcrumb?(S(),E("div",{key:0,class:P(v(r).e("breadcrumb"))},[Oe(i.$slots,"breadcrumb")],2)):ge("v-if",!0),I("div",{class:P(v(r).e("header"))},[I("div",{class:P(v(r).e("left"))},[I("div",{class:P(v(r).e("back")),role:"button",tabindex:"0",onClick:a},[i.icon||i.$slots.icon?(S(),E("div",{key:0,"aria-label":i.title||v(s)("el.pageHeader.title"),class:P(v(r).e("icon"))},[Oe(i.$slots,"icon",{},()=>[i.icon?(S(),$e(v(rt),{key:0},{default:ce(()=>[(S(),$e(Vt(i.icon)))]),_:1})):ge("v-if",!0)])],10,MKe)):ge("v-if",!0),I("div",{class:P(v(r).e("title"))},[Oe(i.$slots,"title",{},()=>[Yt(Ue(i.title||v(s)("el.pageHeader.title")),1)])],2)],2),se(v(Wz),{direction:"vertical"}),I("div",{class:P(v(r).e("content"))},[Oe(i.$slots,"content",{},()=>[Yt(Ue(i.content),1)])],2)],2),i.$slots.extra?(S(),E("div",{key:0,class:P(v(r).e("extra"))},[Oe(i.$slots,"extra")],2)):ge("v-if",!0)],2),i.$slots.default?(S(),E("div",{key:1,class:P(v(r).e("main"))},[Oe(i.$slots,"default")],2)):ge("v-if",!0)],2))}});var zKe=je(LKe,[["__file","/home/runner/work/element-plus/element-plus/packages/components/page-header/src/page-header.vue"]]);const BKe=Dt(zKe),VKe=qe({disabled:Boolean,currentPage:{type:Number,default:1},prevText:{type:String},prevIcon:{type:In}}),HKe={click:t=>t instanceof MouseEvent},WKe=["disabled","aria-disabled"],UKe={key:0},GKe=ue({name:"ElPaginationPrev"}),jKe=ue({...GKe,props:VKe,emits:HKe,setup(t){const e=t,n=A(()=>e.disabled||e.currentPage<=1);return(s,r)=>(S(),E("button",{type:"button",class:"btn-prev",disabled:v(n),"aria-disabled":v(n),onClick:r[0]||(r[0]=o=>s.$emit("click",o))},[s.prevText?(S(),E("span",UKe,Ue(s.prevText),1)):(S(),$e(v(rt),{key:1},{default:ce(()=>[(S(),$e(Vt(s.prevIcon)))]),_:1}))],8,WKe))}});var KKe=je(jKe,[["__file","/home/runner/work/element-plus/element-plus/packages/components/pagination/src/components/prev.vue"]]);const qKe=qe({disabled:Boolean,currentPage:{type:Number,default:1},pageCount:{type:Number,default:50},nextText:{type:String},nextIcon:{type:In}}),XKe=["disabled","aria-disabled"],YKe={key:0},ZKe=ue({name:"ElPaginationNext"}),JKe=ue({...ZKe,props:qKe,emits:["click"],setup(t){const e=t,n=A(()=>e.disabled||e.currentPage===e.pageCount||e.pageCount===0);return(s,r)=>(S(),E("button",{type:"button",class:"btn-next",disabled:v(n),"aria-disabled":v(n),onClick:r[0]||(r[0]=o=>s.$emit("click",o))},[s.nextText?(S(),E("span",YKe,Ue(s.nextText),1)):(S(),$e(v(rt),{key:1},{default:ce(()=>[(S(),$e(Vt(s.nextIcon)))]),_:1}))],8,XKe))}});var QKe=je(JKe,[["__file","/home/runner/work/element-plus/element-plus/packages/components/pagination/src/components/next.vue"]]);const i7="ElSelectGroup",Lg="ElSelect";function eqe(t,e){const n=et(Lg),s=et(i7,{disabled:!1}),r=A(()=>Object.prototype.toString.call(t.value).toLowerCase()==="[object object]"),o=A(()=>n.props.multiple?d(n.props.modelValue,t.value):f(t.value,n.props.modelValue)),a=A(()=>{if(n.props.multiple){const m=n.props.modelValue||[];return!o.value&&m.length>=n.props.multipleLimit&&n.props.multipleLimit>0}else return!1}),i=A(()=>t.label||(r.value?"":t.value)),l=A(()=>t.value||t.label||""),u=A(()=>t.disabled||e.groupDisabled||a.value),c=Rt(),d=(m=[],g)=>{if(r.value){const y=n.props.valueKey;return m&&m.some(w=>fn(Pn(w,y))===Pn(g,y))}else return m&&m.includes(g)},f=(m,g)=>{if(r.value){const{valueKey:y}=n.props;return Pn(m,y)===Pn(g,y)}else return m===g},h=()=>{!t.disabled&&!s.disabled&&(n.hoverIndex=n.optionsArray.indexOf(c.proxy))};Me(()=>i.value,()=>{!t.created&&!n.props.remote&&n.setSelected()}),Me(()=>t.value,(m,g)=>{const{remote:y,valueKey:w}=n.props;if(Object.is(m,g)||(n.onOptionDestroy(g,c.proxy),n.onOptionCreate(c.proxy)),!t.created&&!y){if(w&&typeof m=="object"&&typeof g=="object"&&m[w]===g[w])return;n.setSelected()}}),Me(()=>s.disabled,()=>{e.groupDisabled=s.disabled},{immediate:!0});const{queryChange:p}=fn(n);return Me(p,m=>{const{query:g}=v(m),y=new RegExp(aP(g),"i");e.visible=y.test(i.value)||t.created,e.visible||n.filteredOptionsCount--}),{select:n,currentLabel:i,currentValue:l,itemSelected:o,isDisabled:u,hoverItem:h}}const tqe=ue({name:"ElOption",componentName:"ElOption",props:{value:{required:!0,type:[String,Number,Boolean,Object]},label:[String,Number],created:Boolean,disabled:{type:Boolean,default:!1}},setup(t){const e=Fe("select"),n=on({index:-1,groupDisabled:!1,visible:!0,hitState:!1,hover:!1}),{currentLabel:s,itemSelected:r,isDisabled:o,select:a,hoverItem:i}=eqe(t,n),{visible:l,hover:u}=Ps(n),c=Rt().proxy;a.onOptionCreate(c),ts(()=>{const f=c.value,{selected:h}=a,m=(a.props.multiple?h:[h]).some(g=>g.value===c.value);nt(()=>{a.cachedOptions.get(f)===c&&!m&&a.cachedOptions.delete(f)}),a.onOptionDestroy(f,c)});function d(){t.disabled!==!0&&n.groupDisabled!==!0&&a.handleOptionSelect(c,!0)}return{ns:e,currentLabel:s,itemSelected:r,isDisabled:o,select:a,hoverItem:i,visible:l,hover:u,selectOptionClick:d,states:n}}});function nqe(t,e,n,s,r,o){return St((S(),E("li",{class:P([t.ns.be("dropdown","item"),t.ns.is("disabled",t.isDisabled),{selected:t.itemSelected,hover:t.hover}]),onMouseenter:e[0]||(e[0]=(...a)=>t.hoverItem&&t.hoverItem(...a)),onClick:e[1]||(e[1]=yt((...a)=>t.selectOptionClick&&t.selectOptionClick(...a),["stop"]))},[Oe(t.$slots,"default",{},()=>[I("span",null,Ue(t.currentLabel),1)])],34)),[[Qt,t.visible]])}var gk=je(tqe,[["render",nqe],["__file","/home/runner/work/element-plus/element-plus/packages/components/select/src/option.vue"]]);const sqe=ue({name:"ElSelectDropdown",componentName:"ElSelectDropdown",setup(){const t=et(Lg),e=Fe("select"),n=A(()=>t.props.popperClass),s=A(()=>t.props.multiple),r=A(()=>t.props.fitInputWidth),o=U("");function a(){var i;o.value=`${(i=t.selectWrapper)==null?void 0:i.offsetWidth}px`}return It(()=>{a(),Dr(t.selectWrapper,a)}),{ns:e,minWidth:o,popperClass:n,isMultiple:s,isFitInputWidth:r}}});function rqe(t,e,n,s,r,o){return S(),E("div",{class:P([t.ns.b("dropdown"),t.ns.is("multiple",t.isMultiple),t.popperClass]),style:ot({[t.isFitInputWidth?"width":"minWidth"]:t.minWidth})},[Oe(t.$slots,"default")],6)}var oqe=je(sqe,[["render",rqe],["__file","/home/runner/work/element-plus/element-plus/packages/components/select/src/select-dropdown.vue"]]);function aqe(t){const{t:e}=nn();return on({options:new Map,cachedOptions:new Map,createdLabel:null,createdSelected:!1,selected:t.multiple?[]:{},inputLength:20,inputWidth:0,optionsCount:0,filteredOptionsCount:0,visible:!1,softFocus:!1,selectedLabel:"",hoverIndex:-1,query:"",previousQuery:null,inputHovering:!1,cachedPlaceHolder:"",currentPlaceholder:e("el.select.placeholder"),menuVisibleOnFocus:!1,isOnComposition:!1,isSilentBlur:!1,prefixWidth:11,tagInMultiLine:!1,mouseEnter:!1})}const iqe=(t,e,n)=>{const{t:s}=nn(),r=Fe("select");Sl({from:"suffixTransition",replacement:"override style scheme",version:"2.3.0",scope:"props",ref:"https://element-plus.org/en-US/component/select.html#select-attributes"},A(()=>t.suffixTransition===!1));const o=U(null),a=U(null),i=U(null),l=U(null),u=U(null),c=U(null),d=U(-1),f=Nn({query:""}),h=Nn(""),{form:p,formItem:m}=to(),g=A(()=>!t.filterable||t.multiple||!e.visible),y=A(()=>t.disabled||(p==null?void 0:p.disabled)),w=A(()=>{const Y=t.multiple?Array.isArray(t.modelValue)&&t.modelValue.length>0:t.modelValue!==void 0&&t.modelValue!==null&&t.modelValue!=="";return t.clearable&&!y.value&&e.inputHovering&&Y}),b=A(()=>t.remote&&t.filterable&&!t.remoteShowSuffix?"":t.suffixIcon),_=A(()=>r.is("reverse",b.value&&e.visible&&t.suffixTransition)),$=A(()=>t.remote?300:0),x=A(()=>t.loading?t.loadingText||s("el.select.loading"):t.remote&&e.query===""&&e.options.size===0?!1:t.filterable&&e.query&&e.options.size>0&&e.filteredOptionsCount===0?t.noMatchText||s("el.select.noMatch"):e.options.size===0?t.noDataText||s("el.select.noData"):null),k=A(()=>Array.from(e.options.values())),C=A(()=>Array.from(e.cachedOptions.values())),T=A(()=>{const Y=k.value.filter(de=>!de.created).some(de=>de.currentLabel===e.query);return t.filterable&&t.allowCreate&&e.query!==""&&!Y}),N=ks(),M=A(()=>["small"].includes(N.value)?"small":"default"),R=A({get(){return e.visible&&x.value!==!1},set(Y){e.visible=Y}});Me([()=>y.value,()=>N.value,()=>p==null?void 0:p.size],()=>{nt(()=>{D()})}),Me(()=>t.placeholder,Y=>{e.cachedPlaceHolder=e.currentPlaceholder=Y}),Me(()=>t.modelValue,(Y,de)=>{t.multiple&&(D(),Y&&Y.length>0||a.value&&e.query!==""?e.currentPlaceholder="":e.currentPlaceholder=e.cachedPlaceHolder,t.filterable&&!t.reserveKeyword&&(e.query="",z(e.query))),O(),t.filterable&&!t.multiple&&(e.inputLength=20),!Wo(Y,de)&&t.validateEvent&&(m==null||m.validate("change").catch(Pe=>void 0))},{flush:"post",deep:!0}),Me(()=>e.visible,Y=>{var de,Pe,We;Y?((Pe=(de=i.value)==null?void 0:de.updatePopper)==null||Pe.call(de),t.filterable&&(e.filteredOptionsCount=e.optionsCount,e.query=t.remote?"":e.selectedLabel,t.multiple?(We=a.value)==null||We.focus():e.selectedLabel&&(e.currentPlaceholder=`${e.selectedLabel}`,e.selectedLabel=""),z(e.query),!t.multiple&&!t.remote&&(f.value.query="",Cm(f),Cm(h)))):(t.filterable&&(vt(t.filterMethod)&&t.filterMethod(""),vt(t.remoteMethod)&&t.remoteMethod("")),a.value&&a.value.blur(),e.query="",e.previousQuery=null,e.selectedLabel="",e.inputLength=20,e.menuVisibleOnFocus=!1,L(),nt(()=>{a.value&&a.value.value===""&&e.selected.length===0&&(e.currentPlaceholder=e.cachedPlaceHolder)}),t.multiple||(e.selected&&(t.filterable&&t.allowCreate&&e.createdSelected&&e.createdLabel?e.selectedLabel=e.createdLabel:e.selectedLabel=e.selected.currentLabel,t.filterable&&(e.query=e.selectedLabel)),t.filterable&&(e.currentPlaceholder=e.cachedPlaceHolder))),n.emit("visible-change",Y)}),Me(()=>e.options.entries(),()=>{var Y,de,Pe;if(!Kt)return;(de=(Y=i.value)==null?void 0:Y.updatePopper)==null||de.call(Y),t.multiple&&D();const We=((Pe=u.value)==null?void 0:Pe.querySelectorAll("input"))||[];Array.from(We).includes(document.activeElement)||O(),t.defaultFirstOption&&(t.filterable||t.remote)&&e.filteredOptionsCount&&V()},{flush:"post"}),Me(()=>e.hoverIndex,Y=>{Ct(Y)&&Y>-1?d.value=k.value[Y]||{}:d.value={},k.value.forEach(de=>{de.hover=d.value===de})});const D=()=>{t.collapseTags&&!t.filterable||nt(()=>{var Y,de;if(!o.value)return;const Pe=o.value.$el.querySelector("input"),We=l.value,Ft=z9e(N.value||(p==null?void 0:p.size));Pe.style.height=`${(e.selected.length===0?Ft:Math.max(We?We.clientHeight+(We.clientHeight>Ft?6:0):0,Ft))-2}px`,e.tagInMultiLine=Number.parseFloat(Pe.style.height)>=Ft,e.visible&&x.value!==!1&&((de=(Y=i.value)==null?void 0:Y.updatePopper)==null||de.call(Y))})},z=async Y=>{if(!(e.previousQuery===Y||e.isOnComposition)){if(e.previousQuery===null&&(vt(t.filterMethod)||vt(t.remoteMethod))){e.previousQuery=Y;return}e.previousQuery=Y,nt(()=>{var de,Pe;e.visible&&((Pe=(de=i.value)==null?void 0:de.updatePopper)==null||Pe.call(de))}),e.hoverIndex=-1,t.multiple&&t.filterable&&nt(()=>{const de=a.value.value.length*15+20;e.inputLength=t.collapseTags?Math.min(50,de):de,B(),D()}),t.remote&&vt(t.remoteMethod)?(e.hoverIndex=-1,t.remoteMethod(Y)):vt(t.filterMethod)?(t.filterMethod(Y),Cm(h)):(e.filteredOptionsCount=e.optionsCount,f.value.query=Y,Cm(f),Cm(h)),t.defaultFirstOption&&(t.filterable||t.remote)&&e.filteredOptionsCount&&(await nt(),V())}},B=()=>{e.currentPlaceholder!==""&&(e.currentPlaceholder=a.value.value?"":e.cachedPlaceHolder)},V=()=>{const Y=k.value.filter(We=>We.visible&&!We.disabled&&!We.states.groupDisabled),de=Y.find(We=>We.created),Pe=Y[0];e.hoverIndex=pe(k.value,de||Pe)},O=()=>{var Y;if(t.multiple)e.selectedLabel="";else{const Pe=F(t.modelValue);(Y=Pe.props)!=null&&Y.created?(e.createdLabel=Pe.props.value,e.createdSelected=!0):e.createdSelected=!1,e.selectedLabel=Pe.currentLabel,e.selected=Pe,t.filterable&&(e.query=e.selectedLabel);return}const de=[];Array.isArray(t.modelValue)&&t.modelValue.forEach(Pe=>{de.push(F(Pe))}),e.selected=de,nt(()=>{D()})},F=Y=>{let de;const Pe=Fv(Y).toLowerCase()==="object",We=Fv(Y).toLowerCase()==="null",Ft=Fv(Y).toLowerCase()==="undefined";for(let qs=e.cachedOptions.size-1;qs>=0;qs--){const Sn=C.value[qs];if(Pe?Pn(Sn.value,t.valueKey)===Pn(Y,t.valueKey):Sn.value===Y){de={value:Y,currentLabel:Sn.currentLabel,isDisabled:Sn.isDisabled};break}}if(de)return de;const _n=Pe?Y.label:!We&&!Ft?Y:"",_s={value:Y,currentLabel:_n};return t.multiple&&(_s.hitState=!1),_s},L=()=>{setTimeout(()=>{const Y=t.valueKey;t.multiple?e.selected.length>0?e.hoverIndex=Math.min.apply(null,e.selected.map(de=>k.value.findIndex(Pe=>Pn(Pe,Y)===Pn(de,Y)))):e.hoverIndex=-1:e.hoverIndex=k.value.findIndex(de=>xt(de)===xt(e.selected))},300)},G=()=>{var Y,de;Z(),(de=(Y=i.value)==null?void 0:Y.updatePopper)==null||de.call(Y),t.multiple&&!t.filterable&&D()},Z=()=>{var Y;e.inputWidth=(Y=o.value)==null?void 0:Y.$el.getBoundingClientRect().width},j=()=>{t.filterable&&e.query!==e.selectedLabel&&(e.query=e.selectedLabel,z(e.query))},J=Xr(()=>{j()},$.value),fe=Xr(Y=>{z(Y.target.value)},$.value),X=Y=>{Wo(t.modelValue,Y)||n.emit(Fn,Y)},oe=Y=>{if(Y.target.value.length<=0&&!De()){const de=t.modelValue.slice();de.pop(),n.emit(Ot,de),X(de)}Y.target.value.length===1&&t.modelValue.length===0&&(e.currentPlaceholder=e.cachedPlaceHolder)},ee=(Y,de)=>{const Pe=e.selected.indexOf(de);if(Pe>-1&&!y.value){const We=t.modelValue.slice();We.splice(Pe,1),n.emit(Ot,We),X(We),n.emit("remove-tag",de.value)}Y.stopPropagation()},Q=Y=>{Y.stopPropagation();const de=t.multiple?[]:"";if(!wt(de))for(const Pe of e.selected)Pe.isDisabled&&de.push(Pe.value);n.emit(Ot,de),X(de),e.hoverIndex=-1,e.visible=!1,n.emit("clear")},ie=(Y,de)=>{var Pe;if(t.multiple){const We=(t.modelValue||[]).slice(),Ft=pe(We,Y.value);Ft>-1?We.splice(Ft,1):(t.multipleLimit<=0||We.length<t.multipleLimit)&&We.push(Y.value),n.emit(Ot,We),X(We),Y.created&&(e.query="",z(""),e.inputLength=20),t.filterable&&((Pe=a.value)==null||Pe.focus())}else n.emit(Ot,Y.value),X(Y.value),e.visible=!1;e.isSilentBlur=de,Re(),!e.visible&&nt(()=>{K(Y)})},pe=(Y=[],de)=>{if(!Bt(de))return Y.indexOf(de);const Pe=t.valueKey;let We=-1;return Y.some((Ft,_n)=>fn(Pn(Ft,Pe))===Pn(de,Pe)?(We=_n,!0):!1),We},Re=()=>{e.softFocus=!0;const Y=a.value||o.value;Y&&(Y==null||Y.focus())},K=Y=>{var de,Pe,We,Ft,_n;const _s=Array.isArray(Y)?Y[0]:Y;let qs=null;if(_s!=null&&_s.value){const Sn=k.value.filter(sn=>sn.value===_s.value);Sn.length>0&&(qs=Sn[0].$el)}if(i.value&&qs){const Sn=(Ft=(We=(Pe=(de=i.value)==null?void 0:de.popperRef)==null?void 0:Pe.contentRef)==null?void 0:We.querySelector)==null?void 0:Ft.call(We,`.${r.be("dropdown","wrap")}`);Sn&&uP(Sn,qs)}(_n=c.value)==null||_n.handleScroll()},re=Y=>{e.optionsCount++,e.filteredOptionsCount++,e.options.set(Y.value,Y),e.cachedOptions.set(Y.value,Y)},we=(Y,de)=>{e.options.get(Y)===de&&(e.optionsCount--,e.filteredOptionsCount--,e.options.delete(Y))},Ee=Y=>{Y.code!==ut.backspace&&De(!1),e.inputLength=a.value.value.length*15+20,D()},De=Y=>{if(!Array.isArray(e.selected))return;const de=e.selected[e.selected.length-1];if(!!de)return Y===!0||Y===!1?(de.hitState=Y,Y):(de.hitState=!de.hitState,de.hitState)},_e=Y=>{const de=Y.target.value;if(Y.type==="compositionend")e.isOnComposition=!1,nt(()=>z(de));else{const Pe=de[de.length-1]||"";e.isOnComposition=!fw(Pe)}},ze=()=>{nt(()=>K(e.selected))},Ae=Y=>{e.softFocus?e.softFocus=!1:((t.automaticDropdown||t.filterable)&&(t.filterable&&!e.visible&&(e.menuVisibleOnFocus=!0),e.visible=!0),n.emit("focus",Y))},he=()=>{var Y;e.visible=!1,(Y=o.value)==null||Y.blur()},ve=Y=>{nt(()=>{e.isSilentBlur?e.isSilentBlur=!1:n.emit("blur",Y)}),e.softFocus=!1},me=Y=>{Q(Y)},Ve=()=>{e.visible=!1},Ye=Y=>{e.visible&&(Y.preventDefault(),Y.stopPropagation(),e.visible=!1)},Je=Y=>{var de;Y&&!e.mouseEnter||y.value||(e.menuVisibleOnFocus?e.menuVisibleOnFocus=!1:(!i.value||!i.value.isFocusInsideContent())&&(e.visible=!e.visible),e.visible&&((de=a.value||o.value)==null||de.focus()))},ct=()=>{e.visible?k.value[e.hoverIndex]&&ie(k.value[e.hoverIndex],void 0):Je()},xt=Y=>Bt(Y.value)?Pn(Y.value,t.valueKey):Y.value,dt=A(()=>k.value.filter(Y=>Y.visible).every(Y=>Y.disabled)),xe=Y=>{if(!e.visible){e.visible=!0;return}if(!(e.options.size===0||e.filteredOptionsCount===0)&&!e.isOnComposition&&!dt.value){Y==="next"?(e.hoverIndex++,e.hoverIndex===e.options.size&&(e.hoverIndex=0)):Y==="prev"&&(e.hoverIndex--,e.hoverIndex<0&&(e.hoverIndex=e.options.size-1));const de=k.value[e.hoverIndex];(de.disabled===!0||de.states.groupDisabled===!0||!de.visible)&&xe(Y),nt(()=>K(d.value))}};return{optionsArray:k,selectSize:N,handleResize:G,debouncedOnInputChange:J,debouncedQueryChange:fe,deletePrevTag:oe,deleteTag:ee,deleteSelected:Q,handleOptionSelect:ie,scrollToOption:K,readonly:g,resetInputHeight:D,showClose:w,iconComponent:b,iconReverse:_,showNewOption:T,collapseTagSize:M,setSelected:O,managePlaceholder:B,selectDisabled:y,emptyText:x,toggleLastOptionHitState:De,resetInputState:Ee,handleComposition:_e,onOptionCreate:re,onOptionDestroy:we,handleMenuEnter:ze,handleFocus:Ae,blur:he,handleBlur:ve,handleClearClick:me,handleClose:Ve,handleKeydownEscape:Ye,toggleMenu:Je,selectOption:ct,getValueKey:xt,navigateOptions:xe,dropMenuVisible:R,queryChange:f,groupQueryChange:h,reference:o,input:a,tooltipRef:i,tags:l,selectWrapper:u,scrollbar:c,handleMouseEnter:()=>{e.mouseEnter=!0},handleMouseLeave:()=>{e.mouseEnter=!1}}},eR="ElSelect",lqe=ue({name:eR,componentName:eR,components:{ElInput:Or,ElSelectMenu:oqe,ElOption:gk,ElTag:Sw,ElScrollbar:jl,ElTooltip:No,ElIcon:rt},directives:{ClickOutside:Ku},props:{name:String,id:String,modelValue:{type:[Array,String,Number,Boolean,Object],default:void 0},autocomplete:{type:String,default:"off"},automaticDropdown:Boolean,size:{type:String,validator:Qh},effect:{type:String,default:"light"},disabled:Boolean,clearable:Boolean,filterable:Boolean,allowCreate:Boolean,loading:Boolean,popperClass:{type:String,default:""},remote:Boolean,loadingText:String,noMatchText:String,noDataText:String,remoteMethod:Function,filterMethod:Function,multiple:Boolean,multipleLimit:{type:Number,default:0},placeholder:{type:String},defaultFirstOption:Boolean,reserveKeyword:{type:Boolean,default:!0},valueKey:{type:String,default:"value"},collapseTags:Boolean,collapseTagsTooltip:{type:Boolean,default:!1},teleported:Xs.teleported,persistent:{type:Boolean,default:!0},clearIcon:{type:In,default:Bl},fitInputWidth:{type:Boolean,default:!1},suffixIcon:{type:In,default:zl},tagType:{...lk.type,default:"info"},validateEvent:{type:Boolean,default:!0},remoteShowSuffix:{type:Boolean,default:!1},suffixTransition:{type:Boolean,default:!0},placement:{type:String,values:Qd,default:"bottom-start"}},emits:[Ot,Fn,"remove-tag","clear","visible-change","focus","blur"],setup(t,e){const n=Fe("select"),s=Fe("input"),{t:r}=nn(),o=aqe(t),{optionsArray:a,selectSize:i,readonly:l,handleResize:u,collapseTagSize:c,debouncedOnInputChange:d,debouncedQueryChange:f,deletePrevTag:h,deleteTag:p,deleteSelected:m,handleOptionSelect:g,scrollToOption:y,setSelected:w,resetInputHeight:b,managePlaceholder:_,showClose:$,selectDisabled:x,iconComponent:k,iconReverse:C,showNewOption:T,emptyText:N,toggleLastOptionHitState:M,resetInputState:R,handleComposition:D,onOptionCreate:z,onOptionDestroy:B,handleMenuEnter:V,handleFocus:O,blur:F,handleBlur:L,handleClearClick:G,handleClose:Z,handleKeydownEscape:j,toggleMenu:J,selectOption:fe,getValueKey:X,navigateOptions:oe,dropMenuVisible:ee,reference:Q,input:ie,tooltipRef:pe,tags:Re,selectWrapper:K,scrollbar:re,queryChange:we,groupQueryChange:Ee,handleMouseEnter:De,handleMouseLeave:_e}=iqe(t,o,e),{focus:ze}=q9e(Q),{inputWidth:Ae,selected:he,inputLength:ve,filteredOptionsCount:me,visible:Ve,softFocus:Ye,selectedLabel:Je,hoverIndex:ct,query:xt,inputHovering:dt,currentPlaceholder:xe,menuVisibleOnFocus:Ke,isOnComposition:at,isSilentBlur:Y,options:de,cachedOptions:Pe,optionsCount:We,prefixWidth:Ft,tagInMultiLine:_n}=Ps(o),_s=A(()=>{const He=[n.b()],ft=v(i);return ft&&He.push(n.m(ft)),t.disabled&&He.push(n.m("disabled")),He}),qs=A(()=>({maxWidth:`${v(Ae)-32}px`,width:"100%"})),Sn=A(()=>({maxWidth:`${v(Ae)>123?v(Ae)-123:v(Ae)-75}px`}));Lt(Lg,on({props:t,options:de,optionsArray:a,cachedOptions:Pe,optionsCount:We,filteredOptionsCount:me,hoverIndex:ct,handleOptionSelect:g,onOptionCreate:z,onOptionDestroy:B,selectWrapper:K,selected:he,setSelected:w,queryChange:we,groupQueryChange:Ee})),It(()=>{o.cachedPlaceHolder=xe.value=t.placeholder||r("el.select.placeholder"),t.multiple&&Array.isArray(t.modelValue)&&t.modelValue.length>0&&(xe.value=""),Dr(K,u),t.remote&&t.multiple&&b(),nt(()=>{const He=Q.value&&Q.value.$el;if(!!He&&(Ae.value=He.getBoundingClientRect().width,e.slots.prefix)){const ft=He.querySelector(`.${s.e("prefix")}`);Ft.value=Math.max(ft.getBoundingClientRect().width+5,30)}}),w()}),t.multiple&&!Array.isArray(t.modelValue)&&e.emit(Ot,[]),!t.multiple&&Array.isArray(t.modelValue)&&e.emit(Ot,"");const sn=A(()=>{var He,ft;return(ft=(He=pe.value)==null?void 0:He.popperRef)==null?void 0:ft.contentRef});return{tagInMultiLine:_n,prefixWidth:Ft,selectSize:i,readonly:l,handleResize:u,collapseTagSize:c,debouncedOnInputChange:d,debouncedQueryChange:f,deletePrevTag:h,deleteTag:p,deleteSelected:m,handleOptionSelect:g,scrollToOption:y,inputWidth:Ae,selected:he,inputLength:ve,filteredOptionsCount:me,visible:Ve,softFocus:Ye,selectedLabel:Je,hoverIndex:ct,query:xt,inputHovering:dt,currentPlaceholder:xe,menuVisibleOnFocus:Ke,isOnComposition:at,isSilentBlur:Y,options:de,resetInputHeight:b,managePlaceholder:_,showClose:$,selectDisabled:x,iconComponent:k,iconReverse:C,showNewOption:T,emptyText:N,toggleLastOptionHitState:M,resetInputState:R,handleComposition:D,handleMenuEnter:V,handleFocus:O,blur:F,handleBlur:L,handleClearClick:G,handleClose:Z,handleKeydownEscape:j,toggleMenu:J,selectOption:fe,getValueKey:X,navigateOptions:oe,dropMenuVisible:ee,focus:ze,reference:Q,input:ie,tooltipRef:pe,popperPaneRef:sn,tags:Re,selectWrapper:K,scrollbar:re,wrapperKls:_s,selectTagsStyle:qs,nsSelect:n,tagTextStyle:Sn,handleMouseEnter:De,handleMouseLeave:_e}}}),uqe=["disabled","autocomplete"],cqe={style:{height:"100%",display:"flex","justify-content":"center","align-items":"center"}};function dqe(t,e,n,s,r,o){const a=pt("el-tag"),i=pt("el-tooltip"),l=pt("el-icon"),u=pt("el-input"),c=pt("el-option"),d=pt("el-scrollbar"),f=pt("el-select-menu"),h=rh("click-outside");return St((S(),E("div",{ref:"selectWrapper",class:P(t.wrapperKls),onMouseenter:e[22]||(e[22]=(...p)=>t.handleMouseEnter&&t.handleMouseEnter(...p)),onMouseleave:e[23]||(e[23]=(...p)=>t.handleMouseLeave&&t.handleMouseLeave(...p)),onClick:e[24]||(e[24]=yt((...p)=>t.toggleMenu&&t.toggleMenu(...p),["stop"]))},[se(i,{ref:"tooltipRef",visible:t.dropMenuVisible,placement:t.placement,teleported:t.teleported,"popper-class":[t.nsSelect.e("popper"),t.popperClass],"fallback-placements":["bottom-start","top-start","right","left"],effect:t.effect,pure:"",trigger:"click",transition:`${t.nsSelect.namespace.value}-zoom-in-top`,"stop-popper-mouse-event":!1,"gpu-acceleration":!1,persistent:t.persistent,onShow:t.handleMenuEnter},{default:ce(()=>[I("div",{class:"select-trigger",onMouseenter:e[20]||(e[20]=p=>t.inputHovering=!0),onMouseleave:e[21]||(e[21]=p=>t.inputHovering=!1)},[t.multiple?(S(),E("div",{key:0,ref:"tags",class:P(t.nsSelect.e("tags")),style:ot(t.selectTagsStyle)},[t.collapseTags&&t.selected.length?(S(),E("span",{key:0,class:P([t.nsSelect.b("tags-wrapper"),{"has-prefix":t.prefixWidth&&t.selected.length}])},[se(a,{closable:!t.selectDisabled&&!t.selected[0].isDisabled,size:t.collapseTagSize,hit:t.selected[0].hitState,type:t.tagType,"disable-transitions":"",onClose:e[0]||(e[0]=p=>t.deleteTag(p,t.selected[0]))},{default:ce(()=>[I("span",{class:P(t.nsSelect.e("tags-text")),style:ot(t.tagTextStyle)},Ue(t.selected[0].currentLabel),7)]),_:1},8,["closable","size","hit","type"]),t.selected.length>1?(S(),$e(a,{key:0,closable:!1,size:t.collapseTagSize,type:t.tagType,"disable-transitions":""},{default:ce(()=>[t.collapseTagsTooltip?(S(),$e(i,{key:0,disabled:t.dropMenuVisible,"fallback-placements":["bottom","top","right","left"],effect:t.effect,placement:"bottom",teleported:t.teleported},{default:ce(()=>[I("span",{class:P(t.nsSelect.e("tags-text"))},"+ "+Ue(t.selected.length-1),3)]),content:ce(()=>[I("div",{class:P(t.nsSelect.e("collapse-tags"))},[(S(!0),E(lt,null,Gt(t.selected.slice(1),(p,m)=>(S(),E("div",{key:m,class:P(t.nsSelect.e("collapse-tag"))},[(S(),$e(a,{key:t.getValueKey(p),class:"in-tooltip",closable:!t.selectDisabled&&!p.isDisabled,size:t.collapseTagSize,hit:p.hitState,type:t.tagType,"disable-transitions":"",style:{margin:"2px"},onClose:g=>t.deleteTag(g,p)},{default:ce(()=>[I("span",{class:P(t.nsSelect.e("tags-text")),style:ot({maxWidth:t.inputWidth-75+"px"})},Ue(p.currentLabel),7)]),_:2},1032,["closable","size","hit","type","onClose"]))],2))),128))],2)]),_:1},8,["disabled","effect","teleported"])):(S(),E("span",{key:1,class:P(t.nsSelect.e("tags-text"))},"+ "+Ue(t.selected.length-1),3))]),_:1},8,["size","type"])):ge("v-if",!0)],2)):ge("v-if",!0),ge(" <div> "),t.collapseTags?ge("v-if",!0):(S(),$e(ms,{key:1,onAfterLeave:t.resetInputHeight},{default:ce(()=>[I("span",{class:P([t.nsSelect.b("tags-wrapper"),{"has-prefix":t.prefixWidth&&t.selected.length}])},[(S(!0),E(lt,null,Gt(t.selected,p=>(S(),$e(a,{key:t.getValueKey(p),closable:!t.selectDisabled&&!p.isDisabled,size:t.collapseTagSize,hit:p.hitState,type:t.tagType,"disable-transitions":"",onClose:m=>t.deleteTag(m,p)},{default:ce(()=>[I("span",{class:P(t.nsSelect.e("tags-text")),style:ot({maxWidth:t.inputWidth-75+"px"})},Ue(p.currentLabel),7)]),_:2},1032,["closable","size","hit","type","onClose"]))),128))],2)]),_:1},8,["onAfterLeave"])),ge(" </div> "),t.filterable?St((S(),E("input",{key:2,ref:"input","onUpdate:modelValue":e[1]||(e[1]=p=>t.query=p),type:"text",class:P([t.nsSelect.e("input"),t.nsSelect.is(t.selectSize)]),disabled:t.selectDisabled,autocomplete:t.autocomplete,style:ot({marginLeft:t.prefixWidth&&!t.selected.length||t.tagInMultiLine?`${t.prefixWidth}px`:"",flexGrow:1,width:`${t.inputLength/(t.inputWidth-32)}%`,maxWidth:`${t.inputWidth-42}px`}),onFocus:e[2]||(e[2]=(...p)=>t.handleFocus&&t.handleFocus(...p)),onBlur:e[3]||(e[3]=(...p)=>t.handleBlur&&t.handleBlur(...p)),onKeyup:e[4]||(e[4]=(...p)=>t.managePlaceholder&&t.managePlaceholder(...p)),onKeydown:[e[5]||(e[5]=(...p)=>t.resetInputState&&t.resetInputState(...p)),e[6]||(e[6]=qt(yt(p=>t.navigateOptions("next"),["prevent"]),["down"])),e[7]||(e[7]=qt(yt(p=>t.navigateOptions("prev"),["prevent"]),["up"])),e[8]||(e[8]=qt((...p)=>t.handleKeydownEscape&&t.handleKeydownEscape(...p),["esc"])),e[9]||(e[9]=qt(yt((...p)=>t.selectOption&&t.selectOption(...p),["stop","prevent"]),["enter"])),e[10]||(e[10]=qt((...p)=>t.deletePrevTag&&t.deletePrevTag(...p),["delete"])),e[11]||(e[11]=qt(p=>t.visible=!1,["tab"]))],onCompositionstart:e[12]||(e[12]=(...p)=>t.handleComposition&&t.handleComposition(...p)),onCompositionupdate:e[13]||(e[13]=(...p)=>t.handleComposition&&t.handleComposition(...p)),onCompositionend:e[14]||(e[14]=(...p)=>t.handleComposition&&t.handleComposition(...p)),onInput:e[15]||(e[15]=(...p)=>t.debouncedQueryChange&&t.debouncedQueryChange(...p))},null,46,uqe)),[[lC,t.query]]):ge("v-if",!0)],6)):ge("v-if",!0),se(u,{id:t.id,ref:"reference",modelValue:t.selectedLabel,"onUpdate:modelValue":e[16]||(e[16]=p=>t.selectedLabel=p),type:"text",placeholder:t.currentPlaceholder,name:t.name,autocomplete:t.autocomplete,size:t.selectSize,disabled:t.selectDisabled,readonly:t.readonly,"validate-event":!1,class:P([t.nsSelect.is("focus",t.visible)]),tabindex:t.multiple&&t.filterable?-1:void 0,onFocus:t.handleFocus,onBlur:t.handleBlur,onInput:t.debouncedOnInputChange,onPaste:t.debouncedOnInputChange,onCompositionstart:t.handleComposition,onCompositionupdate:t.handleComposition,onCompositionend:t.handleComposition,onKeydown:[e[17]||(e[17]=qt(yt(p=>t.navigateOptions("next"),["stop","prevent"]),["down"])),e[18]||(e[18]=qt(yt(p=>t.navigateOptions("prev"),["stop","prevent"]),["up"])),qt(yt(t.selectOption,["stop","prevent"]),["enter"]),qt(t.handleKeydownEscape,["esc"]),e[19]||(e[19]=qt(p=>t.visible=!1,["tab"]))]},Uu({suffix:ce(()=>[t.iconComponent&&!t.showClose?(S(),$e(l,{key:0,class:P([t.nsSelect.e("caret"),t.nsSelect.e("icon"),t.iconReverse])},{default:ce(()=>[(S(),$e(Vt(t.iconComponent)))]),_:1},8,["class"])):ge("v-if",!0),t.showClose&&t.clearIcon?(S(),$e(l,{key:1,class:P([t.nsSelect.e("caret"),t.nsSelect.e("icon")]),onClick:t.handleClearClick},{default:ce(()=>[(S(),$e(Vt(t.clearIcon)))]),_:1},8,["class","onClick"])):ge("v-if",!0)]),_:2},[t.$slots.prefix?{name:"prefix",fn:ce(()=>[I("div",cqe,[Oe(t.$slots,"prefix")])])}:void 0]),1032,["id","modelValue","placeholder","name","autocomplete","size","disabled","readonly","class","tabindex","onFocus","onBlur","onInput","onPaste","onCompositionstart","onCompositionupdate","onCompositionend","onKeydown"])],32)]),content:ce(()=>[se(f,null,{default:ce(()=>[St(se(d,{ref:"scrollbar",tag:"ul","wrap-class":t.nsSelect.be("dropdown","wrap"),"view-class":t.nsSelect.be("dropdown","list"),class:P([t.nsSelect.is("empty",!t.allowCreate&&Boolean(t.query)&&t.filteredOptionsCount===0)])},{default:ce(()=>[t.showNewOption?(S(),$e(c,{key:0,value:t.query,created:!0},null,8,["value"])):ge("v-if",!0),Oe(t.$slots,"default")]),_:3},8,["wrap-class","view-class","class"]),[[Qt,t.options.size>0&&!t.loading]]),t.emptyText&&(!t.allowCreate||t.loading||t.allowCreate&&t.options.size===0)?(S(),E(lt,{key:0},[t.$slots.empty?Oe(t.$slots,"empty",{key:0}):(S(),E("p",{key:1,class:P(t.nsSelect.be("dropdown","empty"))},Ue(t.emptyText),3))],64)):ge("v-if",!0)]),_:3})]),_:3},8,["visible","placement","teleported","popper-class","effect","transition","persistent","onShow"])],34)),[[h,t.handleClose,t.popperPaneRef]])}var fqe=je(lqe,[["render",dqe],["__file","/home/runner/work/element-plus/element-plus/packages/components/select/src/select.vue"]]);const hqe=ue({name:"ElOptionGroup",componentName:"ElOptionGroup",props:{label:String,disabled:{type:Boolean,default:!1}},setup(t){const e=Fe("select"),n=U(!0),s=Rt(),r=U([]);Lt(i7,on({...Ps(t)}));const o=et(Lg);It(()=>{r.value=a(s.subTree)});const a=l=>{const u=[];return Array.isArray(l.children)&&l.children.forEach(c=>{var d;c.type&&c.type.name==="ElOption"&&c.component&&c.component.proxy?u.push(c.component.proxy):(d=c.children)!=null&&d.length&&u.push(...a(c))}),u},{groupQueryChange:i}=fn(o);return Me(i,()=>{n.value=r.value.some(l=>l.visible===!0)},{flush:"post"}),{visible:n,ns:e}}});function pqe(t,e,n,s,r,o){return St((S(),E("ul",{class:P(t.ns.be("group","wrap"))},[I("li",{class:P(t.ns.be("group","title"))},Ue(t.label),3),I("li",null,[I("ul",{class:P(t.ns.b("group"))},[Oe(t.$slots,"default")],2)])],2)),[[Qt,t.visible]])}var l7=je(hqe,[["render",pqe],["__file","/home/runner/work/element-plus/element-plus/packages/components/select/src/option-group.vue"]]);const kd=Dt(fqe,{Option:gk,OptionGroup:l7}),Dy=ns(gk),mqe=ns(l7),vk=()=>et(VP,{}),gqe=qe({pageSize:{type:Number,required:!0},pageSizes:{type:Se(Array),default:()=>Ln([10,20,30,40,50,100])},popperClass:{type:String},disabled:Boolean,size:{type:String,values:Hl}}),vqe=ue({name:"ElPaginationSizes"}),yqe=ue({...vqe,props:gqe,emits:["page-size-change"],setup(t,{emit:e}){const n=t,{t:s}=nn(),r=Fe("pagination"),o=vk(),a=U(n.pageSize);Me(()=>n.pageSizes,(u,c)=>{if(!Wo(u,c)&&Array.isArray(u)){const d=u.includes(n.pageSize)?n.pageSize:n.pageSizes[0];e("page-size-change",d)}}),Me(()=>n.pageSize,u=>{a.value=u});const i=A(()=>n.pageSizes);function l(u){var c;u!==a.value&&(a.value=u,(c=o.handleSizeChange)==null||c.call(o,Number(u)))}return(u,c)=>(S(),E("span",{class:P(v(r).e("sizes"))},[se(v(kd),{"model-value":a.value,disabled:u.disabled,"popper-class":u.popperClass,size:u.size,"validate-event":!1,onChange:l},{default:ce(()=>[(S(!0),E(lt,null,Gt(v(i),d=>(S(),$e(v(Dy),{key:d,value:d,label:d+v(s)("el.pagination.pagesize")},null,8,["value","label"]))),128))]),_:1},8,["model-value","disabled","popper-class","size"])],2))}});var bqe=je(yqe,[["__file","/home/runner/work/element-plus/element-plus/packages/components/pagination/src/components/sizes.vue"]]);const wqe=qe({size:{type:String,values:Hl}}),_qe=["disabled"],$qe=ue({name:"ElPaginationJumper"}),xqe=ue({...$qe,props:wqe,setup(t){const{t:e}=nn(),n=Fe("pagination"),{pageCount:s,disabled:r,currentPage:o,changeEvent:a}=vk(),i=U(),l=A(()=>{var d;return(d=i.value)!=null?d:o==null?void 0:o.value});function u(d){i.value=+d}function c(d){d=Math.trunc(+d),a==null||a(+d),i.value=void 0}return(d,f)=>(S(),E("span",{class:P(v(n).e("jump")),disabled:v(r)},[I("span",{class:P([v(n).e("goto")])},Ue(v(e)("el.pagination.goto")),3),se(v(Or),{size:d.size,class:P([v(n).e("editor"),v(n).is("in-pagination")]),min:1,max:v(s),disabled:v(r),"model-value":v(l),"validate-event":!1,type:"number","onUpdate:modelValue":u,onChange:c},null,8,["size","class","max","disabled","model-value"]),I("span",{class:P([v(n).e("classifier")])},Ue(v(e)("el.pagination.pageClassifier")),3)],10,_qe))}});var Sqe=je(xqe,[["__file","/home/runner/work/element-plus/element-plus/packages/components/pagination/src/components/jumper.vue"]]);const Cqe=qe({total:{type:Number,default:1e3}}),kqe=["disabled"],Tqe=ue({name:"ElPaginationTotal"}),Nqe=ue({...Tqe,props:Cqe,setup(t){const{t:e}=nn(),n=Fe("pagination"),{disabled:s}=vk();return(r,o)=>(S(),E("span",{class:P(v(n).e("total")),disabled:v(s)},Ue(v(e)("el.pagination.total",{total:r.total})),11,kqe))}});var Iqe=je(Nqe,[["__file","/home/runner/work/element-plus/element-plus/packages/components/pagination/src/components/total.vue"]]);const Eqe=qe({currentPage:{type:Number,default:1},pageCount:{type:Number,required:!0},pagerCount:{type:Number,default:7},disabled:Boolean}),Aqe=["onKeyup"],Oqe=["aria-current","tabindex"],Rqe=["tabindex"],Dqe=["aria-current","tabindex"],Fqe=["tabindex"],Mqe=["aria-current","tabindex"],Pqe=ue({name:"ElPaginationPager"}),Lqe=ue({...Pqe,props:Eqe,emits:["change"],setup(t,{emit:e}){const n=t,s=Fe("pager"),r=Fe("icon"),o=U(!1),a=U(!1),i=U(!1),l=U(!1),u=U(!1),c=U(!1),d=A(()=>{const y=n.pagerCount,w=(y-1)/2,b=Number(n.currentPage),_=Number(n.pageCount);let $=!1,x=!1;_>y&&(b>y-w&&($=!0),b<_-w&&(x=!0));const k=[];if($&&!x){const C=_-(y-2);for(let T=C;T<_;T++)k.push(T)}else if(!$&&x)for(let C=2;C<y;C++)k.push(C);else if($&&x){const C=Math.floor(y/2)-1;for(let T=b-C;T<=b+C;T++)k.push(T)}else for(let C=2;C<_;C++)k.push(C);return k}),f=A(()=>n.disabled?-1:0);Ho(()=>{const y=(n.pagerCount-1)/2;o.value=!1,a.value=!1,n.pageCount>n.pagerCount&&(n.currentPage>n.pagerCount-y&&(o.value=!0),n.currentPage<n.pageCount-y&&(a.value=!0))});function h(y=!1){n.disabled||(y?i.value=!0:l.value=!0)}function p(y=!1){y?u.value=!0:c.value=!0}function m(y){const w=y.target;if(w.tagName.toLowerCase()==="li"&&Array.from(w.classList).includes("number")){const b=Number(w.textContent);b!==n.currentPage&&e("change",b)}else w.tagName.toLowerCase()==="li"&&Array.from(w.classList).includes("more")&&g(y)}function g(y){const w=y.target;if(w.tagName.toLowerCase()==="ul"||n.disabled)return;let b=Number(w.textContent);const _=n.pageCount,$=n.currentPage,x=n.pagerCount-2;w.className.includes("more")&&(w.className.includes("quickprev")?b=$-x:w.className.includes("quicknext")&&(b=$+x)),Number.isNaN(+b)||(b<1&&(b=1),b>_&&(b=_)),b!==$&&e("change",b)}return(y,w)=>(S(),E("ul",{class:P(v(s).b()),onClick:g,onKeyup:qt(m,["enter"])},[y.pageCount>0?(S(),E("li",{key:0,class:P([[v(s).is("active",y.currentPage===1),v(s).is("disabled",y.disabled)],"number"]),"aria-current":y.currentPage===1,tabindex:v(f)}," 1 ",10,Oqe)):ge("v-if",!0),o.value?(S(),E("li",{key:1,class:P(["more","btn-quickprev",v(r).b(),v(s).is("disabled",y.disabled)]),tabindex:v(f),onMouseenter:w[0]||(w[0]=b=>h(!0)),onMouseleave:w[1]||(w[1]=b=>i.value=!1),onFocus:w[2]||(w[2]=b=>p(!0)),onBlur:w[3]||(w[3]=b=>u.value=!1)},[(i.value||u.value)&&!y.disabled?(S(),$e(v($d),{key:0})):(S(),$e(v(f6),{key:1}))],42,Rqe)):ge("v-if",!0),(S(!0),E(lt,null,Gt(v(d),b=>(S(),E("li",{key:b,class:P([[v(s).is("active",y.currentPage===b),v(s).is("disabled",y.disabled)],"number"]),"aria-current":y.currentPage===b,tabindex:v(f)},Ue(b),11,Dqe))),128)),a.value?(S(),E("li",{key:2,class:P(["more","btn-quicknext",v(r).b(),v(s).is("disabled",y.disabled)]),tabindex:v(f),onMouseenter:w[4]||(w[4]=b=>h()),onMouseleave:w[5]||(w[5]=b=>l.value=!1),onFocus:w[6]||(w[6]=b=>p()),onBlur:w[7]||(w[7]=b=>c.value=!1)},[(l.value||c.value)&&!y.disabled?(S(),$e(v(xd),{key:0})):(S(),$e(v(f6),{key:1}))],42,Fqe)):ge("v-if",!0),y.pageCount>1?(S(),E("li",{key:3,class:P([[v(s).is("active",y.currentPage===y.pageCount),v(s).is("disabled",y.disabled)],"number"]),"aria-current":y.currentPage===y.pageCount,tabindex:v(f)},Ue(y.pageCount),11,Mqe)):ge("v-if",!0)],42,Aqe))}});var zqe=je(Lqe,[["__file","/home/runner/work/element-plus/element-plus/packages/components/pagination/src/components/pager.vue"]]);const Vr=t=>typeof t!="number",Bqe=qe({total:Number,pageSize:Number,defaultPageSize:Number,currentPage:Number,defaultCurrentPage:Number,pageCount:Number,pagerCount:{type:Number,validator:t=>typeof t=="number"&&Math.trunc(t)===t&&t>4&&t<22&&t%2===1,default:7},layout:{type:String,default:["prev","pager","next","jumper","->","total"].join(", ")},pageSizes:{type:Se(Array),default:()=>Ln([10,20,30,40,50,100])},popperClass:{type:String,default:""},prevText:{type:String,default:""},prevIcon:{type:In,default:()=>xl},nextText:{type:String,default:""},nextIcon:{type:In,default:()=>Rr},small:Boolean,background:Boolean,disabled:Boolean,hideOnSinglePage:Boolean}),Vqe={"update:current-page":t=>typeof t=="number","update:page-size":t=>typeof t=="number","size-change":t=>typeof t=="number","current-change":t=>typeof t=="number","prev-click":t=>typeof t=="number","next-click":t=>typeof t=="number"},tR="ElPagination";var Hqe=ue({name:tR,props:Bqe,emits:Vqe,setup(t,{emit:e,slots:n}){const{t:s}=nn(),r=Fe("pagination"),o=Rt().vnode.props||{},a="onUpdate:currentPage"in o||"onUpdate:current-page"in o||"onCurrentChange"in o,i="onUpdate:pageSize"in o||"onUpdate:page-size"in o||"onSizeChange"in o,l=A(()=>{if(Vr(t.total)&&Vr(t.pageCount)||!Vr(t.currentPage)&&!a)return!1;if(t.layout.includes("sizes")){if(Vr(t.pageCount)){if(!Vr(t.total)&&!Vr(t.pageSize)&&!i)return!1}else if(!i)return!1}return!0}),u=U(Vr(t.defaultPageSize)?10:t.defaultPageSize),c=U(Vr(t.defaultCurrentPage)?1:t.defaultCurrentPage),d=A({get(){return Vr(t.pageSize)?u.value:t.pageSize},set(b){Vr(t.pageSize)&&(u.value=b),i&&(e("update:page-size",b),e("size-change",b))}}),f=A(()=>{let b=0;return Vr(t.pageCount)?Vr(t.total)||(b=Math.max(1,Math.ceil(t.total/d.value))):b=t.pageCount,b}),h=A({get(){return Vr(t.currentPage)?c.value:t.currentPage},set(b){let _=b;b<1?_=1:b>f.value&&(_=f.value),Vr(t.currentPage)&&(c.value=_),a&&(e("update:current-page",_),e("current-change",_))}});Me(f,b=>{h.value>b&&(h.value=b)});function p(b){h.value=b}function m(b){d.value=b;const _=f.value;h.value>_&&(h.value=_)}function g(){t.disabled||(h.value-=1,e("prev-click",h.value))}function y(){t.disabled||(h.value+=1,e("next-click",h.value))}function w(b,_){b&&(b.props||(b.props={}),b.props.class=[b.props.class,_].join(" "))}return Lt(VP,{pageCount:f,disabled:A(()=>t.disabled),currentPage:h,changeEvent:p,handleSizeChange:m}),()=>{var b,_;if(!l.value)return s("el.pagination.deprecationWarning"),null;if(!t.layout||t.hideOnSinglePage&&f.value<=1)return null;const $=[],x=[],k=it("div",{class:r.e("rightwrapper")},x),C={prev:it(KKe,{disabled:t.disabled,currentPage:h.value,prevText:t.prevText,prevIcon:t.prevIcon,onClick:g}),jumper:it(Sqe,{size:t.small?"small":"default"}),pager:it(zqe,{currentPage:h.value,pageCount:f.value,pagerCount:t.pagerCount,onChange:p,disabled:t.disabled}),next:it(QKe,{disabled:t.disabled,currentPage:h.value,pageCount:f.value,nextText:t.nextText,nextIcon:t.nextIcon,onClick:y}),sizes:it(bqe,{pageSize:d.value,pageSizes:t.pageSizes,popperClass:t.popperClass,disabled:t.disabled,size:t.small?"small":"default"}),slot:(_=(b=n==null?void 0:n.default)==null?void 0:b.call(n))!=null?_:null,total:it(Iqe,{total:Vr(t.total)?0:t.total})},T=t.layout.split(",").map(M=>M.trim());let N=!1;return T.forEach(M=>{if(M==="->"){N=!0;return}N?x.push(C[M]):$.push(C[M])}),w($[0],r.is("first")),w($[$.length-1],r.is("last")),N&&x.length>0&&(w(x[0],r.is("first")),w(x[x.length-1],r.is("last")),$.push(k)),it("div",{role:"pagination","aria-label":"pagination",class:[r.b(),r.is("background",t.background),{[r.m("small")]:t.small}]},$)}}});const Wqe=Dt(Hqe),Uqe=qe({title:String,confirmButtonText:String,cancelButtonText:String,confirmButtonType:{type:String,values:m6,default:"primary"},cancelButtonType:{type:String,values:m6,default:"text"},icon:{type:In,default:()=>_P},iconColor:{type:String,default:"#f90"},hideIcon:{type:Boolean,default:!1},hideAfter:{type:Number,default:200},onConfirm:{type:Se(Function)},onCancel:{type:Se(Function)},teleported:Xs.teleported,persistent:Xs.persistent,width:{type:[String,Number],default:150}}),Gqe=ue({name:"ElPopconfirm"}),jqe=ue({...Gqe,props:Uqe,setup(t){const e=t,{t:n}=nn(),s=Fe("popconfirm"),r=U(),o=()=>{var d,f;(f=(d=r.value)==null?void 0:d.onClose)==null||f.call(d)},a=A(()=>({width:Cs(e.width)})),i=d=>{var f;(f=e.onConfirm)==null||f.call(e,d),o()},l=d=>{var f;(f=e.onCancel)==null||f.call(e,d),o()},u=A(()=>e.confirmButtonText||n("el.popconfirm.confirmButtonText")),c=A(()=>e.cancelButtonText||n("el.popconfirm.cancelButtonText"));return(d,f)=>(S(),$e(v(No),zt({ref_key:"tooltipRef",ref:r,trigger:"click",effect:"light"},d.$attrs,{"popper-class":`${v(s).namespace.value}-popover`,"popper-style":v(a),teleported:d.teleported,"fallback-placements":["bottom","top","right","left"],"hide-after":d.hideAfter,persistent:d.persistent}),{content:ce(()=>[I("div",{class:P(v(s).b())},[I("div",{class:P(v(s).e("main"))},[!d.hideIcon&&d.icon?(S(),$e(v(rt),{key:0,class:P(v(s).e("icon")),style:ot({color:d.iconColor})},{default:ce(()=>[(S(),$e(Vt(d.icon)))]),_:1},8,["class","style"])):ge("v-if",!0),Yt(" "+Ue(d.title),1)],2),I("div",{class:P(v(s).e("action"))},[se(v(br),{size:"small",type:d.cancelButtonType==="text"?"":d.cancelButtonType,text:d.cancelButtonType==="text",onClick:l},{default:ce(()=>[Yt(Ue(v(c)),1)]),_:1},8,["type","text"]),se(v(br),{size:"small",type:d.confirmButtonType==="text"?"":d.confirmButtonType,text:d.confirmButtonType==="text",onClick:i},{default:ce(()=>[Yt(Ue(v(u)),1)]),_:1},8,["type","text"])],2)],2)]),default:ce(()=>[d.$slots.reference?Oe(d.$slots,"reference",{key:0}):ge("v-if",!0)]),_:3},16,["popper-class","popper-style","teleported","hide-after","persistent"]))}});var Kqe=je(jqe,[["__file","/home/runner/work/element-plus/element-plus/packages/components/popconfirm/src/popconfirm.vue"]]);const qqe=Dt(Kqe),Xqe=qe({trigger:L0.trigger,placement:ey.placement,disabled:L0.disabled,visible:Xs.visible,transition:Xs.transition,popperOptions:ey.popperOptions,tabindex:ey.tabindex,content:Xs.content,popperStyle:Xs.popperStyle,popperClass:Xs.popperClass,enterable:{...Xs.enterable,default:!0},effect:{...Xs.effect,default:"light"},teleported:Xs.teleported,title:String,width:{type:[String,Number],default:150},offset:{type:Number,default:void 0},showAfter:{type:Number,default:0},hideAfter:{type:Number,default:200},autoClose:{type:Number,default:0},showArrow:{type:Boolean,default:!0},persistent:{type:Boolean,default:!0},"onUpdate:visible":{type:Function}}),Yqe={"update:visible":t=>Rs(t),"before-enter":()=>!0,"before-leave":()=>!0,"after-enter":()=>!0,"after-leave":()=>!0},Zqe="onUpdate:visible",Jqe=ue({name:"ElPopover"}),Qqe=ue({...Jqe,props:Xqe,emits:Yqe,setup(t,{expose:e,emit:n}){const s=t,r=A(()=>s[Zqe]),o=Fe("popover"),a=U(),i=A(()=>{var g;return(g=v(a))==null?void 0:g.popperRef}),l=A(()=>[{width:Cs(s.width)},s.popperStyle]),u=A(()=>[o.b(),s.popperClass,{[o.m("plain")]:!!s.content}]),c=A(()=>s.transition===`${o.namespace.value}-fade-in-linear`),d=()=>{var g;(g=a.value)==null||g.hide()},f=()=>{n("before-enter")},h=()=>{n("before-leave")},p=()=>{n("after-enter")},m=()=>{n("update:visible",!1),n("after-leave")};return e({popperRef:i,hide:d}),(g,y)=>(S(),$e(v(No),zt({ref_key:"tooltipRef",ref:a},g.$attrs,{trigger:g.trigger,placement:g.placement,disabled:g.disabled,visible:g.visible,transition:g.transition,"popper-options":g.popperOptions,tabindex:g.tabindex,content:g.content,offset:g.offset,"show-after":g.showAfter,"hide-after":g.hideAfter,"auto-close":g.autoClose,"show-arrow":g.showArrow,"aria-label":g.title,effect:g.effect,enterable:g.enterable,"popper-class":v(u),"popper-style":v(l),teleported:g.teleported,persistent:g.persistent,"gpu-acceleration":v(c),"onUpdate:visible":v(r),onBeforeShow:f,onBeforeHide:h,onShow:p,onHide:m}),{content:ce(()=>[g.title?(S(),E("div",{key:0,class:P(v(o).e("title")),role:"title"},Ue(g.title),3)):ge("v-if",!0),Oe(g.$slots,"default",{},()=>[Yt(Ue(g.content),1)])]),default:ce(()=>[g.$slots.reference?Oe(g.$slots,"reference",{key:0}):ge("v-if",!0)]),_:3},16,["trigger","placement","disabled","visible","transition","popper-options","tabindex","content","offset","show-after","hide-after","auto-close","show-arrow","aria-label","effect","enterable","popper-class","popper-style","teleported","persistent","gpu-acceleration","onUpdate:visible"]))}});var eXe=je(Qqe,[["__file","/home/runner/work/element-plus/element-plus/packages/components/popover/src/popover.vue"]]);const nR=(t,e)=>{const n=e.arg||e.value,s=n==null?void 0:n.popperRef;s&&(s.triggerRef=t)};var tXe={mounted(t,e){nR(t,e)},updated(t,e){nR(t,e)}};const nXe="popover",u7=M9e(tXe,nXe),sXe=Dt(eXe,{directive:u7}),rXe=qe({type:{type:String,default:"line",values:["line","circle","dashboard"]},percentage:{type:Number,default:0,validator:t=>t>=0&&t<=100},status:{type:String,default:"",values:["","success","exception","warning"]},indeterminate:{type:Boolean,default:!1},duration:{type:Number,default:3},strokeWidth:{type:Number,default:6},strokeLinecap:{type:Se(String),default:"round"},textInside:{type:Boolean,default:!1},width:{type:Number,default:126},showText:{type:Boolean,default:!0},color:{type:Se([String,Array,Function]),default:""},format:{type:Se(Function),default:t=>`${t}%`}}),oXe=["aria-valuenow"],aXe={viewBox:"0 0 100 100"},iXe=["d","stroke","stroke-width"],lXe=["d","stroke","opacity","stroke-linecap","stroke-width"],uXe={key:0},cXe=ue({name:"ElProgress"}),dXe=ue({...cXe,props:rXe,setup(t){const e=t,n={success:"#13ce66",exception:"#ff4949",warning:"#e6a23c",default:"#20a0ff"},s=Fe("progress"),r=A(()=>({width:`${e.percentage}%`,animationDuration:`${e.duration}s`,backgroundColor:w(e.percentage)})),o=A(()=>(e.strokeWidth/e.width*100).toFixed(1)),a=A(()=>["circle","dashboard"].includes(e.type)?Number.parseInt(`${50-Number.parseFloat(o.value)/2}`,10):0),i=A(()=>{const b=a.value,_=e.type==="dashboard";return`
          M 50 50
          m 0 ${_?"":"-"}${b}
          a ${b} ${b} 0 1 1 0 ${_?"-":""}${b*2}
          a ${b} ${b} 0 1 1 0 ${_?"":"-"}${b*2}
          `}),l=A(()=>2*Math.PI*a.value),u=A(()=>e.type==="dashboard"?.75:1),c=A(()=>`${-1*l.value*(1-u.value)/2}px`),d=A(()=>({strokeDasharray:`${l.value*u.value}px, ${l.value}px`,strokeDashoffset:c.value})),f=A(()=>({strokeDasharray:`${l.value*u.value*(e.percentage/100)}px, ${l.value}px`,strokeDashoffset:c.value,transition:"stroke-dasharray 0.6s ease 0s, stroke 0.6s ease, opacity ease 0.6s"})),h=A(()=>{let b;return e.color?b=w(e.percentage):b=n[e.status]||n.default,b}),p=A(()=>e.status==="warning"?Rg:e.type==="line"?e.status==="success"?lw:Bl:e.status==="success"?Jh:xa),m=A(()=>e.type==="line"?12+e.strokeWidth*.4:e.width*.111111+2),g=A(()=>e.format(e.percentage));function y(b){const _=100/b.length;return b.map((x,k)=>wt(x)?{color:x,percentage:(k+1)*_}:x).sort((x,k)=>x.percentage-k.percentage)}const w=b=>{var _;const{color:$}=e;if(vt($))return $(b);if(wt($))return $;{const x=y($);for(const k of x)if(k.percentage>b)return k.color;return(_=x[x.length-1])==null?void 0:_.color}};return(b,_)=>(S(),E("div",{class:P([v(s).b(),v(s).m(b.type),v(s).is(b.status),{[v(s).m("without-text")]:!b.showText,[v(s).m("text-inside")]:b.textInside}]),role:"progressbar","aria-valuenow":b.percentage,"aria-valuemin":"0","aria-valuemax":"100"},[b.type==="line"?(S(),E("div",{key:0,class:P(v(s).b("bar"))},[I("div",{class:P(v(s).be("bar","outer")),style:ot({height:`${b.strokeWidth}px`})},[I("div",{class:P([v(s).be("bar","inner"),{[v(s).bem("bar","inner","indeterminate")]:b.indeterminate}]),style:ot(v(r))},[(b.showText||b.$slots.default)&&b.textInside?(S(),E("div",{key:0,class:P(v(s).be("bar","innerText"))},[Oe(b.$slots,"default",{percentage:b.percentage},()=>[I("span",null,Ue(v(g)),1)])],2)):ge("v-if",!0)],6)],6)],2)):(S(),E("div",{key:1,class:P(v(s).b("circle")),style:ot({height:`${b.width}px`,width:`${b.width}px`})},[(S(),E("svg",aXe,[I("path",{class:P(v(s).be("circle","track")),d:v(i),stroke:`var(${v(s).cssVarName("fill-color-light")}, #e5e9f2)`,"stroke-width":v(o),fill:"none",style:ot(v(d))},null,14,iXe),I("path",{class:P(v(s).be("circle","path")),d:v(i),stroke:v(h),fill:"none",opacity:b.percentage?1:0,"stroke-linecap":b.strokeLinecap,"stroke-width":v(o),style:ot(v(f))},null,14,lXe)]))],6)),(b.showText||b.$slots.default)&&!b.textInside?(S(),E("div",{key:2,class:P(v(s).e("text")),style:ot({fontSize:`${v(m)}px`})},[Oe(b.$slots,"default",{percentage:b.percentage},()=>[b.status?(S(),$e(v(rt),{key:1},{default:ce(()=>[(S(),$e(Vt(v(p))))]),_:1})):(S(),E("span",uXe,Ue(v(g)),1))])],6)):ge("v-if",!0)],10,oXe))}});var fXe=je(dXe,[["__file","/home/runner/work/element-plus/element-plus/packages/components/progress/src/progress.vue"]]);const c7=Dt(fXe),hXe=qe({modelValue:{type:Number,default:0},id:{type:String,default:void 0},lowThreshold:{type:Number,default:2},highThreshold:{type:Number,default:4},max:{type:Number,default:5},colors:{type:Se([Array,Object]),default:()=>Ln(["","",""])},voidColor:{type:String,default:""},disabledVoidColor:{type:String,default:""},icons:{type:Se([Array,Object]),default:()=>[Hm,Hm,Hm]},voidIcon:{type:In,default:()=>NP},disabledVoidIcon:{type:In,default:()=>Hm},disabled:{type:Boolean},allowHalf:{type:Boolean},showText:{type:Boolean},showScore:{type:Boolean},textColor:{type:String,default:""},texts:{type:Se(Array),default:()=>Ln(["Extremely bad","Disappointed","Fair","Satisfied","Surprise"])},scoreTemplate:{type:String,default:"{value}"},size:{type:String,validator:Qh},label:{type:String,default:void 0},clearable:{type:Boolean,default:!1}}),pXe={[Fn]:t=>Ct(t),[Ot]:t=>Ct(t)},mXe=["id","aria-label","aria-labelledby","aria-valuenow","aria-valuetext","aria-valuemax"],gXe=["onMousemove","onClick"],vXe=ue({name:"ElRate"}),yXe=ue({...vXe,props:hXe,emits:pXe,setup(t,{expose:e,emit:n}){const s=t;function r(V,O){const F=Z=>Bt(Z),L=Object.keys(O).map(Z=>+Z).filter(Z=>{const j=O[Z];return(F(j)?j.excluded:!1)?V<Z:V<=Z}).sort((Z,j)=>Z-j),G=O[L[0]];return F(G)&&G.value||G}const o=et(Jd,void 0),a=et(Li,void 0),i=ks(),l=Fe("rate"),{inputId:u,isLabeledByFormItem:c}=ic(s,{formItemContext:a}),d=U(s.modelValue),f=U(-1),h=U(!0),p=A(()=>[l.b(),l.m(i.value)]),m=A(()=>s.disabled||(o==null?void 0:o.disabled)),g=A(()=>l.cssVarBlock({"void-color":s.voidColor,"disabled-void-color":s.disabledVoidColor,"fill-color":_.value})),y=A(()=>{let V="";return s.showScore?V=s.scoreTemplate.replace(/\{\s*value\s*\}/,m.value?`${s.modelValue}`:`${d.value}`):s.showText&&(V=s.texts[Math.ceil(d.value)-1]),V}),w=A(()=>s.modelValue*100-Math.floor(s.modelValue)*100),b=A(()=>Qe(s.colors)?{[s.lowThreshold]:s.colors[0],[s.highThreshold]:{value:s.colors[1],excluded:!0},[s.max]:s.colors[2]}:s.colors),_=A(()=>{const V=r(d.value,b.value);return Bt(V)?"":V}),$=A(()=>{let V="";return m.value?V=`${w.value}%`:s.allowHalf&&(V="50%"),{color:_.value,width:V}}),x=A(()=>{let V=Qe(s.icons)?[...s.icons]:{...s.icons};return V=nd(V),Qe(V)?{[s.lowThreshold]:V[0],[s.highThreshold]:{value:V[1],excluded:!0},[s.max]:V[2]}:V}),k=A(()=>r(s.modelValue,x.value)),C=A(()=>m.value?wt(s.disabledVoidIcon)?s.disabledVoidIcon:nd(s.disabledVoidIcon):wt(s.voidIcon)?s.voidIcon:nd(s.voidIcon)),T=A(()=>r(d.value,x.value));function N(V){const O=m.value&&w.value>0&&V-1<s.modelValue&&V>s.modelValue,F=s.allowHalf&&h.value&&V-.5<=d.value&&V>d.value;return O||F}function M(V){s.clearable&&V===s.modelValue&&(V=0),n(Ot,V),s.modelValue!==V&&n("change",V)}function R(V){m.value||(s.allowHalf&&h.value?M(d.value):M(V))}function D(V){if(m.value)return;let O=d.value;const F=V.code;return F===ut.up||F===ut.right?(s.allowHalf?O+=.5:O+=1,V.stopPropagation(),V.preventDefault()):(F===ut.left||F===ut.down)&&(s.allowHalf?O-=.5:O-=1,V.stopPropagation(),V.preventDefault()),O=O<0?0:O,O=O>s.max?s.max:O,n(Ot,O),n("change",O),O}function z(V,O){if(!m.value){if(s.allowHalf){let F=O.target;ja(F,l.e("item"))&&(F=F.querySelector(`.${l.e("icon")}`)),(F.clientWidth===0||ja(F,l.e("decimal")))&&(F=F.parentNode),h.value=O.offsetX*2<=F.clientWidth,d.value=h.value?V-.5:V}else d.value=V;f.value=V}}function B(){m.value||(s.allowHalf&&(h.value=s.modelValue!==Math.floor(s.modelValue)),d.value=s.modelValue,f.value=-1)}return Me(()=>s.modelValue,V=>{d.value=V,h.value=s.modelValue!==Math.floor(s.modelValue)}),s.modelValue||n(Ot,0),e({setCurrentValue:z,resetCurrentValue:B}),(V,O)=>{var F;return S(),E("div",{id:v(u),class:P([v(p),v(l).is("disabled",v(m))]),role:"slider","aria-label":v(c)?void 0:V.label||"rating","aria-labelledby":v(c)?(F=v(a))==null?void 0:F.labelId:void 0,"aria-valuenow":d.value,"aria-valuetext":v(y)||void 0,"aria-valuemin":"0","aria-valuemax":V.max,tabindex:"0",style:ot(v(g)),onKeydown:D},[(S(!0),E(lt,null,Gt(V.max,(L,G)=>(S(),E("span",{key:G,class:P(v(l).e("item")),onMousemove:Z=>z(L,Z),onMouseleave:B,onClick:Z=>R(L)},[se(v(rt),{class:P([v(l).e("icon"),{hover:f.value===L},v(l).is("active",L<=d.value)])},{default:ce(()=>[N(L)?ge("v-if",!0):(S(),E(lt,{key:0},[St((S(),$e(Vt(v(T)),null,null,512)),[[Qt,L<=d.value]]),St((S(),$e(Vt(v(C)),null,null,512)),[[Qt,!(L<=d.value)]])],64)),N(L)?(S(),$e(v(rt),{key:1,style:ot(v($)),class:P([v(l).e("icon"),v(l).e("decimal")])},{default:ce(()=>[(S(),$e(Vt(v(k))))]),_:1},8,["style","class"])):ge("v-if",!0)]),_:2},1032,["class"])],42,gXe))),128)),V.showText||V.showScore?(S(),E("span",{key:0,class:P(v(l).e("text"))},Ue(v(y)),3)):ge("v-if",!0)],46,mXe)}}});var bXe=je(yXe,[["__file","/home/runner/work/element-plus/element-plus/packages/components/rate/src/rate.vue"]]);const wXe=Dt(bXe),Ff={success:"icon-success",warning:"icon-warning",error:"icon-error",info:"icon-info"},sR={[Ff.success]:hP,[Ff.warning]:Rg,[Ff.error]:uw,[Ff.info]:cw},_Xe=qe({title:{type:String,default:""},subTitle:{type:String,default:""},icon:{type:String,values:["success","warning","info","error"],default:"info"}}),$Xe=ue({name:"ElResult"}),xXe=ue({...$Xe,props:_Xe,setup(t){const e=t,n=Fe("result"),s=A(()=>{const r=e.icon,o=r&&Ff[r]?Ff[r]:"icon-info",a=sR[o]||sR["icon-info"];return{class:o,component:a}});return(r,o)=>(S(),E("div",{class:P(v(n).b())},[I("div",{class:P(v(n).e("icon"))},[Oe(r.$slots,"icon",{},()=>[v(s).component?(S(),$e(Vt(v(s).component),{key:0,class:P(v(s).class)},null,8,["class"])):ge("v-if",!0)])],2),r.title||r.$slots.title?(S(),E("div",{key:0,class:P(v(n).e("title"))},[Oe(r.$slots,"title",{},()=>[I("p",null,Ue(r.title),1)])],2)):ge("v-if",!0),r.subTitle||r.$slots["sub-title"]?(S(),E("div",{key:1,class:P(v(n).e("subtitle"))},[Oe(r.$slots,"sub-title",{},()=>[I("p",null,Ue(r.subTitle),1)])],2)):ge("v-if",!0),r.$slots.extra?(S(),E("div",{key:2,class:P(v(n).e("extra"))},[Oe(r.$slots,"extra")],2)):ge("v-if",!0)],2))}});var SXe=je(xXe,[["__file","/home/runner/work/element-plus/element-plus/packages/components/result/src/result.vue"]]);const CXe=Dt(SXe),kXe=["start","center","end","space-around","space-between","space-evenly"],TXe=["top","middle","bottom"],NXe=qe({tag:{type:String,default:"div"},gutter:{type:Number,default:0},justify:{type:String,values:kXe,default:"start"},align:{type:String,values:TXe,default:"top"}}),IXe=ue({name:"ElRow"}),EXe=ue({...IXe,props:NXe,setup(t){const e=t,n=Fe("row"),s=A(()=>e.gutter);Lt(WP,{gutter:s});const r=A(()=>{const a={};return e.gutter&&(a.marginRight=a.marginLeft=`-${e.gutter/2}px`),a}),o=A(()=>[n.b(),n.is(`justify-${e.justify}`,e.justify!=="start"),n.is(`align-${e.align}`,e.align!=="top")]);return(a,i)=>(S(),$e(Vt(a.tag),{class:P(v(o)),style:ot(v(r))},{default:ce(()=>[Oe(a.$slots,"default")]),_:3},8,["class","style"]))}});var AXe=je(EXe,[["__file","/home/runner/work/element-plus/element-plus/packages/components/row/src/row.vue"]]);const OXe=Dt(AXe);var rR=Number.isNaN||function(e){return typeof e=="number"&&e!==e};function RXe(t,e){return!!(t===e||rR(t)&&rR(e))}function DXe(t,e){if(t.length!==e.length)return!1;for(var n=0;n<t.length;n++)if(!RXe(t[n],e[n]))return!1;return!0}function FXe(t,e){e===void 0&&(e=DXe);var n=null;function s(){for(var r=[],o=0;o<arguments.length;o++)r[o]=arguments[o];if(n&&n.lastThis===this&&e(r,n.lastArgs))return n.lastResult;var a=t.apply(this,r);return n={lastResult:a,lastArgs:r,lastThis:this},a}return s.clear=function(){n=null},s}const d7=()=>{const e=Rt().proxy.$props;return A(()=>{const n=(s,r,o)=>({});return e.perfMode?rw(n):FXe(n)})},z6=50,Fy="itemRendered",My="scroll",Mf="forward",Py="backward",ca="auto",Tw="smart",H0="start",Si="center",W0="end",vh="horizontal",yk="vertical",MXe="ltr",Kf="rtl",U0="negative",bk="positive-ascending",wk="positive-descending",PXe={[vh]:"left",[yk]:"top"},LXe=20,zXe={[vh]:"deltaX",[yk]:"deltaY"},BXe=({atEndEdge:t,atStartEdge:e,layout:n},s)=>{let r,o=0;const a=l=>l<0&&e.value||l>0&&t.value;return{hasReachedEdge:a,onWheel:l=>{LC(r);const u=l[zXe[n.value]];a(o)&&a(o+u)||(o+=u,MC()||l.preventDefault(),r=PC(()=>{s(o),o=0}))}}},B6=oi({type:Se([Number,Function]),required:!0}),V6=oi({type:Number}),H6=oi({type:Number,default:2}),VXe=oi({type:String,values:["ltr","rtl"],default:"ltr"}),W6=oi({type:Number,default:0}),Ly=oi({type:Number,required:!0}),f7=oi({type:String,values:["horizontal","vertical"],default:yk}),h7=qe({className:{type:String,default:""},containerElement:{type:Se([String,Object]),default:"div"},data:{type:Se(Array),default:()=>Ln([])},direction:VXe,height:{type:[String,Number],required:!0},innerElement:{type:[String,Object],default:"div"},style:{type:Se([Object,String,Array])},useIsScrolling:{type:Boolean,default:!1},width:{type:[Number,String],required:!1},perfMode:{type:Boolean,default:!0},scrollbarAlwaysOn:{type:Boolean,default:!1}}),p7=qe({cache:H6,estimatedItemSize:V6,layout:f7,initScrollOffset:W6,total:Ly,itemSize:B6,...h7}),U6={type:Number,default:6},m7={type:Number,default:0},g7={type:Number,default:2},ad=qe({columnCache:H6,columnWidth:B6,estimatedColumnWidth:V6,estimatedRowHeight:V6,initScrollLeft:W6,initScrollTop:W6,itemKey:{type:Se(Function),default:({columnIndex:t,rowIndex:e})=>`${e}:${t}`},rowCache:H6,rowHeight:B6,totalColumn:Ly,totalRow:Ly,hScrollbarSize:U6,vScrollbarSize:U6,scrollbarStartGap:m7,scrollbarEndGap:g7,...h7}),v7=qe({alwaysOn:Boolean,class:String,layout:f7,total:Ly,ratio:{type:Number,required:!0},clientSize:{type:Number,required:!0},scrollFrom:{type:Number,required:!0},scrollbarSize:U6,startGap:m7,endGap:g7,visible:Boolean}),Xc=(t,e)=>t<e?Mf:Py,G0=t=>t===MXe||t===Kf||t===vh,oR=t=>t===Kf;let _f=null;function zy(t=!1){if(_f===null||t){const e=document.createElement("div"),n=e.style;n.width="50px",n.height="50px",n.overflow="scroll",n.direction="rtl";const s=document.createElement("div"),r=s.style;return r.width="100px",r.height="100px",e.appendChild(s),document.body.appendChild(e),e.scrollLeft>0?_f=wk:(e.scrollLeft=1,e.scrollLeft===0?_f=U0:_f=bk),document.body.removeChild(e),_f}return _f}function HXe({move:t,size:e,bar:n},s){const r={},o=`translate${n.axis}(${t}px)`;return r[n.size]=e,r.transform=o,r.msTransform=o,r.webkitTransform=o,s==="horizontal"?r.height="100%":r.width="100%",r}const G6=ue({name:"ElVirtualScrollBar",props:v7,emits:["scroll","start-move","stop-move"],setup(t,{emit:e}){const n=A(()=>t.startGap+t.endGap),s=Fe("virtual-scrollbar"),r=Fe("scrollbar"),o=U(),a=U();let i=null,l=null;const u=on({isDragging:!1,traveled:0}),c=A(()=>dL[t.layout]),d=A(()=>t.clientSize-v(n)),f=A(()=>({position:"absolute",width:`${vh===t.layout?d.value:t.scrollbarSize}px`,height:`${vh===t.layout?t.scrollbarSize:d.value}px`,[PXe[t.layout]]:"2px",right:"2px",bottom:"2px",borderRadius:"4px"})),h=A(()=>{const x=t.ratio,k=t.clientSize;if(x>=100)return Number.POSITIVE_INFINITY;if(x>=50)return x*k/100;const C=k/3;return Math.floor(Math.min(Math.max(x*k,LXe),C))}),p=A(()=>{if(!Number.isFinite(h.value))return{display:"none"};const x=`${h.value}px`;return HXe({bar:c.value,size:x,move:u.traveled},t.layout)}),m=A(()=>Math.floor(t.clientSize-h.value-v(n))),g=()=>{window.addEventListener("mousemove",_),window.addEventListener("mouseup",b);const x=v(a);!x||(l=document.onselectstart,document.onselectstart=()=>!1,x.addEventListener("touchmove",_),x.addEventListener("touchend",b))},y=()=>{window.removeEventListener("mousemove",_),window.removeEventListener("mouseup",b),document.onselectstart=l,l=null;const x=v(a);!x||(x.removeEventListener("touchmove",_),x.removeEventListener("touchend",b))},w=x=>{x.stopImmediatePropagation(),!(x.ctrlKey||[1,2].includes(x.button))&&(u.isDragging=!0,u[c.value.axis]=x.currentTarget[c.value.offset]-(x[c.value.client]-x.currentTarget.getBoundingClientRect()[c.value.direction]),e("start-move"),g())},b=()=>{u.isDragging=!1,u[c.value.axis]=0,e("stop-move"),y()},_=x=>{const{isDragging:k}=u;if(!k||!a.value||!o.value)return;const C=u[c.value.axis];if(!C)return;LC(i);const T=(o.value.getBoundingClientRect()[c.value.direction]-x[c.value.client])*-1,N=a.value[c.value.offset]-C,M=T-N;i=PC(()=>{u.traveled=Math.max(t.startGap,Math.min(M,m.value)),e("scroll",M,m.value)})},$=x=>{const k=Math.abs(x.target.getBoundingClientRect()[c.value.direction]-x[c.value.client]),C=a.value[c.value.offset]/2,T=k-C;u.traveled=Math.max(0,Math.min(T,m.value)),e("scroll",T,m.value)};return Me(()=>t.scrollFrom,x=>{u.isDragging||(u.traveled=Math.ceil(x*m.value))}),ts(()=>{y()}),()=>it("div",{role:"presentation",ref:o,class:[s.b(),t.class,(t.alwaysOn||u.isDragging)&&"always-on"],style:f.value,onMousedown:yt($,["stop","prevent"]),onTouchstartPrevent:w},it("div",{ref:a,class:r.e("thumb"),style:p.value,onMousedown:w},[]))}}),y7=({name:t,getOffset:e,getItemSize:n,getItemOffset:s,getEstimatedTotalSize:r,getStartIndexForOffset:o,getStopIndexForStartIndex:a,initCache:i,clearCache:l,validateProps:u})=>ue({name:t??"ElVirtualList",props:p7,emits:[Fy,My],setup(c,{emit:d,expose:f}){u(c);const h=Rt(),p=Fe("vl"),m=U(i(c,h)),g=d7(),y=U(),w=U(),b=U(),_=U({isScrolling:!1,scrollDir:"forward",scrollOffset:Ct(c.initScrollOffset)?c.initScrollOffset:0,updateRequested:!1,isScrollbarDragging:!1,scrollbarAlwaysOn:c.scrollbarAlwaysOn}),$=A(()=>{const{total:J,cache:fe}=c,{isScrolling:X,scrollDir:oe,scrollOffset:ee}=v(_);if(J===0)return[0,0,0,0];const Q=o(c,ee,v(m)),ie=a(c,Q,ee,v(m)),pe=!X||oe===Py?Math.max(1,fe):1,Re=!X||oe===Mf?Math.max(1,fe):1;return[Math.max(0,Q-pe),Math.max(0,Math.min(J-1,ie+Re)),Q,ie]}),x=A(()=>r(c,v(m))),k=A(()=>G0(c.layout)),C=A(()=>[{position:"relative",[`overflow-${k.value?"x":"y"}`]:"scroll",WebkitOverflowScrolling:"touch",willChange:"transform"},{direction:c.direction,height:Ct(c.height)?`${c.height}px`:c.height,width:Ct(c.width)?`${c.width}px`:c.width},c.style]),T=A(()=>{const J=v(x),fe=v(k);return{height:fe?"100%":`${J}px`,pointerEvents:v(_).isScrolling?"none":void 0,width:fe?`${J}px`:"100%"}}),N=A(()=>k.value?c.width:c.height),{onWheel:M}=BXe({atStartEdge:A(()=>_.value.scrollOffset<=0),atEndEdge:A(()=>_.value.scrollOffset>=x.value),layout:A(()=>c.layout)},J=>{var fe,X;(X=(fe=b.value).onMouseUp)==null||X.call(fe),O(Math.min(_.value.scrollOffset+J,x.value-N.value))}),R=()=>{const{total:J}=c;if(J>0){const[ee,Q,ie,pe]=v($);d(Fy,ee,Q,ie,pe)}const{scrollDir:fe,scrollOffset:X,updateRequested:oe}=v(_);d(My,fe,X,oe)},D=J=>{const{clientHeight:fe,scrollHeight:X,scrollTop:oe}=J.currentTarget,ee=v(_);if(ee.scrollOffset===oe)return;const Q=Math.max(0,Math.min(oe,X-fe));_.value={...ee,isScrolling:!0,scrollDir:Xc(ee.scrollOffset,Q),scrollOffset:Q,updateRequested:!1},nt(G)},z=J=>{const{clientWidth:fe,scrollLeft:X,scrollWidth:oe}=J.currentTarget,ee=v(_);if(ee.scrollOffset===X)return;const{direction:Q}=c;let ie=X;if(Q===Kf)switch(zy()){case U0:{ie=-X;break}case wk:{ie=oe-fe-X;break}}ie=Math.max(0,Math.min(ie,oe-fe)),_.value={...ee,isScrolling:!0,scrollDir:Xc(ee.scrollOffset,ie),scrollOffset:ie,updateRequested:!1},nt(G)},B=J=>{v(k)?z(J):D(J),R()},V=(J,fe)=>{const X=(x.value-N.value)/fe*J;O(Math.min(x.value-N.value,X))},O=J=>{J=Math.max(J,0),J!==v(_).scrollOffset&&(_.value={...v(_),scrollOffset:J,scrollDir:Xc(v(_).scrollOffset,J),updateRequested:!0},nt(G))},F=(J,fe=ca)=>{const{scrollOffset:X}=v(_);J=Math.max(0,Math.min(J,c.total-1)),O(e(c,J,fe,X,v(m)))},L=J=>{const{direction:fe,itemSize:X,layout:oe}=c,ee=g.value(l&&X,l&&oe,l&&fe);let Q;if(Ut(ee,String(J)))Q=ee[J];else{const ie=s(c,J,v(m)),pe=n(c,J,v(m)),Re=v(k),K=fe===Kf,re=Re?ie:0;ee[J]=Q={position:"absolute",left:K?void 0:`${re}px`,right:K?`${re}px`:void 0,top:Re?0:`${ie}px`,height:Re?"100%":`${pe}px`,width:Re?`${pe}px`:"100%"}}return Q},G=()=>{_.value.isScrolling=!1,nt(()=>{g.value(-1,null,null)})},Z=()=>{const J=y.value;J&&(J.scrollTop=0)};It(()=>{if(!Kt)return;const{initScrollOffset:J}=c,fe=v(y);Ct(J)&&fe&&(v(k)?fe.scrollLeft=J:fe.scrollTop=J),R()}),Ml(()=>{const{direction:J,layout:fe}=c,{scrollOffset:X,updateRequested:oe}=v(_),ee=v(y);if(oe&&ee)if(fe===vh)if(J===Kf)switch(zy()){case U0:{ee.scrollLeft=-X;break}case bk:{ee.scrollLeft=X;break}default:{const{clientWidth:Q,scrollWidth:ie}=ee;ee.scrollLeft=ie-Q-X;break}}else ee.scrollLeft=X;else ee.scrollTop=X});const j={ns:p,clientSize:N,estimatedTotalSize:x,windowStyle:C,windowRef:y,innerRef:w,innerStyle:T,itemsToRender:$,scrollbarRef:b,states:_,getItemStyle:L,onScroll:B,onScrollbarScroll:V,onWheel:M,scrollTo:O,scrollToItem:F,resetScrollTop:Z};return f({windowRef:y,innerRef:w,getItemStyleCache:g,scrollTo:O,scrollToItem:F,resetScrollTop:Z,states:_}),j},render(c){var d;const{$slots:f,className:h,clientSize:p,containerElement:m,data:g,getItemStyle:y,innerElement:w,itemsToRender:b,innerStyle:_,layout:$,total:x,onScroll:k,onScrollbarScroll:C,onWheel:T,states:N,useIsScrolling:M,windowStyle:R,ns:D}=c,[z,B]=b,V=Vt(m),O=Vt(w),F=[];if(x>0)for(let j=z;j<=B;j++)F.push((d=f.default)==null?void 0:d.call(f,{data:g,key:j,index:j,isScrolling:M?N.isScrolling:void 0,style:y(j)}));const L=[it(O,{style:_,ref:"innerRef"},wt(O)?F:{default:()=>F})],G=it(G6,{ref:"scrollbarRef",clientSize:p,layout:$,onScroll:C,ratio:p*100/this.estimatedTotalSize,scrollFrom:N.scrollOffset/(this.estimatedTotalSize-p),total:x}),Z=it(V,{class:[D.e("window"),h],style:R,onScroll:k,onWheel:T,ref:"windowRef",key:0},wt(V)?[L]:{default:()=>[L]});return it("div",{key:0,class:[D.e("wrapper"),N.scrollbarAlwaysOn?"always-on":""]},[Z,G])}}),b7=y7({name:"ElFixedSizeList",getItemOffset:({itemSize:t},e)=>e*t,getItemSize:({itemSize:t})=>t,getEstimatedTotalSize:({total:t,itemSize:e})=>e*t,getOffset:({height:t,total:e,itemSize:n,layout:s,width:r},o,a,i)=>{const l=G0(s)?r:t,u=Math.max(0,e*n-l),c=Math.min(u,o*n),d=Math.max(0,(o+1)*n-l);switch(a===Tw&&(i>=d-l&&i<=c+l?a=ca:a=Si),a){case H0:return c;case W0:return d;case Si:{const f=Math.round(d+(c-d)/2);return f<Math.ceil(l/2)?0:f>u+Math.floor(l/2)?u:f}case ca:default:return i>=d&&i<=c?i:i<d?d:c}},getStartIndexForOffset:({total:t,itemSize:e},n)=>Math.max(0,Math.min(t-1,Math.floor(n/e))),getStopIndexForStartIndex:({height:t,total:e,itemSize:n,layout:s,width:r},o,a)=>{const i=o*n,l=G0(s)?r:t,u=Math.ceil((l+a-i)/n);return Math.max(0,Math.min(e-1,o+u-1))},initCache(){},clearCache:!0,validateProps(){}}),Pf=(t,e,n)=>{const{itemSize:s}=t,{items:r,lastVisitedIndex:o}=n;if(e>o){let a=0;if(o>=0){const i=r[o];a=i.offset+i.size}for(let i=o+1;i<=e;i++){const l=s(i);r[i]={offset:a,size:l},a+=l}n.lastVisitedIndex=e}return r[e]},WXe=(t,e,n)=>{const{items:s,lastVisitedIndex:r}=e;return(r>0?s[r].offset:0)>=n?w7(t,e,0,r,n):UXe(t,e,Math.max(0,r),n)},w7=(t,e,n,s,r)=>{for(;n<=s;){const o=n+Math.floor((s-n)/2),a=Pf(t,o,e).offset;if(a===r)return o;a<r?n=o+1:a>r&&(s=o-1)}return Math.max(0,n-1)},UXe=(t,e,n,s)=>{const{total:r}=t;let o=1;for(;n<r&&Pf(t,n,e).offset<s;)n+=o,o*=2;return w7(t,e,Math.floor(n/2),Math.min(n,r-1),s)},aR=({total:t},{items:e,estimatedItemSize:n,lastVisitedIndex:s})=>{let r=0;if(s>=t&&(s=t-1),s>=0){const i=e[s];r=i.offset+i.size}const a=(t-s-1)*n;return r+a},GXe=y7({name:"ElDynamicSizeList",getItemOffset:(t,e,n)=>Pf(t,e,n).offset,getItemSize:(t,e,{items:n})=>n[e].size,getEstimatedTotalSize:aR,getOffset:(t,e,n,s,r)=>{const{height:o,layout:a,width:i}=t,l=G0(a)?i:o,u=Pf(t,e,r),c=aR(t,r),d=Math.max(0,Math.min(c-l,u.offset)),f=Math.max(0,u.offset-l+u.size);switch(n===Tw&&(s>=f-l&&s<=d+l?n=ca:n=Si),n){case H0:return d;case W0:return f;case Si:return Math.round(f+(d-f)/2);case ca:default:return s>=f&&s<=d?s:s<f?f:d}},getStartIndexForOffset:(t,e,n)=>WXe(t,n,e),getStopIndexForStartIndex:(t,e,n,s)=>{const{height:r,total:o,layout:a,width:i}=t,l=G0(a)?i:r,u=Pf(t,e,s),c=n+l;let d=u.offset+u.size,f=e;for(;f<o-1&&d<c;)f++,d+=Pf(t,f,s).size;return f},initCache({estimatedItemSize:t=z6},e){const n={items:{},estimatedItemSize:t,lastVisitedIndex:-1};return n.clearCacheAfterIndex=(s,r=!0)=>{var o,a;n.lastVisitedIndex=Math.min(n.lastVisitedIndex,s-1),(o=e.exposed)==null||o.getItemStyleCache(-1),r&&((a=e.proxy)==null||a.$forceUpdate())},n},clearCache:!1,validateProps:({itemSize:t})=>{}}),jXe=({atXEndEdge:t,atXStartEdge:e,atYEndEdge:n,atYStartEdge:s},r)=>{let o=null,a=0,i=0;const l=(c,d)=>{const f=c<0&&e.value||c>0&&t.value,h=d<0&&s.value||d>0&&n.value;return f&&h};return{hasReachedEdge:l,onWheel:c=>{LC(o);let d=c.deltaX,f=c.deltaY;Math.abs(d)>Math.abs(f)?f=0:d=0,c.shiftKey&&f!==0&&(d=f,f=0),!(l(a,i)&&l(a+d,i+f))&&(a+=d,i+=f,MC()||c.preventDefault(),o=PC(()=>{r(a,i),a=0,i=0}))}}},_7=({name:t,clearCache:e,getColumnPosition:n,getColumnStartIndexForOffset:s,getColumnStopIndexForStartIndex:r,getEstimatedTotalHeight:o,getEstimatedTotalWidth:a,getColumnOffset:i,getRowOffset:l,getRowPosition:u,getRowStartIndexForOffset:c,getRowStopIndexForStartIndex:d,initCache:f,injectToInstance:h,validateProps:p})=>ue({name:t??"ElVirtualList",props:ad,emits:[Fy,My],setup(m,{emit:g,expose:y,slots:w}){const b=Fe("vl");p(m);const _=Rt(),$=U(f(m,_));h==null||h(_,$);const x=U(),k=U(),C=U(),T=U(null),N=U({isScrolling:!1,scrollLeft:Ct(m.initScrollLeft)?m.initScrollLeft:0,scrollTop:Ct(m.initScrollTop)?m.initScrollTop:0,updateRequested:!1,xAxisScrollDir:Mf,yAxisScrollDir:Mf}),M=d7(),R=A(()=>Number.parseInt(`${m.height}`,10)),D=A(()=>Number.parseInt(`${m.width}`,10)),z=A(()=>{const{totalColumn:_e,totalRow:ze,columnCache:Ae}=m,{isScrolling:he,xAxisScrollDir:ve,scrollLeft:me}=v(N);if(_e===0||ze===0)return[0,0,0,0];const Ve=s(m,me,v($)),Ye=r(m,Ve,me,v($)),Je=!he||ve===Py?Math.max(1,Ae):1,ct=!he||ve===Mf?Math.max(1,Ae):1;return[Math.max(0,Ve-Je),Math.max(0,Math.min(_e-1,Ye+ct)),Ve,Ye]}),B=A(()=>{const{totalColumn:_e,totalRow:ze,rowCache:Ae}=m,{isScrolling:he,yAxisScrollDir:ve,scrollTop:me}=v(N);if(_e===0||ze===0)return[0,0,0,0];const Ve=c(m,me,v($)),Ye=d(m,Ve,me,v($)),Je=!he||ve===Py?Math.max(1,Ae):1,ct=!he||ve===Mf?Math.max(1,Ae):1;return[Math.max(0,Ve-Je),Math.max(0,Math.min(ze-1,Ye+ct)),Ve,Ye]}),V=A(()=>o(m,v($))),O=A(()=>a(m,v($))),F=A(()=>{var _e;return[{position:"relative",overflow:"hidden",WebkitOverflowScrolling:"touch",willChange:"transform"},{direction:m.direction,height:Ct(m.height)?`${m.height}px`:m.height,width:Ct(m.width)?`${m.width}px`:m.width},(_e=m.style)!=null?_e:{}]}),L=A(()=>{const _e=`${v(O)}px`;return{height:`${v(V)}px`,pointerEvents:v(N).isScrolling?"none":void 0,width:_e}}),G=()=>{const{totalColumn:_e,totalRow:ze}=m;if(_e>0&&ze>0){const[Ye,Je,ct,xt]=v(z),[dt,xe,Ke,at]=v(B);g(Fy,{columnCacheStart:Ye,columnCacheEnd:Je,rowCacheStart:dt,rowCacheEnd:xe,columnVisibleStart:ct,columnVisibleEnd:xt,rowVisibleStart:Ke,rowVisibleEnd:at})}const{scrollLeft:Ae,scrollTop:he,updateRequested:ve,xAxisScrollDir:me,yAxisScrollDir:Ve}=v(N);g(My,{xAxisScrollDir:me,scrollLeft:Ae,yAxisScrollDir:Ve,scrollTop:he,updateRequested:ve})},Z=_e=>{const{clientHeight:ze,clientWidth:Ae,scrollHeight:he,scrollLeft:ve,scrollTop:me,scrollWidth:Ve}=_e.currentTarget,Ye=v(N);if(Ye.scrollTop===me&&Ye.scrollLeft===ve)return;let Je=ve;if(oR(m.direction))switch(zy()){case U0:Je=-ve;break;case wk:Je=Ve-Ae-ve;break}N.value={...Ye,isScrolling:!0,scrollLeft:Je,scrollTop:Math.max(0,Math.min(me,he-ze)),updateRequested:!0,xAxisScrollDir:Xc(Ye.scrollLeft,Je),yAxisScrollDir:Xc(Ye.scrollTop,me)},nt(()=>Q()),ie(),G()},j=(_e,ze)=>{const Ae=v(R),he=(V.value-Ae)/ze*_e;X({scrollTop:Math.min(V.value-Ae,he)})},J=(_e,ze)=>{const Ae=v(D),he=(O.value-Ae)/ze*_e;X({scrollLeft:Math.min(O.value-Ae,he)})},{onWheel:fe}=jXe({atXStartEdge:A(()=>N.value.scrollLeft<=0),atXEndEdge:A(()=>N.value.scrollLeft>=O.value),atYStartEdge:A(()=>N.value.scrollTop<=0),atYEndEdge:A(()=>N.value.scrollTop>=V.value)},(_e,ze)=>{var Ae,he,ve,me;(he=(Ae=k.value)==null?void 0:Ae.onMouseUp)==null||he.call(Ae),(me=(ve=k.value)==null?void 0:ve.onMouseUp)==null||me.call(ve);const Ve=v(D),Ye=v(R);X({scrollLeft:Math.min(N.value.scrollLeft+_e,O.value-Ve),scrollTop:Math.min(N.value.scrollTop+ze,V.value-Ye)})}),X=({scrollLeft:_e=N.value.scrollLeft,scrollTop:ze=N.value.scrollTop})=>{_e=Math.max(_e,0),ze=Math.max(ze,0);const Ae=v(N);ze===Ae.scrollTop&&_e===Ae.scrollLeft||(N.value={...Ae,xAxisScrollDir:Xc(Ae.scrollLeft,_e),yAxisScrollDir:Xc(Ae.scrollTop,ze),scrollLeft:_e,scrollTop:ze,updateRequested:!0},nt(()=>Q()),ie(),G())},oe=(_e=0,ze=0,Ae=ca)=>{const he=v(N);ze=Math.max(0,Math.min(ze,m.totalColumn-1)),_e=Math.max(0,Math.min(_e,m.totalRow-1));const ve=lP(b.namespace.value),me=v($),Ve=o(m,me),Ye=a(m,me);X({scrollLeft:i(m,ze,Ae,he.scrollLeft,me,Ye>m.width?ve:0),scrollTop:l(m,_e,Ae,he.scrollTop,me,Ve>m.height?ve:0)})},ee=(_e,ze)=>{const{columnWidth:Ae,direction:he,rowHeight:ve}=m,me=M.value(e&&Ae,e&&ve,e&&he),Ve=`${_e},${ze}`;if(Ut(me,Ve))return me[Ve];{const[,Ye]=n(m,ze,v($)),Je=v($),ct=oR(he),[xt,dt]=u(m,_e,Je),[xe]=n(m,ze,Je);return me[Ve]={position:"absolute",left:ct?void 0:`${Ye}px`,right:ct?`${Ye}px`:void 0,top:`${dt}px`,height:`${xt}px`,width:`${xe}px`},me[Ve]}},Q=()=>{N.value.isScrolling=!1,nt(()=>{M.value(-1,null,null)})};It(()=>{if(!Kt)return;const{initScrollLeft:_e,initScrollTop:ze}=m,Ae=v(x);Ae&&(Ct(_e)&&(Ae.scrollLeft=_e),Ct(ze)&&(Ae.scrollTop=ze)),G()});const ie=()=>{const{direction:_e}=m,{scrollLeft:ze,scrollTop:Ae,updateRequested:he}=v(N),ve=v(x);if(he&&ve){if(_e===Kf)switch(zy()){case U0:{ve.scrollLeft=-ze;break}case bk:{ve.scrollLeft=ze;break}default:{const{clientWidth:me,scrollWidth:Ve}=ve;ve.scrollLeft=Ve-me-ze;break}}else ve.scrollLeft=Math.max(0,ze);ve.scrollTop=Math.max(0,Ae)}},{resetAfterColumnIndex:pe,resetAfterRowIndex:Re,resetAfter:K}=_.proxy;y({windowRef:x,innerRef:T,getItemStyleCache:M,scrollTo:X,scrollToItem:oe,states:N,resetAfterColumnIndex:pe,resetAfterRowIndex:Re,resetAfter:K});const re=()=>{const{scrollbarAlwaysOn:_e,scrollbarStartGap:ze,scrollbarEndGap:Ae,totalColumn:he,totalRow:ve}=m,me=v(D),Ve=v(R),Ye=v(O),Je=v(V),{scrollLeft:ct,scrollTop:xt}=v(N),dt=it(G6,{ref:k,alwaysOn:_e,startGap:ze,endGap:Ae,class:b.e("horizontal"),clientSize:me,layout:"horizontal",onScroll:J,ratio:me*100/Ye,scrollFrom:ct/(Ye-me),total:ve,visible:!0}),xe=it(G6,{ref:C,alwaysOn:_e,startGap:ze,endGap:Ae,class:b.e("vertical"),clientSize:Ve,layout:"vertical",onScroll:j,ratio:Ve*100/Je,scrollFrom:xt/(Je-Ve),total:he,visible:!0});return{horizontalScrollbar:dt,verticalScrollbar:xe}},we=()=>{var _e;const[ze,Ae]=v(z),[he,ve]=v(B),{data:me,totalColumn:Ve,totalRow:Ye,useIsScrolling:Je,itemKey:ct}=m,xt=[];if(Ye>0&&Ve>0)for(let dt=he;dt<=ve;dt++)for(let xe=ze;xe<=Ae;xe++)xt.push((_e=w.default)==null?void 0:_e.call(w,{columnIndex:xe,data:me,key:ct({columnIndex:xe,data:me,rowIndex:dt}),isScrolling:Je?v(N).isScrolling:void 0,style:ee(dt,xe),rowIndex:dt}));return xt},Ee=()=>{const _e=Vt(m.innerElement),ze=we();return[it(_e,{style:v(L),ref:T},wt(_e)?ze:{default:()=>ze})]};return()=>{const _e=Vt(m.containerElement),{horizontalScrollbar:ze,verticalScrollbar:Ae}=re(),he=Ee();return it("div",{key:0,class:b.e("wrapper")},[it(_e,{class:m.className,style:v(F),onScroll:Z,onWheel:fe,ref:x},wt(_e)?he:{default:()=>he}),ze,Ae])}}}),KXe=_7({name:"ElFixedSizeGrid",getColumnPosition:({columnWidth:t},e)=>[t,e*t],getRowPosition:({rowHeight:t},e)=>[t,e*t],getEstimatedTotalHeight:({totalRow:t,rowHeight:e})=>e*t,getEstimatedTotalWidth:({totalColumn:t,columnWidth:e})=>e*t,getColumnOffset:({totalColumn:t,columnWidth:e,width:n},s,r,o,a,i)=>{n=Number(n);const l=Math.max(0,t*e-n),u=Math.min(l,s*e),c=Math.max(0,s*e-n+i+e);switch(r==="smart"&&(o>=c-n&&o<=u+n?r=ca:r=Si),r){case H0:return u;case W0:return c;case Si:{const d=Math.round(c+(u-c)/2);return d<Math.ceil(n/2)?0:d>l+Math.floor(n/2)?l:d}case ca:default:return o>=c&&o<=u?o:c>u||o<c?c:u}},getRowOffset:({rowHeight:t,height:e,totalRow:n},s,r,o,a,i)=>{e=Number(e);const l=Math.max(0,n*t-e),u=Math.min(l,s*t),c=Math.max(0,s*t-e+i+t);switch(r===Tw&&(o>=c-e&&o<=u+e?r=ca:r=Si),r){case H0:return u;case W0:return c;case Si:{const d=Math.round(c+(u-c)/2);return d<Math.ceil(e/2)?0:d>l+Math.floor(e/2)?l:d}case ca:default:return o>=c&&o<=u?o:c>u||o<c?c:u}},getColumnStartIndexForOffset:({columnWidth:t,totalColumn:e},n)=>Math.max(0,Math.min(e-1,Math.floor(n/t))),getColumnStopIndexForStartIndex:({columnWidth:t,totalColumn:e,width:n},s,r)=>{const o=s*t,a=Math.ceil((n+r-o)/t);return Math.max(0,Math.min(e-1,s+a-1))},getRowStartIndexForOffset:({rowHeight:t,totalRow:e},n)=>Math.max(0,Math.min(e-1,Math.floor(n/t))),getRowStopIndexForStartIndex:({rowHeight:t,totalRow:e,height:n},s,r)=>{const o=s*t,a=Math.ceil((n+r-o)/t);return Math.max(0,Math.min(e-1,s+a-1))},initCache:()=>{},clearCache:!0,validateProps:({columnWidth:t,rowHeight:e})=>{}}),{max:By,min:$7,floor:x7}=Math,qXe={column:"columnWidth",row:"rowHeight"},j6={column:"lastVisitedColumnIndex",row:"lastVisitedRowIndex"},al=(t,e,n,s)=>{const[r,o,a]=[n[s],t[qXe[s]],n[j6[s]]];if(e>a){let i=0;if(a>=0){const l=r[a];i=l.offset+l.size}for(let l=a+1;l<=e;l++){const u=o(l);r[l]={offset:i,size:u},i+=u}n[j6[s]]=e}return r[e]},S7=(t,e,n,s,r,o)=>{for(;n<=s;){const a=n+x7((s-n)/2),i=al(t,a,e,o).offset;if(i===r)return a;i<r?n=a+1:s=a-1}return By(0,n-1)},XXe=(t,e,n,s,r)=>{const o=r==="column"?t.totalColumn:t.totalRow;let a=1;for(;n<o&&al(t,n,e,r).offset<s;)n+=a,a*=2;return S7(t,e,x7(n/2),$7(n,o-1),s,r)},iR=(t,e,n,s)=>{const[r,o]=[e[s],e[j6[s]]];return(o>0?r[o].offset:0)>=n?S7(t,e,0,o,n,s):XXe(t,e,By(0,o),n,s)},C7=({totalRow:t},{estimatedRowHeight:e,lastVisitedRowIndex:n,row:s})=>{let r=0;if(n>=t&&(n=t-1),n>=0){const i=s[n];r=i.offset+i.size}const a=(t-n-1)*e;return r+a},k7=({totalColumn:t},{column:e,estimatedColumnWidth:n,lastVisitedColumnIndex:s})=>{let r=0;if(s>t&&(s=t-1),s>=0){const i=e[s];r=i.offset+i.size}const a=(t-s-1)*n;return r+a},YXe={column:k7,row:C7},lR=(t,e,n,s,r,o,a)=>{const[i,l]=[o==="row"?t.height:t.width,YXe[o]],u=al(t,e,r,o),c=l(t,r),d=By(0,$7(c-i,u.offset)),f=By(0,u.offset-i+a+u.size);switch(n===Tw&&(s>=f-i&&s<=d+i?n=ca:n=Si),n){case H0:return d;case W0:return f;case Si:return Math.round(f+(d-f)/2);case ca:default:return s>=f&&s<=d?s:f>d||s<f?f:d}},ZXe=_7({name:"ElDynamicSizeGrid",getColumnPosition:(t,e,n)=>{const s=al(t,e,n,"column");return[s.size,s.offset]},getRowPosition:(t,e,n)=>{const s=al(t,e,n,"row");return[s.size,s.offset]},getColumnOffset:(t,e,n,s,r,o)=>lR(t,e,n,s,r,"column",o),getRowOffset:(t,e,n,s,r,o)=>lR(t,e,n,s,r,"row",o),getColumnStartIndexForOffset:(t,e,n)=>iR(t,n,e,"column"),getColumnStopIndexForStartIndex:(t,e,n,s)=>{const r=al(t,e,s,"column"),o=n+t.width;let a=r.offset+r.size,i=e;for(;i<t.totalColumn-1&&a<o;)i++,a+=al(t,e,s,"column").size;return i},getEstimatedTotalHeight:C7,getEstimatedTotalWidth:k7,getRowStartIndexForOffset:(t,e,n)=>iR(t,n,e,"row"),getRowStopIndexForStartIndex:(t,e,n,s)=>{const{totalRow:r,height:o}=t,a=al(t,e,s,"row"),i=n+o;let l=a.size+a.offset,u=e;for(;u<r-1&&l<i;)u++,l+=al(t,u,s,"row").size;return u},injectToInstance:(t,e)=>{const n=({columnIndex:o,rowIndex:a},i)=>{var l,u;i=er(i)?!0:i,Ct(o)&&(e.value.lastVisitedColumnIndex=Math.min(e.value.lastVisitedColumnIndex,o-1)),Ct(a)&&(e.value.lastVisitedRowIndex=Math.min(e.value.lastVisitedRowIndex,a-1)),(l=t.exposed)==null||l.getItemStyleCache.value(-1,null,null),i&&((u=t.proxy)==null||u.$forceUpdate())},s=(o,a)=>{n({columnIndex:o},a)},r=(o,a)=>{n({rowIndex:o},a)};Object.assign(t.proxy,{resetAfterColumnIndex:s,resetAfterRowIndex:r,resetAfter:n})},initCache:({estimatedColumnWidth:t=z6,estimatedRowHeight:e=z6})=>({column:{},estimatedColumnWidth:t,estimatedRowHeight:e,lastVisitedColumnIndex:-1,lastVisitedRowIndex:-1,row:{}}),clearCache:!1,validateProps:({columnWidth:t,rowHeight:e})=>{}}),JXe=ue({props:{item:{type:Object,required:!0},style:Object,height:Number},setup(){return{ns:Fe("select")}}});function QXe(t,e,n,s,r,o){return t.item.isTitle?(S(),E("div",{key:0,class:P(t.ns.be("group","title")),style:ot([t.style,{lineHeight:`${t.height}px`}])},Ue(t.item.label),7)):(S(),E("div",{key:1,class:P(t.ns.be("group","split")),style:ot(t.style)},[I("span",{class:P(t.ns.be("group","split-dash")),style:ot({top:`${t.height/2}px`})},null,6)],6))}var eYe=je(JXe,[["render",QXe],["__file","/home/runner/work/element-plus/element-plus/packages/components/select-v2/src/group-item.vue"]]);function tYe(t,{emit:e}){return{hoverItem:()=>{t.disabled||e("hover",t.index)},selectOptionClick:()=>{t.disabled||e("select",t.item,t.index)}}}const nYe={allowCreate:Boolean,autocomplete:{type:String,default:"none"},automaticDropdown:Boolean,clearable:Boolean,clearIcon:{type:[String,Object],default:Bl},effect:{type:String,default:"light"},collapseTags:Boolean,collapseTagsTooltip:{type:Boolean,default:!1},defaultFirstOption:Boolean,disabled:Boolean,estimatedOptionHeight:{type:Number,default:void 0},filterable:Boolean,filterMethod:Function,height:{type:Number,default:170},itemHeight:{type:Number,default:34},id:String,loading:Boolean,loadingText:String,label:String,modelValue:[Array,String,Number,Boolean,Object],multiple:Boolean,multipleLimit:{type:Number,default:0},name:String,noDataText:String,noMatchText:String,remoteMethod:Function,reserveKeyword:{type:Boolean,default:!0},options:{type:Array,required:!0},placeholder:{type:String},teleported:Xs.teleported,persistent:{type:Boolean,default:!0},popperClass:{type:String,default:""},popperOptions:{type:Object,default:()=>({})},remote:Boolean,size:{type:String,validator:Qh},valueKey:{type:String,default:"value"},scrollbarAlwaysOn:{type:Boolean,default:!1},validateEvent:{type:Boolean,default:!0},placement:{type:Se(String),values:Qd,default:"bottom-start"}},sYe={data:Array,disabled:Boolean,hovering:Boolean,item:Object,index:Number,style:Object,selected:Boolean,created:Boolean},rYe=ue({props:sYe,emits:["select","hover"],setup(t,{emit:e}){const n=Fe("select"),{hoverItem:s,selectOptionClick:r}=tYe(t,{emit:e});return{ns:n,hoverItem:s,selectOptionClick:r}}}),oYe=["aria-selected"];function aYe(t,e,n,s,r,o){return S(),E("li",{"aria-selected":t.selected,style:ot(t.style),class:P([t.ns.be("dropdown","option-item"),t.ns.is("selected",t.selected),t.ns.is("disabled",t.disabled),t.ns.is("created",t.created),{hover:t.hovering}]),onMouseenter:e[0]||(e[0]=(...a)=>t.hoverItem&&t.hoverItem(...a)),onClick:e[1]||(e[1]=yt((...a)=>t.selectOptionClick&&t.selectOptionClick(...a),["stop"]))},[Oe(t.$slots,"default",{item:t.item,index:t.index,disabled:t.disabled},()=>[I("span",null,Ue(t.item.label),1)])],46,oYe)}var iYe=je(rYe,[["render",aYe],["__file","/home/runner/work/element-plus/element-plus/packages/components/select-v2/src/option-item.vue"]]);const T7="ElSelectV2Injection";var lYe=ue({name:"ElSelectDropdown",props:{data:{type:Array,required:!0},hoveringIndex:Number,width:Number},setup(t,{slots:e,expose:n}){const s=et(T7),r=Fe("select"),o=U([]),a=U(),i=A(()=>t.data.length);Me(()=>i.value,()=>{var C,T;(T=(C=s.popper.value).updatePopper)==null||T.call(C)});const l=A(()=>er(s.props.estimatedOptionHeight)),u=A(()=>l.value?{itemSize:s.props.itemHeight}:{estimatedSize:s.props.estimatedOptionHeight,itemSize:C=>o.value[C]}),c=(C=[],T)=>{const{props:{valueKey:N}}=s;return Bt(T)?C&&C.some(M=>Pn(M,N)===Pn(T,N)):C.includes(T)},d=(C,T)=>{if(Bt(T)){const{valueKey:N}=s.props;return Pn(C,N)===Pn(T,N)}else return C===T},f=(C,T)=>{const{valueKey:N}=s.props;return s.props.multiple?c(C,Pn(T,N)):d(C,Pn(T,N))},h=(C,T)=>{const{disabled:N,multiple:M,multipleLimit:R}=s.props;return N||!T&&(M?R>0&&C.length>=R:!1)},p=C=>t.hoveringIndex===C;n({listRef:a,isSized:l,isItemDisabled:h,isItemHovering:p,isItemSelected:f,scrollToItem:C=>{const T=a.value;T&&T.scrollToItem(C)},resetScrollTop:()=>{const C=a.value;C&&C.resetScrollTop()}});const y=C=>{const{index:T,data:N,style:M}=C,R=v(l),{itemSize:D,estimatedSize:z}=v(u),{modelValue:B}=s.props,{onSelect:V,onHover:O}=s,F=N[T];if(F.type==="Group")return se(eYe,{item:F,style:M,height:R?D:z},null);const L=f(B,F),G=h(B,L),Z=p(T);return se(iYe,zt(C,{selected:L,disabled:F.disabled||G,created:!!F.created,hovering:Z,item:F,onSelect:V,onHover:O}),{default:j=>{var J;return((J=e.default)==null?void 0:J.call(e,j))||se("span",null,[F.label])}})},{onKeyboardNavigate:w,onKeyboardSelect:b}=s,_=()=>{w("forward")},$=()=>{w("backward")},x=()=>{s.expanded=!1},k=C=>{const{code:T}=C,{tab:N,esc:M,down:R,up:D,enter:z}=ut;switch(T!==N&&(C.preventDefault(),C.stopPropagation()),T){case N:case M:{x();break}case R:{_();break}case D:{$();break}case z:{b();break}}};return()=>{var C;const{data:T,width:N}=t,{height:M,multiple:R,scrollbarAlwaysOn:D}=s.props;if(T.length===0)return se("div",{class:r.b("dropdown"),style:{width:`${N}px`}},[(C=e.empty)==null?void 0:C.call(e)]);const z=v(l)?b7:GXe;return se("div",{class:[r.b("dropdown"),r.is("multiple",R)]},[se(z,zt({ref:a},v(u),{className:r.be("dropdown","list"),scrollbarAlwaysOn:D,data:T,height:M,width:N,total:T.length,onKeydown:k}),{default:B=>se(y,B,null)})])}}});function uYe(t,e){const n=U(0),s=U(null),r=A(()=>t.allowCreate&&t.filterable);function o(c){const d=f=>f.value===c;return t.options&&t.options.some(d)||e.createdOptions.some(d)}function a(c){!r.value||(t.multiple&&c.created?n.value++:s.value=c)}function i(c){if(r.value)if(c&&c.length>0&&!o(c)){const d={value:c,label:c,created:!0,disabled:!1};e.createdOptions.length>=n.value?e.createdOptions[n.value]=d:e.createdOptions.push(d)}else if(t.multiple)e.createdOptions.length=n.value;else{const d=s.value;e.createdOptions.length=0,d&&d.created&&e.createdOptions.push(d)}}function l(c){if(!r.value||!c||!c.created||c.created&&t.reserveKeyword&&e.inputValue===c.label)return;const d=e.createdOptions.findIndex(f=>f.value===c.value);~d&&(e.createdOptions.splice(d,1),n.value--)}function u(){r.value&&(e.createdOptions.length=0,n.value=0)}return{createNewOption:i,removeNewOption:l,selectNewOption:a,clearAllNewOption:u}}const cYe=t=>{const e=[];return t.forEach(n=>{Qe(n.options)?(e.push({label:n.label,isTitle:!0,type:"Group"}),n.options.forEach(s=>{e.push(s)}),e.push({type:"Group"})):e.push(n)}),e};function dYe(t){const e=U(!1);return{handleCompositionStart:()=>{e.value=!0},handleCompositionUpdate:o=>{const a=o.target.value,i=a[a.length-1]||"";e.value=!fw(i)},handleCompositionEnd:o=>{e.value&&(e.value=!1,vt(t)&&t(o))}}}const uR="",cR=11,fYe={larget:51,default:42,small:33},hYe=(t,e)=>{const{t:n}=nn(),s=Fe("select-v2"),r=Fe("input"),{form:o,formItem:a}=to(),i=on({inputValue:uR,displayInputValue:uR,calculatedWidth:0,cachedPlaceholder:"",cachedOptions:[],createdOptions:[],createdLabel:"",createdSelected:!1,currentPlaceholder:"",hoveringIndex:-1,comboBoxHovering:!1,isOnComposition:!1,isSilentBlur:!1,isComposing:!1,inputLength:20,selectWidth:200,initialInputHeight:0,previousQuery:null,previousValue:void 0,query:"",selectedLabel:"",softFocus:!1,tagInMultiLine:!1}),l=U(-1),u=U(-1),c=U(null),d=U(null),f=U(null),h=U(null),p=U(null),m=U(null),g=U(null),y=U(!1),w=A(()=>t.disabled||(o==null?void 0:o.disabled)),b=A(()=>{const He=R.value.length*34;return He>t.height?t.height:He}),_=A(()=>!nr(t.modelValue)),$=A(()=>{const He=t.multiple?Array.isArray(t.modelValue)&&t.modelValue.length>0:_.value;return t.clearable&&!w.value&&i.comboBoxHovering&&He}),x=A(()=>t.remote&&t.filterable?"":Og),k=A(()=>x.value&&s.is("reverse",y.value)),C=A(()=>(a==null?void 0:a.validateState)||""),T=A(()=>RP[C.value]),N=A(()=>t.remote?300:0),M=A(()=>{const He=R.value;return t.loading?t.loadingText||n("el.select.loading"):t.remote&&i.inputValue===""&&He.length===0?!1:t.filterable&&i.inputValue&&He.length>0?t.noMatchText||n("el.select.noMatch"):He.length===0?t.noDataText||n("el.select.noData"):null}),R=A(()=>{const He=ft=>{const Ht=i.inputValue,pn=new RegExp(aP(Ht),"i");return Ht?pn.test(ft.label||""):!0};return t.loading?[]:cYe(t.options.concat(i.createdOptions).map(ft=>{if(Qe(ft.options)){const Ht=ft.options.filter(He);if(Ht.length>0)return{...ft,options:Ht}}else if(t.remote||He(ft))return ft;return null}).filter(ft=>ft!==null))}),D=A(()=>R.value.every(He=>He.disabled)),z=ks(),B=A(()=>z.value==="small"?"small":"default"),V=A(()=>{const He=m.value,ft=B.value||"default",Ht=He?Number.parseInt(getComputedStyle(He).paddingLeft):0,pn=He?Number.parseInt(getComputedStyle(He).paddingRight):0;return i.selectWidth-pn-Ht-fYe[ft]}),O=()=>{var He;u.value=((He=p.value)==null?void 0:He.offsetWidth)||200},F=A(()=>({width:`${i.calculatedWidth===0?cR:Math.ceil(i.calculatedWidth)+cR}px`})),L=A(()=>Qe(t.modelValue)?t.modelValue.length===0&&!i.displayInputValue:t.filterable?i.displayInputValue.length===0:!0),G=A(()=>{const He=t.placeholder||n("el.select.placeholder");return t.multiple||nr(t.modelValue)?He:i.selectedLabel}),Z=A(()=>{var He,ft;return(ft=(He=h.value)==null?void 0:He.popperRef)==null?void 0:ft.contentRef}),j=A(()=>{if(t.multiple){const He=t.modelValue.length;if(t.modelValue.length>0)return R.value.findIndex(ft=>ft.value===t.modelValue[He-1])}else if(t.modelValue)return R.value.findIndex(He=>He.value===t.modelValue);return-1}),J=A({get(){return y.value&&M.value!==!1},set(He){y.value=He}}),{createNewOption:fe,removeNewOption:X,selectNewOption:oe,clearAllNewOption:ee}=uYe(t,i),{handleCompositionStart:Q,handleCompositionUpdate:ie,handleCompositionEnd:pe}=dYe(He=>_n(He)),Re=()=>{var He,ft,Ht;(ft=(He=d.value).focus)==null||ft.call(He),(Ht=h.value)==null||Ht.updatePopper()},K=()=>{if(!t.automaticDropdown&&!w.value)return i.isComposing&&(i.softFocus=!0),nt(()=>{var He,ft;y.value=!y.value,(ft=(He=d.value)==null?void 0:He.focus)==null||ft.call(He)})},re=()=>(t.filterable&&i.inputValue!==i.selectedLabel&&(i.query=i.selectedLabel),Ee(i.inputValue),nt(()=>{fe(i.inputValue)})),we=Xr(re,N.value),Ee=He=>{i.previousQuery!==He&&(i.previousQuery=He,t.filterable&&vt(t.filterMethod)?t.filterMethod(He):t.filterable&&t.remote&&vt(t.remoteMethod)&&t.remoteMethod(He))},De=He=>{Wo(t.modelValue,He)||e(Fn,He)},_e=He=>{e(Ot,He),De(He),i.previousValue=He==null?void 0:He.toString()},ze=(He=[],ft)=>{if(!Bt(ft))return He.indexOf(ft);const Ht=t.valueKey;let pn=-1;return He.some((di,fi)=>Pn(di,Ht)===Pn(ft,Ht)?(pn=fi,!0):!1),pn},Ae=He=>Bt(He)?Pn(He,t.valueKey):He,he=He=>Bt(He)?He.label:He,ve=()=>{if(!(t.collapseTags&&!t.filterable))return nt(()=>{var He,ft;if(!d.value)return;const Ht=m.value;p.value.height=Ht.offsetHeight,y.value&&M.value!==!1&&((ft=(He=h.value)==null?void 0:He.updatePopper)==null||ft.call(He))})},me=()=>{var He,ft;if(Ve(),O(),(ft=(He=h.value)==null?void 0:He.updatePopper)==null||ft.call(He),t.multiple)return ve()},Ve=()=>{const He=m.value;He&&(i.selectWidth=He.getBoundingClientRect().width)},Ye=(He,ft,Ht=!0)=>{var pn,di;if(t.multiple){let fi=t.modelValue.slice();const G2=ze(fi,Ae(He));G2>-1?(fi=[...fi.slice(0,G2),...fi.slice(G2+1)],i.cachedOptions.splice(G2,1),X(He)):(t.multipleLimit<=0||fi.length<t.multipleLimit)&&(fi=[...fi,Ae(He)],i.cachedOptions.push(He),oe(He),Pe(ft)),_e(fi),He.created&&(i.query="",Ee(""),i.inputLength=20),t.filterable&&!t.reserveKeyword&&((di=(pn=d.value).focus)==null||di.call(pn),at("")),t.filterable&&(i.calculatedWidth=g.value.getBoundingClientRect().width),ve(),Ft()}else l.value=ft,i.selectedLabel=He.label,_e(Ae(He)),y.value=!1,i.isComposing=!1,i.isSilentBlur=Ht,oe(He),He.created||ee(),Pe(ft)},Je=(He,ft)=>{const{valueKey:Ht}=t,pn=t.modelValue.indexOf(Pn(ft,Ht));if(pn>-1&&!w.value){const di=[...t.modelValue.slice(0,pn),...t.modelValue.slice(pn+1)];return i.cachedOptions.splice(pn,1),_e(di),e("remove-tag",Pn(ft,Ht)),i.softFocus=!0,X(ft),nt(Re)}He.stopPropagation()},ct=He=>{const ft=i.isComposing;i.isComposing=!0,i.softFocus?i.softFocus=!1:ft||e("focus",He)},xt=He=>(i.softFocus=!1,nt(()=>{var ft,Ht;(Ht=(ft=d.value)==null?void 0:ft.blur)==null||Ht.call(ft),g.value&&(i.calculatedWidth=g.value.getBoundingClientRect().width),i.isSilentBlur?i.isSilentBlur=!1:i.isComposing&&e("blur",He),i.isComposing=!1})),dt=()=>{i.displayInputValue.length>0?at(""):y.value=!1},xe=He=>{if(i.displayInputValue.length===0){He.preventDefault();const ft=t.modelValue.slice();ft.pop(),X(i.cachedOptions.pop()),_e(ft)}},Ke=()=>{let He;return Qe(t.modelValue)?He=[]:He=void 0,i.softFocus=!0,t.multiple?i.cachedOptions=[]:i.selectedLabel="",y.value=!1,_e(He),e("clear"),ee(),nt(Re)},at=He=>{i.displayInputValue=He,i.inputValue=He},Y=(He,ft=void 0)=>{const Ht=R.value;if(!["forward","backward"].includes(He)||w.value||Ht.length<=0||D.value)return;if(!y.value)return K();ft===void 0&&(ft=i.hoveringIndex);let pn=-1;He==="forward"?(pn=ft+1,pn>=Ht.length&&(pn=0)):He==="backward"&&(pn=ft-1,(pn<0||pn>=Ht.length)&&(pn=Ht.length-1));const di=Ht[pn];if(di.disabled||di.type==="Group")return Y(He,pn);Pe(pn),Sn(pn)},de=()=>{if(y.value)~i.hoveringIndex&&R.value[i.hoveringIndex]&&Ye(R.value[i.hoveringIndex],i.hoveringIndex,!1);else return K()},Pe=He=>{i.hoveringIndex=He},We=()=>{i.hoveringIndex=-1},Ft=()=>{var He;const ft=d.value;ft&&((He=ft.focus)==null||He.call(ft))},_n=He=>{const ft=He.target.value;if(at(ft),i.displayInputValue.length>0&&!y.value&&(y.value=!0),i.calculatedWidth=g.value.getBoundingClientRect().width,t.multiple&&ve(),t.remote)we();else return re()},_s=()=>(y.value=!1,xt()),qs=()=>(i.inputValue=i.displayInputValue,nt(()=>{~j.value&&(Pe(j.value),Sn(i.hoveringIndex))})),Sn=He=>{f.value.scrollToItem(He)},sn=()=>{if(We(),t.multiple)if(t.modelValue.length>0){let He=!1;i.cachedOptions.length=0,i.previousValue=t.modelValue.toString(),t.modelValue.forEach(ft=>{const Ht=R.value.findIndex(pn=>Ae(pn)===ft);~Ht&&(i.cachedOptions.push(R.value[Ht]),He||Pe(Ht),He=!0)})}else i.cachedOptions=[],i.previousValue=void 0;else if(_.value){i.previousValue=t.modelValue;const He=R.value,ft=He.findIndex(Ht=>Ae(Ht)===Ae(t.modelValue));~ft?(i.selectedLabel=He[ft].label,Pe(ft)):i.selectedLabel=`${t.modelValue}`}else i.selectedLabel="",i.previousValue=void 0;ee(),O()};return Me(y,He=>{var ft,Ht;e("visible-change",He),He?(Ht=(ft=h.value).update)==null||Ht.call(ft):(i.displayInputValue="",i.previousQuery=null,fe(""))}),Me(()=>t.modelValue,(He,ft)=>{var Ht;(!He||He.toString()!==i.previousValue)&&sn(),!Wo(He,ft)&&t.validateEvent&&((Ht=a==null?void 0:a.validate)==null||Ht.call(a,"change").catch(pn=>void 0))},{deep:!0}),Me(()=>t.options,()=>{const He=d.value;(!He||He&&document.activeElement!==He)&&sn()},{deep:!0}),Me(R,()=>nt(f.value.resetScrollTop)),It(()=>{sn()}),Dr(p,me),{collapseTagSize:B,currentPlaceholder:G,expanded:y,emptyText:M,popupHeight:b,debounce:N,filteredOptions:R,iconComponent:x,iconReverse:k,inputWrapperStyle:F,popperSize:u,dropdownMenuVisible:J,hasModelValue:_,shouldShowPlaceholder:L,selectDisabled:w,selectSize:z,showClearBtn:$,states:i,tagMaxWidth:V,nsSelectV2:s,nsInput:r,calculatorRef:g,controlRef:c,inputRef:d,menuRef:f,popper:h,selectRef:p,selectionRef:m,popperRef:Z,validateState:C,validateIcon:T,debouncedOnInputChange:we,deleteTag:Je,getLabel:he,getValueKey:Ae,handleBlur:xt,handleClear:Ke,handleClickOutside:_s,handleDel:xe,handleEsc:dt,handleFocus:ct,handleMenuEnter:qs,handleResize:me,toggleMenu:K,scrollTo:Sn,onInput:_n,onKeyboardNavigate:Y,onKeyboardSelect:de,onSelect:Ye,onHover:Pe,onUpdateInputValue:at,handleCompositionStart:Q,handleCompositionEnd:pe,handleCompositionUpdate:ie}},pYe=ue({name:"ElSelectV2",components:{ElSelectMenu:lYe,ElTag:Sw,ElTooltip:No,ElIcon:rt},directives:{ClickOutside:Ku,ModelText:lC},props:nYe,emits:[Ot,Fn,"remove-tag","clear","visible-change","focus","blur"],setup(t,{emit:e}){const n=A(()=>{const{modelValue:r,multiple:o}=t,a=o?[]:void 0;return Qe(r)?o?r:a:o?a:r}),s=hYe(on({...Ps(t),modelValue:n}),e);return Lt(T7,{props:on({...Ps(t),height:s.popupHeight,modelValue:n}),popper:s.popper,onSelect:s.onSelect,onHover:s.onHover,onKeyboardNavigate:s.onKeyboardNavigate,onKeyboardSelect:s.onKeyboardSelect}),{...s,modelValue:n}}}),mYe={key:0},gYe=["id","autocomplete","aria-expanded","aria-labelledby","disabled","readonly","name","unselectable"],vYe=["textContent"],yYe=["id","aria-labelledby","aria-expanded","autocomplete","disabled","name","readonly","unselectable"],bYe=["textContent"];function wYe(t,e,n,s,r,o){const a=pt("el-tag"),i=pt("el-tooltip"),l=pt("el-icon"),u=pt("el-select-menu"),c=rh("model-text"),d=rh("click-outside");return St((S(),E("div",{ref:"selectRef",class:P([t.nsSelectV2.b(),t.nsSelectV2.m(t.selectSize)]),onClick:e[25]||(e[25]=yt((...f)=>t.toggleMenu&&t.toggleMenu(...f),["stop"])),onMouseenter:e[26]||(e[26]=f=>t.states.comboBoxHovering=!0),onMouseleave:e[27]||(e[27]=f=>t.states.comboBoxHovering=!1)},[se(i,{ref:"popper",visible:t.dropdownMenuVisible,teleported:t.teleported,"popper-class":[t.nsSelectV2.e("popper"),t.popperClass],"gpu-acceleration":!1,"stop-popper-mouse-event":!1,"popper-options":t.popperOptions,"fallback-placements":["bottom-start","top-start","right","left"],effect:t.effect,placement:t.placement,pure:"",transition:`${t.nsSelectV2.namespace.value}-zoom-in-top`,trigger:"click",persistent:t.persistent,onBeforeShow:t.handleMenuEnter,onHide:e[24]||(e[24]=f=>t.states.inputValue=t.states.displayInputValue)},{default:ce(()=>{var f;return[I("div",{ref:"selectionRef",class:P([t.nsSelectV2.e("wrapper"),t.nsSelectV2.is("focused",t.states.isComposing||t.expanded),t.nsSelectV2.is("hovering",t.states.comboBoxHovering),t.nsSelectV2.is("filterable",t.filterable),t.nsSelectV2.is("disabled",t.selectDisabled)])},[t.$slots.prefix?(S(),E("div",mYe,[Oe(t.$slots,"prefix")])):ge("v-if",!0),t.multiple?(S(),E("div",{key:1,class:P(t.nsSelectV2.e("selection"))},[t.collapseTags&&t.modelValue.length>0?(S(),E("div",{key:0,class:P(t.nsSelectV2.e("selected-item"))},[se(a,{closable:!t.selectDisabled&&!((f=t.states.cachedOptions[0])!=null&&f.disable),size:t.collapseTagSize,type:"info","disable-transitions":"",onClose:e[0]||(e[0]=h=>t.deleteTag(h,t.states.cachedOptions[0]))},{default:ce(()=>{var h;return[I("span",{class:P(t.nsSelectV2.e("tags-text")),style:ot({maxWidth:`${t.tagMaxWidth}px`})},Ue((h=t.states.cachedOptions[0])==null?void 0:h.label),7)]}),_:1},8,["closable","size"]),t.modelValue.length>1?(S(),$e(a,{key:0,closable:!1,size:t.collapseTagSize,type:"info","disable-transitions":""},{default:ce(()=>[t.collapseTagsTooltip?(S(),$e(i,{key:0,disabled:t.dropdownMenuVisible,"fallback-placements":["bottom","top","right","left"],effect:t.effect,placement:"bottom",teleported:!1},{default:ce(()=>[I("span",{class:P(t.nsSelectV2.e("tags-text")),style:ot({maxWidth:`${t.tagMaxWidth}px`})},"+ "+Ue(t.modelValue.length-1),7)]),content:ce(()=>[I("div",{class:P(t.nsSelectV2.e("selection"))},[(S(!0),E(lt,null,Gt(t.states.cachedOptions.slice(1),(h,p)=>(S(),E("div",{key:p,class:P(t.nsSelectV2.e("selected-item"))},[(S(),$e(a,{key:t.getValueKey(h),closable:!t.selectDisabled&&!h.disabled,size:t.collapseTagSize,class:"in-tooltip",type:"info","disable-transitions":"",onClose:m=>t.deleteTag(m,h)},{default:ce(()=>[I("span",{class:P(t.nsSelectV2.e("tags-text")),style:ot({maxWidth:`${t.tagMaxWidth}px`})},Ue(t.getLabel(h)),7)]),_:2},1032,["closable","size","onClose"]))],2))),128))],2)]),_:1},8,["disabled","effect"])):(S(),E("span",{key:1,class:P(t.nsSelectV2.e("tags-text")),style:ot({maxWidth:`${t.tagMaxWidth}px`})},"+ "+Ue(t.modelValue.length-1),7))]),_:1},8,["size"])):ge("v-if",!0)],2)):(S(!0),E(lt,{key:1},Gt(t.states.cachedOptions,(h,p)=>(S(),E("div",{key:p,class:P(t.nsSelectV2.e("selected-item"))},[(S(),$e(a,{key:t.getValueKey(h),closable:!t.selectDisabled&&!h.disabled,size:t.collapseTagSize,type:"info","disable-transitions":"",onClose:m=>t.deleteTag(m,h)},{default:ce(()=>[I("span",{class:P(t.nsSelectV2.e("tags-text")),style:ot({maxWidth:`${t.tagMaxWidth}px`})},Ue(t.getLabel(h)),7)]),_:2},1032,["closable","size","onClose"]))],2))),128)),I("div",{class:P([t.nsSelectV2.e("selected-item"),t.nsSelectV2.e("input-wrapper")]),style:ot(t.inputWrapperStyle)},[St(I("input",{id:t.id,ref:"inputRef",autocomplete:t.autocomplete,"aria-autocomplete":"list","aria-haspopup":"listbox",autocapitalize:"off","aria-expanded":t.expanded,"aria-labelledby":t.label,class:P([t.nsSelectV2.is(t.selectSize),t.nsSelectV2.e("combobox-input")]),disabled:t.disabled,role:"combobox",readonly:!t.filterable,spellcheck:"false",type:"text",name:t.name,unselectable:t.expanded?"on":void 0,"onUpdate:modelValue":e[1]||(e[1]=(...h)=>t.onUpdateInputValue&&t.onUpdateInputValue(...h)),onFocus:e[2]||(e[2]=(...h)=>t.handleFocus&&t.handleFocus(...h)),onBlur:e[3]||(e[3]=(...h)=>t.handleBlur&&t.handleBlur(...h)),onInput:e[4]||(e[4]=(...h)=>t.onInput&&t.onInput(...h)),onCompositionstart:e[5]||(e[5]=(...h)=>t.handleCompositionStart&&t.handleCompositionStart(...h)),onCompositionupdate:e[6]||(e[6]=(...h)=>t.handleCompositionUpdate&&t.handleCompositionUpdate(...h)),onCompositionend:e[7]||(e[7]=(...h)=>t.handleCompositionEnd&&t.handleCompositionEnd(...h)),onKeydown:[e[8]||(e[8]=qt(yt(h=>t.onKeyboardNavigate("backward"),["stop","prevent"]),["up"])),e[9]||(e[9]=qt(yt(h=>t.onKeyboardNavigate("forward"),["stop","prevent"]),["down"])),e[10]||(e[10]=qt(yt((...h)=>t.onKeyboardSelect&&t.onKeyboardSelect(...h),["stop","prevent"]),["enter"])),e[11]||(e[11]=qt(yt((...h)=>t.handleEsc&&t.handleEsc(...h),["stop","prevent"]),["esc"])),e[12]||(e[12]=qt(yt((...h)=>t.handleDel&&t.handleDel(...h),["stop"]),["delete"]))]},null,42,gYe),[[c,t.states.displayInputValue]]),t.filterable?(S(),E("span",{key:0,ref:"calculatorRef","aria-hidden":"true",class:P(t.nsSelectV2.e("input-calculator")),textContent:Ue(t.states.displayInputValue)},null,10,vYe)):ge("v-if",!0)],6)],2)):(S(),E(lt,{key:2},[I("div",{class:P([t.nsSelectV2.e("selected-item"),t.nsSelectV2.e("input-wrapper")])},[St(I("input",{id:t.id,ref:"inputRef","aria-autocomplete":"list","aria-haspopup":"listbox","aria-labelledby":t.label,"aria-expanded":t.expanded,autocapitalize:"off",autocomplete:t.autocomplete,class:P(t.nsSelectV2.e("combobox-input")),disabled:t.disabled,name:t.name,role:"combobox",readonly:!t.filterable,spellcheck:"false",type:"text",unselectable:t.expanded?"on":void 0,onCompositionstart:e[13]||(e[13]=(...h)=>t.handleCompositionStart&&t.handleCompositionStart(...h)),onCompositionupdate:e[14]||(e[14]=(...h)=>t.handleCompositionUpdate&&t.handleCompositionUpdate(...h)),onCompositionend:e[15]||(e[15]=(...h)=>t.handleCompositionEnd&&t.handleCompositionEnd(...h)),onFocus:e[16]||(e[16]=(...h)=>t.handleFocus&&t.handleFocus(...h)),onBlur:e[17]||(e[17]=(...h)=>t.handleBlur&&t.handleBlur(...h)),onInput:e[18]||(e[18]=(...h)=>t.onInput&&t.onInput(...h)),onKeydown:[e[19]||(e[19]=qt(yt(h=>t.onKeyboardNavigate("backward"),["stop","prevent"]),["up"])),e[20]||(e[20]=qt(yt(h=>t.onKeyboardNavigate("forward"),["stop","prevent"]),["down"])),e[21]||(e[21]=qt(yt((...h)=>t.onKeyboardSelect&&t.onKeyboardSelect(...h),["stop","prevent"]),["enter"])),e[22]||(e[22]=qt(yt((...h)=>t.handleEsc&&t.handleEsc(...h),["stop","prevent"]),["esc"]))],"onUpdate:modelValue":e[23]||(e[23]=(...h)=>t.onUpdateInputValue&&t.onUpdateInputValue(...h))},null,42,yYe),[[c,t.states.displayInputValue]])],2),t.filterable?(S(),E("span",{key:0,ref:"calculatorRef","aria-hidden":"true",class:P([t.nsSelectV2.e("selected-item"),t.nsSelectV2.e("input-calculator")]),textContent:Ue(t.states.displayInputValue)},null,10,bYe)):ge("v-if",!0)],64)),t.shouldShowPlaceholder?(S(),E("span",{key:3,class:P([t.nsSelectV2.e("placeholder"),t.nsSelectV2.is("transparent",t.multiple?t.modelValue.length===0:!t.hasModelValue)])},Ue(t.currentPlaceholder),3)):ge("v-if",!0),I("span",{class:P(t.nsSelectV2.e("suffix"))},[t.iconComponent?St((S(),$e(l,{key:0,class:P([t.nsSelectV2.e("caret"),t.nsInput.e("icon"),t.iconReverse])},{default:ce(()=>[(S(),$e(Vt(t.iconComponent)))]),_:1},8,["class"])),[[Qt,!t.showClearBtn]]):ge("v-if",!0),t.showClearBtn&&t.clearIcon?(S(),$e(l,{key:1,class:P([t.nsSelectV2.e("caret"),t.nsInput.e("icon")]),onClick:yt(t.handleClear,["prevent","stop"])},{default:ce(()=>[(S(),$e(Vt(t.clearIcon)))]),_:1},8,["class","onClick"])):ge("v-if",!0),t.validateState&&t.validateIcon?(S(),$e(l,{key:2,class:P([t.nsInput.e("icon"),t.nsInput.e("validateIcon")])},{default:ce(()=>[(S(),$e(Vt(t.validateIcon)))]),_:1},8,["class"])):ge("v-if",!0)],2)],2)]}),content:ce(()=>[se(u,{ref:"menuRef",data:t.filteredOptions,width:t.popperSize,"hovering-index":t.states.hoveringIndex,"scrollbar-always-on":t.scrollbarAlwaysOn},{default:ce(f=>[Oe(t.$slots,"default",Wa(Zb(f)))]),empty:ce(()=>[Oe(t.$slots,"empty",{},()=>[I("p",{class:P(t.nsSelectV2.e("empty"))},Ue(t.emptyText?t.emptyText:""),3)])]),_:3},8,["data","width","hovering-index","scrollbar-always-on"])]),_:3},8,["visible","teleported","popper-class","popper-options","effect","placement","transition","persistent","onBeforeShow"])],34)),[[d,t.handleClickOutside,t.popperRef]])}var ny=je(pYe,[["render",wYe],["__file","/home/runner/work/element-plus/element-plus/packages/components/select-v2/src/select.vue"]]);ny.install=t=>{t.component(ny.name,ny)};const _Ye=ny,$Ye=_Ye,xYe=qe({animated:{type:Boolean,default:!1},count:{type:Number,default:1},rows:{type:Number,default:3},loading:{type:Boolean,default:!0},throttle:{type:Number}}),SYe=qe({variant:{type:String,values:["circle","rect","h1","h3","text","caption","p","image","button"],default:"text"}}),CYe=ue({name:"ElSkeletonItem"}),kYe=ue({...CYe,props:SYe,setup(t){const e=Fe("skeleton");return(n,s)=>(S(),E("div",{class:P([v(e).e("item"),v(e).e(n.variant)])},[n.variant==="image"?(S(),$e(v(wP),{key:0})):ge("v-if",!0)],2))}});var Vy=je(kYe,[["__file","/home/runner/work/element-plus/element-plus/packages/components/skeleton/src/skeleton-item.vue"]]);const TYe=ue({name:"ElSkeleton"}),NYe=ue({...TYe,props:xYe,setup(t,{expose:e}){const n=t,s=Fe("skeleton"),r=oFe(Un(n,"loading"),n.throttle);return e({uiLoading:r}),(o,a)=>v(r)?(S(),E("div",zt({key:0,class:[v(s).b(),v(s).is("animated",o.animated)]},o.$attrs),[(S(!0),E(lt,null,Gt(o.count,i=>(S(),E(lt,{key:i},[o.loading?Oe(o.$slots,"template",{key:i},()=>[se(Vy,{class:P(v(s).is("first")),variant:"p"},null,8,["class"]),(S(!0),E(lt,null,Gt(o.rows,l=>(S(),$e(Vy,{key:l,class:P([v(s).e("paragraph"),v(s).is("last",l===o.rows&&o.rows>1)]),variant:"p"},null,8,["class"]))),128))]):ge("v-if",!0)],64))),128))],16)):Oe(o.$slots,"default",Wa(zt({key:1},o.$attrs)))}});var IYe=je(NYe,[["__file","/home/runner/work/element-plus/element-plus/packages/components/skeleton/src/skeleton.vue"]]);const EYe=Dt(IYe,{SkeletonItem:Vy}),AYe=ns(Vy),OYe=qe({modelValue:{type:Se([Number,Array]),default:0},id:{type:String,default:void 0},min:{type:Number,default:0},max:{type:Number,default:100},step:{type:Number,default:1},showInput:Boolean,showInputControls:{type:Boolean,default:!0},size:wo,inputSize:wo,showStops:Boolean,showTooltip:{type:Boolean,default:!0},formatTooltip:{type:Se(Function),default:void 0},disabled:Boolean,range:Boolean,vertical:Boolean,height:String,debounce:{type:Number,default:300},label:{type:String,default:void 0},rangeStartLabel:{type:String,default:void 0},rangeEndLabel:{type:String,default:void 0},formatValueText:{type:Se(Function),default:void 0},tooltipClass:{type:String,default:void 0},placement:{type:String,values:Qd,default:"top"},marks:{type:Se(Object)},validateEvent:{type:Boolean,default:!0}}),a$=t=>Ct(t)||Qe(t)&&t.every(Ct),RYe={[Ot]:a$,[jr]:a$,[Fn]:a$},DYe=(t,e,n)=>{const s=U();return It(async()=>{t.range?(Array.isArray(t.modelValue)?(e.firstValue=Math.max(t.min,t.modelValue[0]),e.secondValue=Math.min(t.max,t.modelValue[1])):(e.firstValue=t.min,e.secondValue=t.max),e.oldValue=[e.firstValue,e.secondValue]):(typeof t.modelValue!="number"||Number.isNaN(t.modelValue)?e.firstValue=t.min:e.firstValue=Math.min(t.max,Math.max(t.min,t.modelValue)),e.oldValue=e.firstValue),Rn(window,"resize",n),await nt(),n()}),{sliderWrapper:s}},FYe=t=>A(()=>t.marks?Object.keys(t.marks).map(Number.parseFloat).sort((n,s)=>n-s).filter(n=>n<=t.max&&n>=t.min).map(n=>({point:n,position:(n-t.min)*100/(t.max-t.min),mark:t.marks[n]})):[]),MYe=(t,e,n)=>{const{form:s,formItem:r}=to(),o=Nn(),a=U(),i=U(),l={firstButton:a,secondButton:i},u=A(()=>t.disabled||(s==null?void 0:s.disabled)||!1),c=A(()=>Math.min(e.firstValue,e.secondValue)),d=A(()=>Math.max(e.firstValue,e.secondValue)),f=A(()=>t.range?`${100*(d.value-c.value)/(t.max-t.min)}%`:`${100*(e.firstValue-t.min)/(t.max-t.min)}%`),h=A(()=>t.range?`${100*(c.value-t.min)/(t.max-t.min)}%`:"0%"),p=A(()=>t.vertical?{height:t.height}:{}),m=A(()=>t.vertical?{height:f.value,bottom:h.value}:{width:f.value,left:h.value}),g=()=>{o.value&&(e.sliderSize=o.value[`client${t.vertical?"Height":"Width"}`])},y=M=>{const R=t.min+M*(t.max-t.min)/100;if(!t.range)return a;let D;return Math.abs(c.value-R)<Math.abs(d.value-R)?D=e.firstValue<e.secondValue?"firstButton":"secondButton":D=e.firstValue>e.secondValue?"firstButton":"secondButton",l[D]},w=M=>{const R=y(M);return R.value.setPosition(M),R},b=M=>{e.firstValue=M,$(t.range?[c.value,d.value]:M)},_=M=>{e.secondValue=M,t.range&&$([c.value,d.value])},$=M=>{n(Ot,M),n(jr,M)},x=async()=>{await nt(),n(Fn,t.range?[c.value,d.value]:t.modelValue)},k=M=>{var R,D,z,B,V,O;if(u.value||e.dragging)return;g();let F=0;if(t.vertical){const L=(z=(D=(R=M.touches)==null?void 0:R.item(0))==null?void 0:D.clientY)!=null?z:M.clientY;F=(o.value.getBoundingClientRect().bottom-L)/e.sliderSize*100}else{const L=(O=(V=(B=M.touches)==null?void 0:B.item(0))==null?void 0:V.clientX)!=null?O:M.clientX,G=o.value.getBoundingClientRect().left;F=(L-G)/e.sliderSize*100}if(!(F<0||F>100))return w(F)};return{elFormItem:r,slider:o,firstButton:a,secondButton:i,sliderDisabled:u,minValue:c,maxValue:d,runwayStyle:p,barStyle:m,resetSize:g,setPosition:w,emitChange:x,onSliderWrapperPrevent:M=>{var R,D;(((R=l.firstButton.value)==null?void 0:R.dragging)||((D=l.secondButton.value)==null?void 0:D.dragging))&&M.preventDefault()},onSliderClick:M=>{k(M)&&x()},onSliderDown:async M=>{const R=k(M);R&&(await nt(),R.value.onButtonDown(M))},setFirstValue:b,setSecondValue:_}},{left:PYe,down:LYe,right:zYe,up:BYe,home:VYe,end:HYe,pageUp:WYe,pageDown:UYe}=ut,GYe=(t,e,n)=>{const s=U(),r=U(!1),o=A(()=>e.value instanceof Function),a=A(()=>o.value&&e.value(t.modelValue)||t.modelValue),i=Xr(()=>{n.value&&(r.value=!0)},50),l=Xr(()=>{n.value&&(r.value=!1)},50);return{tooltip:s,tooltipVisible:r,formatValue:a,displayTooltip:i,hideTooltip:l}},jYe=(t,e,n)=>{const{disabled:s,min:r,max:o,step:a,showTooltip:i,precision:l,sliderSize:u,formatTooltip:c,emitChange:d,resetSize:f,updateDragging:h}=et(GP),{tooltip:p,tooltipVisible:m,formatValue:g,displayTooltip:y,hideTooltip:w}=GYe(t,c,i),b=U(),_=A(()=>`${(t.modelValue-r.value)/(o.value-r.value)*100}%`),$=A(()=>t.vertical?{bottom:_.value}:{left:_.value}),x=()=>{e.hovering=!0,y()},k=()=>{e.hovering=!1,e.dragging||w()},C=j=>{s.value||(j.preventDefault(),F(j),window.addEventListener("mousemove",L),window.addEventListener("touchmove",L),window.addEventListener("mouseup",G),window.addEventListener("touchend",G),window.addEventListener("contextmenu",G),b.value.focus())},T=j=>{s.value||(e.newPosition=Number.parseFloat(_.value)+j/(o.value-r.value)*100,Z(e.newPosition),d())},N=()=>{T(-a.value)},M=()=>{T(a.value)},R=()=>{T(-a.value*4)},D=()=>{T(a.value*4)},z=()=>{s.value||(Z(0),d())},B=()=>{s.value||(Z(100),d())},V=j=>{let J=!0;[PYe,LYe].includes(j.key)?N():[zYe,BYe].includes(j.key)?M():j.key===VYe?z():j.key===HYe?B():j.key===UYe?R():j.key===WYe?D():J=!1,J&&j.preventDefault()},O=j=>{let J,fe;return j.type.startsWith("touch")?(fe=j.touches[0].clientY,J=j.touches[0].clientX):(fe=j.clientY,J=j.clientX),{clientX:J,clientY:fe}},F=j=>{e.dragging=!0,e.isClick=!0;const{clientX:J,clientY:fe}=O(j);t.vertical?e.startY=fe:e.startX=J,e.startPosition=Number.parseFloat(_.value),e.newPosition=e.startPosition},L=j=>{if(e.dragging){e.isClick=!1,y(),f();let J;const{clientX:fe,clientY:X}=O(j);t.vertical?(e.currentY=X,J=(e.startY-e.currentY)/u.value*100):(e.currentX=fe,J=(e.currentX-e.startX)/u.value*100),e.newPosition=e.startPosition+J,Z(e.newPosition)}},G=()=>{e.dragging&&(setTimeout(()=>{e.dragging=!1,e.hovering||w(),e.isClick||Z(e.newPosition),d()},0),window.removeEventListener("mousemove",L),window.removeEventListener("touchmove",L),window.removeEventListener("mouseup",G),window.removeEventListener("touchend",G),window.removeEventListener("contextmenu",G))},Z=async j=>{if(j===null||Number.isNaN(+j))return;j<0?j=0:j>100&&(j=100);const J=100/((o.value-r.value)/a.value);let X=Math.round(j/J)*J*(o.value-r.value)*.01+r.value;X=Number.parseFloat(X.toFixed(l.value)),X!==t.modelValue&&n(Ot,X),!e.dragging&&t.modelValue!==e.oldValue&&(e.oldValue=t.modelValue),await nt(),e.dragging&&y(),p.value.updatePopper()};return Me(()=>e.dragging,j=>{h(j)}),{disabled:s,button:b,tooltip:p,tooltipVisible:m,showTooltip:i,wrapperStyle:$,formatValue:g,handleMouseEnter:x,handleMouseLeave:k,onButtonDown:C,onKeyDown:V,setPosition:Z}},KYe=(t,e,n,s)=>({stops:A(()=>{if(!t.showStops||t.min>t.max)return[];if(t.step===0)return[];const a=(t.max-t.min)/t.step,i=100*t.step/(t.max-t.min),l=Array.from({length:a-1}).map((u,c)=>(c+1)*i);return t.range?l.filter(u=>u<100*(n.value-t.min)/(t.max-t.min)||u>100*(s.value-t.min)/(t.max-t.min)):l.filter(u=>u>100*(e.firstValue-t.min)/(t.max-t.min))}),getStopStyle:a=>t.vertical?{bottom:`${a}%`}:{left:`${a}%`}}),qYe=(t,e,n,s,r,o)=>{const a=u=>{r(Ot,u),r(jr,u)},i=()=>t.range?![n.value,s.value].every((u,c)=>u===e.oldValue[c]):t.modelValue!==e.oldValue,l=()=>{var u,c;if(t.min>t.max){Ls("Slider","min should not be greater than max.");return}const d=t.modelValue;t.range&&Array.isArray(d)?d[1]<t.min?a([t.min,t.min]):d[0]>t.max?a([t.max,t.max]):d[0]<t.min?a([t.min,d[1]]):d[1]>t.max?a([d[0],t.max]):(e.firstValue=d[0],e.secondValue=d[1],i()&&(t.validateEvent&&((u=o==null?void 0:o.validate)==null||u.call(o,"change").catch(f=>void 0)),e.oldValue=d.slice())):!t.range&&typeof d=="number"&&!Number.isNaN(d)&&(d<t.min?a(t.min):d>t.max?a(t.max):(e.firstValue=d,i()&&(t.validateEvent&&((c=o==null?void 0:o.validate)==null||c.call(o,"change").catch(f=>void 0)),e.oldValue=d)))};l(),Me(()=>e.dragging,u=>{u||l()}),Me(()=>t.modelValue,(u,c)=>{e.dragging||Array.isArray(u)&&Array.isArray(c)&&u.every((d,f)=>d===c[f])&&e.firstValue===u[0]&&e.secondValue===u[1]||l()},{deep:!0}),Me(()=>[t.min,t.max],()=>{l()})},XYe=qe({modelValue:{type:Number,default:0},vertical:Boolean,tooltipClass:String,placement:{type:String,values:Qd,default:"top"}}),YYe={[Ot]:t=>Ct(t)},ZYe=["tabindex"],JYe=ue({name:"ElSliderButton"}),QYe=ue({...JYe,props:XYe,emits:YYe,setup(t,{expose:e,emit:n}){const s=t,r=Fe("slider"),o=on({hovering:!1,dragging:!1,isClick:!1,startX:0,currentX:0,startY:0,currentY:0,startPosition:0,newPosition:0,oldValue:s.modelValue}),{disabled:a,button:i,tooltip:l,showTooltip:u,tooltipVisible:c,wrapperStyle:d,formatValue:f,handleMouseEnter:h,handleMouseLeave:p,onButtonDown:m,onKeyDown:g,setPosition:y}=jYe(s,o,n),{hovering:w,dragging:b}=Ps(o);return e({onButtonDown:m,onKeyDown:g,setPosition:y,hovering:w,dragging:b}),(_,$)=>(S(),E("div",{ref_key:"button",ref:i,class:P([v(r).e("button-wrapper"),{hover:v(w),dragging:v(b)}]),style:ot(v(d)),tabindex:v(a)?-1:0,onMouseenter:$[0]||($[0]=(...x)=>v(h)&&v(h)(...x)),onMouseleave:$[1]||($[1]=(...x)=>v(p)&&v(p)(...x)),onMousedown:$[2]||($[2]=(...x)=>v(m)&&v(m)(...x)),onTouchstart:$[3]||($[3]=(...x)=>v(m)&&v(m)(...x)),onFocus:$[4]||($[4]=(...x)=>v(h)&&v(h)(...x)),onBlur:$[5]||($[5]=(...x)=>v(p)&&v(p)(...x)),onKeydown:$[6]||($[6]=(...x)=>v(g)&&v(g)(...x))},[se(v(No),{ref_key:"tooltip",ref:l,visible:v(c),placement:_.placement,"fallback-placements":["top","bottom","right","left"],"stop-popper-mouse-event":!1,"popper-class":_.tooltipClass,disabled:!v(u),persistent:""},{content:ce(()=>[I("span",null,Ue(v(f)),1)]),default:ce(()=>[I("div",{class:P([v(r).e("button"),{hover:v(w),dragging:v(b)}])},null,2)]),_:1},8,["visible","placement","popper-class","disabled"])],46,ZYe))}});var dR=je(QYe,[["__file","/home/runner/work/element-plus/element-plus/packages/components/slider/src/button.vue"]]);const eZe=qe({mark:{type:Se([String,Object]),default:void 0}});var tZe=ue({name:"ElSliderMarker",props:eZe,setup(t){const e=Fe("slider"),n=A(()=>wt(t.mark)?t.mark:t.mark.label),s=A(()=>wt(t.mark)?void 0:t.mark.style);return()=>it("div",{class:e.e("marks-text"),style:s.value},n.value)}});const nZe=["id","role","aria-label","aria-labelledby"],sZe={key:1},rZe=ue({name:"ElSlider"}),oZe=ue({...rZe,props:OYe,emits:RYe,setup(t,{expose:e,emit:n}){const s=t,r=Fe("slider"),{t:o}=nn(),a=on({firstValue:0,secondValue:0,oldValue:0,dragging:!1,sliderSize:1}),{elFormItem:i,slider:l,firstButton:u,secondButton:c,sliderDisabled:d,minValue:f,maxValue:h,runwayStyle:p,barStyle:m,resetSize:g,emitChange:y,onSliderWrapperPrevent:w,onSliderClick:b,onSliderDown:_,setFirstValue:$,setSecondValue:x}=MYe(s,a,n),{stops:k,getStopStyle:C}=KYe(s,a,f,h),{inputId:T,isLabeledByFormItem:N}=ic(s,{formItemContext:i}),M=ks(),R=A(()=>s.inputSize||M.value),D=A(()=>s.label||o("el.slider.defaultLabel",{min:s.min,max:s.max})),z=A(()=>s.range?s.rangeStartLabel||o("el.slider.defaultRangeStartLabel"):D.value),B=A(()=>s.formatValueText?s.formatValueText(j.value):`${j.value}`),V=A(()=>s.rangeEndLabel||o("el.slider.defaultRangeEndLabel")),O=A(()=>s.formatValueText?s.formatValueText(J.value):`${J.value}`),F=A(()=>[r.b(),r.m(M.value),r.is("vertical",s.vertical),{[r.m("with-input")]:s.showInput}]),L=FYe(s);qYe(s,a,f,h,n,i);const G=A(()=>{const oe=[s.min,s.max,s.step].map(ee=>{const Q=`${ee}`.split(".")[1];return Q?Q.length:0});return Math.max.apply(null,oe)}),{sliderWrapper:Z}=DYe(s,a,g),{firstValue:j,secondValue:J,sliderSize:fe}=Ps(a),X=oe=>{a.dragging=oe};return Lt(GP,{...Ps(s),sliderSize:fe,disabled:d,precision:G,emitChange:y,resetSize:g,updateDragging:X}),e({onSliderClick:b}),(oe,ee)=>{var Q,ie;return S(),E("div",{id:oe.range?v(T):void 0,ref_key:"sliderWrapper",ref:Z,class:P(v(F)),role:oe.range?"group":void 0,"aria-label":oe.range&&!v(N)?v(D):void 0,"aria-labelledby":oe.range&&v(N)?(Q=v(i))==null?void 0:Q.labelId:void 0,onTouchstart:ee[2]||(ee[2]=(...pe)=>v(w)&&v(w)(...pe)),onTouchmove:ee[3]||(ee[3]=(...pe)=>v(w)&&v(w)(...pe))},[I("div",{ref_key:"slider",ref:l,class:P([v(r).e("runway"),{"show-input":oe.showInput&&!oe.range},v(r).is("disabled",v(d))]),style:ot(v(p)),onMousedown:ee[0]||(ee[0]=(...pe)=>v(_)&&v(_)(...pe)),onTouchstart:ee[1]||(ee[1]=(...pe)=>v(_)&&v(_)(...pe))},[I("div",{class:P(v(r).e("bar")),style:ot(v(m))},null,6),se(dR,{id:oe.range?void 0:v(T),ref_key:"firstButton",ref:u,"model-value":v(j),vertical:oe.vertical,"tooltip-class":oe.tooltipClass,placement:oe.placement,role:"slider","aria-label":oe.range||!v(N)?v(z):void 0,"aria-labelledby":!oe.range&&v(N)?(ie=v(i))==null?void 0:ie.labelId:void 0,"aria-valuemin":oe.min,"aria-valuemax":oe.range?v(J):oe.max,"aria-valuenow":v(j),"aria-valuetext":v(B),"aria-orientation":oe.vertical?"vertical":"horizontal","aria-disabled":v(d),"onUpdate:modelValue":v($)},null,8,["id","model-value","vertical","tooltip-class","placement","aria-label","aria-labelledby","aria-valuemin","aria-valuemax","aria-valuenow","aria-valuetext","aria-orientation","aria-disabled","onUpdate:modelValue"]),oe.range?(S(),$e(dR,{key:0,ref_key:"secondButton",ref:c,"model-value":v(J),vertical:oe.vertical,"tooltip-class":oe.tooltipClass,placement:oe.placement,role:"slider","aria-label":v(V),"aria-valuemin":v(j),"aria-valuemax":oe.max,"aria-valuenow":v(J),"aria-valuetext":v(O),"aria-orientation":oe.vertical?"vertical":"horizontal","aria-disabled":v(d),"onUpdate:modelValue":v(x)},null,8,["model-value","vertical","tooltip-class","placement","aria-label","aria-valuemin","aria-valuemax","aria-valuenow","aria-valuetext","aria-orientation","aria-disabled","onUpdate:modelValue"])):ge("v-if",!0),oe.showStops?(S(),E("div",sZe,[(S(!0),E(lt,null,Gt(v(k),(pe,Re)=>(S(),E("div",{key:Re,class:P(v(r).e("stop")),style:ot(v(C)(pe))},null,6))),128))])):ge("v-if",!0),v(L).length>0?(S(),E(lt,{key:2},[I("div",null,[(S(!0),E(lt,null,Gt(v(L),(pe,Re)=>(S(),E("div",{key:Re,style:ot(v(C)(pe.position)),class:P([v(r).e("stop"),v(r).e("marks-stop")])},null,6))),128))]),I("div",{class:P(v(r).e("marks"))},[(S(!0),E(lt,null,Gt(v(L),(pe,Re)=>(S(),$e(v(tZe),{key:Re,mark:pe.mark,style:ot(v(C)(pe.position))},null,8,["mark","style"]))),128))],2)],64)):ge("v-if",!0)],38),oe.showInput&&!oe.range?(S(),$e(v(n7),{key:0,ref:"input","model-value":v(j),class:P(v(r).e("input")),step:oe.step,disabled:v(d),controls:oe.showInputControls,min:oe.min,max:oe.max,debounce:oe.debounce,size:v(R),"onUpdate:modelValue":v($),onChange:v(y)},null,8,["model-value","class","step","disabled","controls","min","max","debounce","size","onUpdate:modelValue","onChange"])):ge("v-if",!0)],42,nZe)}}});var aZe=je(oZe,[["__file","/home/runner/work/element-plus/element-plus/packages/components/slider/src/slider.vue"]]);const iZe=Dt(aZe),lZe=qe({prefixCls:{type:String}}),fR=ue({name:"ElSpaceItem",props:lZe,setup(t,{slots:e}){const n=Fe("space"),s=A(()=>`${t.prefixCls||n.b()}__item`);return()=>it("div",{class:s.value},Oe(e,"default"))}}),hR={small:8,default:12,large:16};function uZe(t){const e=Fe("space"),n=A(()=>[e.b(),e.m(t.direction),t.class]),s=U(0),r=U(0),o=A(()=>{const i=t.wrap||t.fill?{flexWrap:"wrap",marginBottom:`-${r.value}px`}:{},l={alignItems:t.alignment};return[i,l,t.style]}),a=A(()=>{const i={paddingBottom:`${r.value}px`,marginRight:`${s.value}px`},l=t.fill?{flexGrow:1,minWidth:`${t.fillRatio}%`}:{};return[i,l]});return Ho(()=>{const{size:i="small",wrap:l,direction:u,fill:c}=t;if(Qe(i)){const[d=0,f=0]=i;s.value=d,r.value=f}else{let d;Ct(i)?d=i:d=hR[i||"small"]||hR.small,(l||c)&&u==="horizontal"?s.value=r.value=d:u==="horizontal"?(s.value=d,r.value=0):(r.value=d,s.value=0)}}),{classes:n,containerStyle:o,itemStyle:a}}const cZe=qe({direction:{type:String,values:["horizontal","vertical"],default:"horizontal"},class:{type:Se([String,Object,Array]),default:""},style:{type:Se([String,Array,Object]),default:""},alignment:{type:Se(String),default:"center"},prefixCls:{type:String},spacer:{type:Se([Object,String,Number,Array]),default:null,validator:t=>Bn(t)||Ct(t)||wt(t)},wrap:Boolean,fill:Boolean,fillRatio:{type:Number,default:100},size:{type:[String,Array,Number],values:Hl,validator:t=>Ct(t)||Qe(t)&&t.length===2&&t.every(Ct)}}),dZe=ue({name:"ElSpace",props:cZe,setup(t,{slots:e}){const{classes:n,containerStyle:s,itemStyle:r}=uZe(t);function o(a,i="",l=[]){const{prefixCls:u}=t;return a.forEach((c,d)=>{h6(c)?Qe(c.children)&&c.children.forEach((f,h)=>{h6(f)&&Qe(f.children)?o(f.children,`${i+h}-`,l):l.push(se(fR,{style:r.value,prefixCls:u,key:`nested-${i+h}`},{default:()=>[f]},ra.PROPS|ra.STYLE,["style","prefixCls"]))}):V9e(c)&&l.push(se(fR,{style:r.value,prefixCls:u,key:`LoopKey${i+d}`},{default:()=>[c]},ra.PROPS|ra.STYLE,["style","prefixCls"]))}),l}return()=>{var a;const{spacer:i,direction:l}=t,u=Oe(e,"default",{key:0},()=>[]);if(((a=u.children)!=null?a:[]).length===0)return null;if(Qe(u.children)){let c=o(u.children);if(i){const d=c.length-1;c=c.reduce((f,h,p)=>{const m=[...f,h];return p!==d&&m.push(se("span",{style:[r.value,l==="vertical"?"width: 100%":null],key:p},[Bn(i)?i:Yt(i,ra.TEXT)],ra.STYLE)),m},[])}return se("div",{class:n.value,style:s.value},c,ra.STYLE|ra.CLASS)}return u.children}}}),fZe=Dt(dZe),hZe=qe({space:{type:[Number,String],default:""},active:{type:Number,default:0},direction:{type:String,default:"horizontal",values:["horizontal","vertical"]},alignCenter:{type:Boolean},simple:{type:Boolean},finishStatus:{type:String,values:["wait","process","finish","error","success"],default:"finish"},processStatus:{type:String,values:["wait","process","finish","error","success"],default:"process"}}),pZe={[Fn]:(t,e)=>[t,e].every(Ct)},mZe=ue({name:"ElSteps"}),gZe=ue({...mZe,props:hZe,emits:pZe,setup(t,{emit:e}){const n=t,s=Fe("steps"),r=U([]);return Me(r,()=>{r.value.forEach((o,a)=>{o.setIndex(a)})}),Lt("ElSteps",{props:n,steps:r}),Me(()=>n.active,(o,a)=>{e(Fn,o,a)}),(o,a)=>(S(),E("div",{class:P([v(s).b(),v(s).m(o.simple?"simple":o.direction)])},[Oe(o.$slots,"default")],2))}});var vZe=je(gZe,[["__file","/home/runner/work/element-plus/element-plus/packages/components/steps/src/steps.vue"]]);const yZe=qe({title:{type:String,default:""},icon:{type:In},description:{type:String,default:""},status:{type:String,values:["","wait","process","finish","error","success"],default:""}}),bZe=ue({name:"ElStep"}),wZe=ue({...bZe,props:yZe,setup(t){const e=t,n=Fe("step"),s=U(-1),r=U({}),o=U(""),a=et("ElSteps"),i=Rt();It(()=>{Me([()=>a.props.active,()=>a.props.processStatus,()=>a.props.finishStatus],([$])=>{b($)},{immediate:!0})}),ts(()=>{a.steps.value=a.steps.value.filter($=>$.uid!==(i==null?void 0:i.uid))});const l=A(()=>e.status||o.value),u=A(()=>{const $=a.steps.value[s.value-1];return $?$.currentStatus:"wait"}),c=A(()=>a.props.alignCenter),d=A(()=>a.props.direction==="vertical"),f=A(()=>a.props.simple),h=A(()=>a.steps.value.length),p=A(()=>{var $;return(($=a.steps.value[h.value-1])==null?void 0:$.uid)===(i==null?void 0:i.uid)}),m=A(()=>f.value?"":a.props.space),g=A(()=>{const $={flexBasis:typeof m.value=="number"?`${m.value}px`:m.value?m.value:`${100/(h.value-(c.value?0:1))}%`};return d.value||p.value&&($.maxWidth=`${100/h.value}%`),$}),y=$=>{s.value=$},w=$=>{let x=100;const k={};k.transitionDelay=`${150*s.value}ms`,$===a.props.processStatus?x=0:$==="wait"&&(x=0,k.transitionDelay=`${-150*s.value}ms`),k.borderWidth=x&&!f.value?"1px":0,k[a.props.direction==="vertical"?"height":"width"]=`${x}%`,r.value=k},b=$=>{$>s.value?o.value=a.props.finishStatus:$===s.value&&u.value!=="error"?o.value=a.props.processStatus:o.value="wait";const x=a.steps.value[s.value-1];x&&x.calcProgress(o.value)},_=on({uid:A(()=>i==null?void 0:i.uid),currentStatus:l,setIndex:y,calcProgress:w});return a.steps.value=[...a.steps.value,_],($,x)=>(S(),E("div",{style:ot(v(g)),class:P([v(n).b(),v(n).is(v(f)?"simple":v(a).props.direction),v(n).is("flex",v(p)&&!v(m)&&!v(c)),v(n).is("center",v(c)&&!v(d)&&!v(f))])},[ge(" icon & line "),I("div",{class:P([v(n).e("head"),v(n).is(v(l))])},[v(f)?ge("v-if",!0):(S(),E("div",{key:0,class:P(v(n).e("line"))},[I("i",{class:P(v(n).e("line-inner")),style:ot(r.value)},null,6)],2)),I("div",{class:P([v(n).e("icon"),v(n).is($.icon||$.$slots.icon?"icon":"text")])},[Oe($.$slots,"icon",{},()=>[$.icon?(S(),$e(v(rt),{key:0,class:P(v(n).e("icon-inner"))},{default:ce(()=>[(S(),$e(Vt($.icon)))]),_:1},8,["class"])):v(l)==="success"?(S(),$e(v(rt),{key:1,class:P([v(n).e("icon-inner"),v(n).is("status")])},{default:ce(()=>[se(v(Jh))]),_:1},8,["class"])):v(l)==="error"?(S(),$e(v(rt),{key:2,class:P([v(n).e("icon-inner"),v(n).is("status")])},{default:ce(()=>[se(v(xa))]),_:1},8,["class"])):v(f)?ge("v-if",!0):(S(),E("div",{key:3,class:P(v(n).e("icon-inner"))},Ue(s.value+1),3))])],2)],2),ge(" title & description "),I("div",{class:P(v(n).e("main"))},[I("div",{class:P([v(n).e("title"),v(n).is(v(l))])},[Oe($.$slots,"title",{},()=>[Yt(Ue($.title),1)])],2),v(f)?(S(),E("div",{key:0,class:P(v(n).e("arrow"))},null,2)):(S(),E("div",{key:1,class:P([v(n).e("description"),v(n).is(v(l))])},[Oe($.$slots,"description",{},()=>[Yt(Ue($.description),1)])],2))],2)],6))}});var N7=je(wZe,[["__file","/home/runner/work/element-plus/element-plus/packages/components/steps/src/item.vue"]]);const _Ze=Dt(vZe,{Step:N7}),$Ze=ns(N7),xZe=qe({modelValue:{type:[Boolean,String,Number],default:!1},value:{type:[Boolean,String,Number],default:!1},disabled:{type:Boolean,default:!1},width:{type:[String,Number],default:""},inlinePrompt:{type:Boolean,default:!1},activeIcon:{type:In},inactiveIcon:{type:In},activeText:{type:String,default:""},inactiveText:{type:String,default:""},activeColor:{type:String,default:""},inactiveColor:{type:String,default:""},borderColor:{type:String,default:""},activeValue:{type:[Boolean,String,Number],default:!0},inactiveValue:{type:[Boolean,String,Number],default:!1},name:{type:String,default:""},validateEvent:{type:Boolean,default:!0},id:String,loading:{type:Boolean,default:!1},beforeChange:{type:Se(Function)},size:{type:String,validator:Qh},tabindex:{type:[String,Number]}}),SZe={[Ot]:t=>Rs(t)||wt(t)||Ct(t),[Fn]:t=>Rs(t)||wt(t)||Ct(t),[jr]:t=>Rs(t)||wt(t)||Ct(t)},CZe=["onClick"],kZe=["id","aria-checked","aria-disabled","name","true-value","false-value","disabled","tabindex","onKeydown"],TZe=["aria-hidden"],NZe=["aria-hidden"],IZe=["aria-hidden"],K6="ElSwitch",EZe=ue({name:K6}),AZe=ue({...EZe,props:xZe,emits:SZe,setup(t,{expose:e,emit:n}){const s=t,r=Rt(),{formItem:o}=to(),a=ks(),i=Fe("switch");Sl({from:'"value"',replacement:'"model-value" or "v-model"',scope:K6,version:"2.3.0",ref:"https://element-plus.org/en-US/component/switch.html#attributes",type:"Attribute"},A(()=>{var $;return!!(($=r.vnode.props)!=null&&$.value)}));const{inputId:l}=ic(s,{formItemContext:o}),u=To(A(()=>s.loading)),c=U(s.modelValue!==!1),d=U(),f=U(),h=A(()=>[i.b(),i.m(a.value),i.is("disabled",u.value),i.is("checked",g.value)]),p=A(()=>({width:Cs(s.width)}));Me(()=>s.modelValue,()=>{c.value=!0}),Me(()=>s.value,()=>{c.value=!1});const m=A(()=>c.value?s.modelValue:s.value),g=A(()=>m.value===s.activeValue);[s.activeValue,s.inactiveValue].includes(m.value)||(n(Ot,s.inactiveValue),n(Fn,s.inactiveValue),n(jr,s.inactiveValue)),Me(g,$=>{var x;d.value.checked=$,s.validateEvent&&((x=o==null?void 0:o.validate)==null||x.call(o,"change").catch(k=>void 0))});const y=()=>{const $=g.value?s.inactiveValue:s.activeValue;n(Ot,$),n(Fn,$),n(jr,$),nt(()=>{d.value.checked=g.value})},w=()=>{if(u.value)return;const{beforeChange:$}=s;if(!$){y();return}const x=$();[b0(x),Rs(x)].includes(!0)||Ls(K6,"beforeChange must return type `Promise<boolean>` or `boolean`"),b0(x)?x.then(C=>{C&&y()}).catch(C=>{}):x&&y()},b=A(()=>i.cssVarBlock({...s.activeColor?{"on-color":s.activeColor}:null,...s.inactiveColor?{"off-color":s.inactiveColor}:null,...s.borderColor?{"border-color":s.borderColor}:null})),_=()=>{var $,x;(x=($=d.value)==null?void 0:$.focus)==null||x.call($)};return It(()=>{d.value.checked=g.value}),e({focus:_,checked:g}),($,x)=>(S(),E("div",{class:P(v(h)),style:ot(v(b)),onClick:yt(w,["prevent"])},[I("input",{id:v(l),ref_key:"input",ref:d,class:P(v(i).e("input")),type:"checkbox",role:"switch","aria-checked":v(g),"aria-disabled":v(u),name:$.name,"true-value":$.activeValue,"false-value":$.inactiveValue,disabled:v(u),tabindex:$.tabindex,onChange:y,onKeydown:qt(w,["enter"])},null,42,kZe),!$.inlinePrompt&&($.inactiveIcon||$.inactiveText)?(S(),E("span",{key:0,class:P([v(i).e("label"),v(i).em("label","left"),v(i).is("active",!v(g))])},[$.inactiveIcon?(S(),$e(v(rt),{key:0},{default:ce(()=>[(S(),$e(Vt($.inactiveIcon)))]),_:1})):ge("v-if",!0),!$.inactiveIcon&&$.inactiveText?(S(),E("span",{key:1,"aria-hidden":v(g)},Ue($.inactiveText),9,TZe)):ge("v-if",!0)],2)):ge("v-if",!0),I("span",{ref_key:"core",ref:f,class:P(v(i).e("core")),style:ot(v(p))},[$.inlinePrompt?(S(),E("div",{key:0,class:P(v(i).e("inner"))},[$.activeIcon||$.inactiveIcon?(S(),$e(v(rt),{key:0,class:P(v(i).is("icon"))},{default:ce(()=>[(S(),$e(Vt(v(g)?$.activeIcon:$.inactiveIcon)))]),_:1},8,["class"])):$.activeText||$.inactiveText?(S(),E("span",{key:1,class:P(v(i).is("text")),"aria-hidden":!v(g)},Ue(v(g)?$.activeText:$.inactiveText),11,NZe)):ge("v-if",!0)],2)):ge("v-if",!0),I("div",{class:P(v(i).e("action"))},[$.loading?(S(),$e(v(rt),{key:0,class:P(v(i).is("loading"))},{default:ce(()=>[se(v(Vl))]),_:1},8,["class"])):ge("v-if",!0)],2)],6),!$.inlinePrompt&&($.activeIcon||$.activeText)?(S(),E("span",{key:1,class:P([v(i).e("label"),v(i).em("label","right"),v(i).is("active",v(g))])},[$.activeIcon?(S(),$e(v(rt),{key:0},{default:ce(()=>[(S(),$e(Vt($.activeIcon)))]),_:1})):ge("v-if",!0),!$.activeIcon&&$.activeText?(S(),E("span",{key:1,"aria-hidden":!v(g)},Ue($.activeText),9,IZe)):ge("v-if",!0)],2)):ge("v-if",!0)],14,CZe))}});var OZe=je(AZe,[["__file","/home/runner/work/element-plus/element-plus/packages/components/switch/src/switch.vue"]]);const RZe=Dt(OZe);var DZe=/["'&<>]/,FZe=MZe;function MZe(t){var e=""+t,n=DZe.exec(e);if(!n)return e;var s,r="",o=0,a=0;for(o=n.index;o<e.length;o++){switch(e.charCodeAt(o)){case 34:s="&quot;";break;case 38:s="&amp;";break;case 39:s="&#39;";break;case 60:s="&lt;";break;case 62:s="&gt;";break;default:continue}a!==o&&(r+=e.substring(a,o)),a=o+1,r+=s}return a!==o?r+e.substring(a,o):r}const i$=function(t){var e;return(e=t.target)==null?void 0:e.closest("td")},pR=function(t){return t!==null&&typeof t=="object"},PZe=function(t,e,n,s,r){if(!e&&!s&&(!r||Array.isArray(r)&&!r.length))return t;typeof n=="string"?n=n==="descending"?-1:1:n=n&&n<0?-1:1;const o=s?null:function(i,l){return r?(Array.isArray(r)||(r=[r]),r.map(u=>typeof u=="string"?Pn(i,u):u(i,l,t))):(e!=="$key"&&pR(i)&&"$value"in i&&(i=i.$value),[pR(i)?Pn(i,e):i])},a=function(i,l){if(s)return s(i.value,l.value);for(let u=0,c=i.key.length;u<c;u++){if(i.key[u]<l.key[u])return-1;if(i.key[u]>l.key[u])return 1}return 0};return t.map((i,l)=>({value:i,index:l,key:o?o(i,l):null})).sort((i,l)=>{let u=a(i,l);return u||(u=i.index-l.index),u*+n}).map(i=>i.value)},I7=function(t,e){let n=null;return t.columns.forEach(s=>{s.id===e&&(n=s)}),n},LZe=function(t,e){let n=null;for(let s=0;s<t.columns.length;s++){const r=t.columns[s];if(r.columnKey===e){n=r;break}}return n||Ls("ElTable",`No column matching with column-key: ${e}`),n},mR=function(t,e,n){const s=(e.className||"").match(new RegExp(`${n}-table_[^\\s]+`,"gm"));return s?I7(t,s[0]):null},mr=(t,e)=>{if(!t)throw new Error("Row is required when get row identity");if(typeof e=="string"){if(!e.includes("."))return`${t[e]}`;const n=e.split(".");let s=t;for(const r of n)s=s[r];return`${s}`}else if(typeof e=="function")return e.call(null,t)},Yc=function(t,e){const n={};return(t||[]).forEach((s,r)=>{n[mr(s,e)]={row:s,index:r}}),n};function zZe(t,e){const n={};let s;for(s in t)n[s]=t[s];for(s in e)if(Ut(e,s)){const r=e[s];typeof r<"u"&&(n[s]=r)}return n}function _k(t){return t===""||t!==void 0&&(t=Number.parseInt(t,10),Number.isNaN(t)&&(t="")),t}function E7(t){return t===""||t!==void 0&&(t=_k(t),Number.isNaN(t)&&(t=80)),t}function BZe(t){return typeof t=="number"?t:typeof t=="string"?/^\d+(?:px)?$/.test(t)?Number.parseInt(t,10):t:null}function VZe(...t){return t.length===0?e=>e:t.length===1?t[0]:t.reduce((e,n)=>(...s)=>e(n(...s)))}function h0(t,e,n){let s=!1;const r=t.indexOf(e),o=r!==-1,a=i=>{i==="add"?t.push(e):t.splice(r,1),s=!0,Qe(e.children)&&e.children.forEach(l=>{h0(t,l,n??!o)})};return Rs(n)?n&&!o?a("add"):!n&&o&&a("remove"):a(o?"remove":"add"),s}function HZe(t,e,n="children",s="hasChildren"){const r=a=>!(Array.isArray(a)&&a.length);function o(a,i,l){e(a,i,l),i.forEach(u=>{if(u[s]){e(u,null,l+1);return}const c=u[n];r(c)||o(u,c,l+1)})}t.forEach(a=>{if(a[s]){e(a,null,0);return}const i=a[n];r(i)||o(a,i,0)})}let nl;function WZe(t,e,n,s,r){const{nextZIndex:o}=Ul(),a=t==null?void 0:t.dataset.prefix,i=t==null?void 0:t.querySelector(`.${a}-scrollbar__wrap`);function l(){const p=r==="light",m=document.createElement("div");return m.className=`${a}-popper ${p?"is-light":"is-dark"}`,n=FZe(n),m.innerHTML=n,m.style.zIndex=String(o()),t==null||t.appendChild(m),m}function u(){const p=document.createElement("div");return p.className=`${a}-popper__arrow`,p}function c(){d&&d.update()}nl==null||nl(),nl=()=>{try{d&&d.destroy(),f&&(t==null||t.removeChild(f)),e.removeEventListener("mouseenter",c),e.removeEventListener("mouseleave",nl),i==null||i.removeEventListener("scroll",nl),nl=void 0}catch{}};let d=null;const f=l(),h=u();return f.appendChild(h),d=NL(e,f,{strategy:"absolute",modifiers:[{name:"offset",options:{offset:[0,8]}},{name:"arrow",options:{element:h,padding:10}}],...s}),e.addEventListener("mouseenter",c),e.addEventListener("mouseleave",nl),i==null||i.addEventListener("scroll",nl),d}function A7(t){return t.children?Ble(t.children,A7):[t]}function gR(t,e){return t+e.colSpan}const O7=(t,e,n,s)=>{let r=0,o=t;const a=n.states.columns.value;if(s){const l=A7(s[t]);r=a.slice(0,a.indexOf(l[0])).reduce(gR,0),o=r+l.reduce(gR,0)-1}else r=t;let i;switch(e){case"left":o<n.states.fixedLeafColumnsLength.value&&(i="left");break;case"right":r>=a.length-n.states.rightFixedLeafColumnsLength.value&&(i="right");break;default:o<n.states.fixedLeafColumnsLength.value?i="left":r>=a.length-n.states.rightFixedLeafColumnsLength.value&&(i="right")}return i?{direction:i,start:r,after:o}:{}},$k=(t,e,n,s,r,o=0)=>{const a=[],{direction:i,start:l,after:u}=O7(e,n,s,r);if(i){const c=i==="left";a.push(`${t}-fixed-column--${i}`),c&&u+o===s.states.fixedLeafColumnsLength.value-1?a.push("is-last-column"):!c&&l-o===s.states.columns.value.length-s.states.rightFixedLeafColumnsLength.value&&a.push("is-first-column")}return a};function vR(t,e){return t+(e.realWidth===null||Number.isNaN(e.realWidth)?Number(e.width):e.realWidth)}const xk=(t,e,n,s)=>{const{direction:r,start:o=0,after:a=0}=O7(t,e,n,s);if(!r)return;const i={},l=r==="left",u=n.states.columns.value;return l?i.left=u.slice(0,o).reduce(vR,0):i.right=u.slice(a+1).reverse().reduce(vR,0),i},yh=(t,e)=>{!t||Number.isNaN(t[e])||(t[e]=`${t[e]}px`)};function UZe(t){const e=Rt(),n=U(!1),s=U([]);return{updateExpandRows:()=>{const l=t.data.value||[],u=t.rowKey.value;if(n.value)s.value=l.slice();else if(u){const c=Yc(s.value,u);s.value=l.reduce((d,f)=>{const h=mr(f,u);return c[h]&&d.push(f),d},[])}else s.value=[]},toggleRowExpansion:(l,u)=>{h0(s.value,l,u)&&e.emit("expand-change",l,s.value.slice())},setExpandRowKeys:l=>{e.store.assertRowKey();const u=t.data.value||[],c=t.rowKey.value,d=Yc(u,c);s.value=l.reduce((f,h)=>{const p=d[h];return p&&f.push(p.row),f},[])},isRowExpanded:l=>{const u=t.rowKey.value;return u?!!Yc(s.value,u)[mr(l,u)]:s.value.includes(l)},states:{expandRows:s,defaultExpandAll:n}}}function GZe(t){const e=Rt(),n=U(null),s=U(null),r=u=>{e.store.assertRowKey(),n.value=u,a(u)},o=()=>{n.value=null},a=u=>{const{data:c,rowKey:d}=t;let f=null;d.value&&(f=(v(c)||[]).find(h=>mr(h,d.value)===u)),s.value=f,e.emit("current-change",s.value,null)};return{setCurrentRowKey:r,restoreCurrentRowKey:o,setCurrentRowByKey:a,updateCurrentRow:u=>{const c=s.value;if(u&&u!==c){s.value=u,e.emit("current-change",s.value,c);return}!u&&c&&(s.value=null,e.emit("current-change",null,c))},updateCurrentRowData:()=>{const u=t.rowKey.value,c=t.data.value||[],d=s.value;if(!c.includes(d)&&d){if(u){const f=mr(d,u);a(f)}else s.value=null;s.value===null&&e.emit("current-change",null,d)}else n.value&&(a(n.value),o())},states:{_currentRowKey:n,currentRow:s}}}function jZe(t){const e=U([]),n=U({}),s=U(16),r=U(!1),o=U({}),a=U("hasChildren"),i=U("children"),l=Rt(),u=A(()=>{if(!t.rowKey.value)return{};const y=t.data.value||[];return d(y)}),c=A(()=>{const y=t.rowKey.value,w=Object.keys(o.value),b={};return w.length&&w.forEach(_=>{if(o.value[_].length){const $={children:[]};o.value[_].forEach(x=>{const k=mr(x,y);$.children.push(k),x[a.value]&&!b[k]&&(b[k]={children:[]})}),b[_]=$}}),b}),d=y=>{const w=t.rowKey.value,b={};return HZe(y,(_,$,x)=>{const k=mr(_,w);Array.isArray($)?b[k]={children:$.map(C=>mr(C,w)),level:x}:r.value&&(b[k]={children:[],lazy:!0,level:x})},i.value,a.value),b},f=(y=!1,w=(b=>(b=l.store)==null?void 0:b.states.defaultExpandAll.value)())=>{var b;const _=u.value,$=c.value,x=Object.keys(_),k={};if(x.length){const C=v(n),T=[],N=(R,D)=>{if(y)return e.value?w||e.value.includes(D):!!(w||(R==null?void 0:R.expanded));{const z=w||e.value&&e.value.includes(D);return!!((R==null?void 0:R.expanded)||z)}};x.forEach(R=>{const D=C[R],z={..._[R]};if(z.expanded=N(D,R),z.lazy){const{loaded:B=!1,loading:V=!1}=D||{};z.loaded=!!B,z.loading=!!V,T.push(R)}k[R]=z});const M=Object.keys($);r.value&&M.length&&T.length&&M.forEach(R=>{const D=C[R],z=$[R].children;if(T.includes(R)){if(k[R].children.length!==0)throw new Error("[ElTable]children must be an empty array.");k[R].children=z}else{const{loaded:B=!1,loading:V=!1}=D||{};k[R]={lazy:!0,loaded:!!B,loading:!!V,expanded:N(D,R),children:z,level:""}}})}n.value=k,(b=l.store)==null||b.updateTableScrollY()};Me(()=>e.value,()=>{f(!0)}),Me(()=>u.value,()=>{f()}),Me(()=>c.value,()=>{f()});const h=y=>{e.value=y,f()},p=(y,w)=>{l.store.assertRowKey();const b=t.rowKey.value,_=mr(y,b),$=_&&n.value[_];if(_&&$&&"expanded"in $){const x=$.expanded;w=typeof w>"u"?!$.expanded:w,n.value[_].expanded=w,x!==w&&l.emit("expand-change",y,w),l.store.updateTableScrollY()}},m=y=>{l.store.assertRowKey();const w=t.rowKey.value,b=mr(y,w),_=n.value[b];r.value&&_&&"loaded"in _&&!_.loaded?g(y,b,_):p(y,void 0)},g=(y,w,b)=>{const{load:_}=l.props;_&&!n.value[w].loaded&&(n.value[w].loading=!0,_(y,b,$=>{if(!Array.isArray($))throw new TypeError("[ElTable] data must be an array");n.value[w].loading=!1,n.value[w].loaded=!0,n.value[w].expanded=!0,$.length&&(o.value[w]=$),l.emit("expand-change",y,!0)}))};return{loadData:g,loadOrToggle:m,toggleTreeExpansion:p,updateTreeExpandKeys:h,updateTreeData:f,normalize:d,states:{expandRowKeys:e,treeData:n,indent:s,lazy:r,lazyTreeNodeMap:o,lazyColumnIdentifier:a,childrenColumnName:i}}}const KZe=(t,e)=>{const n=e.sortingColumn;return!n||typeof n.sortable=="string"?t:PZe(t,e.sortProp,e.sortOrder,n.sortMethod,n.sortBy)},sy=t=>{const e=[];return t.forEach(n=>{n.children?e.push.apply(e,sy(n.children)):e.push(n)}),e};function qZe(){var t;const e=Rt(),{size:n}=Ps((t=e.proxy)==null?void 0:t.$props),s=U(null),r=U([]),o=U([]),a=U(!1),i=U([]),l=U([]),u=U([]),c=U([]),d=U([]),f=U([]),h=U([]),p=U([]),m=U(0),g=U(0),y=U(0),w=U(!1),b=U([]),_=U(!1),$=U(!1),x=U(null),k=U({}),C=U(null),T=U(null),N=U(null),M=U(null),R=U(null);Me(r,()=>e.state&&V(!1),{deep:!0});const D=()=>{if(!s.value)throw new Error("[ElTable] prop row-key is required")},z=xe=>{var Ke;(Ke=xe.children)==null||Ke.forEach(at=>{at.fixed=xe.fixed,z(at)})},B=()=>{i.value.forEach(de=>{z(de)}),c.value=i.value.filter(de=>de.fixed===!0||de.fixed==="left"),d.value=i.value.filter(de=>de.fixed==="right"),c.value.length>0&&i.value[0]&&i.value[0].type==="selection"&&!i.value[0].fixed&&(i.value[0].fixed=!0,c.value.unshift(i.value[0]));const xe=i.value.filter(de=>!de.fixed);l.value=[].concat(c.value).concat(xe).concat(d.value);const Ke=sy(xe),at=sy(c.value),Y=sy(d.value);m.value=Ke.length,g.value=at.length,y.value=Y.length,u.value=[].concat(at).concat(Ke).concat(Y),a.value=c.value.length>0||d.value.length>0},V=(xe,Ke=!1)=>{xe&&B(),Ke?e.state.doLayout():e.state.debouncedUpdateLayout()},O=xe=>b.value.includes(xe),F=()=>{w.value=!1,b.value.length&&(b.value=[],e.emit("selection-change",[]))},L=()=>{let xe;if(s.value){xe=[];const Ke=Yc(b.value,s.value),at=Yc(r.value,s.value);for(const Y in Ke)Ut(Ke,Y)&&!at[Y]&&xe.push(Ke[Y].row)}else xe=b.value.filter(Ke=>!r.value.includes(Ke));if(xe.length){const Ke=b.value.filter(at=>!xe.includes(at));b.value=Ke,e.emit("selection-change",Ke.slice())}},G=()=>(b.value||[]).slice(),Z=(xe,Ke=void 0,at=!0)=>{if(h0(b.value,xe,Ke)){const de=(b.value||[]).slice();at&&e.emit("select",de,xe),e.emit("selection-change",de)}},j=()=>{var xe,Ke;const at=$.value?!w.value:!(w.value||b.value.length);w.value=at;let Y=!1,de=0;const Pe=(Ke=(xe=e==null?void 0:e.store)==null?void 0:xe.states)==null?void 0:Ke.rowKey.value;r.value.forEach((We,Ft)=>{const _n=Ft+de;x.value?x.value.call(null,We,_n)&&h0(b.value,We,at)&&(Y=!0):h0(b.value,We,at)&&(Y=!0),de+=X(mr(We,Pe))}),Y&&e.emit("selection-change",b.value?b.value.slice():[]),e.emit("select-all",b.value)},J=()=>{const xe=Yc(b.value,s.value);r.value.forEach(Ke=>{const at=mr(Ke,s.value),Y=xe[at];Y&&(b.value[Y.index]=Ke)})},fe=()=>{var xe,Ke,at;if(((xe=r.value)==null?void 0:xe.length)===0){w.value=!1;return}let Y;s.value&&(Y=Yc(b.value,s.value));const de=function(_n){return Y?!!Y[mr(_n,s.value)]:b.value.includes(_n)};let Pe=!0,We=0,Ft=0;for(let _n=0,_s=(r.value||[]).length;_n<_s;_n++){const qs=(at=(Ke=e==null?void 0:e.store)==null?void 0:Ke.states)==null?void 0:at.rowKey.value,Sn=_n+Ft,sn=r.value[_n],He=x.value&&x.value.call(null,sn,Sn);if(de(sn))We++;else if(!x.value||He){Pe=!1;break}Ft+=X(mr(sn,qs))}We===0&&(Pe=!1),w.value=Pe},X=xe=>{var Ke;if(!e||!e.store)return 0;const{treeData:at}=e.store.states;let Y=0;const de=(Ke=at.value[xe])==null?void 0:Ke.children;return de&&(Y+=de.length,de.forEach(Pe=>{Y+=X(Pe)})),Y},oe=(xe,Ke)=>{Array.isArray(xe)||(xe=[xe]);const at={};return xe.forEach(Y=>{k.value[Y.id]=Ke,at[Y.columnKey||Y.id]=Ke}),at},ee=(xe,Ke,at)=>{T.value&&T.value!==xe&&(T.value.order=null),T.value=xe,N.value=Ke,M.value=at},Q=()=>{let xe=v(o);Object.keys(k.value).forEach(Ke=>{const at=k.value[Ke];if(!at||at.length===0)return;const Y=I7({columns:u.value},Ke);Y&&Y.filterMethod&&(xe=xe.filter(de=>at.some(Pe=>Y.filterMethod.call(null,Pe,de,Y))))}),C.value=xe},ie=()=>{r.value=KZe(C.value,{sortingColumn:T.value,sortProp:N.value,sortOrder:M.value})},pe=(xe=void 0)=>{xe&&xe.filter||Q(),ie()},Re=xe=>{const{tableHeaderRef:Ke}=e.refs;if(!Ke)return;const at=Object.assign({},Ke.filterPanels),Y=Object.keys(at);if(!!Y.length)if(typeof xe=="string"&&(xe=[xe]),Array.isArray(xe)){const de=xe.map(Pe=>LZe({columns:u.value},Pe));Y.forEach(Pe=>{const We=de.find(Ft=>Ft.id===Pe);We&&(We.filteredValue=[])}),e.store.commit("filterChange",{column:de,values:[],silent:!0,multi:!0})}else Y.forEach(de=>{const Pe=u.value.find(We=>We.id===de);Pe&&(Pe.filteredValue=[])}),k.value={},e.store.commit("filterChange",{column:{},values:[],silent:!0})},K=()=>{!T.value||(ee(null,null,null),e.store.commit("changeSortCondition",{silent:!0}))},{setExpandRowKeys:re,toggleRowExpansion:we,updateExpandRows:Ee,states:De,isRowExpanded:_e}=UZe({data:r,rowKey:s}),{updateTreeExpandKeys:ze,toggleTreeExpansion:Ae,updateTreeData:he,loadOrToggle:ve,states:me}=jZe({data:r,rowKey:s}),{updateCurrentRowData:Ve,updateCurrentRow:Ye,setCurrentRowKey:Je,states:ct}=GZe({data:r,rowKey:s});return{assertRowKey:D,updateColumns:B,scheduleLayout:V,isSelected:O,clearSelection:F,cleanSelection:L,getSelectionRows:G,toggleRowSelection:Z,_toggleAllSelection:j,toggleAllSelection:null,updateSelectionByRowKey:J,updateAllSelected:fe,updateFilters:oe,updateCurrentRow:Ye,updateSort:ee,execFilter:Q,execSort:ie,execQuery:pe,clearFilter:Re,clearSort:K,toggleRowExpansion:we,setExpandRowKeysAdapter:xe=>{re(xe),ze(xe)},setCurrentRowKey:Je,toggleRowExpansionAdapter:(xe,Ke)=>{u.value.some(({type:Y})=>Y==="expand")?we(xe,Ke):Ae(xe,Ke)},isRowExpanded:_e,updateExpandRows:Ee,updateCurrentRowData:Ve,loadOrToggle:ve,updateTreeData:he,states:{tableSize:n,rowKey:s,data:r,_data:o,isComplex:a,_columns:i,originColumns:l,columns:u,fixedColumns:c,rightFixedColumns:d,leafColumns:f,fixedLeafColumns:h,rightFixedLeafColumns:p,leafColumnsLength:m,fixedLeafColumnsLength:g,rightFixedLeafColumnsLength:y,isAllSelected:w,selection:b,reserveSelection:_,selectOnIndeterminate:$,selectable:x,filters:k,filteredData:C,sortingColumn:T,sortProp:N,sortOrder:M,hoverRow:R,...De,...me,...ct}}}function q6(t,e){return t.map(n=>{var s;return n.id===e.id?e:((s=n.children)!=null&&s.length&&(n.children=q6(n.children,e)),n)})}function R7(t){t.forEach(e=>{var n,s;e.no=(n=e.getColumnIndex)==null?void 0:n.call(e),(s=e.children)!=null&&s.length&&R7(e.children)}),t.sort((e,n)=>e.no-n.no)}function XZe(){const t=Rt(),e=qZe();return{ns:Fe("table"),...e,mutations:{setData(a,i){const l=v(a._data)!==i;a.data.value=i,a._data.value=i,t.store.execQuery(),t.store.updateCurrentRowData(),t.store.updateExpandRows(),t.store.updateTreeData(t.store.states.defaultExpandAll.value),v(a.reserveSelection)?(t.store.assertRowKey(),t.store.updateSelectionByRowKey()):l?t.store.clearSelection():t.store.cleanSelection(),t.store.updateAllSelected(),t.$ready&&t.store.scheduleLayout()},insertColumn(a,i,l){const u=v(a._columns);let c=[];l?(l&&!l.children&&(l.children=[]),l.children.push(i),c=q6(u,l)):(u.push(i),c=u),R7(c),a._columns.value=c,i.type==="selection"&&(a.selectable.value=i.selectable,a.reserveSelection.value=i.reserveSelection),t.$ready&&(t.store.updateColumns(),t.store.scheduleLayout())},removeColumn(a,i,l){const u=v(a._columns)||[];if(l)l.children.splice(l.children.findIndex(c=>c.id===i.id),1),nt(()=>{var c;((c=l.children)==null?void 0:c.length)===0&&delete l.children}),a._columns.value=q6(u,l);else{const c=u.indexOf(i);c>-1&&(u.splice(c,1),a._columns.value=u)}t.$ready&&(t.store.updateColumns(),t.store.scheduleLayout())},sort(a,i){const{prop:l,order:u,init:c}=i;if(l){const d=v(a.columns).find(f=>f.property===l);d&&(d.order=u,t.store.updateSort(d,l,u),t.store.commit("changeSortCondition",{init:c}))}},changeSortCondition(a,i){const{sortingColumn:l,sortProp:u,sortOrder:c}=a,d=v(l),f=v(u),h=v(c);h===null&&(a.sortingColumn.value=null,a.sortProp.value=null);const p={filter:!0};t.store.execQuery(p),(!i||!(i.silent||i.init))&&t.emit("sort-change",{column:d,prop:f,order:h}),t.store.updateTableScrollY()},filterChange(a,i){const{column:l,values:u,silent:c}=i,d=t.store.updateFilters(l,u);t.store.execQuery(),c||t.emit("filter-change",d),t.store.updateTableScrollY()},toggleAllSelection(){t.store.toggleAllSelection()},rowSelectedChanged(a,i){t.store.toggleRowSelection(i),t.store.updateAllSelected()},setHoverRow(a,i){a.hoverRow.value=i},setCurrentRow(a,i){t.store.updateCurrentRow(i)}},commit:function(a,...i){const l=t.store.mutations;if(l[a])l[a].apply(t,[t.store.states].concat(i));else throw new Error(`Action not found: ${a}`)},updateTableScrollY:function(){nt(()=>t.layout.updateScrollY.apply(t.layout))}}}const p0={rowKey:"rowKey",defaultExpandAll:"defaultExpandAll",selectOnIndeterminate:"selectOnIndeterminate",indent:"indent",lazy:"lazy",data:"data",["treeProps.hasChildren"]:{key:"lazyColumnIdentifier",default:"hasChildren"},["treeProps.children"]:{key:"childrenColumnName",default:"children"}};function YZe(t,e){if(!t)throw new Error("Table is required.");const n=XZe();return n.toggleAllSelection=Xr(n._toggleAllSelection,10),Object.keys(p0).forEach(s=>{D7(F7(e,s),s,n)}),ZZe(n,e),n}function ZZe(t,e){Object.keys(p0).forEach(n=>{Me(()=>F7(e,n),s=>{D7(s,n,t)})})}function D7(t,e,n){let s=t,r=p0[e];typeof p0[e]=="object"&&(r=r.key,s=s||p0[e].default),n.states[r].value=s}function F7(t,e){if(e.includes(".")){const n=e.split(".");let s=t;return n.forEach(r=>{s=s[r]}),s}else return t[e]}class JZe{constructor(e){this.observers=[],this.table=null,this.store=null,this.columns=[],this.fit=!0,this.showHeader=!0,this.height=U(null),this.scrollX=U(!1),this.scrollY=U(!1),this.bodyWidth=U(null),this.fixedWidth=U(null),this.rightFixedWidth=U(null),this.gutterWidth=0;for(const n in e)Ut(e,n)&&(kn(this[n])?this[n].value=e[n]:this[n]=e[n]);if(!this.table)throw new Error("Table is required for Table Layout");if(!this.store)throw new Error("Store is required for Table Layout")}updateScrollY(){if(this.height.value===null)return!1;const n=this.table.refs.scrollBarRef;if(this.table.vnode.el&&n){let s=!0;const r=this.scrollY.value;return s=n.wrapRef.scrollHeight>n.wrapRef.clientHeight,this.scrollY.value=s,r!==s}return!1}setHeight(e,n="height"){if(!Kt)return;const s=this.table.vnode.el;if(e=BZe(e),this.height.value=Number(e),!s&&(e||e===0))return nt(()=>this.setHeight(e,n));typeof e=="number"?(s.style[n]=`${e}px`,this.updateElsHeight()):typeof e=="string"&&(s.style[n]=e,this.updateElsHeight())}setMaxHeight(e){this.setHeight(e,"max-height")}getFlattenColumns(){const e=[];return this.table.store.states.columns.value.forEach(s=>{s.isColumnGroup?e.push.apply(e,s.columns):e.push(s)}),e}updateElsHeight(){this.updateScrollY(),this.notifyObservers("scrollable")}headerDisplayNone(e){if(!e)return!0;let n=e;for(;n.tagName!=="DIV";){if(getComputedStyle(n).display==="none")return!0;n=n.parentElement}return!1}updateColumnsWidth(){if(!Kt)return;const e=this.fit,n=this.table.vnode.el.clientWidth;let s=0;const r=this.getFlattenColumns(),o=r.filter(l=>typeof l.width!="number");if(r.forEach(l=>{typeof l.width=="number"&&l.realWidth&&(l.realWidth=null)}),o.length>0&&e){if(r.forEach(l=>{s+=Number(l.width||l.minWidth||80)}),s<=n){this.scrollX.value=!1;const l=n-s;if(o.length===1)o[0].realWidth=Number(o[0].minWidth||80)+l;else{const u=o.reduce((f,h)=>f+Number(h.minWidth||80),0),c=l/u;let d=0;o.forEach((f,h)=>{if(h===0)return;const p=Math.floor(Number(f.minWidth||80)*c);d+=p,f.realWidth=Number(f.minWidth||80)+p}),o[0].realWidth=Number(o[0].minWidth||80)+l-d}}else this.scrollX.value=!0,o.forEach(l=>{l.realWidth=Number(l.minWidth)});this.bodyWidth.value=Math.max(s,n),this.table.state.resizeState.value.width=this.bodyWidth.value}else r.forEach(l=>{!l.width&&!l.minWidth?l.realWidth=80:l.realWidth=Number(l.width||l.minWidth),s+=l.realWidth}),this.scrollX.value=s>n,this.bodyWidth.value=s;const a=this.store.states.fixedColumns.value;if(a.length>0){let l=0;a.forEach(u=>{l+=Number(u.realWidth||u.width)}),this.fixedWidth.value=l}const i=this.store.states.rightFixedColumns.value;if(i.length>0){let l=0;i.forEach(u=>{l+=Number(u.realWidth||u.width)}),this.rightFixedWidth.value=l}this.notifyObservers("columns")}addObserver(e){this.observers.push(e)}removeObserver(e){const n=this.observers.indexOf(e);n!==-1&&this.observers.splice(n,1)}notifyObservers(e){this.observers.forEach(s=>{var r,o;switch(e){case"columns":(r=s.state)==null||r.onColumnsChange(this);break;case"scrollable":(o=s.state)==null||o.onScrollableChange(this);break;default:throw new Error(`Table Layout don't have event ${e}.`)}})}}const{CheckboxGroup:QZe}=ka,eJe=ue({name:"ElTableFilterPanel",components:{ElCheckbox:ka,ElCheckboxGroup:QZe,ElScrollbar:jl,ElTooltip:No,ElIcon:rt,ArrowDown:zl,ArrowUp:Og},directives:{ClickOutside:Ku},props:{placement:{type:String,default:"bottom-start"},store:{type:Object},column:{type:Object},upDataColumn:{type:Function}},setup(t){const e=Rt(),{t:n}=nn(),s=Fe("table-filter"),r=e==null?void 0:e.parent;r.filterPanels.value[t.column.id]||(r.filterPanels.value[t.column.id]=e);const o=U(!1),a=U(null),i=A(()=>t.column&&t.column.filters),l=A({get:()=>{var _;return(((_=t.column)==null?void 0:_.filteredValue)||[])[0]},set:_=>{u.value&&(typeof _<"u"&&_!==null?u.value.splice(0,1,_):u.value.splice(0,1))}}),u=A({get(){return t.column?t.column.filteredValue||[]:[]},set(_){t.column&&t.upDataColumn("filteredValue",_)}}),c=A(()=>t.column?t.column.filterMultiple:!0),d=_=>_.value===l.value,f=()=>{o.value=!1},h=_=>{_.stopPropagation(),o.value=!o.value},p=()=>{o.value=!1},m=()=>{w(u.value),f()},g=()=>{u.value=[],w(u.value),f()},y=_=>{l.value=_,w(typeof _<"u"&&_!==null?u.value:[]),f()},w=_=>{t.store.commit("filterChange",{column:t.column,values:_}),t.store.updateAllSelected()};Me(o,_=>{t.column&&t.upDataColumn("filterOpened",_)},{immediate:!0});const b=A(()=>{var _,$;return($=(_=a.value)==null?void 0:_.popperRef)==null?void 0:$.contentRef});return{tooltipVisible:o,multiple:c,filteredValue:u,filterValue:l,filters:i,handleConfirm:m,handleReset:g,handleSelect:y,isActive:d,t:n,ns:s,showFilterPanel:h,hideFilterPanel:p,popperPaneRef:b,tooltip:a}}}),tJe={key:0},nJe=["disabled"],sJe=["label","onClick"];function rJe(t,e,n,s,r,o){const a=pt("el-checkbox"),i=pt("el-checkbox-group"),l=pt("el-scrollbar"),u=pt("arrow-up"),c=pt("arrow-down"),d=pt("el-icon"),f=pt("el-tooltip"),h=rh("click-outside");return S(),$e(f,{ref:"tooltip",visible:t.tooltipVisible,offset:0,placement:t.placement,"show-arrow":!1,"stop-popper-mouse-event":!1,teleported:"",effect:"light",pure:"","popper-class":t.ns.b(),persistent:""},{content:ce(()=>[t.multiple?(S(),E("div",tJe,[I("div",{class:P(t.ns.e("content"))},[se(l,{"wrap-class":t.ns.e("wrap")},{default:ce(()=>[se(i,{modelValue:t.filteredValue,"onUpdate:modelValue":e[0]||(e[0]=p=>t.filteredValue=p),class:P(t.ns.e("checkbox-group"))},{default:ce(()=>[(S(!0),E(lt,null,Gt(t.filters,p=>(S(),$e(a,{key:p.value,label:p.value},{default:ce(()=>[Yt(Ue(p.text),1)]),_:2},1032,["label"]))),128))]),_:1},8,["modelValue","class"])]),_:1},8,["wrap-class"])],2),I("div",{class:P(t.ns.e("bottom"))},[I("button",{class:P({[t.ns.is("disabled")]:t.filteredValue.length===0}),disabled:t.filteredValue.length===0,type:"button",onClick:e[1]||(e[1]=(...p)=>t.handleConfirm&&t.handleConfirm(...p))},Ue(t.t("el.table.confirmFilter")),11,nJe),I("button",{type:"button",onClick:e[2]||(e[2]=(...p)=>t.handleReset&&t.handleReset(...p))},Ue(t.t("el.table.resetFilter")),1)],2)])):(S(),E("ul",{key:1,class:P(t.ns.e("list"))},[I("li",{class:P([t.ns.e("list-item"),{[t.ns.is("active")]:t.filterValue===void 0||t.filterValue===null}]),onClick:e[3]||(e[3]=p=>t.handleSelect(null))},Ue(t.t("el.table.clearFilter")),3),(S(!0),E(lt,null,Gt(t.filters,p=>(S(),E("li",{key:p.value,class:P([t.ns.e("list-item"),t.ns.is("active",t.isActive(p))]),label:p.value,onClick:m=>t.handleSelect(p.value)},Ue(p.text),11,sJe))),128))],2))]),default:ce(()=>[St((S(),E("span",{class:P([`${t.ns.namespace.value}-table__column-filter-trigger`,`${t.ns.namespace.value}-none-outline`]),onClick:e[4]||(e[4]=(...p)=>t.showFilterPanel&&t.showFilterPanel(...p))},[se(d,null,{default:ce(()=>[t.column.filterOpened?(S(),$e(u,{key:0})):(S(),$e(c,{key:1}))]),_:1})],2)),[[h,t.hideFilterPanel,t.popperPaneRef]])]),_:1},8,["visible","placement","popper-class"])}var oJe=je(eJe,[["render",rJe],["__file","/home/runner/work/element-plus/element-plus/packages/components/table/src/filter-panel.vue"]]);function M7(t){const e=Rt();Xb(()=>{n.value.addObserver(e)}),It(()=>{s(n.value),r(n.value)}),Ml(()=>{s(n.value),r(n.value)}),Xd(()=>{n.value.removeObserver(e)});const n=A(()=>{const o=t.layout;if(!o)throw new Error("Can not find table layout.");return o}),s=o=>{var a;const i=((a=t.vnode.el)==null?void 0:a.querySelectorAll("colgroup > col"))||[];if(!i.length)return;const l=o.getFlattenColumns(),u={};l.forEach(c=>{u[c.id]=c});for(let c=0,d=i.length;c<d;c++){const f=i[c],h=f.getAttribute("name"),p=u[h];p&&f.setAttribute("width",p.realWidth||p.width)}},r=o=>{var a,i;const l=((a=t.vnode.el)==null?void 0:a.querySelectorAll("colgroup > col[name=gutter]"))||[];for(let c=0,d=l.length;c<d;c++)l[c].setAttribute("width",o.scrollY.value?o.gutterWidth:"0");const u=((i=t.vnode.el)==null?void 0:i.querySelectorAll("th.gutter"))||[];for(let c=0,d=u.length;c<d;c++){const f=u[c];f.style.width=o.scrollY.value?`${o.gutterWidth}px`:"0",f.style.display=o.scrollY.value?"":"none"}};return{tableLayout:n.value,onColumnsChange:s,onScrollableChange:r}}const Yi=Symbol("ElTable");function aJe(t,e){const n=Rt(),s=et(Yi),r=m=>{m.stopPropagation()},o=(m,g)=>{!g.filters&&g.sortable?p(m,g,!1):g.filterable&&!g.sortable&&r(m),s==null||s.emit("header-click",g,m)},a=(m,g)=>{s==null||s.emit("header-contextmenu",g,m)},i=U(null),l=U(!1),u=U({}),c=(m,g)=>{if(!!Kt&&!(g.children&&g.children.length>0)&&i.value&&t.border){l.value=!0;const y=s;e("set-drag-visible",!0);const b=(y==null?void 0:y.vnode.el).getBoundingClientRect().left,_=n.vnode.el.querySelector(`th.${g.id}`),$=_.getBoundingClientRect(),x=$.left-b+30;xi(_,"noclick"),u.value={startMouseLeft:m.clientX,startLeft:$.right-b,startColumnLeft:$.left-b,tableLeft:b};const k=y==null?void 0:y.refs.resizeProxy;k.style.left=`${u.value.startLeft}px`,document.onselectstart=function(){return!1},document.ondragstart=function(){return!1};const C=N=>{const M=N.clientX-u.value.startMouseLeft,R=u.value.startLeft+M;k.style.left=`${Math.max(x,R)}px`},T=()=>{if(l.value){const{startColumnLeft:N,startLeft:M}=u.value,D=Number.parseInt(k.style.left,10)-N;g.width=g.realWidth=D,y==null||y.emit("header-dragend",g.width,M-N,g,m),requestAnimationFrame(()=>{t.store.scheduleLayout(!1,!0)}),document.body.style.cursor="",l.value=!1,i.value=null,u.value={},e("set-drag-visible",!1)}document.removeEventListener("mousemove",C),document.removeEventListener("mouseup",T),document.onselectstart=null,document.ondragstart=null,setTimeout(()=>{mo(_,"noclick")},0)};document.addEventListener("mousemove",C),document.addEventListener("mouseup",T)}},d=(m,g)=>{var y;if(g.children&&g.children.length>0)return;const w=(y=m.target)==null?void 0:y.closest("th");if(!(!g||!g.resizable)&&!l.value&&t.border){const b=w.getBoundingClientRect(),_=document.body.style;b.width>12&&b.right-m.pageX<8?(_.cursor="col-resize",ja(w,"is-sortable")&&(w.style.cursor="col-resize"),i.value=g):l.value||(_.cursor="",ja(w,"is-sortable")&&(w.style.cursor="pointer"),i.value=null)}},f=()=>{!Kt||(document.body.style.cursor="")},h=({order:m,sortOrders:g})=>{if(m==="")return g[0];const y=g.indexOf(m||null);return g[y>g.length-2?0:y+1]},p=(m,g,y)=>{var w;m.stopPropagation();const b=g.order===y?null:y||h(g),_=(w=m.target)==null?void 0:w.closest("th");if(_&&ja(_,"noclick")){mo(_,"noclick");return}if(!g.sortable)return;const $=t.store.states;let x=$.sortProp.value,k;const C=$.sortingColumn.value;(C!==g||C===g&&C.order===null)&&(C&&(C.order=null),$.sortingColumn.value=g,x=g.property),b?k=g.order=b:k=g.order=null,$.sortProp.value=x,$.sortOrder.value=k,s==null||s.store.commit("changeSortCondition")};return{handleHeaderClick:o,handleHeaderContextMenu:a,handleMouseDown:c,handleMouseMove:d,handleMouseOut:f,handleSortClick:p,handleFilterClick:r}}function iJe(t){const e=et(Yi),n=Fe("table");return{getHeaderRowStyle:i=>{const l=e==null?void 0:e.props.headerRowStyle;return typeof l=="function"?l.call(null,{rowIndex:i}):l},getHeaderRowClass:i=>{const l=[],u=e==null?void 0:e.props.headerRowClassName;return typeof u=="string"?l.push(u):typeof u=="function"&&l.push(u.call(null,{rowIndex:i})),l.join(" ")},getHeaderCellStyle:(i,l,u,c)=>{var d;let f=(d=e==null?void 0:e.props.headerCellStyle)!=null?d:{};typeof f=="function"&&(f=f.call(null,{rowIndex:i,columnIndex:l,row:u,column:c}));const h=xk(l,c.fixed,t.store,u);return yh(h,"left"),yh(h,"right"),Object.assign({},f,h)},getHeaderCellClass:(i,l,u,c)=>{const d=$k(n.b(),l,c.fixed,t.store,u),f=[c.id,c.order,c.headerAlign,c.className,c.labelClassName,...d];c.children||f.push("is-leaf"),c.sortable&&f.push("is-sortable");const h=e==null?void 0:e.props.headerCellClassName;return typeof h=="string"?f.push(h):typeof h=="function"&&f.push(h.call(null,{rowIndex:i,columnIndex:l,row:u,column:c})),f.push(n.e("cell")),f.filter(p=>Boolean(p)).join(" ")}}}const P7=t=>{const e=[];return t.forEach(n=>{n.children?(e.push(n),e.push.apply(e,P7(n.children))):e.push(n)}),e},lJe=t=>{let e=1;const n=(o,a)=>{if(a&&(o.level=a.level+1,e<o.level&&(e=o.level)),o.children){let i=0;o.children.forEach(l=>{n(l,o),i+=l.colSpan}),o.colSpan=i}else o.colSpan=1};t.forEach(o=>{o.level=1,n(o,void 0)});const s=[];for(let o=0;o<e;o++)s.push([]);return P7(t).forEach(o=>{o.children?(o.rowSpan=1,o.children.forEach(a=>a.isSubColumn=!0)):o.rowSpan=e-o.level+1,s[o.level-1].push(o)}),s};function uJe(t){const e=et(Yi),n=A(()=>lJe(t.store.states.originColumns.value));return{isGroup:A(()=>{const o=n.value.length>1;return o&&e&&(e.state.isGroup.value=!0),o}),toggleAllSelection:o=>{o.stopPropagation(),e==null||e.store.commit("toggleAllSelection")},columnRows:n}}var cJe=ue({name:"ElTableHeader",components:{ElCheckbox:ka},props:{fixed:{type:String,default:""},store:{required:!0,type:Object},border:Boolean,defaultSort:{type:Object,default:()=>({prop:"",order:""})}},setup(t,{emit:e}){const n=Rt(),s=et(Yi),r=Fe("table"),o=U({}),{onColumnsChange:a,onScrollableChange:i}=M7(s);It(async()=>{await nt(),await nt();const{prop:x,order:k}=t.defaultSort;s==null||s.store.commit("sort",{prop:x,order:k,init:!0})});const{handleHeaderClick:l,handleHeaderContextMenu:u,handleMouseDown:c,handleMouseMove:d,handleMouseOut:f,handleSortClick:h,handleFilterClick:p}=aJe(t,e),{getHeaderRowStyle:m,getHeaderRowClass:g,getHeaderCellStyle:y,getHeaderCellClass:w}=iJe(t),{isGroup:b,toggleAllSelection:_,columnRows:$}=uJe(t);return n.state={onColumnsChange:a,onScrollableChange:i},n.filterPanels=o,{ns:r,filterPanels:o,onColumnsChange:a,onScrollableChange:i,columnRows:$,getHeaderRowClass:g,getHeaderRowStyle:m,getHeaderCellClass:w,getHeaderCellStyle:y,handleHeaderClick:l,handleHeaderContextMenu:u,handleMouseDown:c,handleMouseMove:d,handleMouseOut:f,handleSortClick:h,handleFilterClick:p,isGroup:b,toggleAllSelection:_}},render(){const{ns:t,isGroup:e,columnRows:n,getHeaderCellStyle:s,getHeaderCellClass:r,getHeaderRowClass:o,getHeaderRowStyle:a,handleHeaderClick:i,handleHeaderContextMenu:l,handleMouseDown:u,handleMouseMove:c,handleSortClick:d,handleMouseOut:f,store:h,$parent:p}=this;let m=1;return it("thead",{class:{[t.is("group")]:e}},n.map((g,y)=>it("tr",{class:o(y),key:y,style:a(y)},g.map((w,b)=>(w.rowSpan>m&&(m=w.rowSpan),it("th",{class:r(y,b,g,w),colspan:w.colSpan,key:`${w.id}-thead`,rowspan:w.rowSpan,style:s(y,b,g,w),onClick:_=>i(_,w),onContextmenu:_=>l(_,w),onMousedown:_=>u(_,w),onMousemove:_=>c(_,w),onMouseout:f},[it("div",{class:["cell",w.filteredValue&&w.filteredValue.length>0?"highlight":""]},[w.renderHeader?w.renderHeader({column:w,$index:b,store:h,_self:p}):w.label,w.sortable&&it("span",{onClick:_=>d(_,w),class:"caret-wrapper"},[it("i",{onClick:_=>d(_,w,"ascending"),class:"sort-caret ascending"}),it("i",{onClick:_=>d(_,w,"descending"),class:"sort-caret descending"})]),w.filterable&&it(oJe,{store:h,placement:w.filterPlacement||"bottom-start",column:w,upDataColumn:(_,$)=>{w[_]=$}})])]))))))}});function dJe(t){const e=et(Yi),n=U(""),s=U(it("div")),r=(f,h,p)=>{var m;const g=e,y=i$(f);let w;const b=(m=g==null?void 0:g.vnode.el)==null?void 0:m.dataset.prefix;y&&(w=mR({columns:t.store.states.columns.value},y,b),w&&(g==null||g.emit(`cell-${p}`,h,w,y,f))),g==null||g.emit(`row-${p}`,h,w,f)},o=(f,h)=>{r(f,h,"dblclick")},a=(f,h)=>{t.store.commit("setCurrentRow",h),r(f,h,"click")},i=(f,h)=>{r(f,h,"contextmenu")},l=Xr(f=>{t.store.commit("setHoverRow",f)},30),u=Xr(()=>{t.store.commit("setHoverRow",null)},30);return{handleDoubleClick:o,handleClick:a,handleContextMenu:i,handleMouseEnter:l,handleMouseLeave:u,handleCellMouseEnter:(f,h,p)=>{var m;const g=e,y=i$(f),w=(m=g==null?void 0:g.vnode.el)==null?void 0:m.dataset.prefix;if(y){const k=mR({columns:t.store.states.columns.value},y,w),C=g.hoverState={cell:y,column:k,row:h};g==null||g.emit("cell-mouse-enter",C.row,C.column,C.cell,f)}const b=f.target.querySelector(".cell");if(!(ja(b,`${w}-tooltip`)&&b.childNodes.length))return;const _=document.createRange();_.setStart(b,0),_.setEnd(b,b.childNodes.length);const $=Math.round(_.getBoundingClientRect().width),x=(Number.parseInt(dl(b,"paddingLeft"),10)||0)+(Number.parseInt(dl(b,"paddingRight"),10)||0);($+x>b.offsetWidth||b.scrollWidth>b.offsetWidth)&&WZe(e==null?void 0:e.refs.tableWrapper,y,y.innerText||y.textContent,{placement:"top",strategy:"fixed"},p)},handleCellMouseLeave:f=>{if(!i$(f))return;const p=e==null?void 0:e.hoverState;e==null||e.emit("cell-mouse-leave",p==null?void 0:p.row,p==null?void 0:p.column,p==null?void 0:p.cell,f)},tooltipContent:n,tooltipTrigger:s}}function fJe(t){const e=et(Yi),n=Fe("table");return{getRowStyle:(u,c)=>{const d=e==null?void 0:e.props.rowStyle;return typeof d=="function"?d.call(null,{row:u,rowIndex:c}):d||null},getRowClass:(u,c)=>{const d=[n.e("row")];(e==null?void 0:e.props.highlightCurrentRow)&&u===t.store.states.currentRow.value&&d.push("current-row"),t.stripe&&c%2===1&&d.push(n.em("row","striped"));const f=e==null?void 0:e.props.rowClassName;return typeof f=="string"?d.push(f):typeof f=="function"&&d.push(f.call(null,{row:u,rowIndex:c})),d},getCellStyle:(u,c,d,f)=>{const h=e==null?void 0:e.props.cellStyle;let p=h??{};typeof h=="function"&&(p=h.call(null,{rowIndex:u,columnIndex:c,row:d,column:f}));const m=xk(c,t==null?void 0:t.fixed,t.store);return yh(m,"left"),yh(m,"right"),Object.assign({},p,m)},getCellClass:(u,c,d,f,h)=>{const p=$k(n.b(),c,t==null?void 0:t.fixed,t.store,void 0,h),m=[f.id,f.align,f.className,...p],g=e==null?void 0:e.props.cellClassName;return typeof g=="string"?m.push(g):typeof g=="function"&&m.push(g.call(null,{rowIndex:u,columnIndex:c,row:d,column:f})),m.push(n.e("cell")),m.filter(y=>Boolean(y)).join(" ")},getSpan:(u,c,d,f)=>{let h=1,p=1;const m=e==null?void 0:e.props.spanMethod;if(typeof m=="function"){const g=m({row:u,column:c,rowIndex:d,columnIndex:f});Array.isArray(g)?(h=g[0],p=g[1]):typeof g=="object"&&(h=g.rowspan,p=g.colspan)}return{rowspan:h,colspan:p}},getColspanRealWidth:(u,c,d)=>{if(c<1)return u[d].realWidth;const f=u.map(({realWidth:h,width:p})=>h||p).slice(d,d+c);return Number(f.reduce((h,p)=>Number(h)+Number(p),-1))}}}function hJe(t){const e=et(Yi),n=Fe("table"),{handleDoubleClick:s,handleClick:r,handleContextMenu:o,handleMouseEnter:a,handleMouseLeave:i,handleCellMouseEnter:l,handleCellMouseLeave:u,tooltipContent:c,tooltipTrigger:d}=dJe(t),{getRowStyle:f,getRowClass:h,getCellStyle:p,getCellClass:m,getSpan:g,getColspanRealWidth:y}=fJe(t),w=A(()=>t.store.states.columns.value.findIndex(({type:k})=>k==="default")),b=(k,C)=>{const T=e.props.rowKey;return T?mr(k,T):C},_=(k,C,T,N=!1)=>{const{tooltipEffect:M,store:R}=t,{indent:D,columns:z}=R.states,B=h(k,C);let V=!0;return T&&(B.push(n.em("row",`level-${T.level}`)),V=T.display),it("tr",{style:[V?null:{display:"none"},f(k,C)],class:B,key:b(k,C),onDblclick:F=>s(F,k),onClick:F=>r(F,k),onContextmenu:F=>o(F,k),onMouseenter:()=>a(C),onMouseleave:i},z.value.map((F,L)=>{const{rowspan:G,colspan:Z}=g(k,F,C,L);if(!G||!Z)return null;const j={...F};j.realWidth=y(z.value,Z,L);const J={store:t.store,_self:t.context||e,column:j,row:k,$index:C,cellIndex:L,expanded:N};L===w.value&&T&&(J.treeNode={indent:T.level*D.value,level:T.level},typeof T.expanded=="boolean"&&(J.treeNode.expanded=T.expanded,"loading"in T&&(J.treeNode.loading=T.loading),"noLazyChildren"in T&&(J.treeNode.noLazyChildren=T.noLazyChildren)));const fe=`${C},${L}`,X=j.columnKey||j.rawColumnKey||"",oe=$(L,F,J);return it("td",{style:p(C,L,k,F),class:m(C,L,k,F,Z-1),key:`${X}${fe}`,rowspan:G,colspan:Z,onMouseenter:ee=>l(ee,k,M),onMouseleave:u},[oe])}))},$=(k,C,T)=>C.renderCell(T);return{wrappedRowRender:(k,C)=>{const T=t.store,{isRowExpanded:N,assertRowKey:M}=T,{treeData:R,lazyTreeNodeMap:D,childrenColumnName:z,rowKey:B}=T.states,V=T.states.columns.value;if(V.some(({type:F})=>F==="expand")){const F=N(k),L=_(k,C,void 0,F),G=e.renderExpanded;return F?G?[[L,it("tr",{key:`expanded-row__${L.key}`},[it("td",{colspan:V.length,class:`${n.e("cell")} ${n.e("expanded-cell")}`},[G({row:k,$index:C,store:T,expanded:F})])])]]:(console.error("[Element Error]renderExpanded is required."),L):[[L]]}else if(Object.keys(R.value).length){M();const F=mr(k,B.value);let L=R.value[F],G=null;L&&(G={expanded:L.expanded,level:L.level,display:!0},typeof L.lazy=="boolean"&&(typeof L.loaded=="boolean"&&L.loaded&&(G.noLazyChildren=!(L.children&&L.children.length)),G.loading=L.loading));const Z=[_(k,C,G)];if(L){let j=0;const J=(X,oe)=>{!(X&&X.length&&oe)||X.forEach(ee=>{const Q={display:oe.display&&oe.expanded,level:oe.level+1,expanded:!1,noLazyChildren:!1,loading:!1},ie=mr(ee,B.value);if(ie==null)throw new Error("For nested data item, row-key is required.");if(L={...R.value[ie]},L&&(Q.expanded=L.expanded,L.level=L.level||Q.level,L.display=!!(L.expanded&&Q.display),typeof L.lazy=="boolean"&&(typeof L.loaded=="boolean"&&L.loaded&&(Q.noLazyChildren=!(L.children&&L.children.length)),Q.loading=L.loading)),j++,Z.push(_(ee,C+j,Q)),L){const pe=D.value[ie]||ee[z.value];J(pe,L)}})};L.display=!0;const fe=D.value[F]||k[z.value];J(fe,L)}return Z}else return _(k,C,void 0)},tooltipContent:c,tooltipTrigger:d}}const pJe={store:{required:!0,type:Object},stripe:Boolean,tooltipEffect:String,context:{default:()=>({}),type:Object},rowClassName:[String,Function],rowStyle:[Object,Function],fixed:{type:String,default:""},highlight:Boolean};var mJe=ue({name:"ElTableBody",props:pJe,setup(t){const e=Rt(),n=et(Yi),s=Fe("table"),{wrappedRowRender:r,tooltipContent:o,tooltipTrigger:a}=hJe(t),{onColumnsChange:i,onScrollableChange:l}=M7(n);return Me(t.store.states.hoverRow,(u,c)=>{if(!t.store.states.isComplex.value||!Kt)return;let d=window.requestAnimationFrame;d||(d=f=>window.setTimeout(f,16)),d(()=>{const f=e==null?void 0:e.vnode.el,h=Array.from((f==null?void 0:f.children)||[]).filter(g=>g==null?void 0:g.classList.contains(`${s.e("row")}`)),p=h[c],m=h[u];p&&mo(p,"hover-row"),m&&xi(m,"hover-row")})}),Xd(()=>{var u;(u=nl)==null||u()}),{ns:s,onColumnsChange:i,onScrollableChange:l,wrappedRowRender:r,tooltipContent:o,tooltipTrigger:a}},render(){const{wrappedRowRender:t,store:e}=this,n=e.states.data.value||[];return it("tbody",{},[n.reduce((s,r)=>s.concat(t(r,s.length)),[])])}});function Sk(t){const e=t.tableLayout==="auto";let n=t.columns||[];e&&n.every(r=>r.width===void 0)&&(n=[]);const s=r=>{const o={key:`${t.tableLayout}_${r.id}`,style:{},name:void 0};return e?o.style={width:`${r.width}px`}:o.name=r.id,o};return it("colgroup",{},n.map(r=>it("col",s(r))))}Sk.props=["columns","tableLayout"];function gJe(){const t=et(Yi),e=t==null?void 0:t.store,n=A(()=>e.states.fixedLeafColumnsLength.value),s=A(()=>e.states.rightFixedColumns.value.length),r=A(()=>e.states.columns.value.length),o=A(()=>e.states.fixedColumns.value.length),a=A(()=>e.states.rightFixedColumns.value.length);return{leftFixedLeafCount:n,rightFixedLeafCount:s,columnsCount:r,leftFixedCount:o,rightFixedCount:a,columns:e.states.columns}}function vJe(t){const{columns:e}=gJe(),n=Fe("table");return{getCellClasses:(o,a)=>{const i=o[a],l=[n.e("cell"),i.id,i.align,i.labelClassName,...$k(n.b(),a,i.fixed,t.store)];return i.className&&l.push(i.className),i.children||l.push(n.is("leaf")),l},getCellStyles:(o,a)=>{const i=xk(a,o.fixed,t.store);return yh(i,"left"),yh(i,"right"),i},columns:e}}var yJe=ue({name:"ElTableFooter",props:{fixed:{type:String,default:""},store:{required:!0,type:Object},summaryMethod:Function,sumText:String,border:Boolean,defaultSort:{type:Object,default:()=>({prop:"",order:""})}},setup(t){const{getCellClasses:e,getCellStyles:n,columns:s}=vJe(t);return{ns:Fe("table"),getCellClasses:e,getCellStyles:n,columns:s}},render(){const{columns:t,getCellStyles:e,getCellClasses:n,summaryMethod:s,sumText:r,ns:o}=this,a=this.store.states.data.value;let i=[];return s?i=s({columns:t,data:a}):t.forEach((l,u)=>{if(u===0){i[u]=r;return}const c=a.map(p=>Number(p[l.property])),d=[];let f=!0;c.forEach(p=>{if(!Number.isNaN(+p)){f=!1;const m=`${p}`.split(".")[1];d.push(m?m.length:0)}});const h=Math.max.apply(null,d);f?i[u]="":i[u]=c.reduce((p,m)=>{const g=Number(m);return Number.isNaN(+g)?p:Number.parseFloat((p+m).toFixed(Math.min(h,20)))},0)}),it("table",{class:o.e("footer"),cellspacing:"0",cellpadding:"0",border:"0"},[Sk({columns:t}),it("tbody",[it("tr",{},[...t.map((l,u)=>it("td",{key:u,colspan:l.colSpan,rowspan:l.rowSpan,class:n(t,u),style:e(l,u)},[it("div",{class:["cell",l.labelClassName]},[i[u]])]))])])])}});function bJe(t){return{setCurrentRow:c=>{t.commit("setCurrentRow",c)},getSelectionRows:()=>t.getSelectionRows(),toggleRowSelection:(c,d)=>{t.toggleRowSelection(c,d,!1),t.updateAllSelected()},clearSelection:()=>{t.clearSelection()},clearFilter:c=>{t.clearFilter(c)},toggleAllSelection:()=>{t.commit("toggleAllSelection")},toggleRowExpansion:(c,d)=>{t.toggleRowExpansionAdapter(c,d)},clearSort:()=>{t.clearSort()},sort:(c,d)=>{t.commit("sort",{prop:c,order:d})}}}function wJe(t,e,n,s){const r=U(!1),o=U(null),a=U(!1),i=F=>{a.value=F},l=U({width:null,height:null,headerHeight:null}),u=U(!1),c={display:"inline-block",verticalAlign:"middle"},d=U(),f=U(0),h=U(0),p=U(0),m=U(0);Ho(()=>{e.setHeight(t.height)}),Ho(()=>{e.setMaxHeight(t.maxHeight)}),Me(()=>[t.currentRowKey,n.states.rowKey],([F,L])=>{!v(L)||!v(F)||n.setCurrentRowKey(`${F}`)},{immediate:!0}),Me(()=>t.data,F=>{s.store.commit("setData",F)},{immediate:!0,deep:!0}),Ho(()=>{t.expandRowKeys&&n.setExpandRowKeysAdapter(t.expandRowKeys)});const g=()=>{s.store.commit("setHoverRow",null),s.hoverState&&(s.hoverState=null)},y=(F,L)=>{const{pixelX:G,pixelY:Z}=L;Math.abs(G)>=Math.abs(Z)&&(s.refs.bodyWrapper.scrollLeft+=L.pixelX/5)},w=A(()=>t.height||t.maxHeight||n.states.fixedColumns.value.length>0||n.states.rightFixedColumns.value.length>0),b=A(()=>({width:e.bodyWidth.value?`${e.bodyWidth.value}px`:""})),_=()=>{w.value&&e.updateElsHeight(),e.updateColumnsWidth(),requestAnimationFrame(C)};It(async()=>{await nt(),n.updateColumns(),T(),requestAnimationFrame(_);const F=s.vnode.el,L=s.refs.headerWrapper;t.flexible&&F&&F.parentElement&&(F.parentElement.style.minWidth="0"),l.value={width:d.value=F.offsetWidth,height:F.offsetHeight,headerHeight:t.showHeader&&L?L.offsetHeight:null},n.states.columns.value.forEach(G=>{G.filteredValue&&G.filteredValue.length&&s.store.commit("filterChange",{column:G,values:G.filteredValue,silent:!0})}),s.$ready=!0});const $=(F,L)=>{if(!F)return;const G=Array.from(F.classList).filter(Z=>!Z.startsWith("is-scrolling-"));G.push(e.scrollX.value?L:"is-scrolling-none"),F.className=G.join(" ")},x=F=>{const{tableWrapper:L}=s.refs;$(L,F)},k=F=>{const{tableWrapper:L}=s.refs;return!!(L&&L.classList.contains(F))},C=function(){if(!s.refs.scrollBarRef)return;if(!e.scrollX.value){const X="is-scrolling-none";k(X)||x(X);return}const F=s.refs.scrollBarRef.wrapRef;if(!F)return;const{scrollLeft:L,offsetWidth:G,scrollWidth:Z}=F,{headerWrapper:j,footerWrapper:J}=s.refs;j&&(j.scrollLeft=L),J&&(J.scrollLeft=L);const fe=Z-G-1;L>=fe?x("is-scrolling-right"):x(L===0?"is-scrolling-left":"is-scrolling-middle")},T=()=>{!s.refs.scrollBarRef||(s.refs.scrollBarRef.wrapRef&&Rn(s.refs.scrollBarRef.wrapRef,"scroll",C,{passive:!0}),t.fit?Dr(s.vnode.el,N):Rn(window,"resize",N),Dr(s.refs.bodyWrapper,()=>{var F,L;N(),(L=(F=s.refs)==null?void 0:F.scrollBarRef)==null||L.update()}))},N=()=>{var F,L,G;const Z=s.vnode.el;if(!s.$ready||!Z)return;let j=!1;const{width:J,height:fe,headerHeight:X}=l.value,oe=d.value=Z.offsetWidth;J!==oe&&(j=!0);const ee=Z.offsetHeight;(t.height||w.value)&&fe!==ee&&(j=!0);const Q=t.tableLayout==="fixed"?s.refs.headerWrapper:(F=s.refs.tableHeaderRef)==null?void 0:F.$el;t.showHeader&&(Q==null?void 0:Q.offsetHeight)!==X&&(j=!0),f.value=((L=s.refs.tableWrapper)==null?void 0:L.scrollHeight)||0,p.value=(Q==null?void 0:Q.scrollHeight)||0,m.value=((G=s.refs.footerWrapper)==null?void 0:G.offsetHeight)||0,h.value=f.value-p.value-m.value,j&&(l.value={width:oe,height:ee,headerHeight:t.showHeader&&(Q==null?void 0:Q.offsetHeight)||0},_())},M=ks(),R=A(()=>{const{bodyWidth:F,scrollY:L,gutterWidth:G}=e;return F.value?`${F.value-(L.value?G:0)}px`:""}),D=A(()=>t.maxHeight?"fixed":t.tableLayout),z=A(()=>{if(t.data&&t.data.length)return null;let F="100%";t.height&&h.value&&(F=`${h.value}px`);const L=d.value;return{width:L?`${L}px`:"",height:F}}),B=A(()=>t.height?{height:Number.isNaN(Number(t.height))?t.height:`${t.height}px`}:t.maxHeight?{maxHeight:Number.isNaN(Number(t.maxHeight))?t.maxHeight:`${t.maxHeight}px`}:{}),V=A(()=>{if(t.height)return{height:"100%"};if(t.maxHeight){if(Number.isNaN(Number(t.maxHeight)))return{maxHeight:`calc(${t.maxHeight} - ${p.value+m.value}px)`};{const F=t.maxHeight;if(f.value>=Number(F))return{maxHeight:`${f.value-p.value-m.value}px`}}}return{}});return{isHidden:r,renderExpanded:o,setDragVisible:i,isGroup:u,handleMouseLeave:g,handleHeaderFooterMousewheel:y,tableSize:M,emptyBlockStyle:z,handleFixedMousewheel:(F,L)=>{const G=s.refs.bodyWrapper;if(Math.abs(L.spinY)>0){const Z=G.scrollTop;L.pixelY<0&&Z!==0&&F.preventDefault(),L.pixelY>0&&G.scrollHeight-G.clientHeight>Z&&F.preventDefault(),G.scrollTop+=Math.ceil(L.pixelY/5)}else G.scrollLeft+=Math.ceil(L.pixelX/5)},resizeProxyVisible:a,bodyWidth:R,resizeState:l,doLayout:_,tableBodyStyles:b,tableLayout:D,scrollbarViewStyle:c,tableInnerStyle:B,scrollbarStyle:V}}var _Je={data:{type:Array,default:()=>[]},size:String,width:[String,Number],height:[String,Number],maxHeight:[String,Number],fit:{type:Boolean,default:!0},stripe:Boolean,border:Boolean,rowKey:[String,Function],showHeader:{type:Boolean,default:!0},showSummary:Boolean,sumText:String,summaryMethod:Function,rowClassName:[String,Function],rowStyle:[Object,Function],cellClassName:[String,Function],cellStyle:[Object,Function],headerRowClassName:[String,Function],headerRowStyle:[Object,Function],headerCellClassName:[String,Function],headerCellStyle:[Object,Function],highlightCurrentRow:Boolean,currentRowKey:[String,Number],emptyText:String,expandRowKeys:Array,defaultExpandAll:Boolean,defaultSort:Object,tooltipEffect:String,spanMethod:Function,selectOnIndeterminate:{type:Boolean,default:!0},indent:{type:Number,default:16},treeProps:{type:Object,default:()=>({hasChildren:"hasChildren",children:"children"})},lazy:Boolean,load:Function,style:{type:Object,default:()=>({})},className:{type:String,default:""},tableLayout:{type:String,default:"fixed"},scrollbarAlwaysOn:{type:Boolean,default:!1},flexible:Boolean};const $Je=()=>{const t=U(),e=(o,a)=>{const i=t.value;i&&i.scrollTo(o,a)},n=(o,a)=>{const i=t.value;i&&Ct(a)&&["Top","Left"].includes(o)&&i[`setScroll${o}`](a)};return{scrollBarRef:t,scrollTo:e,setScrollTop:o=>n("Top",o),setScrollLeft:o=>n("Left",o)}};let xJe=1;const SJe=ue({name:"ElTable",directives:{Mousewheel:qze},components:{TableHeader:cJe,TableBody:mJe,TableFooter:yJe,ElScrollbar:jl,hColgroup:Sk},props:_Je,emits:["select","select-all","selection-change","cell-mouse-enter","cell-mouse-leave","cell-contextmenu","cell-click","cell-dblclick","row-click","row-contextmenu","row-dblclick","header-click","header-contextmenu","sort-change","filter-change","current-change","header-dragend","expand-change"],setup(t){const{t:e}=nn(),n=Fe("table"),s=Rt();Lt(Yi,s);const r=YZe(s,t);s.store=r;const o=new JZe({store:s.store,table:s,fit:t.fit,showHeader:t.showHeader});s.layout=o;const a=A(()=>(r.states.data.value||[]).length===0),{setCurrentRow:i,getSelectionRows:l,toggleRowSelection:u,clearSelection:c,clearFilter:d,toggleAllSelection:f,toggleRowExpansion:h,clearSort:p,sort:m}=bJe(r),{isHidden:g,renderExpanded:y,setDragVisible:w,isGroup:b,handleMouseLeave:_,handleHeaderFooterMousewheel:$,tableSize:x,emptyBlockStyle:k,handleFixedMousewheel:C,resizeProxyVisible:T,bodyWidth:N,resizeState:M,doLayout:R,tableBodyStyles:D,tableLayout:z,scrollbarViewStyle:B,tableInnerStyle:V,scrollbarStyle:O}=wJe(t,o,r,s),{scrollBarRef:F,scrollTo:L,setScrollLeft:G,setScrollTop:Z}=$Je(),j=Xr(R,50),J=`${n.namespace.value}-table_${xJe++}`;s.tableId=J,s.state={isGroup:b,resizeState:M,doLayout:R,debouncedUpdateLayout:j};const fe=A(()=>t.sumText||e("el.table.sumText")),X=A(()=>t.emptyText||e("el.table.emptyText"));return{ns:n,layout:o,store:r,handleHeaderFooterMousewheel:$,handleMouseLeave:_,tableId:J,tableSize:x,isHidden:g,isEmpty:a,renderExpanded:y,resizeProxyVisible:T,resizeState:M,isGroup:b,bodyWidth:N,tableBodyStyles:D,emptyBlockStyle:k,debouncedUpdateLayout:j,handleFixedMousewheel:C,setCurrentRow:i,getSelectionRows:l,toggleRowSelection:u,clearSelection:c,clearFilter:d,toggleAllSelection:f,toggleRowExpansion:h,clearSort:p,doLayout:R,sort:m,t:e,setDragVisible:w,context:s,computedSumText:fe,computedEmptyText:X,tableLayout:z,scrollbarViewStyle:B,tableInnerStyle:V,scrollbarStyle:O,scrollBarRef:F,scrollTo:L,setScrollLeft:G,setScrollTop:Z}}}),CJe=["data-prefix"],kJe={ref:"hiddenColumns",class:"hidden-columns"};function TJe(t,e,n,s,r,o){const a=pt("hColgroup"),i=pt("table-header"),l=pt("table-body"),u=pt("el-scrollbar"),c=pt("table-footer"),d=rh("mousewheel");return S(),E("div",{ref:"tableWrapper",class:P([{[t.ns.m("fit")]:t.fit,[t.ns.m("striped")]:t.stripe,[t.ns.m("border")]:t.border||t.isGroup,[t.ns.m("hidden")]:t.isHidden,[t.ns.m("group")]:t.isGroup,[t.ns.m("fluid-height")]:t.maxHeight,[t.ns.m("scrollable-x")]:t.layout.scrollX.value,[t.ns.m("scrollable-y")]:t.layout.scrollY.value,[t.ns.m("enable-row-hover")]:!t.store.states.isComplex.value,[t.ns.m("enable-row-transition")]:(t.store.states.data.value||[]).length!==0&&(t.store.states.data.value||[]).length<100,"has-footer":t.showSummary},t.ns.m(t.tableSize),t.className,t.ns.b(),t.ns.m(`layout-${t.tableLayout}`)]),style:ot(t.style),"data-prefix":t.ns.namespace.value,onMouseleave:e[0]||(e[0]=f=>t.handleMouseLeave())},[I("div",{class:P(t.ns.e("inner-wrapper")),style:ot(t.tableInnerStyle)},[I("div",kJe,[Oe(t.$slots,"default")],512),t.showHeader&&t.tableLayout==="fixed"?St((S(),E("div",{key:0,ref:"headerWrapper",class:P(t.ns.e("header-wrapper"))},[I("table",{ref:"tableHeader",class:P(t.ns.e("header")),style:ot(t.tableBodyStyles),border:"0",cellpadding:"0",cellspacing:"0"},[se(a,{columns:t.store.states.columns.value,"table-layout":t.tableLayout},null,8,["columns","table-layout"]),se(i,{ref:"tableHeaderRef",border:t.border,"default-sort":t.defaultSort,store:t.store,onSetDragVisible:t.setDragVisible},null,8,["border","default-sort","store","onSetDragVisible"])],6)],2)),[[d,t.handleHeaderFooterMousewheel]]):ge("v-if",!0),I("div",{ref:"bodyWrapper",class:P(t.ns.e("body-wrapper"))},[se(u,{ref:"scrollBarRef","view-style":t.scrollbarViewStyle,"wrap-style":t.scrollbarStyle,always:t.scrollbarAlwaysOn},{default:ce(()=>[I("table",{ref:"tableBody",class:P(t.ns.e("body")),cellspacing:"0",cellpadding:"0",border:"0",style:ot({width:t.bodyWidth,tableLayout:t.tableLayout})},[se(a,{columns:t.store.states.columns.value,"table-layout":t.tableLayout},null,8,["columns","table-layout"]),t.showHeader&&t.tableLayout==="auto"?(S(),$e(i,{key:0,ref:"tableHeaderRef",border:t.border,"default-sort":t.defaultSort,store:t.store,onSetDragVisible:t.setDragVisible},null,8,["border","default-sort","store","onSetDragVisible"])):ge("v-if",!0),se(l,{context:t.context,highlight:t.highlightCurrentRow,"row-class-name":t.rowClassName,"tooltip-effect":t.tooltipEffect,"row-style":t.rowStyle,store:t.store,stripe:t.stripe},null,8,["context","highlight","row-class-name","tooltip-effect","row-style","store","stripe"])],6),t.isEmpty?(S(),E("div",{key:0,ref:"emptyBlock",style:ot(t.emptyBlockStyle),class:P(t.ns.e("empty-block"))},[I("span",{class:P(t.ns.e("empty-text"))},[Oe(t.$slots,"empty",{},()=>[Yt(Ue(t.computedEmptyText),1)])],2)],6)):ge("v-if",!0),t.$slots.append?(S(),E("div",{key:1,ref:"appendWrapper",class:P(t.ns.e("append-wrapper"))},[Oe(t.$slots,"append")],2)):ge("v-if",!0)]),_:3},8,["view-style","wrap-style","always"])],2),t.showSummary?St((S(),E("div",{key:1,ref:"footerWrapper",class:P(t.ns.e("footer-wrapper"))},[se(c,{border:t.border,"default-sort":t.defaultSort,store:t.store,style:ot(t.tableBodyStyles),"sum-text":t.computedSumText,"summary-method":t.summaryMethod},null,8,["border","default-sort","store","style","sum-text","summary-method"])],2)),[[Qt,!t.isEmpty],[d,t.handleHeaderFooterMousewheel]]):ge("v-if",!0),t.border||t.isGroup?(S(),E("div",{key:2,class:P(t.ns.e("border-left-patch"))},null,2)):ge("v-if",!0)],6),St(I("div",{ref:"resizeProxy",class:P(t.ns.e("column-resize-proxy"))},null,2),[[Qt,t.resizeProxyVisible]])],46,CJe)}var NJe=je(SJe,[["render",TJe],["__file","/home/runner/work/element-plus/element-plus/packages/components/table/src/table.vue"]]);const IJe={selection:"table-column--selection",expand:"table__expand-column"},EJe={default:{order:""},selection:{width:48,minWidth:48,realWidth:48,order:""},expand:{width:48,minWidth:48,realWidth:48,order:""},index:{width:48,minWidth:48,realWidth:48,order:""}},AJe=t=>IJe[t]||"",OJe={selection:{renderHeader({store:t}){function e(){return t.states.data.value&&t.states.data.value.length===0}return it(ka,{disabled:e(),size:t.states.tableSize.value,indeterminate:t.states.selection.value.length>0&&!t.states.isAllSelected.value,"onUpdate:modelValue":t.toggleAllSelection,modelValue:t.states.isAllSelected.value})},renderCell({row:t,column:e,store:n,$index:s}){return it(ka,{disabled:e.selectable?!e.selectable.call(null,t,s):!1,size:n.states.tableSize.value,onChange:()=>{n.commit("rowSelectedChanged",t)},onClick:r=>r.stopPropagation(),modelValue:n.isSelected(t)})},sortable:!1,resizable:!1},index:{renderHeader({column:t}){return t.label||"#"},renderCell({column:t,$index:e}){let n=e+1;const s=t.index;return typeof s=="number"?n=e+s:typeof s=="function"&&(n=s(e)),it("div",{},[n])},sortable:!1},expand:{renderHeader({column:t}){return t.label||""},renderCell({row:t,store:e,expanded:n}){const{ns:s}=e,r=[s.e("expand-icon")];return n&&r.push(s.em("expand-icon","expanded")),it("div",{class:r,onClick:function(a){a.stopPropagation(),e.toggleRowExpansion(t)}},{default:()=>[it(rt,null,{default:()=>[it(Rr)]})]})},sortable:!1,resizable:!1}};function RJe({row:t,column:e,$index:n}){var s;const r=e.property,o=r&&Wv(t,r).value;return e&&e.formatter?e.formatter(t,e,o,n):((s=o==null?void 0:o.toString)==null?void 0:s.call(o))||""}function DJe({row:t,treeNode:e,store:n},s=!1){const{ns:r}=n;if(!e)return s?[it("span",{class:r.e("placeholder")})]:null;const o=[],a=function(i){i.stopPropagation(),!e.loading&&n.loadOrToggle(t)};if(e.indent&&o.push(it("span",{class:r.e("indent"),style:{"padding-left":`${e.indent}px`}})),typeof e.expanded=="boolean"&&!e.noLazyChildren){const i=[r.e("expand-icon"),e.expanded?r.em("expand-icon","expanded"):""];let l=Rr;e.loading&&(l=Vl),o.push(it("div",{class:i,onClick:a},{default:()=>[it(rt,{class:{[r.is("loading")]:e.loading}},{default:()=>[it(l)]})]}))}else o.push(it("span",{class:r.e("placeholder")}));return o}function yR(t,e){return t.reduce((n,s)=>(n[s]=s,n),e)}function FJe(t,e){const n=Rt();return{registerComplexWatchers:()=>{const o=["fixed"],a={realWidth:"width",realMinWidth:"minWidth"},i=yR(o,a);Object.keys(i).forEach(l=>{const u=a[l];Ut(e,u)&&Me(()=>e[u],c=>{let d=c;u==="width"&&l==="realWidth"&&(d=_k(c)),u==="minWidth"&&l==="realMinWidth"&&(d=E7(c)),n.columnConfig.value[u]=d,n.columnConfig.value[l]=d;const f=u==="fixed";t.value.store.scheduleLayout(f)})})},registerNormalWatchers:()=>{const o=["label","filters","filterMultiple","sortable","index","formatter","className","labelClassName","showOverflowTooltip"],a={property:"prop",align:"realAlign",headerAlign:"realHeaderAlign"},i=yR(o,a);Object.keys(i).forEach(l=>{const u=a[l];Ut(e,u)&&Me(()=>e[u],c=>{n.columnConfig.value[l]=c})})}}}function MJe(t,e,n){const s=Rt(),r=U(""),o=U(!1),a=U(),i=U(),l=Fe("table");Ho(()=>{a.value=t.align?`is-${t.align}`:null,a.value}),Ho(()=>{i.value=t.headerAlign?`is-${t.headerAlign}`:a.value,i.value});const u=A(()=>{let b=s.vnode.vParent||s.parent;for(;b&&!b.tableId&&!b.columnId;)b=b.vnode.vParent||b.parent;return b}),c=A(()=>{const{store:b}=s.parent;if(!b)return!1;const{treeData:_}=b.states,$=_.value;return $&&Object.keys($).length>0}),d=U(_k(t.width)),f=U(E7(t.minWidth)),h=b=>(d.value&&(b.width=d.value),f.value&&(b.minWidth=f.value),!d.value&&f.value&&(b.width=void 0),b.minWidth||(b.minWidth=80),b.realWidth=Number(b.width===void 0?b.minWidth:b.width),b),p=b=>{const _=b.type,$=OJe[_]||{};Object.keys($).forEach(k=>{const C=$[k];k!=="className"&&C!==void 0&&(b[k]=C)});const x=AJe(_);if(x){const k=`${v(l.namespace)}-${x}`;b.className=b.className?`${b.className} ${k}`:k}return b},m=b=>{Array.isArray(b)?b.forEach($=>_($)):_(b);function _($){var x;((x=$==null?void 0:$.type)==null?void 0:x.name)==="ElTableColumn"&&($.vParent=s)}};return{columnId:r,realAlign:a,isSubColumn:o,realHeaderAlign:i,columnOrTableParent:u,setColumnWidth:h,setColumnForcedProps:p,setColumnRenders:b=>{t.renderHeader||b.type!=="selection"&&(b.renderHeader=$=>{s.columnConfig.value.label;const x=e.header;return x?x($):b.label});let _=b.renderCell;return b.type==="expand"?(b.renderCell=$=>it("div",{class:"cell"},[_($)]),n.value.renderExpanded=$=>e.default?e.default($):e.default):(_=_||RJe,b.renderCell=$=>{let x=null;if(e.default){const N=e.default($);x=N.some(M=>M.type!==Gr)?N:_($)}else x=_($);const k=c.value&&$.cellIndex===0&&$.column.type!=="selection",C=DJe($,k),T={class:"cell",style:{}};return b.showOverflowTooltip&&(T.class=`${T.class} ${v(l.namespace)}-tooltip`,T.style={width:`${($.column.realWidth||Number($.column.width))-1}px`}),m(x),it("div",T,[C,x])}),b},getPropsData:(...b)=>b.reduce((_,$)=>(Array.isArray($)&&$.forEach(x=>{_[x]=t[x]}),_),{}),getColumnElIndex:(b,_)=>Array.prototype.indexOf.call(b,_)}}var PJe={type:{type:String,default:"default"},label:String,className:String,labelClassName:String,property:String,prop:String,width:{type:[String,Number],default:""},minWidth:{type:[String,Number],default:""},renderHeader:Function,sortable:{type:[Boolean,String],default:!1},sortMethod:Function,sortBy:[String,Function,Array],resizable:{type:Boolean,default:!0},columnKey:String,align:String,headerAlign:String,showTooltipWhenOverflow:Boolean,showOverflowTooltip:Boolean,fixed:[Boolean,String],formatter:Function,selectable:Function,reserveSelection:Boolean,filterMethod:Function,filteredValue:Array,filters:Array,filterPlacement:String,filterMultiple:{type:Boolean,default:!0},index:[Number,Function],sortOrders:{type:Array,default:()=>["ascending","descending",null],validator:t=>t.every(e=>["ascending","descending",null].includes(e))}};let LJe=1;var L7=ue({name:"ElTableColumn",components:{ElCheckbox:ka},props:PJe,setup(t,{slots:e}){const n=Rt(),s=U({}),r=A(()=>{let w=n.parent;for(;w&&!w.tableId;)w=w.parent;return w}),{registerNormalWatchers:o,registerComplexWatchers:a}=FJe(r,t),{columnId:i,isSubColumn:l,realHeaderAlign:u,columnOrTableParent:c,setColumnWidth:d,setColumnForcedProps:f,setColumnRenders:h,getPropsData:p,getColumnElIndex:m,realAlign:g}=MJe(t,e,r),y=c.value;i.value=`${y.tableId||y.columnId}_column_${LJe++}`,Xb(()=>{l.value=r.value!==y;const w=t.type||"default",b=t.sortable===""?!0:t.sortable,_={...EJe[w],id:i.value,type:w,property:t.prop||t.property,align:g,headerAlign:u,showOverflowTooltip:t.showOverflowTooltip||t.showTooltipWhenOverflow,filterable:t.filters||t.filterMethod,filteredValue:[],filterPlacement:"",isColumnGroup:!1,isSubColumn:!1,filterOpened:!1,sortable:b,index:t.index,rawColumnKey:n.vnode.key};let T=p(["columnKey","label","className","labelClassName","type","renderHeader","formatter","fixed","resizable"],["sortMethod","sortBy","sortOrders"],["selectable","reserveSelection"],["filterMethod","filters","filterMultiple","filterOpened","filteredValue","filterPlacement"]);T=zZe(_,T),T=VZe(h,d,f)(T),s.value=T,o(),a()}),It(()=>{var w;const b=c.value,_=l.value?b.vnode.el.children:(w=b.refs.hiddenColumns)==null?void 0:w.children,$=()=>m(_||[],n.vnode.el);s.value.getColumnIndex=$,$()>-1&&r.value.store.commit("insertColumn",s.value,l.value?b.columnConfig.value:null)}),ts(()=>{r.value.store.commit("removeColumn",s.value,l.value?y.columnConfig.value:null)}),n.columnId=i.value,n.columnConfig=s},render(){var t,e,n;try{const s=(e=(t=this.$slots).default)==null?void 0:e.call(t,{row:{},column:{},$index:-1}),r=[];if(Array.isArray(s))for(const a of s)((n=a.type)==null?void 0:n.name)==="ElTableColumn"||a.shapeFlag&2?r.push(a):a.type===lt&&Array.isArray(a.children)&&a.children.forEach(i=>{(i==null?void 0:i.patchFlag)!==1024&&!wt(i==null?void 0:i.children)&&r.push(i)});return it("div",r)}catch{return it("div",[])}}});const zJe=Dt(NJe,{TableColumn:L7}),BJe=ns(L7);var j0=(t=>(t.ASC="asc",t.DESC="desc",t))(j0||{}),K0=(t=>(t.CENTER="center",t.RIGHT="right",t))(K0||{}),z7=(t=>(t.LEFT="left",t.RIGHT="right",t))(z7||{});const X6={asc:"desc",desc:"asc"},q0=Symbol("placeholder"),VJe=(t,e,n)=>{var s;const r={flexGrow:0,flexShrink:0,...n?{}:{flexGrow:t.flexGrow||0,flexShrink:t.flexShrink||1}};n||(r.flexShrink=1);const o={...(s=t.style)!=null?s:{},...r,flexBasis:"auto",width:t.width};return e||(t.maxWidth&&(o.maxWidth=t.maxWidth),t.minWidth&&(o.minWidth=t.minWidth)),o};function HJe(t,e,n){const s=A(()=>v(e).filter(m=>!m.hidden)),r=A(()=>v(s).filter(m=>m.fixed==="left"||m.fixed===!0)),o=A(()=>v(s).filter(m=>m.fixed==="right")),a=A(()=>v(s).filter(m=>!m.fixed)),i=A(()=>{const m=[];return v(r).forEach(g=>{m.push({...g,placeholderSign:q0})}),v(a).forEach(g=>{m.push(g)}),v(o).forEach(g=>{m.push({...g,placeholderSign:q0})}),m}),l=A(()=>v(r).length||v(o).length),u=A(()=>v(e).reduce((g,y)=>(g[y.key]=VJe(y,v(n),t.fixed),g),{})),c=A(()=>v(s).reduce((m,g)=>m+g.width,0)),d=m=>v(e).find(g=>g.key===m),f=m=>v(u)[m],h=(m,g)=>{m.width=g};function p(m){var g;const{key:y}=m.currentTarget.dataset;if(!y)return;const{sortState:w,sortBy:b}=t;let _=j0.ASC;Bt(w)?_=X6[w[y]]:_=X6[b.order],(g=t.onColumnSort)==null||g.call(t,{column:d(y),key:y,order:_})}return{columns:e,columnsStyles:u,columnsTotalWidth:c,fixedColumnsOnLeft:r,fixedColumnsOnRight:o,hasFixedColumns:l,mainColumns:i,normalColumns:a,visibleColumns:s,getColumn:d,getColumnStyle:f,updateColumnWidth:h,onColumnSorted:p}}const WJe=(t,{mainTableRef:e,leftTableRef:n,rightTableRef:s,onMaybeEndReached:r})=>{const o=U({scrollLeft:0,scrollTop:0});function a(h){var p,m,g;const{scrollTop:y}=h;(p=e.value)==null||p.scrollTo(h),(m=n.value)==null||m.scrollToTop(y),(g=s.value)==null||g.scrollToTop(y)}function i(h){o.value=h,a(h)}function l(h){o.value.scrollTop=h,a(v(o))}function u(h){var p,m;o.value.scrollLeft=h,(m=(p=e.value)==null?void 0:p.scrollTo)==null||m.call(p,v(o))}function c(h){var p;i(h),(p=t.onScroll)==null||p.call(t,h)}function d({scrollTop:h}){const{scrollTop:p}=v(o);h!==p&&l(h)}function f(h,p="auto"){var m;(m=e.value)==null||m.scrollToRow(h,p)}return Me(()=>v(o).scrollTop,(h,p)=>{h>p&&r()}),{scrollPos:o,scrollTo:i,scrollToLeft:u,scrollToTop:l,scrollToRow:f,onScroll:c,onVerticalScroll:d}},UJe=(t,{mainTableRef:e,leftTableRef:n,rightTableRef:s,onMaybeEndReached:r})=>{const o=Rt(),{emit:a}=o,i=Nn(!1),l=Nn(null),u=U(t.defaultExpandedRowKeys||[]),c=U(-1),d=Nn(null),f=U({}),h=U({}),p=Nn({}),m=Nn({}),g=Nn({}),y=A(()=>Ct(t.estimatedRowHeight));function w(T){var N;(N=t.onRowsRendered)==null||N.call(t,T),T.rowCacheEnd>v(c)&&(c.value=T.rowCacheEnd)}function b({hovered:T,rowKey:N}){l.value=T?N:null}function _({expanded:T,rowData:N,rowIndex:M,rowKey:R}){var D,z;const B=[...v(u)],V=B.indexOf(R);T?V===-1&&B.push(R):V>-1&&B.splice(V,1),u.value=B,a("update:expandedRowKeys",B),(D=t.onRowExpand)==null||D.call(t,{expanded:T,rowData:N,rowIndex:M,rowKey:R}),(z=t.onExpandedRowsChange)==null||z.call(t,B)}const $=Xr(()=>{var T,N,M,R;i.value=!0,f.value={...v(f),...v(h)},x(v(d),!1),h.value={},d.value=null,(T=e.value)==null||T.forceUpdate(),(N=n.value)==null||N.forceUpdate(),(M=s.value)==null||M.forceUpdate(),(R=o.proxy)==null||R.$forceUpdate(),i.value=!1},0);function x(T,N=!1){!v(y)||[e,n,s].forEach(M=>{const R=v(M);R&&R.resetAfterRowIndex(T,N)})}function k(T,N,M){const R=v(d);(R===null||R>M)&&(d.value=M),h.value[T]=N}function C({rowKey:T,height:N,rowIndex:M},R){R?R===z7.RIGHT?g.value[T]=N:p.value[T]=N:m.value[T]=N;const D=Math.max(...[p,g,m].map(z=>z.value[T]||0));v(f)[T]!==D&&(k(T,D,M),$())}return Me(c,()=>r()),{hoveringRowKey:l,expandedRowKeys:u,lastRenderedRowIndex:c,isDynamic:y,isResetting:i,rowHeights:f,resetAfterIndex:x,onRowExpanded:_,onRowHovered:b,onRowsRendered:w,onRowHeightChange:C}},GJe=(t,{expandedRowKeys:e,lastRenderedRowIndex:n,resetAfterIndex:s})=>{const r=U({}),o=A(()=>{const i={},{data:l,rowKey:u}=t,c=v(e);if(!c||!c.length)return l;const d=[],f=new Set;c.forEach(p=>f.add(p));let h=l.slice();for(h.forEach(p=>i[p[u]]=0);h.length>0;){const p=h.shift();d.push(p),f.has(p[u])&&Array.isArray(p.children)&&p.children.length>0&&(h=[...p.children,...h],p.children.forEach(m=>i[m[u]]=i[p[u]]+1))}return r.value=i,d}),a=A(()=>{const{data:i,expandColumnKey:l}=t;return l?v(o):i});return Me(a,(i,l)=>{i!==l&&(n.value=-1,s(0,!0))}),{data:a,depthMap:r}},jJe=(t,e)=>t+e,ry=t=>Qe(t)?t.reduce(jJe,0):t,Td=(t,e,n={})=>vt(t)?t(e):t??n,Su=t=>(["width","maxWidth","minWidth","height"].forEach(e=>{t[e]=Cs(t[e])}),t),B7=t=>Bn(t)?e=>it(t,e):t,KJe=(t,{columnsTotalWidth:e,data:n,fixedColumnsOnLeft:s,fixedColumnsOnRight:r})=>{const o=A(()=>{const{fixed:b,width:_,vScrollbarSize:$}=t,x=_-$;return b?Math.max(Math.round(v(e)),x):x}),a=A(()=>v(o)+(t.fixed?t.vScrollbarSize:0)),i=A(()=>{const{height:b=0,maxHeight:_=0,footerHeight:$,hScrollbarSize:x}=t;if(_>0){const k=v(p),C=v(l),N=v(h)+k+C+x;return Math.min(N,_-$)}return b-$}),l=A(()=>{const{rowHeight:b,estimatedRowHeight:_}=t,$=v(n);return Ct(_)?$.length*_:$.length*b}),u=A(()=>{const{maxHeight:b}=t,_=v(i);if(Ct(b)&&b>0)return _;const $=v(l)+v(h)+v(p);return Math.min(_,$)}),c=b=>b.width,d=A(()=>ry(v(s).map(c))),f=A(()=>ry(v(r).map(c))),h=A(()=>ry(t.headerHeight)),p=A(()=>{var b;return(((b=t.fixedData)==null?void 0:b.length)||0)*t.rowHeight}),m=A(()=>v(i)-v(h)-v(p)),g=A(()=>{const{style:b={},height:_,width:$}=t;return Su({...b,height:_,width:$})}),y=A(()=>Su({height:t.footerHeight})),w=A(()=>({top:Cs(v(h)),bottom:Cs(t.footerHeight),width:Cs(t.width)}));return{bodyWidth:o,fixedTableHeight:u,mainTableHeight:i,leftTableWidth:d,rightTableWidth:f,headerWidth:a,rowsHeight:l,windowHeight:m,footerHeight:y,emptyStyle:w,rootStyle:g,headerHeight:h}},qJe=t=>{const e=U(),n=U(0),s=U(0);let r;return It(()=>{r=Dr(e,([o])=>{const{width:a,height:i}=o.contentRect,{paddingLeft:l,paddingRight:u,paddingTop:c,paddingBottom:d}=getComputedStyle(o.target),f=Number.parseInt(l)||0,h=Number.parseInt(u)||0,p=Number.parseInt(c)||0,m=Number.parseInt(d)||0;n.value=a-f-h,s.value=i-p-m}).stop}),ts(()=>{r==null||r()}),Me([n,s],([o,a])=>{var i;(i=t.onResize)==null||i.call(t,{width:o,height:a})}),{sizer:e,width:n,height:s}};function XJe(t){const e=U(),n=U(),s=U(),{columns:r,columnsStyles:o,columnsTotalWidth:a,fixedColumnsOnLeft:i,fixedColumnsOnRight:l,hasFixedColumns:u,mainColumns:c,onColumnSorted:d}=HJe(t,Un(t,"columns"),Un(t,"fixed")),{scrollTo:f,scrollToLeft:h,scrollToTop:p,scrollToRow:m,onScroll:g,onVerticalScroll:y,scrollPos:w}=WJe(t,{mainTableRef:e,leftTableRef:n,rightTableRef:s,onMaybeEndReached:K}),{expandedRowKeys:b,hoveringRowKey:_,lastRenderedRowIndex:$,isDynamic:x,isResetting:k,rowHeights:C,resetAfterIndex:T,onRowExpanded:N,onRowHeightChange:M,onRowHovered:R,onRowsRendered:D}=UJe(t,{mainTableRef:e,leftTableRef:n,rightTableRef:s,onMaybeEndReached:K}),{data:z,depthMap:B}=GJe(t,{expandedRowKeys:b,lastRenderedRowIndex:$,resetAfterIndex:T}),{bodyWidth:V,fixedTableHeight:O,mainTableHeight:F,leftTableWidth:L,rightTableWidth:G,headerWidth:Z,rowsHeight:j,windowHeight:J,footerHeight:fe,emptyStyle:X,rootStyle:oe,headerHeight:ee}=KJe(t,{columnsTotalWidth:a,data:z,fixedColumnsOnLeft:i,fixedColumnsOnRight:l}),Q=Nn(!1),ie=U(),pe=A(()=>{const re=v(z).length===0;return Qe(t.fixedData)?t.fixedData.length===0&&re:re});function Re(re){const{estimatedRowHeight:we,rowHeight:Ee,rowKey:De}=t;return we?v(C)[v(z)[re][De]]||we:Ee}function K(){const{onEndReached:re}=t;if(!re)return;const{scrollTop:we}=v(w),Ee=v(j),De=v(J),_e=Ee-(we+De)+t.hScrollbarSize;v($)>=0&&Ee===we+v(F)-v(ee)&&re(_e)}return Me(()=>t.expandedRowKeys,re=>b.value=re,{deep:!0}),{columns:r,containerRef:ie,mainTableRef:e,leftTableRef:n,rightTableRef:s,isDynamic:x,isResetting:k,isScrolling:Q,hoveringRowKey:_,hasFixedColumns:u,columnsStyles:o,columnsTotalWidth:a,data:z,expandedRowKeys:b,depthMap:B,fixedColumnsOnLeft:i,fixedColumnsOnRight:l,mainColumns:c,bodyWidth:V,emptyStyle:X,rootStyle:oe,headerWidth:Z,footerHeight:fe,mainTableHeight:F,fixedTableHeight:O,leftTableWidth:L,rightTableWidth:G,showEmpty:pe,getRowHeight:Re,onColumnSorted:d,onRowHovered:R,onRowExpanded:N,onRowsRendered:D,onRowHeightChange:M,scrollTo:f,scrollToLeft:h,scrollToTop:p,scrollToRow:m,onScroll:g,onVerticalScroll:y}}const Ck=Symbol("tableV2"),V7=String,zg={type:Se(Array),required:!0},kk={type:Se(Array)},H7={...kk,required:!0},YJe=String,bR={type:Se(Array),default:()=>Ln([])},Bc={type:Number,required:!0},W7={type:Se([String,Number,Symbol]),default:"id"},wR={type:Se(Object)},Zc=qe({class:String,columns:zg,columnsStyles:{type:Se(Object),required:!0},depth:Number,expandColumnKey:YJe,estimatedRowHeight:{...ad.estimatedRowHeight,default:void 0},isScrolling:Boolean,onRowExpand:{type:Se(Function)},onRowHover:{type:Se(Function)},onRowHeightChange:{type:Se(Function)},rowData:{type:Se(Object),required:!0},rowEventHandlers:{type:Se(Object)},rowIndex:{type:Number,required:!0},rowKey:W7,style:{type:Se(Object)}}),l$={type:Number,required:!0},Tk=qe({class:String,columns:zg,fixedHeaderData:{type:Se(Array)},headerData:{type:Se(Array),required:!0},headerHeight:{type:Se([Number,Array]),default:50},rowWidth:l$,rowHeight:{type:Number,default:50},height:l$,width:l$}),oy=qe({columns:zg,data:H7,fixedData:kk,estimatedRowHeight:Zc.estimatedRowHeight,width:Bc,height:Bc,headerWidth:Bc,headerHeight:Tk.headerHeight,bodyWidth:Bc,rowHeight:Bc,cache:p7.cache,useIsScrolling:Boolean,scrollbarAlwaysOn:ad.scrollbarAlwaysOn,scrollbarStartGap:ad.scrollbarStartGap,scrollbarEndGap:ad.scrollbarEndGap,class:V7,style:wR,containerStyle:wR,getRowHeight:{type:Se(Function),required:!0},rowKey:Zc.rowKey,onRowsRendered:{type:Se(Function)},onScroll:{type:Se(Function)}}),ZJe=qe({cache:oy.cache,estimatedRowHeight:Zc.estimatedRowHeight,rowKey:W7,headerClass:{type:Se([String,Function])},headerProps:{type:Se([Object,Function])},headerCellProps:{type:Se([Object,Function])},headerHeight:Tk.headerHeight,footerHeight:{type:Number,default:0},rowClass:{type:Se([String,Function])},rowProps:{type:Se([Object,Function])},rowHeight:{type:Number,default:50},cellProps:{type:Se([Object,Function])},columns:zg,data:H7,dataGetter:{type:Se(Function)},fixedData:kk,expandColumnKey:Zc.expandColumnKey,expandedRowKeys:bR,defaultExpandedRowKeys:bR,class:V7,fixed:Boolean,style:{type:Se(Object)},width:Bc,height:Bc,maxHeight:Number,useIsScrolling:Boolean,indentSize:{type:Number,default:12},iconSize:{type:Number,default:12},hScrollbarSize:ad.hScrollbarSize,vScrollbarSize:ad.vScrollbarSize,scrollbarAlwaysOn:v7.alwaysOn,sortBy:{type:Se(Object),default:()=>({})},sortState:{type:Se(Object),default:void 0},onColumnSort:{type:Se(Function)},onExpandedRowsChange:{type:Se(Function)},onEndReached:{type:Se(Function)},onRowExpand:Zc.onRowExpand,onScroll:oy.onScroll,onRowsRendered:oy.onRowsRendered,rowEventHandlers:Zc.rowEventHandlers}),Nk=(t,{slots:e})=>{var n;const{cellData:s,style:r}=t,o=((n=s==null?void 0:s.toString)==null?void 0:n.call(s))||"";return se("div",{class:t.class,title:o,style:r},[e.default?e.default(t):o])};Nk.displayName="ElTableV2Cell";Nk.inheritAttrs=!1;const Ik=(t,{slots:e})=>{var n,s;return e.default?e.default(t):se("div",{class:t.class,title:(n=t.column)==null?void 0:n.title},[(s=t.column)==null?void 0:s.title])};Ik.displayName="ElTableV2HeaderCell";Ik.inheritAttrs=!1;const JJe=qe({class:String,columns:zg,columnsStyles:{type:Se(Object),required:!0},headerIndex:Number,style:{type:Se(Object)}}),QJe=ue({name:"ElTableV2HeaderRow",props:JJe,setup(t,{slots:e}){return()=>{const{columns:n,columnsStyles:s,headerIndex:r,style:o}=t;let a=n.map((i,l)=>e.cell({columns:n,column:i,columnIndex:l,headerIndex:r,style:s[i.key]}));return e.header&&(a=e.header({cells:a.map(i=>Qe(i)&&i.length===1?i[0]:i),columns:n,headerIndex:r})),se("div",{class:t.class,style:o},[a])}}}),eQe="ElTableV2Header",tQe=ue({name:eQe,props:Tk,setup(t,{slots:e,expose:n}){const s=Fe("table-v2"),r=U(),o=A(()=>Su({width:t.width,height:t.height})),a=A(()=>Su({width:t.rowWidth,height:t.height})),i=A(()=>dh(v(t.headerHeight))),l=d=>{const f=v(r);nt(()=>{f!=null&&f.scroll&&f.scroll({left:d})})},u=()=>{const d=s.e("fixed-header-row"),{columns:f,fixedHeaderData:h,rowHeight:p}=t;return h==null?void 0:h.map((m,g)=>{var y;const w=Su({height:p,width:"100%"});return(y=e.fixed)==null?void 0:y.call(e,{class:d,columns:f,rowData:m,rowIndex:-(g+1),style:w})})},c=()=>{const d=s.e("dynamic-header-row"),{columns:f}=t;return v(i).map((h,p)=>{var m;const g=Su({width:"100%",height:h});return(m=e.dynamic)==null?void 0:m.call(e,{class:d,columns:f,headerIndex:p,style:g})})};return n({scrollToLeft:l}),()=>{if(!(t.height<=0))return se("div",{ref:r,class:t.class,style:v(o)},[se("div",{style:v(a),class:s.e("header")},[c(),u()])])}}}),nQe=t=>{const{isScrolling:e}=et(Ck),n=U(!1),s=U(),r=A(()=>Ct(t.estimatedRowHeight)&&t.rowIndex>=0),o=(l=!1)=>{const u=v(s);if(!u)return;const{columns:c,onRowHeightChange:d,rowKey:f,rowIndex:h,style:p}=t,{height:m}=u.getBoundingClientRect();n.value=!0,nt(()=>{if(l||m!==Number.parseInt(p.height)){const g=c[0],y=(g==null?void 0:g.placeholderSign)===q0;d==null||d({rowKey:f,height:m,rowIndex:h},g&&!y&&g.fixed)}})},a=A(()=>{const{rowData:l,rowIndex:u,rowKey:c,onRowHover:d}=t,f=t.rowEventHandlers||{},h={};return Object.entries(f).forEach(([p,m])=>{vt(m)&&(h[p]=g=>{m({event:g,rowData:l,rowIndex:u,rowKey:c})})}),d&&[{name:"onMouseleave",hovered:!1},{name:"onMouseenter",hovered:!0}].forEach(({name:p,hovered:m})=>{const g=h[p];h[p]=y=>{d({event:y,hovered:m,rowData:l,rowIndex:u,rowKey:c}),g==null||g(y)}}),h}),i=l=>{const{onRowExpand:u,rowData:c,rowIndex:d,rowKey:f}=t;u==null||u({expanded:l,rowData:c,rowIndex:d,rowKey:f})};return It(()=>{v(r)&&o(!0)}),{isScrolling:e,measurable:r,measured:n,rowRef:s,eventHandlers:a,onExpand:i}},sQe="ElTableV2TableRow",rQe=ue({name:sQe,props:Zc,setup(t,{expose:e,slots:n,attrs:s}){const{eventHandlers:r,isScrolling:o,measurable:a,measured:i,rowRef:l,onExpand:u}=nQe(t);return e({onExpand:u}),()=>{const{columns:c,columnsStyles:d,expandColumnKey:f,depth:h,rowData:p,rowIndex:m,style:g}=t;let y=c.map((w,b)=>{const _=Qe(p.children)&&p.children.length>0&&w.key===f;return n.cell({column:w,columns:c,columnIndex:b,depth:h,style:d[w.key],rowData:p,rowIndex:m,isScrolling:v(o),expandIconProps:_?{rowData:p,rowIndex:m,onExpand:u}:void 0})});if(n.row&&(y=n.row({cells:y.map(w=>Qe(w)&&w.length===1?w[0]:w),style:g,columns:c,depth:h,rowData:p,rowIndex:m,isScrolling:v(o)})),v(a)){const{height:w,...b}=g||{},_=v(i);return se("div",zt({ref:l,class:t.class,style:_?g:b},s,v(r)),[y])}return se("div",zt(s,{ref:l,class:t.class,style:g},v(r)),[y])}}}),oQe=t=>{const{sortOrder:e}=t;return se(rt,{size:14,class:t.class},{default:()=>[e===j0.ASC?se(TP,null,null):se(kP,null,null)]})},aQe=t=>{const{expanded:e,expandable:n,onExpand:s,style:r,size:o}=t,a={onClick:n?()=>s(!e):void 0,class:t.class};return se(rt,zt(a,{size:o,style:r}),{default:()=>[se(Rr,null,null)]})},iQe="ElTableV2Grid",lQe=t=>{const e=U(),n=U(),s=A(()=>{const{data:m,rowHeight:g,estimatedRowHeight:y}=t;if(!y)return m.length*g}),r=A(()=>{const{fixedData:m,rowHeight:g}=t;return((m==null?void 0:m.length)||0)*g}),o=A(()=>ry(t.headerHeight)),a=A(()=>{const{height:m}=t;return Math.max(0,m-v(o)-v(r))}),i=A(()=>v(o)+v(r)>0),l=({data:m,rowIndex:g})=>m[g][t.rowKey];function u({rowCacheStart:m,rowCacheEnd:g,rowVisibleStart:y,rowVisibleEnd:w}){var b;(b=t.onRowsRendered)==null||b.call(t,{rowCacheStart:m,rowCacheEnd:g,rowVisibleStart:y,rowVisibleEnd:w})}function c(m,g){var y;(y=n.value)==null||y.resetAfterRowIndex(m,g)}function d(m,g){const y=v(e),w=v(n);!y||!w||(Bt(m)?(y.scrollToLeft(m.scrollLeft),w.scrollTo(m)):(y.scrollToLeft(m),w.scrollTo({scrollLeft:m,scrollTop:g})))}function f(m){var g;(g=v(n))==null||g.scrollTo({scrollTop:m})}function h(m,g){var y;(y=v(n))==null||y.scrollToItem(m,1,g)}function p(){var m,g;(m=v(n))==null||m.$forceUpdate(),(g=v(e))==null||g.$forceUpdate()}return{bodyRef:n,forceUpdate:p,fixedRowHeight:r,gridHeight:a,hasHeader:i,headerHeight:o,headerRef:e,totalHeight:s,itemKey:l,onItemRendered:u,resetAfterRowIndex:c,scrollTo:d,scrollToTop:f,scrollToRow:h}},Ek=ue({name:iQe,props:oy,setup(t,{slots:e,expose:n}){const{ns:s}=et(Ck),{bodyRef:r,fixedRowHeight:o,gridHeight:a,hasHeader:i,headerRef:l,headerHeight:u,totalHeight:c,forceUpdate:d,itemKey:f,onItemRendered:h,resetAfterRowIndex:p,scrollTo:m,scrollToTop:g,scrollToRow:y}=lQe(t);n({forceUpdate:d,totalHeight:c,scrollTo:m,scrollToTop:g,scrollToRow:y,resetAfterRowIndex:p});const w=()=>t.bodyWidth;return()=>{const{cache:b,columns:_,data:$,fixedData:x,useIsScrolling:k,scrollbarAlwaysOn:C,scrollbarEndGap:T,scrollbarStartGap:N,style:M,rowHeight:R,bodyWidth:D,estimatedRowHeight:z,headerWidth:B,height:V,width:O,getRowHeight:F,onScroll:L}=t,G=Ct(z),Z=G?ZXe:KXe,j=v(u);return se("div",{role:"table",class:[s.e("table"),t.class],style:M},[se(Z,{ref:r,data:$,useIsScrolling:k,itemKey:f,columnCache:0,columnWidth:G?w:D,totalColumn:1,totalRow:$.length,rowCache:b,rowHeight:G?F:R,width:O,height:v(a),class:s.e("body"),scrollbarStartGap:N,scrollbarEndGap:T,scrollbarAlwaysOn:C,onScroll:L,onItemRendered:h,perfMode:!1},{default:J=>{var fe;const X=$[J.rowIndex];return(fe=e.row)==null?void 0:fe.call(e,{...J,columns:_,rowData:X})}}),v(i)&&se(tQe,{ref:l,class:s.e("header-wrapper"),columns:_,headerData:$,headerHeight:t.headerHeight,fixedHeaderData:x,rowWidth:B,rowHeight:R,width:O,height:Math.min(j+v(o),V)},{dynamic:e.header,fixed:e.row})])}}});function uQe(t){return typeof t=="function"||Object.prototype.toString.call(t)==="[object Object]"&&!Bn(t)}const cQe=(t,{slots:e})=>{const{mainTableRef:n,...s}=t;return se(Ek,zt({ref:n},s),uQe(e)?e:{default:()=>[e]})};function dQe(t){return typeof t=="function"||Object.prototype.toString.call(t)==="[object Object]"&&!Bn(t)}const fQe=(t,{slots:e})=>{if(!t.columns.length)return;const{leftTableRef:n,...s}=t;return se(Ek,zt({ref:n},s),dQe(e)?e:{default:()=>[e]})};function hQe(t){return typeof t=="function"||Object.prototype.toString.call(t)==="[object Object]"&&!Bn(t)}const pQe=(t,{slots:e})=>{if(!t.columns.length)return;const{rightTableRef:n,...s}=t;return se(Ek,zt({ref:n},s),hQe(e)?e:{default:()=>[e]})};function mQe(t){return typeof t=="function"||Object.prototype.toString.call(t)==="[object Object]"&&!Bn(t)}const gQe=(t,{slots:e})=>{const{columns:n,columnsStyles:s,depthMap:r,expandColumnKey:o,expandedRowKeys:a,estimatedRowHeight:i,hasFixedColumns:l,hoveringRowKey:u,rowData:c,rowIndex:d,style:f,isScrolling:h,rowProps:p,rowClass:m,rowKey:g,rowEventHandlers:y,ns:w,onRowHovered:b,onRowExpanded:_}=t,$=Td(m,{columns:n,rowData:c,rowIndex:d},""),x=Td(p,{columns:n,rowData:c,rowIndex:d}),k=c[g],C=r[k]||0,T=Boolean(o),N=d<0,M=[w.e("row"),$,{[w.e(`row-depth-${C}`)]:T&&d>=0,[w.is("expanded")]:T&&a.includes(k),[w.is("hovered")]:!h&&k===u,[w.is("fixed")]:!C&&N,[w.is("customized")]:Boolean(e.row)}],R=l?b:void 0,D={...x,columns:n,columnsStyles:s,class:M,depth:C,expandColumnKey:o,estimatedRowHeight:N?void 0:i,isScrolling:h,rowIndex:d,rowData:c,rowKey:k,rowEventHandlers:y,style:f};return se(rQe,zt(D,{onRowHover:R,onRowExpand:_}),mQe(e)?e:{default:()=>[e]})},Y6=({columns:t,column:e,columnIndex:n,depth:s,expandIconProps:r,isScrolling:o,rowData:a,rowIndex:i,style:l,expandedRowKeys:u,ns:c,cellProps:d,expandColumnKey:f,indentSize:h,iconSize:p,rowKey:m},{slots:g})=>{const y=Su(l);if(e.placeholderSign===q0)return se("div",{class:c.em("row-cell","placeholder"),style:y},null);const{cellRenderer:w,dataKey:b,dataGetter:_}=e,x=B7(w)||g.default||(V=>se(Nk,V,null)),k=vt(_)?_({columns:t,column:e,columnIndex:n,rowData:a,rowIndex:i}):Pn(a,b??""),C=Td(d,{cellData:k,columns:t,column:e,columnIndex:n,rowIndex:i,rowData:a}),T={class:c.e("cell-text"),columns:t,column:e,columnIndex:n,cellData:k,isScrolling:o,rowData:a,rowIndex:i},N=x(T),M=[c.e("row-cell"),e.align===K0.CENTER&&c.is("align-center"),e.align===K0.RIGHT&&c.is("align-right")],R=i>=0&&e.key===f,D=i>=0&&u.includes(a[m]);let z;const B=`margin-inline-start: ${s*h}px;`;return R&&(Bt(r)?z=se(aQe,zt(r,{class:[c.e("expand-icon"),c.is("expanded",D)],size:p,expanded:D,style:B,expandable:!0}),null):z=se("div",{style:[B,`width: ${p}px; height: ${p}px;`].join(" ")},null)),se("div",zt({class:M,style:y},C),[z,N])};Y6.inheritAttrs=!1;function vQe(t){return typeof t=="function"||Object.prototype.toString.call(t)==="[object Object]"&&!Bn(t)}const yQe=({columns:t,columnsStyles:e,headerIndex:n,style:s,headerClass:r,headerProps:o,ns:a},{slots:i})=>{const l={columns:t,headerIndex:n},u=[a.e("header-row"),Td(r,l,""),{[a.is("customized")]:Boolean(i.header)}],c={...Td(o,l),columnsStyles:e,class:u,columns:t,headerIndex:n,style:s};return se(QJe,c,vQe(i)?i:{default:()=>[i]})},_R=(t,{slots:e})=>{const{column:n,ns:s,style:r,onColumnSorted:o}=t,a=Su(r);if(n.placeholderSign===q0)return se("div",{class:s.em("header-row-cell","placeholder"),style:a},null);const{headerCellRenderer:i,headerClass:l,sortable:u}=n,c={...t,class:s.e("header-cell-text")},f=(B7(i)||e.default||(_=>se(Ik,_,null)))(c),{sortBy:h,sortState:p,headerCellProps:m}=t;let g,y;if(p){const _=p[n.key];g=Boolean(X6[_]),y=g?_:j0.ASC}else g=n.key===h.key,y=g?h.order:j0.ASC;const w=[s.e("header-cell"),Td(l,t,""),n.align===K0.CENTER&&s.is("align-center"),n.align===K0.RIGHT&&s.is("align-right"),u&&s.is("sortable")],b={...Td(m,t),onClick:n.sortable?o:void 0,class:w,style:a,["data-key"]:n.key};return se("div",b,[f,u&&se(oQe,{class:[s.e("sort-icon"),g&&s.is("sorting")],sortOrder:y},null)])},U7=(t,{slots:e})=>{var n;return se("div",{class:t.class,style:t.style},[(n=e.default)==null?void 0:n.call(e)])};U7.displayName="ElTableV2Footer";const G7=(t,{slots:e})=>se("div",{class:t.class,style:t.style},[e.default?e.default():se(Jz,null,null)]);G7.displayName="ElTableV2Empty";const j7=(t,{slots:e})=>{var n;return se("div",{class:t.class,style:t.style},[(n=e.default)==null?void 0:n.call(e)])};j7.displayName="ElTableV2Overlay";function Rm(t){return typeof t=="function"||Object.prototype.toString.call(t)==="[object Object]"&&!Bn(t)}const bQe="ElTableV2",wQe=ue({name:bQe,props:ZJe,setup(t,{slots:e,expose:n}){const s=Fe("table-v2"),{columnsStyles:r,fixedColumnsOnLeft:o,fixedColumnsOnRight:a,mainColumns:i,mainTableHeight:l,fixedTableHeight:u,leftTableWidth:c,rightTableWidth:d,data:f,depthMap:h,expandedRowKeys:p,hasFixedColumns:m,hoveringRowKey:g,mainTableRef:y,leftTableRef:w,rightTableRef:b,isDynamic:_,isResetting:$,isScrolling:x,bodyWidth:k,emptyStyle:C,rootStyle:T,headerWidth:N,footerHeight:M,showEmpty:R,scrollTo:D,scrollToLeft:z,scrollToTop:B,scrollToRow:V,getRowHeight:O,onColumnSorted:F,onRowHeightChange:L,onRowHovered:G,onRowExpanded:Z,onRowsRendered:j,onScroll:J,onVerticalScroll:fe}=XJe(t);return n({scrollTo:D,scrollToLeft:z,scrollToTop:B,scrollToRow:V}),Lt(Ck,{ns:s,isResetting:$,hoveringRowKey:g,isScrolling:x}),()=>{const{cache:X,cellProps:oe,estimatedRowHeight:ee,expandColumnKey:Q,fixedData:ie,headerHeight:pe,headerClass:Re,headerProps:K,headerCellProps:re,sortBy:we,sortState:Ee,rowHeight:De,rowClass:_e,rowEventHandlers:ze,rowKey:Ae,rowProps:he,scrollbarAlwaysOn:ve,indentSize:me,iconSize:Ve,useIsScrolling:Ye,vScrollbarSize:Je,width:ct}=t,xt=v(f),dt={cache:X,class:s.e("main"),columns:v(i),data:xt,fixedData:ie,estimatedRowHeight:ee,bodyWidth:v(k),headerHeight:pe,headerWidth:v(N),height:v(l),mainTableRef:y,rowKey:Ae,rowHeight:De,scrollbarAlwaysOn:ve,scrollbarStartGap:2,scrollbarEndGap:Je,useIsScrolling:Ye,width:ct,getRowHeight:O,onRowsRendered:j,onScroll:J},xe=v(c),Ke=v(u),at={cache:X,class:s.e("left"),columns:v(o),data:xt,estimatedRowHeight:ee,leftTableRef:w,rowHeight:De,bodyWidth:xe,headerWidth:xe,headerHeight:pe,height:Ke,rowKey:Ae,scrollbarAlwaysOn:ve,scrollbarStartGap:2,scrollbarEndGap:Je,useIsScrolling:Ye,width:xe,getRowHeight:O,onScroll:fe},de=v(d)+Je,Pe={cache:X,class:s.e("right"),columns:v(a),data:xt,estimatedRowHeight:ee,rightTableRef:b,rowHeight:De,bodyWidth:de,headerWidth:de,headerHeight:pe,height:Ke,rowKey:Ae,scrollbarAlwaysOn:ve,scrollbarStartGap:2,scrollbarEndGap:Je,width:de,style:`--${v(s.namespace)}-table-scrollbar-size: ${Je}px`,useIsScrolling:Ye,getRowHeight:O,onScroll:fe},We=v(r),Ft={ns:s,depthMap:v(h),columnsStyles:We,expandColumnKey:Q,expandedRowKeys:v(p),estimatedRowHeight:ee,hasFixedColumns:v(m),hoveringRowKey:v(g),rowProps:he,rowClass:_e,rowKey:Ae,rowEventHandlers:ze,onRowHovered:G,onRowExpanded:Z,onRowHeightChange:L},_n={cellProps:oe,expandColumnKey:Q,indentSize:me,iconSize:Ve,rowKey:Ae,expandedRowKeys:v(p),ns:s},_s={ns:s,headerClass:Re,headerProps:K,columnsStyles:We},qs={ns:s,sortBy:we,sortState:Ee,headerCellProps:re,onColumnSorted:F},Sn={row:ft=>se(gQe,zt(ft,Ft),{row:e.row,cell:Ht=>{let pn;return e.cell?se(Y6,zt(Ht,_n,{style:We[Ht.column.key]}),Rm(pn=e.cell(Ht))?pn:{default:()=>[pn]}):se(Y6,zt(Ht,_n,{style:We[Ht.column.key]}),null)}}),header:ft=>se(yQe,zt(ft,_s),{header:e.header,cell:Ht=>{let pn;return e["header-cell"]?se(_R,zt(Ht,qs,{style:We[Ht.column.key]}),Rm(pn=e["header-cell"](Ht))?pn:{default:()=>[pn]}):se(_R,zt(Ht,qs,{style:We[Ht.column.key]}),null)}})},sn=[t.class,s.b(),s.e("root"),{[s.is("dynamic")]:v(_)}],He={class:s.e("footer"),style:v(M)};return se("div",{class:sn,style:v(T)},[se(cQe,dt,Rm(Sn)?Sn:{default:()=>[Sn]}),se(fQe,at,Rm(Sn)?Sn:{default:()=>[Sn]}),se(pQe,Pe,Rm(Sn)?Sn:{default:()=>[Sn]}),e.footer&&se(U7,He,{default:e.footer}),v(R)&&se(G7,{class:s.e("empty"),style:v(C)},{default:e.empty}),e.overlay&&se(j7,{class:s.e("overlay")},{default:e.overlay})])}}}),_Qe=qe({disableWidth:Boolean,disableHeight:Boolean,onResize:{type:Se(Function)}}),$Qe=ue({name:"ElAutoResizer",props:_Qe,setup(t,{slots:e}){const n=Fe("auto-resizer"),{height:s,width:r,sizer:o}=qJe(t),a={width:"100%",height:"100%"};return()=>{var i;return se("div",{ref:o,class:n.b(),style:a},[(i=e.default)==null?void 0:i.call(e,{height:s.value,width:r.value})])}}}),xQe=Dt(wQe),SQe=Dt($Qe),CQe=qe({tabs:{type:Se(Array),default:()=>Ln([])}}),K7="ElTabBar",kQe=ue({name:K7}),TQe=ue({...kQe,props:CQe,setup(t,{expose:e}){const n=t,s=Rt(),r=et(pw);r||Ls(K7,"<el-tabs><el-tab-bar /></el-tabs>");const o=Fe("tabs"),a=U(),i=U(),l=()=>{let c=0,d=0;const f=["top","bottom"].includes(r.props.tabPosition)?"width":"height",h=f==="width"?"x":"y";return n.tabs.every(p=>{var m,g,y,w;const b=(g=(m=s.parent)==null?void 0:m.refs)==null?void 0:g[`tab-${p.uid}`];if(!b)return!1;if(!p.active)return!0;d=b[`client${la(f)}`];const _=h==="x"?"left":"top";c=b[`offset${la(_)}`]-((w=(y=b.parentElement)==null?void 0:y[`offset${la(_)}`])!=null?w:0);const $=b.closest(".is-scrollable");if($){const k=window.getComputedStyle($);c+=Number.parseFloat(k[`padding${la(_)}`])}const x=window.getComputedStyle(b);return f==="width"&&(n.tabs.length>1&&(d-=Number.parseFloat(x.paddingLeft)+Number.parseFloat(x.paddingRight)),c+=Number.parseFloat(x.paddingLeft)),!1}),{[f]:`${d}px`,transform:`translate${la(h)}(${c}px)`}},u=()=>i.value=l();return Me(()=>n.tabs,async()=>{await nt(),u()},{immediate:!0}),Dr(a,()=>u()),e({ref:a,update:u}),(c,d)=>(S(),E("div",{ref_key:"barRef",ref:a,class:P([v(o).e("active-bar"),v(o).is(v(r).props.tabPosition)]),style:ot(i.value)},null,6))}});var NQe=je(TQe,[["__file","/home/runner/work/element-plus/element-plus/packages/components/tabs/src/tab-bar.vue"]]);const IQe=qe({panes:{type:Se(Array),default:()=>Ln([])},currentName:{type:[String,Number],default:""},editable:Boolean,type:{type:String,values:["card","border-card",""],default:""},stretch:Boolean}),EQe={tabClick:(t,e,n)=>n instanceof Event,tabRemove:(t,e)=>e instanceof Event},$R="ElTabNav",AQe=ue({name:$R,props:IQe,emits:EQe,setup(t,{expose:e,emit:n}){const s=Rt(),r=et(pw);r||Ls($R,"<el-tabs><tab-nav /></el-tabs>");const o=Fe("tabs"),a=xue(),i=Rue(),l=U(),u=U(),c=U(),d=U(!1),f=U(0),h=U(!1),p=U(!0),m=A(()=>["top","bottom"].includes(r.props.tabPosition)?"width":"height"),g=A(()=>({transform:`translate${m.value==="width"?"X":"Y"}(-${f.value}px)`})),y=()=>{if(!l.value)return;const C=l.value[`offset${la(m.value)}`],T=f.value;if(!T)return;const N=T>C?T-C:0;f.value=N},w=()=>{if(!l.value||!u.value)return;const C=u.value[`offset${la(m.value)}`],T=l.value[`offset${la(m.value)}`],N=f.value;if(C-N<=T)return;const M=C-N>T*2?N+T:C-T;f.value=M},b=async()=>{const C=u.value;if(!d.value||!c.value||!l.value||!C)return;await nt();const T=c.value.querySelector(".is-active");if(!T)return;const N=l.value,M=["top","bottom"].includes(r.props.tabPosition),R=T.getBoundingClientRect(),D=N.getBoundingClientRect(),z=M?C.offsetWidth-D.width:C.offsetHeight-D.height,B=f.value;let V=B;M?(R.left<D.left&&(V=B-(D.left-R.left)),R.right>D.right&&(V=B+R.right-D.right)):(R.top<D.top&&(V=B-(D.top-R.top)),R.bottom>D.bottom&&(V=B+(R.bottom-D.bottom))),V=Math.max(V,0),f.value=Math.min(V,z)},_=()=>{if(!u.value||!l.value)return;const C=u.value[`offset${la(m.value)}`],T=l.value[`offset${la(m.value)}`],N=f.value;if(T<C){const M=f.value;d.value=d.value||{},d.value.prev=M,d.value.next=M+T<C,C-M<T&&(f.value=C-T)}else d.value=!1,N>0&&(f.value=0)},$=C=>{const T=C.code,{up:N,down:M,left:R,right:D}=ut;if(![N,M,R,D].includes(T))return;const z=Array.from(C.currentTarget.querySelectorAll("[role=tab]:not(.is-disabled)")),B=z.indexOf(C.target);let V;T===R||T===N?B===0?V=z.length-1:V=B-1:B<z.length-1?V=B+1:V=0,z[V].focus({preventScroll:!0}),z[V].click(),x()},x=()=>{p.value&&(h.value=!0)},k=()=>h.value=!1;return Me(a,C=>{C==="hidden"?p.value=!1:C==="visible"&&setTimeout(()=>p.value=!0,50)}),Me(i,C=>{C?setTimeout(()=>p.value=!0,50):p.value=!1}),Dr(c,_),It(()=>setTimeout(()=>b(),0)),Ml(()=>_()),e({scrollToActiveTab:b,removeFocus:k}),Me(()=>t.panes,()=>s.update(),{flush:"post"}),()=>{const C=d.value?[se("span",{class:[o.e("nav-prev"),o.is("disabled",!d.value.prev)],onClick:y},[se(rt,null,{default:()=>[se(xl,null,null)]})]),se("span",{class:[o.e("nav-next"),o.is("disabled",!d.value.next)],onClick:w},[se(rt,null,{default:()=>[se(Rr,null,null)]})])]:null,T=t.panes.map((N,M)=>{var R,D,z,B;const V=N.uid,O=N.props.disabled,F=(D=(R=N.props.name)!=null?R:N.index)!=null?D:`${M}`,L=!O&&(N.isClosable||t.editable);N.index=`${M}`;const G=L?se(rt,{class:"is-icon-close",onClick:J=>n("tabRemove",N,J)},{default:()=>[se(xa,null,null)]}):null,Z=((B=(z=N.slots).label)==null?void 0:B.call(z))||N.props.label,j=!O&&N.active?0:-1;return se("div",{ref:`tab-${V}`,class:[o.e("item"),o.is(r.props.tabPosition),o.is("active",N.active),o.is("disabled",O),o.is("closable",L),o.is("focus",h.value)],id:`tab-${F}`,key:`tab-${V}`,"aria-controls":`pane-${F}`,role:"tab","aria-selected":N.active,tabindex:j,onFocus:()=>x(),onBlur:()=>k(),onClick:J=>{k(),n("tabClick",N,F,J)},onKeydown:J=>{L&&(J.code===ut.delete||J.code===ut.backspace)&&n("tabRemove",N,J)}},[Z,G])});return se("div",{ref:c,class:[o.e("nav-wrap"),o.is("scrollable",!!d.value),o.is(r.props.tabPosition)]},[C,se("div",{class:o.e("nav-scroll"),ref:l},[se("div",{class:[o.e("nav"),o.is(r.props.tabPosition),o.is("stretch",t.stretch&&["top","bottom"].includes(r.props.tabPosition))],ref:u,style:g.value,role:"tablist",onKeydown:$},[t.type?null:se(NQe,{tabs:[...t.panes]},null),T])])])}}}),OQe=qe({type:{type:String,values:["card","border-card",""],default:""},activeName:{type:[String,Number]},closable:Boolean,addable:Boolean,modelValue:{type:[String,Number]},editable:Boolean,tabPosition:{type:String,values:["top","right","bottom","left"],default:"top"},beforeLeave:{type:Se(Function),default:()=>!0},stretch:Boolean}),u$=t=>wt(t)||Ct(t),RQe={[Ot]:t=>u$(t),tabClick:(t,e)=>e instanceof Event,tabChange:t=>u$(t),edit:(t,e)=>["remove","add"].includes(e),tabRemove:t=>u$(t),tabAdd:()=>!0};var DQe=ue({name:"ElTabs",props:OQe,emits:RQe,setup(t,{emit:e,slots:n,expose:s}){var r,o;const a=Fe("tabs"),{children:i,addChild:l,removeChild:u}=uL(Rt(),"ElTabPane"),c=U(),d=U((o=(r=t.modelValue)!=null?r:t.activeName)!=null?o:"0"),f=y=>{d.value=y,e(Ot,y),e("tabChange",y)},h=async y=>{var w,b,_;if(!(d.value===y||er(y)))try{await((w=t.beforeLeave)==null?void 0:w.call(t,y,d.value))!==!1&&(f(y),(_=(b=c.value)==null?void 0:b.removeFocus)==null||_.call(b))}catch{}},p=(y,w,b)=>{y.props.disabled||(h(w),e("tabClick",y,b))},m=(y,w)=>{y.props.disabled||er(y.props.name)||(w.stopPropagation(),e("edit",y.props.name,"remove"),e("tabRemove",y.props.name))},g=()=>{e("edit",void 0,"add"),e("tabAdd")};return Sl({from:'"activeName"',replacement:'"model-value" or "v-model"',scope:"ElTabs",version:"2.3.0",ref:"https://element-plus.org/en-US/component/tabs.html#attributes",type:"Attribute"},A(()=>!!t.activeName)),Me(()=>t.activeName,y=>h(y)),Me(()=>t.modelValue,y=>h(y)),Me(d,async()=>{var y;await nt(),(y=c.value)==null||y.scrollToActiveTab()}),Lt(pw,{props:t,currentName:d,registerPane:l,unregisterPane:u}),s({currentName:d}),()=>{const y=t.editable||t.addable?se("span",{class:a.e("new-tab"),tabindex:"0",onClick:g,onKeydown:_=>{_.code===ut.enter&&g()}},[se(rt,{class:a.is("icon-plus")},{default:()=>[se(OC,null,null)]})]):null,w=se("div",{class:[a.e("header"),a.is(t.tabPosition)]},[y,se(AQe,{ref:c,currentName:d.value,editable:t.editable,type:t.type,panes:i.value,stretch:t.stretch,onTabClick:p,onTabRemove:m},null)]),b=se("div",{class:a.e("content")},[Oe(n,"default")]);return se("div",{class:[a.b(),a.m(t.tabPosition),{[a.m("card")]:t.type==="card",[a.m("border-card")]:t.type==="border-card"}]},[...t.tabPosition!=="bottom"?[w,b]:[b,w]])}}});const FQe=qe({label:{type:String,default:""},name:{type:[String,Number]},closable:Boolean,disabled:Boolean,lazy:Boolean}),MQe=["id","aria-hidden","aria-labelledby"],q7="ElTabPane",PQe=ue({name:q7}),LQe=ue({...PQe,props:FQe,setup(t){const e=t,n=Rt(),s=ir(),r=et(pw);r||Ls(q7,"usage: <el-tabs><el-tab-pane /></el-tabs/>");const o=Fe("tab-pane"),a=U(),i=A(()=>e.closable||r.props.closable),l=RA(()=>{var h;return r.currentName.value===((h=e.name)!=null?h:a.value)}),u=U(l.value),c=A(()=>{var h;return(h=e.name)!=null?h:a.value}),d=RA(()=>!e.lazy||u.value||l.value);Me(l,h=>{h&&(u.value=!0)});const f=on({uid:n.uid,slots:s,props:e,paneName:c,active:l,index:a,isClosable:i});return It(()=>{r.registerPane(f)}),Xd(()=>{r.unregisterPane(f.uid)}),(h,p)=>v(d)?St((S(),E("div",{key:0,id:`pane-${v(c)}`,class:P(v(o).b()),role:"tabpanel","aria-hidden":!v(l),"aria-labelledby":`tab-${v(c)}`},[Oe(h.$slots,"default")],10,MQe)),[[Qt,v(l)]]):ge("v-if",!0)}});var X7=je(LQe,[["__file","/home/runner/work/element-plus/element-plus/packages/components/tabs/src/tab-pane.vue"]]);const zQe=Dt(DQe,{TabPane:X7}),BQe=ns(X7),VQe=qe({format:{type:String,default:"HH:mm"},modelValue:String,disabled:Boolean,editable:{type:Boolean,default:!0},effect:{type:String,default:"light"},clearable:{type:Boolean,default:!0},size:wo,placeholder:String,start:{type:String,default:"09:00"},end:{type:String,default:"18:00"},step:{type:String,default:"00:30"},minTime:String,maxTime:String,name:String,prefixIcon:{type:Se([String,Object]),default:()=>AC},clearIcon:{type:Se([String,Object]),default:()=>Bl}}),fl=t=>{const e=(t||"").split(":");if(e.length>=2){let n=Number.parseInt(e[0],10);const s=Number.parseInt(e[1],10),r=t.toUpperCase();return r.includes("AM")&&n===12?n=0:r.includes("PM")&&n!==12&&(n+=12),{hours:n,minutes:s}}return null},c$=(t,e)=>{const n=fl(t);if(!n)return-1;const s=fl(e);if(!s)return-1;const r=n.minutes+n.hours*60,o=s.minutes+s.hours*60;return r===o?0:r>o?1:-1},xR=t=>`${t}`.padStart(2,"0"),Nf=t=>`${xR(t.hours)}:${xR(t.minutes)}`,HQe=(t,e)=>{const n=fl(t);if(!n)return"";const s=fl(e);if(!s)return"";const r={hours:n.hours,minutes:n.minutes};return r.minutes+=s.minutes,r.hours+=s.hours,r.hours+=Math.floor(r.minutes/60),r.minutes=r.minutes%60,Nf(r)},WQe=ue({name:"ElTimeSelect"}),UQe=ue({...WQe,props:VQe,emits:["change","blur","focus","update:modelValue"],setup(t,{expose:e}){const n=t;Nt.extend(ok);const{Option:s}=kd,r=Fe("input"),o=U(),a=To(),i=A(()=>n.modelValue),l=A(()=>{const g=fl(n.start);return g?Nf(g):null}),u=A(()=>{const g=fl(n.end);return g?Nf(g):null}),c=A(()=>{const g=fl(n.step);return g?Nf(g):null}),d=A(()=>{const g=fl(n.minTime||"");return g?Nf(g):null}),f=A(()=>{const g=fl(n.maxTime||"");return g?Nf(g):null}),h=A(()=>{const g=[];if(n.start&&n.end&&n.step){let y=l.value,w;for(;y&&u.value&&c$(y,u.value)<=0;)w=Nt(y,"HH:mm").format(n.format),g.push({value:w,disabled:c$(y,d.value||"-1:-1")<=0||c$(y,f.value||"100:100")>=0}),y=HQe(y,c.value)}return g});return e({blur:()=>{var g,y;(y=(g=o.value)==null?void 0:g.blur)==null||y.call(g)},focus:()=>{var g,y;(y=(g=o.value)==null?void 0:g.focus)==null||y.call(g)}}),(g,y)=>(S(),$e(v(kd),{ref_key:"select",ref:o,"model-value":v(i),disabled:v(a),clearable:g.clearable,"clear-icon":g.clearIcon,size:g.size,effect:g.effect,placeholder:g.placeholder,"default-first-option":"",filterable:g.editable,"onUpdate:modelValue":y[0]||(y[0]=w=>g.$emit("update:modelValue",w)),onChange:y[1]||(y[1]=w=>g.$emit("change",w)),onBlur:y[2]||(y[2]=w=>g.$emit("blur",w)),onFocus:y[3]||(y[3]=w=>g.$emit("focus",w))},{prefix:ce(()=>[g.prefixIcon?(S(),$e(v(rt),{key:0,class:P(v(r).e("prefix-icon"))},{default:ce(()=>[(S(),$e(Vt(g.prefixIcon)))]),_:1},8,["class"])):ge("v-if",!0)]),default:ce(()=>[(S(!0),E(lt,null,Gt(v(h),w=>(S(),$e(v(s),{key:w.value,label:w.value,value:w.value,disabled:w.disabled},null,8,["label","value","disabled"]))),128))]),_:1},8,["model-value","disabled","clearable","clear-icon","size","effect","placeholder","filterable"]))}});var ay=je(UQe,[["__file","/home/runner/work/element-plus/element-plus/packages/components/time-select/src/time-select.vue"]]);ay.install=t=>{t.component(ay.name,ay)};const GQe=ay,jQe=GQe,KQe=ue({name:"ElTimeline",setup(t,{slots:e}){const n=Fe("timeline");return Lt("timeline",e),()=>it("ul",{class:[n.b()]},[Oe(e,"default")])}}),qQe=qe({timestamp:{type:String,default:""},hideTimestamp:{type:Boolean,default:!1},center:{type:Boolean,default:!1},placement:{type:String,values:["top","bottom"],default:"bottom"},type:{type:String,values:["primary","success","warning","danger","info"],default:""},color:{type:String,default:""},size:{type:String,values:["normal","large"],default:"normal"},icon:{type:In},hollow:{type:Boolean,default:!1}}),XQe=ue({name:"ElTimelineItem"}),YQe=ue({...XQe,props:qQe,setup(t){const e=Fe("timeline-item");return(n,s)=>(S(),E("li",{class:P([v(e).b(),{[v(e).e("center")]:n.center}])},[I("div",{class:P(v(e).e("tail"))},null,2),n.$slots.dot?ge("v-if",!0):(S(),E("div",{key:0,class:P([v(e).e("node"),v(e).em("node",n.size||""),v(e).em("node",n.type||""),v(e).is("hollow",n.hollow)]),style:ot({backgroundColor:n.color})},[n.icon?(S(),$e(v(rt),{key:0,class:P(v(e).e("icon"))},{default:ce(()=>[(S(),$e(Vt(n.icon)))]),_:1},8,["class"])):ge("v-if",!0)],6)),n.$slots.dot?(S(),E("div",{key:1,class:P(v(e).e("dot"))},[Oe(n.$slots,"dot")],2)):ge("v-if",!0),I("div",{class:P(v(e).e("wrapper"))},[!n.hideTimestamp&&n.placement==="top"?(S(),E("div",{key:0,class:P([v(e).e("timestamp"),v(e).is("top")])},Ue(n.timestamp),3)):ge("v-if",!0),I("div",{class:P(v(e).e("content"))},[Oe(n.$slots,"default")],2),!n.hideTimestamp&&n.placement==="bottom"?(S(),E("div",{key:1,class:P([v(e).e("timestamp"),v(e).is("bottom")])},Ue(n.timestamp),3)):ge("v-if",!0)],2)],2))}});var Y7=je(YQe,[["__file","/home/runner/work/element-plus/element-plus/packages/components/timeline/src/timeline-item.vue"]]);const ZQe=Dt(KQe,{TimelineItem:Y7}),JQe=ns(Y7),Z7=qe({nowrap:Boolean});var J7=(t=>(t.top="top",t.bottom="bottom",t.left="left",t.right="right",t))(J7||{});const QQe=Object.values(J7),Ak=qe({width:{type:Number,default:10},height:{type:Number,default:10},style:{type:Se(Object),default:null}}),eet=qe({side:{type:Se(String),values:QQe,required:!0}}),tet=["absolute","fixed"],net=["top-start","top-end","top","bottom-start","bottom-end","bottom","left-start","left-end","left","right-start","right-end","right"],Ok=qe({ariaLabel:String,arrowPadding:{type:Se(Number),default:5},effect:{type:String,default:""},contentClass:String,placement:{type:Se(String),values:net,default:"bottom"},reference:{type:Se(Object),default:null},offset:{type:Number,default:8},strategy:{type:Se(String),values:tet,default:"absolute"},showArrow:{type:Boolean,default:!1}}),Rk=qe({delayDuration:{type:Number,default:300},defaultOpen:Boolean,open:{type:Boolean,default:void 0},onOpenChange:{type:Se(Function)},"onUpdate:open":{type:Se(Function)}}),$f={type:Se(Function)},Dk=qe({onBlur:$f,onClick:$f,onFocus:$f,onMouseDown:$f,onMouseEnter:$f,onMouseLeave:$f}),set=qe({...Rk,...Ak,...Dk,...Ok,alwaysOn:Boolean,fullTransition:Boolean,transitionProps:{type:Se(Object),default:null},teleported:Boolean,to:{type:Se(String),default:"body"}}),ret=ue({name:"ElTooltipV2Root"}),oet=ue({...ret,props:Rk,setup(t,{expose:e}){const n=t,s=U(n.defaultOpen),r=U(null),o=A({get:()=>Pue(n.open)?s.value:n.open,set:g=>{var y;s.value=g,(y=n["onUpdate:open"])==null||y.call(n,g)}}),a=A(()=>Ct(n.delayDuration)&&n.delayDuration>0),{start:i,stop:l}=_d(()=>{o.value=!0},A(()=>n.delayDuration),{immediate:!1}),u=Fe("tooltip-v2"),c=ei(),d=()=>{l(),o.value=!0},f=()=>{v(a)?i():d()},h=d,p=()=>{l(),o.value=!1};return Me(o,g=>{var y;g&&(document.dispatchEvent(new CustomEvent(G4)),h()),(y=n.onOpenChange)==null||y.call(n,g)}),It(()=>{document.addEventListener(G4,p)}),ts(()=>{l(),document.removeEventListener(G4,p)}),Lt(gw,{contentId:c,triggerRef:r,ns:u,onClose:p,onDelayOpen:f,onOpen:h}),e({onOpen:h,onClose:p}),(g,y)=>Oe(g.$slots,"default",{open:v(o)})}});var aet=je(oet,[["__file","/home/runner/work/element-plus/element-plus/packages/components/tooltip-v2/src/root.vue"]]);const iet=ue({name:"ElTooltipV2Arrow"}),uet=ue({...iet,props:{...Ak,...eet},setup(t){const e=t,{ns:n}=et(gw),{arrowRef:s}=et(qP),r=A(()=>{const{style:o,width:a,height:i}=e,l=n.namespace.value;return{[`--${l}-tooltip-v2-arrow-width`]:`${a}px`,[`--${l}-tooltip-v2-arrow-height`]:`${i}px`,[`--${l}-tooltip-v2-arrow-border-width`]:`${a/2}px`,[`--${l}-tooltip-v2-arrow-cover-width`]:a/2-1,...o||{}}});return(o,a)=>(S(),E("span",{ref_key:"arrowRef",ref:s,style:ot(v(r)),class:P(v(n).e("arrow"))},null,6))}});var SR=je(uet,[["__file","/home/runner/work/element-plus/element-plus/packages/components/tooltip-v2/src/arrow.vue"]]);const cet=qe({style:{type:Se([String,Object,Array]),default:()=>({})}}),det=ue({name:"ElVisuallyHidden"}),fet=ue({...det,props:cet,setup(t){const e=t,n=A(()=>[e.style,{position:"absolute",border:0,width:1,height:1,padding:0,margin:-1,overflow:"hidden",clip:"rect(0, 0, 0, 0)",whiteSpace:"nowrap",wordWrap:"normal"}]);return(s,r)=>(S(),E("span",zt(s.$attrs,{style:v(n)}),[Oe(s.$slots,"default")],16))}});var het=je(fet,[["__file","/home/runner/work/element-plus/element-plus/packages/components/visual-hidden/src/visual-hidden.vue"]]);const pet=["data-side"],met=ue({name:"ElTooltipV2Content"}),get=ue({...met,props:{...Ok,...Z7},setup(t){const e=t,{triggerRef:n,contentId:s}=et(gw),r=U(e.placement),o=U(e.strategy),a=U(null),{referenceRef:i,contentRef:l,middlewareData:u,x:c,y:d,update:f}=PFe({placement:r,strategy:o,middleware:A(()=>{const b=[$Fe(e.offset)];return e.showArrow&&b.push(LFe({arrowRef:a})),b})}),h=Ul().nextZIndex(),p=Fe("tooltip-v2"),m=A(()=>r.value.split("-")[0]),g=A(()=>({position:v(o),top:`${v(d)||0}px`,left:`${v(c)||0}px`,zIndex:h})),y=A(()=>{if(!e.showArrow)return{};const{arrow:b}=v(u);return{[`--${p.namespace.value}-tooltip-v2-arrow-x`]:`${b==null?void 0:b.x}px`||"",[`--${p.namespace.value}-tooltip-v2-arrow-y`]:`${b==null?void 0:b.y}px`||""}}),w=A(()=>[p.e("content"),p.is("dark",e.effect==="dark"),p.is(v(o)),e.contentClass]);return Me(a,()=>f()),Me(()=>e.placement,b=>r.value=b),It(()=>{Me(()=>e.reference||n.value,b=>{i.value=b||void 0},{immediate:!0})}),Lt(qP,{arrowRef:a}),(b,_)=>(S(),E("div",{ref_key:"contentRef",ref:l,style:ot(v(g)),"data-tooltip-v2-root":""},[b.nowrap?ge("v-if",!0):(S(),E("div",{key:0,"data-side":v(m),class:P(v(w))},[Oe(b.$slots,"default",{contentStyle:v(g),contentClass:v(w)}),se(v(het),{id:v(s),role:"tooltip"},{default:ce(()=>[b.ariaLabel?(S(),E(lt,{key:0},[Yt(Ue(b.ariaLabel),1)],64)):Oe(b.$slots,"default",{key:1})]),_:3},8,["id"]),Oe(b.$slots,"arrow",{style:ot(v(y)),side:v(m)})],10,pet))],4))}});var CR=je(get,[["__file","/home/runner/work/element-plus/element-plus/packages/components/tooltip-v2/src/content.vue"]]);const vet=qe({setRef:{type:Se(Function),required:!0},onlyChild:Boolean});var yet=ue({props:vet,setup(t,{slots:e}){const n=U(),s=dw(n,r=>{r?t.setRef(r.nextElementSibling):t.setRef(null)});return()=>{var r;const[o]=((r=e.default)==null?void 0:r.call(e))||[],a=t.onlyChild?W9e(o.children):o.children;return se(lt,{ref:s},[a])}}});const bet=ue({name:"ElTooltipV2Trigger"}),wet=ue({...bet,props:{...Z7,...Dk},setup(t){const e=t,{onClose:n,onOpen:s,onDelayOpen:r,triggerRef:o,contentId:a}=et(gw);let i=!1;const l=w=>{o.value=w},u=()=>{i=!1},c=Xn(e.onMouseEnter,r),d=Xn(e.onMouseLeave,n),f=Xn(e.onMouseDown,()=>{n(),i=!0,document.addEventListener("mouseup",u,{once:!0})}),h=Xn(e.onFocus,()=>{i||s()}),p=Xn(e.onBlur,n),m=Xn(e.onClick,w=>{w.detail===0&&n()}),g={blur:p,click:m,focus:h,mousedown:f,mouseenter:c,mouseleave:d},y=(w,b,_)=>{w&&Object.entries(b).forEach(([$,x])=>{w[_]($,x)})};return Me(o,(w,b)=>{y(w,g,"addEventListener"),y(b,g,"removeEventListener"),w&&w.setAttribute("aria-describedby",a.value)}),ts(()=>{y(o.value,g,"removeEventListener"),document.removeEventListener("mouseup",u)}),(w,b)=>w.nowrap?(S(),$e(v(yet),{key:0,"set-ref":l,"only-child":""},{default:ce(()=>[Oe(w.$slots,"default")]),_:3})):(S(),E("button",zt({key:1,ref_key:"triggerRef",ref:o},w.$attrs),[Oe(w.$slots,"default")],16))}});var _et=je(wet,[["__file","/home/runner/work/element-plus/element-plus/packages/components/tooltip-v2/src/trigger.vue"]]);const $et=ue({name:"ElTooltipV2"}),xet=ue({...$et,props:set,setup(t){const n=Ps(t),s=on(gl(n,Object.keys(Ak))),r=on(gl(n,Object.keys(Ok))),o=on(gl(n,Object.keys(Rk))),a=on(gl(n,Object.keys(Dk)));return(i,l)=>(S(),$e(aet,Wa(Zb(o)),{default:ce(({open:u})=>[se(_et,zt(a,{nowrap:""}),{default:ce(()=>[Oe(i.$slots,"trigger")]),_:3},16),(S(),$e(kg,{to:i.to,disabled:!i.teleported},[i.fullTransition?(S(),$e(ms,Wa(zt({key:0},i.transitionProps)),{default:ce(()=>[i.alwaysOn||u?(S(),$e(CR,Wa(zt({key:0},r)),{arrow:ce(({style:c,side:d})=>[i.showArrow?(S(),$e(SR,zt({key:0},s,{style:c,side:d}),null,16,["style","side"])):ge("v-if",!0)]),default:ce(()=>[Oe(i.$slots,"default")]),_:3},16)):ge("v-if",!0)]),_:2},1040)):(S(),E(lt,{key:1},[i.alwaysOn||u?(S(),$e(CR,Wa(zt({key:0},r)),{arrow:ce(({style:c,side:d})=>[i.showArrow?(S(),$e(SR,zt({key:0},s,{style:c,side:d}),null,16,["style","side"])):ge("v-if",!0)]),default:ce(()=>[Oe(i.$slots,"default")]),_:3},16)):ge("v-if",!0)],64))],8,["to","disabled"]))]),_:3},16))}});var Cet=je(xet,[["__file","/home/runner/work/element-plus/element-plus/packages/components/tooltip-v2/src/tooltip.vue"]]);const ket=Dt(Cet),Q7="left-check-change",eB="right-check-change",If=qe({data:{type:Se(Array),default:()=>[]},titles:{type:Se(Array),default:()=>[]},buttonTexts:{type:Se(Array),default:()=>[]},filterPlaceholder:String,filterMethod:{type:Se(Function)},leftDefaultChecked:{type:Se(Array),default:()=>[]},rightDefaultChecked:{type:Se(Array),default:()=>[]},renderContent:{type:Se(Function)},modelValue:{type:Se(Array),default:()=>[]},format:{type:Se(Object),default:()=>({})},filterable:Boolean,props:{type:Se(Object),default:()=>Ln({label:"label",key:"key",disabled:"disabled"})},targetOrder:{type:String,values:["original","push","unshift"],default:"original"},validateEvent:{type:Boolean,default:!0}}),Z6=(t,e)=>[t,e].every(Qe)||Qe(t)&&nr(e),Tet={[Fn]:(t,e,n)=>[t,n].every(Qe)&&["left","right"].includes(e),[Ot]:t=>Qe(t),[Q7]:Z6,[eB]:Z6},J6="checked-change",Net=qe({data:If.data,optionRender:{type:Se(Function)},placeholder:String,title:String,filterable:Boolean,format:If.format,filterMethod:If.filterMethod,defaultChecked:If.leftDefaultChecked,props:If.props}),Iet={[J6]:Z6},Bg=t=>{const e={label:"label",key:"key",disabled:"disabled"};return A(()=>({...e,...t.props}))},Eet=(t,e,n)=>{const s=Bg(t),r=A(()=>t.data.filter(c=>vt(t.filterMethod)?t.filterMethod(e.query,c):String(c[s.value.label]||c[s.value.key]).toLowerCase().includes(e.query.toLowerCase()))),o=A(()=>r.value.filter(c=>!c[s.value.disabled])),a=A(()=>{const c=e.checked.length,d=t.data.length,{noChecked:f,hasChecked:h}=t.format;return f&&h?c>0?h.replace(/\${checked}/g,c.toString()).replace(/\${total}/g,d.toString()):f.replace(/\${total}/g,d.toString()):`${c}/${d}`}),i=A(()=>{const c=e.checked.length;return c>0&&c<o.value.length}),l=()=>{const c=o.value.map(d=>d[s.value.key]);e.allChecked=c.length>0&&c.every(d=>e.checked.includes(d))},u=c=>{e.checked=c?o.value.map(d=>d[s.value.key]):[]};return Me(()=>e.checked,(c,d)=>{if(l(),e.checkChangeByUser){const f=c.concat(d).filter(h=>!c.includes(h)||!d.includes(h));n(J6,c,f)}else n(J6,c),e.checkChangeByUser=!0}),Me(o,()=>{l()}),Me(()=>t.data,()=>{const c=[],d=r.value.map(f=>f[s.value.key]);e.checked.forEach(f=>{d.includes(f)&&c.push(f)}),e.checkChangeByUser=!1,e.checked=c}),Me(()=>t.defaultChecked,(c,d)=>{if(d&&c.length===d.length&&c.every(p=>d.includes(p)))return;const f=[],h=o.value.map(p=>p[s.value.key]);c.forEach(p=>{h.includes(p)&&f.push(p)}),e.checkChangeByUser=!1,e.checked=f},{immediate:!0}),{filteredData:r,checkableData:o,checkedSummary:a,isIndeterminate:i,updateAllChecked:l,handleAllCheckedChange:u}},Aet=(t,e)=>({onSourceCheckedChange:(r,o)=>{t.leftChecked=r,o&&e(Q7,r,o)},onTargetCheckedChange:(r,o)=>{t.rightChecked=r,o&&e(eB,r,o)}}),Oet=t=>{const e=Bg(t),n=A(()=>t.data.reduce((o,a)=>(o[a[e.value.key]]=a)&&o,{})),s=A(()=>t.data.filter(o=>!t.modelValue.includes(o[e.value.key]))),r=A(()=>t.targetOrder==="original"?t.data.filter(o=>t.modelValue.includes(o[e.value.key])):t.modelValue.reduce((o,a)=>{const i=n.value[a];return i&&o.push(i),o},[]));return{sourceData:s,targetData:r}},Ret=(t,e,n)=>{const s=Bg(t),r=(i,l,u)=>{n(Ot,i),n(Fn,i,l,u)};return{addToLeft:()=>{const i=t.modelValue.slice();e.rightChecked.forEach(l=>{const u=i.indexOf(l);u>-1&&i.splice(u,1)}),r(i,"left",e.rightChecked)},addToRight:()=>{let i=t.modelValue.slice();const l=t.data.filter(u=>{const c=u[s.value.key];return e.leftChecked.includes(c)&&!t.modelValue.includes(c)}).map(u=>u[s.value.key]);i=t.targetOrder==="unshift"?l.concat(i):i.concat(l),t.targetOrder==="original"&&(i=t.data.filter(u=>i.includes(u[s.value.key])).map(u=>u[s.value.key])),r(i,"right",e.leftChecked)}}},Det=ue({name:"ElTransferPanel"}),Fet=ue({...Det,props:Net,emits:Iet,setup(t,{expose:e,emit:n}){const s=t,r=ir(),o=({option:_})=>_,{t:a}=nn(),i=Fe("transfer"),l=on({checked:[],allChecked:!1,query:"",inputHover:!1,checkChangeByUser:!0}),u=Bg(s),{filteredData:c,checkedSummary:d,isIndeterminate:f,handleAllCheckedChange:h}=Eet(s,l,n),p=A(()=>!ia(l.query)&&ia(c.value)),m=A(()=>!ia(r.default()[0].children)),{checked:g,allChecked:y,query:w,inputHover:b}=Ps(l);return e({query:w}),(_,$)=>(S(),E("div",{class:P(v(i).b("panel"))},[I("p",{class:P(v(i).be("panel","header"))},[se(v(ka),{modelValue:v(y),"onUpdate:modelValue":$[0]||($[0]=x=>kn(y)?y.value=x:null),indeterminate:v(f),"validate-event":!1,onChange:v(h)},{default:ce(()=>[Yt(Ue(_.title)+" ",1),I("span",null,Ue(v(d)),1)]),_:1},8,["modelValue","indeterminate","onChange"])],2),I("div",{class:P([v(i).be("panel","body"),v(i).is("with-footer",v(m))])},[_.filterable?(S(),$e(v(Or),{key:0,modelValue:v(w),"onUpdate:modelValue":$[1]||($[1]=x=>kn(w)?w.value=x:null),class:P(v(i).be("panel","filter")),size:"default",placeholder:_.placeholder,"prefix-icon":v(CP),clearable:"","validate-event":!1,onMouseenter:$[2]||($[2]=x=>b.value=!0),onMouseleave:$[3]||($[3]=x=>b.value=!1)},null,8,["modelValue","class","placeholder","prefix-icon"])):ge("v-if",!0),St(se(v(fz),{modelValue:v(g),"onUpdate:modelValue":$[4]||($[4]=x=>kn(g)?g.value=x:null),"validate-event":!1,class:P([v(i).is("filterable",_.filterable),v(i).be("panel","list")])},{default:ce(()=>[(S(!0),E(lt,null,Gt(v(c),x=>(S(),$e(v(ka),{key:x[v(u).key],class:P(v(i).be("panel","item")),label:x[v(u).key],disabled:x[v(u).disabled],"validate-event":!1},{default:ce(()=>{var k;return[se(o,{option:(k=_.optionRender)==null?void 0:k.call(_,x)},null,8,["option"])]}),_:2},1032,["class","label","disabled"]))),128))]),_:1},8,["modelValue","class"]),[[Qt,!v(p)&&!v(ia)(_.data)]]),St(I("p",{class:P(v(i).be("panel","empty"))},Ue(v(p)?v(a)("el.transfer.noMatch"):v(a)("el.transfer.noData")),3),[[Qt,v(p)||v(ia)(_.data)]])],2),v(m)?(S(),E("p",{key:0,class:P(v(i).be("panel","footer"))},[Oe(_.$slots,"default")],2)):ge("v-if",!0)],2))}});var kR=je(Fet,[["__file","/home/runner/work/element-plus/element-plus/packages/components/transfer/src/transfer-panel.vue"]]);const Met={key:0},Pet={key:0},Let=ue({name:"ElTransfer"}),zet=ue({...Let,props:If,emits:Tet,setup(t,{expose:e,emit:n}){const s=t,r=ir(),{t:o}=nn(),a=Fe("transfer"),{formItem:i}=to(),l=on({leftChecked:[],rightChecked:[]}),u=Bg(s),{sourceData:c,targetData:d}=Oet(s),{onSourceCheckedChange:f,onTargetCheckedChange:h}=Aet(l,n),{addToLeft:p,addToRight:m}=Ret(s,l,n),g=U(),y=U(),w=C=>{switch(C){case"left":g.value.query="";break;case"right":y.value.query="";break}},b=A(()=>s.buttonTexts.length===2),_=A(()=>s.titles[0]||o("el.transfer.titles.0")),$=A(()=>s.titles[1]||o("el.transfer.titles.1")),x=A(()=>s.filterPlaceholder||o("el.transfer.filterPlaceholder"));Me(()=>s.modelValue,()=>{var C;s.validateEvent&&((C=i==null?void 0:i.validate)==null||C.call(i,"change").catch(T=>void 0))});const k=A(()=>C=>s.renderContent?s.renderContent(it,C):r.default?r.default({option:C}):it("span",C[u.value.label]||C[u.value.key]));return e({clearQuery:w,leftPanel:g,rightPanel:y}),(C,T)=>(S(),E("div",{class:P(v(a).b())},[se(kR,{ref_key:"leftPanel",ref:g,data:v(c),"option-render":v(k),placeholder:v(x),title:v(_),filterable:C.filterable,format:C.format,"filter-method":C.filterMethod,"default-checked":C.leftDefaultChecked,props:s.props,onCheckedChange:v(f)},{default:ce(()=>[Oe(C.$slots,"left-footer")]),_:3},8,["data","option-render","placeholder","title","filterable","format","filter-method","default-checked","props","onCheckedChange"]),I("div",{class:P(v(a).e("buttons"))},[se(v(br),{type:"primary",class:P([v(a).e("button"),v(a).is("with-texts",v(b))]),disabled:v(ia)(l.rightChecked),onClick:v(p)},{default:ce(()=>[se(v(rt),null,{default:ce(()=>[se(v(xl))]),_:1}),v(er)(C.buttonTexts[0])?ge("v-if",!0):(S(),E("span",Met,Ue(C.buttonTexts[0]),1))]),_:1},8,["class","disabled","onClick"]),se(v(br),{type:"primary",class:P([v(a).e("button"),v(a).is("with-texts",v(b))]),disabled:v(ia)(l.leftChecked),onClick:v(m)},{default:ce(()=>[v(er)(C.buttonTexts[1])?ge("v-if",!0):(S(),E("span",Pet,Ue(C.buttonTexts[1]),1)),se(v(rt),null,{default:ce(()=>[se(v(Rr))]),_:1})]),_:1},8,["class","disabled","onClick"])],2),se(kR,{ref_key:"rightPanel",ref:y,data:v(d),"option-render":v(k),placeholder:v(x),filterable:C.filterable,format:C.format,"filter-method":C.filterMethod,title:v($),"default-checked":C.rightDefaultChecked,props:s.props,onCheckedChange:v(h)},{default:ce(()=>[Oe(C.$slots,"right-footer")]),_:3},8,["data","option-render","placeholder","filterable","format","filter-method","title","default-checked","props","onCheckedChange"])],2))}});var Bet=je(zet,[["__file","/home/runner/work/element-plus/element-plus/packages/components/transfer/src/transfer.vue"]]);const Vet=Dt(Bet),qf="$treeNodeId",TR=function(t,e){!e||e[qf]||Object.defineProperty(e,qf,{value:t.id,enumerable:!1,configurable:!1,writable:!1})},Fk=function(t,e){return t?e[t]:e[qf]},Q6=(t,e,n)=>{const s=t.value.currentNode;n();const r=t.value.currentNode;s!==r&&e("current-change",r?r.data:null,r)},ex=t=>{let e=!0,n=!0,s=!0;for(let r=0,o=t.length;r<o;r++){const a=t[r];(a.checked!==!0||a.indeterminate)&&(e=!1,a.disabled||(s=!1)),(a.checked!==!1||a.indeterminate)&&(n=!1)}return{all:e,none:n,allWithoutDisable:s,half:!e&&!n}},iy=function(t){if(t.childNodes.length===0||t.loading)return;const{all:e,none:n,half:s}=ex(t.childNodes);e?(t.checked=!0,t.indeterminate=!1):s?(t.checked=!1,t.indeterminate=!0):n&&(t.checked=!1,t.indeterminate=!1);const r=t.parent;!r||r.level===0||t.store.checkStrictly||iy(r)},fv=function(t,e){const n=t.store.props,s=t.data||{},r=n[e];if(typeof r=="function")return r(s,t);if(typeof r=="string")return s[r];if(typeof r>"u"){const o=s[e];return o===void 0?"":o}};let Het=0,Xf=class{constructor(e){this.id=Het++,this.text=null,this.checked=!1,this.indeterminate=!1,this.data=null,this.expanded=!1,this.parent=null,this.visible=!0,this.isCurrent=!1,this.canFocus=!1;for(const n in e)Ut(e,n)&&(this[n]=e[n]);this.level=0,this.loaded=!1,this.childNodes=[],this.loading=!1,this.parent&&(this.level=this.parent.level+1)}initialize(){const e=this.store;if(!e)throw new Error("[Node]store is required!");e.registerNode(this);const n=e.props;if(n&&typeof n.isLeaf<"u"){const o=fv(this,"isLeaf");typeof o=="boolean"&&(this.isLeafByUser=o)}if(e.lazy!==!0&&this.data?(this.setData(this.data),e.defaultExpandAll&&(this.expanded=!0,this.canFocus=!0)):this.level>0&&e.lazy&&e.defaultExpandAll&&this.expand(),Array.isArray(this.data)||TR(this,this.data),!this.data)return;const s=e.defaultExpandedKeys,r=e.key;r&&s&&s.includes(this.key)&&this.expand(null,e.autoExpandParent),r&&e.currentNodeKey!==void 0&&this.key===e.currentNodeKey&&(e.currentNode=this,e.currentNode.isCurrent=!0),e.lazy&&e._initDefaultCheckedNode(this),this.updateLeafState(),this.parent&&(this.level===1||this.parent.expanded===!0)&&(this.canFocus=!0)}setData(e){Array.isArray(e)||TR(this,e),this.data=e,this.childNodes=[];let n;this.level===0&&Array.isArray(this.data)?n=this.data:n=fv(this,"children")||[];for(let s=0,r=n.length;s<r;s++)this.insertChild({data:n[s]})}get label(){return fv(this,"label")}get key(){const e=this.store.key;return this.data?this.data[e]:null}get disabled(){return fv(this,"disabled")}get nextSibling(){const e=this.parent;if(e){const n=e.childNodes.indexOf(this);if(n>-1)return e.childNodes[n+1]}return null}get previousSibling(){const e=this.parent;if(e){const n=e.childNodes.indexOf(this);if(n>-1)return n>0?e.childNodes[n-1]:null}return null}contains(e,n=!0){return(this.childNodes||[]).some(s=>s===e||n&&s.contains(e))}remove(){const e=this.parent;e&&e.removeChild(this)}insertChild(e,n,s){if(!e)throw new Error("InsertChild error: child is required.");if(!(e instanceof Xf)){if(!s){const r=this.getChildren(!0);r.includes(e.data)||(typeof n>"u"||n<0?r.push(e.data):r.splice(n,0,e.data))}Object.assign(e,{parent:this,store:this.store}),e=on(new Xf(e)),e instanceof Xf&&e.initialize()}e.level=this.level+1,typeof n>"u"||n<0?this.childNodes.push(e):this.childNodes.splice(n,0,e),this.updateLeafState()}insertBefore(e,n){let s;n&&(s=this.childNodes.indexOf(n)),this.insertChild(e,s)}insertAfter(e,n){let s;n&&(s=this.childNodes.indexOf(n),s!==-1&&(s+=1)),this.insertChild(e,s)}removeChild(e){const n=this.getChildren()||[],s=n.indexOf(e.data);s>-1&&n.splice(s,1);const r=this.childNodes.indexOf(e);r>-1&&(this.store&&this.store.deregisterNode(e),e.parent=null,this.childNodes.splice(r,1)),this.updateLeafState()}removeChildByData(e){let n=null;for(let s=0;s<this.childNodes.length;s++)if(this.childNodes[s].data===e){n=this.childNodes[s];break}n&&this.removeChild(n)}expand(e,n){const s=()=>{if(n){let r=this.parent;for(;r.level>0;)r.expanded=!0,r=r.parent}this.expanded=!0,e&&e(),this.childNodes.forEach(r=>{r.canFocus=!0})};this.shouldLoadData()?this.loadData(r=>{Array.isArray(r)&&(this.checked?this.setChecked(!0,!0):this.store.checkStrictly||iy(this),s())}):s()}doCreateChildren(e,n={}){e.forEach(s=>{this.insertChild(Object.assign({data:s},n),void 0,!0)})}collapse(){this.expanded=!1,this.childNodes.forEach(e=>{e.canFocus=!1})}shouldLoadData(){return this.store.lazy===!0&&this.store.load&&!this.loaded}updateLeafState(){if(this.store.lazy===!0&&this.loaded!==!0&&typeof this.isLeafByUser<"u"){this.isLeaf=this.isLeafByUser;return}const e=this.childNodes;if(!this.store.lazy||this.store.lazy===!0&&this.loaded===!0){this.isLeaf=!e||e.length===0;return}this.isLeaf=!1}setChecked(e,n,s,r){if(this.indeterminate=e==="half",this.checked=e===!0,this.store.checkStrictly)return;if(!(this.shouldLoadData()&&!this.store.checkDescendants)){const{all:a,allWithoutDisable:i}=ex(this.childNodes);!this.isLeaf&&!a&&i&&(this.checked=!1,e=!1);const l=()=>{if(n){const u=this.childNodes;for(let f=0,h=u.length;f<h;f++){const p=u[f];r=r||e!==!1;const m=p.disabled?p.checked:r;p.setChecked(m,n,!0,r)}const{half:c,all:d}=ex(u);d||(this.checked=d,this.indeterminate=c)}};if(this.shouldLoadData()){this.loadData(()=>{l(),iy(this)},{checked:e!==!1});return}else l()}const o=this.parent;!o||o.level===0||s||iy(o)}getChildren(e=!1){if(this.level===0)return this.data;const n=this.data;if(!n)return null;const s=this.store.props;let r="children";return s&&(r=s.children||"children"),n[r]===void 0&&(n[r]=null),e&&!n[r]&&(n[r]=[]),n[r]}updateChildren(){const e=this.getChildren()||[],n=this.childNodes.map(o=>o.data),s={},r=[];e.forEach((o,a)=>{const i=o[qf];!!i&&n.findIndex(u=>u[qf]===i)>=0?s[i]={index:a,data:o}:r.push({index:a,data:o})}),this.store.lazy||n.forEach(o=>{s[o[qf]]||this.removeChildByData(o)}),r.forEach(({index:o,data:a})=>{this.insertChild({data:a},o)}),this.updateLeafState()}loadData(e,n={}){if(this.store.lazy===!0&&this.store.load&&!this.loaded&&(!this.loading||Object.keys(n).length)){this.loading=!0;const s=r=>{this.childNodes=[],this.doCreateChildren(r,n),this.loaded=!0,this.loading=!1,this.updateLeafState(),e&&e.call(this,r)};this.store.load(this,s)}else e&&e.call(this)}};class Wet{constructor(e){this.currentNode=null,this.currentNodeKey=null;for(const n in e)Ut(e,n)&&(this[n]=e[n]);this.nodesMap={}}initialize(){if(this.root=new Xf({data:this.data,store:this}),this.root.initialize(),this.lazy&&this.load){const e=this.load;e(this.root,n=>{this.root.doCreateChildren(n),this._initDefaultCheckedNodes()})}else this._initDefaultCheckedNodes()}filter(e){const n=this.filterNodeMethod,s=this.lazy,r=function(o){const a=o.root?o.root.childNodes:o.childNodes;if(a.forEach(i=>{i.visible=n.call(i,e,i.data,i),r(i)}),!o.visible&&a.length){let i=!0;i=!a.some(l=>l.visible),o.root?o.root.visible=i===!1:o.visible=i===!1}!e||o.visible&&!o.isLeaf&&!s&&o.expand()};r(this)}setData(e){e!==this.root.data?(this.root.setData(e),this._initDefaultCheckedNodes()):this.root.updateChildren()}getNode(e){if(e instanceof Xf)return e;const n=Bt(e)?Fk(this.key,e):e;return this.nodesMap[n]||null}insertBefore(e,n){const s=this.getNode(n);s.parent.insertBefore({data:e},s)}insertAfter(e,n){const s=this.getNode(n);s.parent.insertAfter({data:e},s)}remove(e){const n=this.getNode(e);n&&n.parent&&(n===this.currentNode&&(this.currentNode=null),n.parent.removeChild(n))}append(e,n){const s=n?this.getNode(n):this.root;s&&s.insertChild({data:e})}_initDefaultCheckedNodes(){const e=this.defaultCheckedKeys||[],n=this.nodesMap;e.forEach(s=>{const r=n[s];r&&r.setChecked(!0,!this.checkStrictly)})}_initDefaultCheckedNode(e){(this.defaultCheckedKeys||[]).includes(e.key)&&e.setChecked(!0,!this.checkStrictly)}setDefaultCheckedKey(e){e!==this.defaultCheckedKeys&&(this.defaultCheckedKeys=e,this._initDefaultCheckedNodes())}registerNode(e){const n=this.key;!e||!e.data||(n?e.key!==void 0&&(this.nodesMap[e.key]=e):this.nodesMap[e.id]=e)}deregisterNode(e){!this.key||!e||!e.data||(e.childNodes.forEach(s=>{this.deregisterNode(s)}),delete this.nodesMap[e.key])}getCheckedNodes(e=!1,n=!1){const s=[],r=function(o){(o.root?o.root.childNodes:o.childNodes).forEach(i=>{(i.checked||n&&i.indeterminate)&&(!e||e&&i.isLeaf)&&s.push(i.data),r(i)})};return r(this),s}getCheckedKeys(e=!1){return this.getCheckedNodes(e).map(n=>(n||{})[this.key])}getHalfCheckedNodes(){const e=[],n=function(s){(s.root?s.root.childNodes:s.childNodes).forEach(o=>{o.indeterminate&&e.push(o.data),n(o)})};return n(this),e}getHalfCheckedKeys(){return this.getHalfCheckedNodes().map(e=>(e||{})[this.key])}_getAllNodes(){const e=[],n=this.nodesMap;for(const s in n)Ut(n,s)&&e.push(n[s]);return e}updateChildren(e,n){const s=this.nodesMap[e];if(!s)return;const r=s.childNodes;for(let o=r.length-1;o>=0;o--){const a=r[o];this.remove(a.data)}for(let o=0,a=n.length;o<a;o++){const i=n[o];this.append(i,s.data)}}_setCheckedKeys(e,n=!1,s){const r=this._getAllNodes().sort((i,l)=>l.level-i.level),o=Object.create(null),a=Object.keys(s);r.forEach(i=>i.setChecked(!1,!1));for(let i=0,l=r.length;i<l;i++){const u=r[i],c=u.data[e].toString();if(!a.includes(c)){u.checked&&!o[c]&&u.setChecked(!1,!1);continue}let f=u.parent;for(;f&&f.level>0;)o[f.data[e]]=!0,f=f.parent;if(u.isLeaf||this.checkStrictly){u.setChecked(!0,!1);continue}if(u.setChecked(!0,!0),n){u.setChecked(!1,!1);const h=function(p){p.childNodes.forEach(g=>{g.isLeaf||g.setChecked(!1,!1),h(g)})};h(u)}}}setCheckedNodes(e,n=!1){const s=this.key,r={};e.forEach(o=>{r[(o||{})[s]]=!0}),this._setCheckedKeys(s,n,r)}setCheckedKeys(e,n=!1){this.defaultCheckedKeys=e;const s=this.key,r={};e.forEach(o=>{r[o]=!0}),this._setCheckedKeys(s,n,r)}setDefaultExpandedKeys(e){e=e||[],this.defaultExpandedKeys=e,e.forEach(n=>{const s=this.getNode(n);s&&s.expand(null,this.autoExpandParent)})}setChecked(e,n,s){const r=this.getNode(e);r&&r.setChecked(!!n,s)}getCurrentNode(){return this.currentNode}setCurrentNode(e){const n=this.currentNode;n&&(n.isCurrent=!1),this.currentNode=e,this.currentNode.isCurrent=!0}setUserCurrentNode(e,n=!0){const s=e[this.key],r=this.nodesMap[s];this.setCurrentNode(r),n&&this.currentNode.level>1&&this.currentNode.parent.expand(null,!0)}setCurrentNodeKey(e,n=!0){if(e==null){this.currentNode&&(this.currentNode.isCurrent=!1),this.currentNode=null;return}const s=this.getNode(e);s&&(this.setCurrentNode(s),n&&this.currentNode.level>1&&this.currentNode.parent.expand(null,!0))}}const Uet=ue({name:"ElTreeNodeContent",props:{node:{type:Object,required:!0},renderContent:Function},setup(t){const e=Fe("tree"),n=et("NodeInstance"),s=et("RootTree");return()=>{const r=t.node,{data:o,store:a}=r;return t.renderContent?t.renderContent(it,{_self:n,node:r,data:o,store:a}):s.ctx.slots.default?s.ctx.slots.default({node:r,data:o}):it("span",{class:e.be("node","label")},[r.label])}}});var Get=je(Uet,[["__file","/home/runner/work/element-plus/element-plus/packages/components/tree/src/tree-node-content.vue"]]);function tB(t){const e=et("TreeNodeMap",null),n={treeNodeExpand:s=>{t.node!==s&&t.node.collapse()},children:[]};return e&&e.children.push(n),Lt("TreeNodeMap",n),{broadcastExpanded:s=>{if(!!t.accordion)for(const r of n.children)r.treeNodeExpand(s)}}}const nB=Symbol("dragEvents");function jet({props:t,ctx:e,el$:n,dropIndicator$:s,store:r}){const o=Fe("tree"),a=U({showDropIndicator:!1,draggingNode:null,dropNode:null,allowDrop:!0,dropType:null});return Lt(nB,{treeNodeDragStart:({event:c,treeNode:d})=>{if(typeof t.allowDrag=="function"&&!t.allowDrag(d.node))return c.preventDefault(),!1;c.dataTransfer.effectAllowed="move";try{c.dataTransfer.setData("text/plain","")}catch{}a.value.draggingNode=d,e.emit("node-drag-start",d.node,c)},treeNodeDragOver:({event:c,treeNode:d})=>{const f=d,h=a.value.dropNode;h&&h!==f&&mo(h.$el,o.is("drop-inner"));const p=a.value.draggingNode;if(!p||!f)return;let m=!0,g=!0,y=!0,w=!0;typeof t.allowDrop=="function"&&(m=t.allowDrop(p.node,f.node,"prev"),w=g=t.allowDrop(p.node,f.node,"inner"),y=t.allowDrop(p.node,f.node,"next")),c.dataTransfer.dropEffect=g||m||y?"move":"none",(m||g||y)&&h!==f&&(h&&e.emit("node-drag-leave",p.node,h.node,c),e.emit("node-drag-enter",p.node,f.node,c)),(m||g||y)&&(a.value.dropNode=f),f.node.nextSibling===p.node&&(y=!1),f.node.previousSibling===p.node&&(m=!1),f.node.contains(p.node,!1)&&(g=!1),(p.node===f.node||p.node.contains(f.node))&&(m=!1,g=!1,y=!1);const b=f.$el.getBoundingClientRect(),_=n.value.getBoundingClientRect();let $;const x=m?g?.25:y?.45:1:-1,k=y?g?.75:m?.55:0:1;let C=-9999;const T=c.clientY-b.top;T<b.height*x?$="before":T>b.height*k?$="after":g?$="inner":$="none";const N=f.$el.querySelector(`.${o.be("node","expand-icon")}`).getBoundingClientRect(),M=s.value;$==="before"?C=N.top-_.top:$==="after"&&(C=N.bottom-_.top),M.style.top=`${C}px`,M.style.left=`${N.right-_.left}px`,$==="inner"?xi(f.$el,o.is("drop-inner")):mo(f.$el,o.is("drop-inner")),a.value.showDropIndicator=$==="before"||$==="after",a.value.allowDrop=a.value.showDropIndicator||w,a.value.dropType=$,e.emit("node-drag-over",p.node,f.node,c)},treeNodeDragEnd:c=>{const{draggingNode:d,dropType:f,dropNode:h}=a.value;if(c.preventDefault(),c.dataTransfer.dropEffect="move",d&&h){const p={data:d.node.data};f!=="none"&&d.node.remove(),f==="before"?h.node.parent.insertBefore(p,h.node):f==="after"?h.node.parent.insertAfter(p,h.node):f==="inner"&&h.node.insertChild(p),f!=="none"&&r.value.registerNode(p),mo(h.$el,o.is("drop-inner")),e.emit("node-drag-end",d.node,h.node,f,c),f!=="none"&&e.emit("node-drop",d.node,h.node,f,c)}d&&!h&&e.emit("node-drag-end",d.node,null,f,c),a.value.showDropIndicator=!1,a.value.draggingNode=null,a.value.dropNode=null,a.value.allowDrop=!0}}),{dragState:a}}const Ket=ue({name:"ElTreeNode",components:{ElCollapseTransition:Cw,ElCheckbox:ka,NodeContent:Get,ElIcon:rt,Loading:Vl},props:{node:{type:Xf,default:()=>({})},props:{type:Object,default:()=>({})},accordion:Boolean,renderContent:Function,renderAfterExpand:Boolean,showCheckbox:{type:Boolean,default:!1}},emits:["node-expand"],setup(t,e){const n=Fe("tree"),{broadcastExpanded:s}=tB(t),r=et("RootTree"),o=U(!1),a=U(!1),i=U(null),l=U(null),u=U(null),c=et(nB),d=Rt();Lt("NodeInstance",d),t.node.expanded&&(o.value=!0,a.value=!0);const f=r.props.children||"children";Me(()=>{const T=t.node.data[f];return T&&[...T]},()=>{t.node.updateChildren()}),Me(()=>t.node.indeterminate,T=>{m(t.node.checked,T)}),Me(()=>t.node.checked,T=>{m(T,t.node.indeterminate)}),Me(()=>t.node.expanded,T=>{nt(()=>o.value=T),T&&(a.value=!0)});const h=T=>Fk(r.props.nodeKey,T.data),p=T=>{const N=t.props.class;if(!N)return{};let M;if(vt(N)){const{data:R}=T;M=N(R,T)}else M=N;return wt(M)?{[M]:!0}:M},m=(T,N)=>{(i.value!==T||l.value!==N)&&r.ctx.emit("check-change",t.node.data,T,N),i.value=T,l.value=N},g=T=>{Q6(r.store,r.ctx.emit,()=>r.store.value.setCurrentNode(t.node)),r.currentNode.value=t.node,r.props.expandOnClickNode&&w(),r.props.checkOnClickNode&&!t.node.disabled&&b(null,{target:{checked:!t.node.checked}}),r.ctx.emit("node-click",t.node.data,t.node,d,T)},y=T=>{r.instance.vnode.props.onNodeContextmenu&&(T.stopPropagation(),T.preventDefault()),r.ctx.emit("node-contextmenu",T,t.node.data,t.node,d)},w=()=>{t.node.isLeaf||(o.value?(r.ctx.emit("node-collapse",t.node.data,t.node,d),t.node.collapse()):(t.node.expand(),e.emit("node-expand",t.node.data,t.node,d)))},b=(T,N)=>{t.node.setChecked(N.target.checked,!r.props.checkStrictly),nt(()=>{const M=r.store.value;r.ctx.emit("check",t.node.data,{checkedNodes:M.getCheckedNodes(),checkedKeys:M.getCheckedKeys(),halfCheckedNodes:M.getHalfCheckedNodes(),halfCheckedKeys:M.getHalfCheckedKeys()})})};return{ns:n,node$:u,tree:r,expanded:o,childNodeRendered:a,oldChecked:i,oldIndeterminate:l,getNodeKey:h,getNodeClass:p,handleSelectChange:m,handleClick:g,handleContextMenu:y,handleExpandIconClick:w,handleCheckChange:b,handleChildNodeExpand:(T,N,M)=>{s(N),r.ctx.emit("node-expand",T,N,M)},handleDragStart:T=>{!r.props.draggable||c.treeNodeDragStart({event:T,treeNode:t})},handleDragOver:T=>{T.preventDefault(),r.props.draggable&&c.treeNodeDragOver({event:T,treeNode:{$el:u.value,node:t.node}})},handleDrop:T=>{T.preventDefault()},handleDragEnd:T=>{!r.props.draggable||c.treeNodeDragEnd(T)},CaretRight:EC}}}),qet=["aria-expanded","aria-disabled","aria-checked","draggable","data-key"],Xet=["aria-expanded"];function Yet(t,e,n,s,r,o){const a=pt("el-icon"),i=pt("el-checkbox"),l=pt("loading"),u=pt("node-content"),c=pt("el-tree-node"),d=pt("el-collapse-transition");return St((S(),E("div",{ref:"node$",class:P([t.ns.b("node"),t.ns.is("expanded",t.expanded),t.ns.is("current",t.node.isCurrent),t.ns.is("hidden",!t.node.visible),t.ns.is("focusable",!t.node.disabled),t.ns.is("checked",!t.node.disabled&&t.node.checked),t.getNodeClass(t.node)]),role:"treeitem",tabindex:"-1","aria-expanded":t.expanded,"aria-disabled":t.node.disabled,"aria-checked":t.node.checked,draggable:t.tree.props.draggable,"data-key":t.getNodeKey(t.node),onClick:e[1]||(e[1]=yt((...f)=>t.handleClick&&t.handleClick(...f),["stop"])),onContextmenu:e[2]||(e[2]=(...f)=>t.handleContextMenu&&t.handleContextMenu(...f)),onDragstart:e[3]||(e[3]=yt((...f)=>t.handleDragStart&&t.handleDragStart(...f),["stop"])),onDragover:e[4]||(e[4]=yt((...f)=>t.handleDragOver&&t.handleDragOver(...f),["stop"])),onDragend:e[5]||(e[5]=yt((...f)=>t.handleDragEnd&&t.handleDragEnd(...f),["stop"])),onDrop:e[6]||(e[6]=yt((...f)=>t.handleDrop&&t.handleDrop(...f),["stop"]))},[I("div",{class:P(t.ns.be("node","content")),style:ot({paddingLeft:(t.node.level-1)*t.tree.props.indent+"px"})},[t.tree.props.icon||t.CaretRight?(S(),$e(a,{key:0,class:P([t.ns.be("node","expand-icon"),t.ns.is("leaf",t.node.isLeaf),{expanded:!t.node.isLeaf&&t.expanded}]),onClick:yt(t.handleExpandIconClick,["stop"])},{default:ce(()=>[(S(),$e(Vt(t.tree.props.icon||t.CaretRight)))]),_:1},8,["class","onClick"])):ge("v-if",!0),t.showCheckbox?(S(),$e(i,{key:1,"model-value":t.node.checked,indeterminate:t.node.indeterminate,disabled:!!t.node.disabled,onClick:e[0]||(e[0]=yt(()=>{},["stop"])),onChange:t.handleCheckChange},null,8,["model-value","indeterminate","disabled","onChange"])):ge("v-if",!0),t.node.loading?(S(),$e(a,{key:2,class:P([t.ns.be("node","loading-icon"),t.ns.is("loading")])},{default:ce(()=>[se(l)]),_:1},8,["class"])):ge("v-if",!0),se(u,{node:t.node,"render-content":t.renderContent},null,8,["node","render-content"])],6),se(d,null,{default:ce(()=>[!t.renderAfterExpand||t.childNodeRendered?St((S(),E("div",{key:0,class:P(t.ns.be("node","children")),role:"group","aria-expanded":t.expanded},[(S(!0),E(lt,null,Gt(t.node.childNodes,f=>(S(),$e(c,{key:t.getNodeKey(f),"render-content":t.renderContent,"render-after-expand":t.renderAfterExpand,"show-checkbox":t.showCheckbox,node:f,accordion:t.accordion,props:t.props,onNodeExpand:t.handleChildNodeExpand},null,8,["render-content","render-after-expand","show-checkbox","node","accordion","props","onNodeExpand"]))),128))],10,Xet)),[[Qt,t.expanded]]):ge("v-if",!0)]),_:1})],42,qet)),[[Qt,t.node.visible]])}var Zet=je(Ket,[["render",Yet],["__file","/home/runner/work/element-plus/element-plus/packages/components/tree/src/tree-node.vue"]]);function Jet({el$:t},e){const n=Fe("tree"),s=Nn([]),r=Nn([]);It(()=>{a()}),Ml(()=>{s.value=Array.from(t.value.querySelectorAll("[role=treeitem]")),r.value=Array.from(t.value.querySelectorAll("input[type=checkbox]"))}),Me(r,i=>{i.forEach(l=>{l.setAttribute("tabindex","-1")})}),Rn(t,"keydown",i=>{const l=i.target;if(!l.className.includes(n.b("node")))return;const u=i.code;s.value=Array.from(t.value.querySelectorAll(`.${n.is("focusable")}[role=treeitem]`));const c=s.value.indexOf(l);let d;if([ut.up,ut.down].includes(u)){if(i.preventDefault(),u===ut.up){d=c===-1?0:c!==0?c-1:s.value.length-1;const h=d;for(;!e.value.getNode(s.value[d].dataset.key).canFocus;){if(d--,d===h){d=-1;break}d<0&&(d=s.value.length-1)}}else{d=c===-1?0:c<s.value.length-1?c+1:0;const h=d;for(;!e.value.getNode(s.value[d].dataset.key).canFocus;){if(d++,d===h){d=-1;break}d>=s.value.length&&(d=0)}}d!==-1&&s.value[d].focus()}[ut.left,ut.right].includes(u)&&(i.preventDefault(),l.click());const f=l.querySelector('[type="checkbox"]');[ut.enter,ut.space].includes(u)&&f&&(i.preventDefault(),f.click())});const a=()=>{var i;s.value=Array.from(t.value.querySelectorAll(`.${n.is("focusable")}[role=treeitem]`)),r.value=Array.from(t.value.querySelectorAll("input[type=checkbox]"));const l=t.value.querySelectorAll(`.${n.is("checked")}[role=treeitem]`);if(l.length){l[0].setAttribute("tabindex","0");return}(i=s.value[0])==null||i.setAttribute("tabindex","0")}}const Qet=ue({name:"ElTree",components:{ElTreeNode:Zet},props:{data:{type:Array,default:()=>[]},emptyText:{type:String},renderAfterExpand:{type:Boolean,default:!0},nodeKey:String,checkStrictly:Boolean,defaultExpandAll:Boolean,expandOnClickNode:{type:Boolean,default:!0},checkOnClickNode:Boolean,checkDescendants:{type:Boolean,default:!1},autoExpandParent:{type:Boolean,default:!0},defaultCheckedKeys:Array,defaultExpandedKeys:Array,currentNodeKey:[String,Number],renderContent:Function,showCheckbox:{type:Boolean,default:!1},draggable:{type:Boolean,default:!1},allowDrag:Function,allowDrop:Function,props:{type:Object,default:()=>({children:"children",label:"label",disabled:"disabled"})},lazy:{type:Boolean,default:!1},highlightCurrent:Boolean,load:Function,filterNodeMethod:Function,accordion:Boolean,indent:{type:Number,default:18},icon:{type:In}},emits:["check-change","current-change","node-click","node-contextmenu","node-collapse","node-expand","check","node-drag-start","node-drag-end","node-drop","node-drag-leave","node-drag-enter","node-drag-over"],setup(t,e){const{t:n}=nn(),s=Fe("tree"),r=U(new Wet({key:t.nodeKey,data:t.data,lazy:t.lazy,props:t.props,load:t.load,currentNodeKey:t.currentNodeKey,checkStrictly:t.checkStrictly,checkDescendants:t.checkDescendants,defaultCheckedKeys:t.defaultCheckedKeys,defaultExpandedKeys:t.defaultExpandedKeys,autoExpandParent:t.autoExpandParent,defaultExpandAll:t.defaultExpandAll,filterNodeMethod:t.filterNodeMethod}));r.value.initialize();const o=U(r.value.root),a=U(null),i=U(null),l=U(null),{broadcastExpanded:u}=tB(t),{dragState:c}=jet({props:t,ctx:e,el$:i,dropIndicator$:l,store:r});Jet({el$:i},r);const d=A(()=>{const{childNodes:O}=o.value;return!O||O.length===0||O.every(({visible:F})=>!F)});Me(()=>t.currentNodeKey,O=>{r.value.setCurrentNodeKey(O)}),Me(()=>t.defaultCheckedKeys,O=>{r.value.setDefaultCheckedKey(O)}),Me(()=>t.defaultExpandedKeys,O=>{r.value.setDefaultExpandedKeys(O)}),Me(()=>t.data,O=>{r.value.setData(O)},{deep:!0}),Me(()=>t.checkStrictly,O=>{r.value.checkStrictly=O});const f=O=>{if(!t.filterNodeMethod)throw new Error("[Tree] filterNodeMethod is required when filter");r.value.filter(O)},h=O=>Fk(t.nodeKey,O.data),p=O=>{if(!t.nodeKey)throw new Error("[Tree] nodeKey is required in getNodePath");const F=r.value.getNode(O);if(!F)return[];const L=[F.data];let G=F.parent;for(;G&&G!==o.value;)L.push(G.data),G=G.parent;return L.reverse()},m=(O,F)=>r.value.getCheckedNodes(O,F),g=O=>r.value.getCheckedKeys(O),y=()=>{const O=r.value.getCurrentNode();return O?O.data:null},w=()=>{if(!t.nodeKey)throw new Error("[Tree] nodeKey is required in getCurrentKey");const O=y();return O?O[t.nodeKey]:null},b=(O,F)=>{if(!t.nodeKey)throw new Error("[Tree] nodeKey is required in setCheckedNodes");r.value.setCheckedNodes(O,F)},_=(O,F)=>{if(!t.nodeKey)throw new Error("[Tree] nodeKey is required in setCheckedKeys");r.value.setCheckedKeys(O,F)},$=(O,F,L)=>{r.value.setChecked(O,F,L)},x=()=>r.value.getHalfCheckedNodes(),k=()=>r.value.getHalfCheckedKeys(),C=(O,F=!0)=>{if(!t.nodeKey)throw new Error("[Tree] nodeKey is required in setCurrentNode");Q6(r,e.emit,()=>r.value.setUserCurrentNode(O,F))},T=(O,F=!0)=>{if(!t.nodeKey)throw new Error("[Tree] nodeKey is required in setCurrentKey");Q6(r,e.emit,()=>r.value.setCurrentNodeKey(O,F))},N=O=>r.value.getNode(O),M=O=>{r.value.remove(O)},R=(O,F)=>{r.value.append(O,F)},D=(O,F)=>{r.value.insertBefore(O,F)},z=(O,F)=>{r.value.insertAfter(O,F)},B=(O,F,L)=>{u(F),e.emit("node-expand",O,F,L)},V=(O,F)=>{if(!t.nodeKey)throw new Error("[Tree] nodeKey is required in updateKeyChild");r.value.updateChildren(O,F)};return Lt("RootTree",{ctx:e,props:t,store:r,root:o,currentNode:a,instance:Rt()}),Lt(Li,void 0),{ns:s,store:r,root:o,currentNode:a,dragState:c,el$:i,dropIndicator$:l,isEmpty:d,filter:f,getNodeKey:h,getNodePath:p,getCheckedNodes:m,getCheckedKeys:g,getCurrentNode:y,getCurrentKey:w,setCheckedNodes:b,setCheckedKeys:_,setChecked:$,getHalfCheckedNodes:x,getHalfCheckedKeys:k,setCurrentNode:C,setCurrentKey:T,t:n,getNode:N,remove:M,append:R,insertBefore:D,insertAfter:z,handleNodeExpand:B,updateKeyChildren:V}}});function ett(t,e,n,s,r,o){var a;const i=pt("el-tree-node");return S(),E("div",{ref:"el$",class:P([t.ns.b(),t.ns.is("dragging",!!t.dragState.draggingNode),t.ns.is("drop-not-allow",!t.dragState.allowDrop),t.ns.is("drop-inner",t.dragState.dropType==="inner"),{[t.ns.m("highlight-current")]:t.highlightCurrent}]),role:"tree"},[(S(!0),E(lt,null,Gt(t.root.childNodes,l=>(S(),$e(i,{key:t.getNodeKey(l),node:l,props:t.props,accordion:t.accordion,"render-after-expand":t.renderAfterExpand,"show-checkbox":t.showCheckbox,"render-content":t.renderContent,onNodeExpand:t.handleNodeExpand},null,8,["node","props","accordion","render-after-expand","show-checkbox","render-content","onNodeExpand"]))),128)),t.isEmpty?(S(),E("div",{key:0,class:P(t.ns.e("empty-block"))},[I("span",{class:P(t.ns.e("empty-text"))},Ue((a=t.emptyText)!=null?a:t.t("el.tree.emptyText")),3)],2)):ge("v-if",!0),St(I("div",{ref:"dropIndicator$",class:P(t.ns.e("drop-indicator"))},null,2),[[Qt,t.dragState.showDropIndicator]])],2)}var ly=je(Qet,[["render",ett],["__file","/home/runner/work/element-plus/element-plus/packages/components/tree/src/tree.vue"]]);ly.install=t=>{t.component(ly.name,ly)};const Hy=ly,ttt=Hy,ntt=(t,{attrs:e},{tree:n,key:s})=>{const r=Fe("tree-select"),o={...gl(Ps(t),Object.keys(kd.props)),...e,valueKey:s,popperClass:A(()=>{const a=[r.e("popper")];return t.popperClass&&a.push(t.popperClass),a.join(" ")}),filterMethod:(a="")=>{t.filterMethod&&t.filterMethod(a),nt(()=>{var i;(i=n.value)==null||i.filter(a)})},onVisibleChange:a=>{var i;(i=e.onVisibleChange)==null||i.call(e,a),t.filterable&&a&&o.filterMethod()}};return o},stt=ue({extends:Dy,setup(t,e){const n=Dy.setup(t,e);delete n.selectOptionClick;const s=Rt().proxy;return nt(()=>{n.select.cachedOptions.get(s.value)||n.select.onOptionCreate(s)}),n},methods:{selectOptionClick(){this.$el.parentElement.click()}}});function tx(t){return t||t===0}function Mk(t){return Array.isArray(t)&&t.length}function d$(t){return Array.isArray(t)?t:tx(t)?[t]:[]}function uy(t,e,n,s,r){for(let o=0;o<t.length;o++){const a=t[o];if(e(a,o,t,r))return s?s(a,o,t,r):a;{const i=n(a);if(Mk(i)){const l=uy(i,e,n,s,a);if(l)return l}}}}function sB(t,e,n,s){for(let r=0;r<t.length;r++){const o=t[r];e(o,r,t,s);const a=n(o);Mk(a)&&sB(a,e,n,o)}}const rtt=(t,{attrs:e,slots:n,emit:s},{select:r,tree:o,key:a})=>{Me(()=>t.modelValue,()=>{t.showCheckbox&&nt(()=>{const d=o.value;d&&!Wo(d.getCheckedKeys(),d$(t.modelValue))&&d.setCheckedKeys(d$(t.modelValue))})},{immediate:!0,deep:!0});const i=A(()=>({value:a.value,...t.props})),l=(d,f)=>{var h;const p=i.value[d];return vt(p)?p(f,(h=o.value)==null?void 0:h.getNode(l("value",f))):f[p]},u=d$(t.modelValue).map(d=>uy(t.data||[],f=>l("value",f)===d,f=>l("children",f),(f,h,p,m)=>m&&l("value",m))).filter(d=>tx(d)),c=A(()=>{if(!t.renderAfterExpand&&!t.lazy)return[];const d=[];return sB(t.data.concat(t.cacheData),f=>{const h=l("value",f);d.push({value:h,currentLabel:l("label",f),isDisabled:l("disabled",f)})},f=>l("children",f)),d});return{...gl(Ps(t),Object.keys(Hy.props)),...e,nodeKey:a,expandOnClickNode:A(()=>!t.checkStrictly&&t.expandOnClickNode),defaultExpandedKeys:A(()=>t.defaultExpandedKeys?t.defaultExpandedKeys.concat(u):u),renderContent:(d,{node:f,data:h,store:p})=>d(stt,{value:l("value",h),label:l("label",h),disabled:l("disabled",h)},t.renderContent?()=>t.renderContent(d,{node:f,data:h,store:p}):n.default?()=>n.default({node:f,data:h,store:p}):void 0),filterNodeMethod:(d,f,h)=>{var p;return t.filterNodeMethod?t.filterNodeMethod(d,f,h):d?(p=l("label",f))==null?void 0:p.includes(d):!0},onNodeClick:(d,f,h)=>{var p,m,g;if((p=e.onNodeClick)==null||p.call(e,d,f,h),!(t.showCheckbox&&t.checkOnClickNode))if(!t.showCheckbox&&(t.checkStrictly||f.isLeaf)){if(!l("disabled",d)){const y=(m=r.value)==null?void 0:m.options.get(l("value",d));(g=r.value)==null||g.handleOptionSelect(y,!0)}}else t.expandOnClickNode&&h.proxy.handleExpandIconClick()},onCheck:(d,f)=>{var h;(h=e.onCheck)==null||h.call(e,d,f);const p=l("value",d);if(t.checkStrictly)s(Ot,t.multiple?f.checkedKeys:f.checkedKeys.includes(p)?p:void 0);else if(t.multiple)s(Ot,o.value.getCheckedKeys(!0));else{const m=uy([d],w=>!Mk(l("children",w))&&!l("disabled",w),w=>l("children",w)),g=m?l("value",m):void 0,y=tx(t.modelValue)&&!!uy([d],w=>l("value",w)===t.modelValue,w=>l("children",w));s(Ot,g===t.modelValue||y?void 0:g)}},cacheOptions:c}};var ott=ue({props:{data:{type:Array,default:()=>[]}},setup(t){const e=et(Lg);return t.data.forEach(n=>e.cachedOptions.set(n.value,n)),()=>{}}});const att=ue({name:"ElTreeSelect",inheritAttrs:!1,props:{...kd.props,...Hy.props,cacheData:{type:Array,default:()=>[]}},setup(t,e){const{slots:n,expose:s}=e,r=U(),o=U(),a=A(()=>t.nodeKey||t.valueKey||"value"),i=ntt(t,e,{select:r,tree:o,key:a}),{cacheOptions:l,...u}=rtt(t,e,{select:r,tree:o,key:a}),c=on({});return s(c),It(()=>{Object.assign(c,{...gl(o.value,["filter","updateKeyChildren","getCheckedNodes","setCheckedNodes","getCheckedKeys","setCheckedKeys","setChecked","getHalfCheckedNodes","getHalfCheckedKeys","getCurrentKey","getCurrentNode","setCurrentKey","setCurrentNode","getNode","remove","append","insertBefore","insertAfter"]),...gl(r.value,["focus","blur"])})}),()=>it(kd,on({...i,ref:d=>r.value=d}),{...n,default:()=>[it(ott,{data:l.value}),it(Hy,on({...u,ref:d=>o.value=d}))]})}});var cy=je(att,[["__file","/home/runner/work/element-plus/element-plus/packages/components/tree-select/src/tree-select.vue"]]);cy.install=t=>{t.component(cy.name,cy)};const itt=cy,ltt=itt,Pk=Symbol(),utt={key:-1,level:-1,data:{}};var Um=(t=>(t.KEY="id",t.LABEL="label",t.CHILDREN="children",t.DISABLED="disabled",t))(Um||{}),nx=(t=>(t.ADD="add",t.DELETE="delete",t))(nx||{});const ctt=qe({data:{type:Se(Array),default:()=>Ln([])},emptyText:{type:String},height:{type:Number,default:200},props:{type:Se(Object),default:()=>Ln({children:"children",label:"label",disabled:"disabled",value:"id"})},highlightCurrent:{type:Boolean,default:!1},showCheckbox:{type:Boolean,default:!1},defaultCheckedKeys:{type:Se(Array),default:()=>Ln([])},checkStrictly:{type:Boolean,default:!1},defaultExpandedKeys:{type:Se(Array),default:()=>Ln([])},indent:{type:Number,default:16},icon:{type:In},expandOnClickNode:{type:Boolean,default:!0},checkOnClickNode:{type:Boolean,default:!1},currentNodeKey:{type:Se([String,Number])},accordion:{type:Boolean,default:!1},filterMethod:{type:Se(Function)},perfMode:{type:Boolean,default:!0}}),dtt=qe({node:{type:Se(Object),default:()=>Ln(utt)},expanded:{type:Boolean,default:!1},checked:{type:Boolean,default:!1},indeterminate:{type:Boolean,default:!1},showCheckbox:{type:Boolean,default:!1},disabled:{type:Boolean,default:!1},current:{type:Boolean,default:!1},hiddenExpandIcon:{type:Boolean,default:!1}}),ftt=qe({node:{type:Se(Object),required:!0}}),rB="node-click",oB="node-expand",aB="node-collapse",iB="current-change",lB="check",uB="check-change",cB="node-contextmenu",htt={[rB]:(t,e,n)=>t&&e&&n,[oB]:(t,e)=>t&&e,[aB]:(t,e)=>t&&e,[iB]:(t,e)=>t&&e,[lB]:(t,e)=>t&&e,[uB]:(t,e)=>t&&typeof e=="boolean",[cB]:(t,e,n)=>t&&e&&n},ptt={click:(t,e)=>!!(t&&e),toggle:t=>!!t,check:(t,e)=>t&&typeof e=="boolean"};function mtt(t,e){const n=U(new Set),s=U(new Set),{emit:r}=Rt();Me([()=>e.value,()=>t.defaultCheckedKeys],()=>nt(()=>{w(t.defaultCheckedKeys)}),{immediate:!0});const o=()=>{if(!e.value||!t.showCheckbox||t.checkStrictly)return;const{levelTreeNodeMap:b,maxLevel:_}=e.value,$=n.value,x=new Set;for(let k=_-1;k>=1;--k){const C=b.get(k);!C||C.forEach(T=>{const N=T.children;if(N){let M=!0,R=!1;for(const D of N){const z=D.key;if($.has(z))R=!0;else if(x.has(z)){M=!1,R=!0;break}else M=!1}M?$.add(T.key):R?(x.add(T.key),$.delete(T.key)):($.delete(T.key),x.delete(T.key))}})}s.value=x},a=b=>n.value.has(b.key),i=b=>s.value.has(b.key),l=(b,_,$=!0)=>{const x=n.value,k=(C,T)=>{x[T?nx.ADD:nx.DELETE](C.key);const N=C.children;!t.checkStrictly&&N&&N.forEach(M=>{M.disabled||k(M,T)})};k(b,_),o(),$&&u(b,_)},u=(b,_)=>{const{checkedNodes:$,checkedKeys:x}=p(),{halfCheckedNodes:k,halfCheckedKeys:C}=m();r(lB,b.data,{checkedKeys:x,checkedNodes:$,halfCheckedKeys:C,halfCheckedNodes:k}),r(uB,b.data,_)};function c(b=!1){return p(b).checkedKeys}function d(b=!1){return p(b).checkedNodes}function f(){return m().halfCheckedKeys}function h(){return m().halfCheckedNodes}function p(b=!1){const _=[],$=[];if((e==null?void 0:e.value)&&t.showCheckbox){const{treeNodeMap:x}=e.value;n.value.forEach(k=>{const C=x.get(k);C&&(!b||b&&C.isLeaf)&&($.push(k),_.push(C.data))})}return{checkedKeys:$,checkedNodes:_}}function m(){const b=[],_=[];if((e==null?void 0:e.value)&&t.showCheckbox){const{treeNodeMap:$}=e.value;s.value.forEach(x=>{const k=$.get(x);k&&(_.push(x),b.push(k.data))})}return{halfCheckedNodes:b,halfCheckedKeys:_}}function g(b){n.value.clear(),s.value.clear(),w(b)}function y(b,_){if((e==null?void 0:e.value)&&t.showCheckbox){const $=e.value.treeNodeMap.get(b);$&&l($,_,!1)}}function w(b){if(e!=null&&e.value){const{treeNodeMap:_}=e.value;if(t.showCheckbox&&_&&b)for(const $ of b){const x=_.get($);x&&!a(x)&&l(x,!0,!1)}}}return{updateCheckedKeys:o,toggleCheckbox:l,isChecked:a,isIndeterminate:i,getCheckedKeys:c,getCheckedNodes:d,getHalfCheckedKeys:f,getHalfCheckedNodes:h,setChecked:y,setCheckedKeys:g}}function gtt(t,e){const n=U(new Set([])),s=U(new Set([])),r=A(()=>vt(t.filterMethod));function o(i){var l;if(!r.value)return;const u=new Set,c=s.value,d=n.value,f=[],h=((l=e.value)==null?void 0:l.treeNodes)||[],p=t.filterMethod;d.clear();function m(g){g.forEach(y=>{f.push(y),p!=null&&p(i,y.data)?f.forEach(b=>{u.add(b.key)}):y.isLeaf&&d.add(y.key);const w=y.children;if(w&&m(w),!y.isLeaf){if(!u.has(y.key))d.add(y.key);else if(w){let b=!0;for(const _ of w)if(!d.has(_.key)){b=!1;break}b?c.add(y.key):c.delete(y.key)}}f.pop()})}return m(h),u}function a(i){return s.value.has(i.key)}return{hiddenExpandIconKeySet:s,hiddenNodeKeySet:n,doFilter:o,isForceHiddenExpandIcon:a}}function vtt(t,e){const n=U(new Set(t.defaultExpandedKeys)),s=U(),r=Nn();Me(()=>t.currentNodeKey,Q=>{s.value=Q},{immediate:!0}),Me(()=>t.data,Q=>{oe(Q)},{immediate:!0});const{isIndeterminate:o,isChecked:a,toggleCheckbox:i,getCheckedKeys:l,getCheckedNodes:u,getHalfCheckedKeys:c,getHalfCheckedNodes:d,setChecked:f,setCheckedKeys:h}=mtt(t,r),{doFilter:p,hiddenNodeKeySet:m,isForceHiddenExpandIcon:g}=gtt(t,r),y=A(()=>{var Q;return((Q=t.props)==null?void 0:Q.value)||Um.KEY}),w=A(()=>{var Q;return((Q=t.props)==null?void 0:Q.children)||Um.CHILDREN}),b=A(()=>{var Q;return((Q=t.props)==null?void 0:Q.disabled)||Um.DISABLED}),_=A(()=>{var Q;return((Q=t.props)==null?void 0:Q.label)||Um.LABEL}),$=A(()=>{const Q=n.value,ie=m.value,pe=[],Re=r.value&&r.value.treeNodes||[];function K(){const re=[];for(let we=Re.length-1;we>=0;--we)re.push(Re[we]);for(;re.length;){const we=re.pop();if(!!we&&(ie.has(we.key)||pe.push(we),Q.has(we.key))){const Ee=we.children;if(Ee){const De=Ee.length;for(let _e=De-1;_e>=0;--_e)re.push(Ee[_e])}}}}return K(),pe}),x=A(()=>$.value.length>0);function k(Q){const ie=new Map,pe=new Map;let Re=1;function K(we,Ee=1,De=void 0){var _e;const ze=[];for(const Ae of we){const he=N(Ae),ve={level:Ee,key:he,data:Ae};ve.label=R(Ae),ve.parent=De;const me=T(Ae);ve.disabled=M(Ae),ve.isLeaf=!me||me.length===0,me&&me.length&&(ve.children=K(me,Ee+1,ve)),ze.push(ve),ie.set(he,ve),pe.has(Ee)||pe.set(Ee,[]),(_e=pe.get(Ee))==null||_e.push(ve)}return Ee>Re&&(Re=Ee),ze}const re=K(Q);return{treeNodeMap:ie,levelTreeNodeMap:pe,maxLevel:Re,treeNodes:re}}function C(Q){const ie=p(Q);ie&&(n.value=ie)}function T(Q){return Q[w.value]}function N(Q){return Q?Q[y.value]:""}function M(Q){return Q[b.value]}function R(Q){return Q[_.value]}function D(Q){n.value.has(Q.key)?L(Q):F(Q)}function z(Q){n.value=new Set(Q)}function B(Q,ie){e(rB,Q.data,Q,ie),V(Q),t.expandOnClickNode&&D(Q),t.showCheckbox&&t.checkOnClickNode&&!Q.disabled&&i(Q,!a(Q),!0)}function V(Q){j(Q)||(s.value=Q.key,e(iB,Q.data,Q))}function O(Q,ie){i(Q,ie)}function F(Q){const ie=n.value;if(r.value&&t.accordion){const{treeNodeMap:pe}=r.value;ie.forEach(Re=>{const K=pe.get(Re);Q&&Q.level===(K==null?void 0:K.level)&&ie.delete(Re)})}ie.add(Q.key),e(oB,Q.data,Q)}function L(Q){n.value.delete(Q.key),e(aB,Q.data,Q)}function G(Q){return n.value.has(Q.key)}function Z(Q){return!!Q.disabled}function j(Q){const ie=s.value;return!!ie&&ie===Q.key}function J(){var Q,ie;if(!!s.value)return(ie=(Q=r.value)==null?void 0:Q.treeNodeMap.get(s.value))==null?void 0:ie.data}function fe(){return s.value}function X(Q){s.value=Q}function oe(Q){nt(()=>r.value=k(Q))}function ee(Q){var ie;const pe=Bt(Q)?N(Q):Q;return(ie=r.value)==null?void 0:ie.treeNodeMap.get(pe)}return{tree:r,flattenTree:$,isNotEmpty:x,getKey:N,getChildren:T,toggleExpand:D,toggleCheckbox:i,isExpanded:G,isChecked:a,isIndeterminate:o,isDisabled:Z,isCurrent:j,isForceHiddenExpandIcon:g,handleNodeClick:B,handleNodeCheck:O,getCurrentNode:J,getCurrentKey:fe,setCurrentKey:X,getCheckedKeys:l,getCheckedNodes:u,getHalfCheckedKeys:c,getHalfCheckedNodes:d,setChecked:f,setCheckedKeys:h,filter:C,setData:oe,getNode:ee,expandNode:F,collapseNode:L,setExpandedKeys:z}}var ytt=ue({name:"ElTreeNodeContent",props:ftt,setup(t){const e=et(Pk),n=Fe("tree");return()=>{const s=t.node,{data:r}=s;return e!=null&&e.ctx.slots.default?e.ctx.slots.default({node:s,data:r}):it("span",{class:n.be("node","label")},[s==null?void 0:s.label])}}});const btt=["aria-expanded","aria-disabled","aria-checked","data-key","onClick"],wtt=ue({name:"ElTreeNode"}),_tt=ue({...wtt,props:dtt,emits:ptt,setup(t,{emit:e}){const n=t,s=et(Pk),r=Fe("tree"),o=A(()=>{var d;return(d=s==null?void 0:s.props.indent)!=null?d:16}),a=A(()=>{var d;return(d=s==null?void 0:s.props.icon)!=null?d:EC}),i=d=>{e("click",n.node,d)},l=()=>{e("toggle",n.node)},u=d=>{e("check",n.node,d)},c=d=>{var f,h,p,m;(p=(h=(f=s==null?void 0:s.instance)==null?void 0:f.vnode)==null?void 0:h.props)!=null&&p.onNodeContextmenu&&(d.stopPropagation(),d.preventDefault()),s==null||s.ctx.emit(cB,d,(m=n.node)==null?void 0:m.data,n.node)};return(d,f)=>{var h,p,m;return S(),E("div",{ref:"node$",class:P([v(r).b("node"),v(r).is("expanded",d.expanded),v(r).is("current",d.current),v(r).is("focusable",!d.disabled),v(r).is("checked",!d.disabled&&d.checked)]),role:"treeitem",tabindex:"-1","aria-expanded":d.expanded,"aria-disabled":d.disabled,"aria-checked":d.checked,"data-key":(h=d.node)==null?void 0:h.key,onClick:yt(i,["stop"]),onContextmenu:c},[I("div",{class:P(v(r).be("node","content")),style:ot({paddingLeft:`${(d.node.level-1)*v(o)}px`})},[v(a)?(S(),$e(v(rt),{key:0,class:P([v(r).is("leaf",!!((p=d.node)!=null&&p.isLeaf)),v(r).is("hidden",d.hiddenExpandIcon),{expanded:!((m=d.node)!=null&&m.isLeaf)&&d.expanded},v(r).be("node","expand-icon")]),onClick:yt(l,["stop"])},{default:ce(()=>[(S(),$e(Vt(v(a))))]),_:1},8,["class","onClick"])):ge("v-if",!0),d.showCheckbox?(S(),$e(v(ka),{key:1,"model-value":d.checked,indeterminate:d.indeterminate,disabled:d.disabled,onChange:u,onClick:f[0]||(f[0]=yt(()=>{},["stop"]))},null,8,["model-value","indeterminate","disabled"])):ge("v-if",!0),se(v(ytt),{node:d.node},null,8,["node"])],6)],42,btt)}}});var $tt=je(_tt,[["__file","/home/runner/work/element-plus/element-plus/packages/components/tree-v2/src/tree-node.vue"]]);const xtt=26,Stt=ue({name:"ElTreeV2"}),Ctt=ue({...Stt,props:ctt,emits:htt,setup(t,{expose:e,emit:n}){const s=t,r=ir();Lt(Pk,{ctx:{emit:n,slots:r},props:s,instance:Rt()}),Lt(Li,void 0);const{t:o}=nn(),a=Fe("tree"),{flattenTree:i,isNotEmpty:l,toggleExpand:u,isExpanded:c,isIndeterminate:d,isChecked:f,isDisabled:h,isCurrent:p,isForceHiddenExpandIcon:m,handleNodeClick:g,handleNodeCheck:y,toggleCheckbox:w,getCurrentNode:b,getCurrentKey:_,setCurrentKey:$,getCheckedKeys:x,getCheckedNodes:k,getHalfCheckedKeys:C,getHalfCheckedNodes:T,setChecked:N,setCheckedKeys:M,filter:R,setData:D,getNode:z,expandNode:B,collapseNode:V,setExpandedKeys:O}=vtt(s,n);return e({toggleCheckbox:w,getCurrentNode:b,getCurrentKey:_,setCurrentKey:$,getCheckedKeys:x,getCheckedNodes:k,getHalfCheckedKeys:C,getHalfCheckedNodes:T,setChecked:N,setCheckedKeys:M,filter:R,setData:D,getNode:z,expandNode:B,collapseNode:V,setExpandedKeys:O}),(F,L)=>{var G;return S(),E("div",{class:P([v(a).b(),{[v(a).m("highlight-current")]:F.highlightCurrent}]),role:"tree"},[v(l)?(S(),$e(v(b7),{key:0,"class-name":v(a).b("virtual-list"),data:v(i),total:v(i).length,height:F.height,"item-size":xtt,"perf-mode":F.perfMode},{default:ce(({data:Z,index:j,style:J})=>[(S(),$e($tt,{key:Z[j].key,style:ot(J),node:Z[j],expanded:v(c)(Z[j]),"show-checkbox":F.showCheckbox,checked:v(f)(Z[j]),indeterminate:v(d)(Z[j]),disabled:v(h)(Z[j]),current:v(p)(Z[j]),"hidden-expand-icon":v(m)(Z[j]),onClick:v(g),onToggle:v(u),onCheck:v(y)},null,8,["style","node","expanded","show-checkbox","checked","indeterminate","disabled","current","hidden-expand-icon","onClick","onToggle","onCheck"]))]),_:1},8,["class-name","data","total","height","perf-mode"])):(S(),E("div",{key:1,class:P(v(a).e("empty-block"))},[I("span",{class:P(v(a).e("empty-text"))},Ue((G=F.emptyText)!=null?G:v(o)("el.tree.emptyText")),3)],2))],2)}}});var ktt=je(Ctt,[["__file","/home/runner/work/element-plus/element-plus/packages/components/tree-v2/src/tree.vue"]]);const Ttt=Dt(ktt),Ntt="ElUpload";class Itt extends Error{constructor(e,n,s,r){super(e),this.name="UploadAjaxError",this.status=n,this.method=s,this.url=r}}function NR(t,e,n){let s;return n.response?s=`${n.response.error||n.response}`:n.responseText?s=`${n.responseText}`:s=`fail to ${e.method} ${t} ${n.status}`,new Itt(s,n.status,e.method,t)}function Ett(t){const e=t.responseText||t.response;if(!e)return e;try{return JSON.parse(e)}catch{return e}}const Att=t=>{typeof XMLHttpRequest>"u"&&Ls(Ntt,"XMLHttpRequest is undefined");const e=new XMLHttpRequest,n=t.action;e.upload&&e.upload.addEventListener("progress",o=>{const a=o;a.percent=o.total>0?o.loaded/o.total*100:0,t.onProgress(a)});const s=new FormData;if(t.data)for(const[o,a]of Object.entries(t.data))Array.isArray(a)?s.append(o,...a):s.append(o,a);s.append(t.filename,t.file,t.file.name),e.addEventListener("error",()=>{t.onError(NR(n,t,e))}),e.addEventListener("load",()=>{if(e.status<200||e.status>=300)return t.onError(NR(n,t,e));t.onSuccess(Ett(e))}),e.open(t.method,n,!0),t.withCredentials&&"withCredentials"in e&&(e.withCredentials=!0);const r=t.headers||{};if(r instanceof Headers)r.forEach((o,a)=>e.setRequestHeader(a,o));else for(const[o,a]of Object.entries(r))nr(a)||e.setRequestHeader(o,String(a));return e.send(s),e},dB=["text","picture","picture-card"];let Ott=1;const sx=()=>Date.now()+Ott++,fB=qe({action:{type:String,default:"#"},headers:{type:Se(Object)},method:{type:String,default:"post"},data:{type:Object,default:()=>Ln({})},multiple:{type:Boolean,default:!1},name:{type:String,default:"file"},drag:{type:Boolean,default:!1},withCredentials:Boolean,showFileList:{type:Boolean,default:!0},accept:{type:String,default:""},type:{type:String,default:"select"},fileList:{type:Se(Array),default:()=>Ln([])},autoUpload:{type:Boolean,default:!0},listType:{type:String,values:dB,default:"text"},httpRequest:{type:Se(Function),default:Att},disabled:Boolean,limit:Number}),Rtt=qe({...fB,beforeUpload:{type:Se(Function),default:gn},beforeRemove:{type:Se(Function)},onRemove:{type:Se(Function),default:gn},onChange:{type:Se(Function),default:gn},onPreview:{type:Se(Function),default:gn},onSuccess:{type:Se(Function),default:gn},onProgress:{type:Se(Function),default:gn},onError:{type:Se(Function),default:gn},onExceed:{type:Se(Function),default:gn}}),Dtt=qe({files:{type:Se(Array),default:()=>Ln([])},disabled:{type:Boolean,default:!1},handlePreview:{type:Se(Function),default:gn},listType:{type:String,values:dB,default:"text"}}),Ftt={remove:t=>!!t},Mtt=["onKeydown"],Ptt=["src"],Ltt=["onClick"],ztt=["onClick"],Btt=["onClick"],Vtt=ue({name:"ElUploadList"}),Htt=ue({...Vtt,props:Dtt,emits:Ftt,setup(t,{emit:e}){const{t:n}=nn(),s=Fe("upload"),r=Fe("icon"),o=Fe("list"),a=To(),i=U(!1),l=u=>{e("remove",u)};return(u,c)=>(S(),$e(Lte,{tag:"ul",class:P([v(s).b("list"),v(s).bm("list",u.listType),v(s).is("disabled",v(a))]),name:v(o).b()},{default:ce(()=>[(S(!0),E(lt,null,Gt(u.files,d=>(S(),E("li",{key:d.uid||d.name,class:P([v(s).be("list","item"),v(s).is(d.status),{focusing:i.value}]),tabindex:"0",onKeydown:qt(f=>!v(a)&&l(d),["delete"]),onFocus:c[0]||(c[0]=f=>i.value=!0),onBlur:c[1]||(c[1]=f=>i.value=!1),onClick:c[2]||(c[2]=f=>i.value=!1)},[Oe(u.$slots,"default",{file:d},()=>[u.listType==="picture"||d.status!=="uploading"&&u.listType==="picture-card"?(S(),E("img",{key:0,class:P(v(s).be("list","item-thumbnail")),src:d.url,alt:""},null,10,Ptt)):ge("v-if",!0),d.status==="uploading"||u.listType!=="picture-card"?(S(),E("div",{key:1,class:P(v(s).be("list","item-info"))},[I("a",{class:P(v(s).be("list","item-name")),onClick:yt(f=>u.handlePreview(d),["prevent"])},[se(v(rt),{class:P(v(r).m("document"))},{default:ce(()=>[se(v(mP))]),_:1},8,["class"]),I("span",{class:P(v(s).be("list","item-file-name"))},Ue(d.name),3)],10,Ltt),d.status==="uploading"?(S(),$e(v(c7),{key:0,type:u.listType==="picture-card"?"circle":"line","stroke-width":u.listType==="picture-card"?6:2,percentage:Number(d.percentage),style:ot(u.listType==="picture-card"?"":"margin-top: 0.5rem")},null,8,["type","stroke-width","percentage","style"])):ge("v-if",!0)],2)):ge("v-if",!0),I("label",{class:P(v(s).be("list","item-status-label"))},[u.listType==="text"?(S(),$e(v(rt),{key:0,class:P([v(r).m("upload-success"),v(r).m("circle-check")])},{default:ce(()=>[se(v(lw))]),_:1},8,["class"])):["picture-card","picture"].includes(u.listType)?(S(),$e(v(rt),{key:1,class:P([v(r).m("upload-success"),v(r).m("check")])},{default:ce(()=>[se(v(Jh))]),_:1},8,["class"])):ge("v-if",!0)],2),v(a)?ge("v-if",!0):(S(),$e(v(rt),{key:2,class:P(v(r).m("close")),onClick:f=>l(d)},{default:ce(()=>[se(v(xa))]),_:2},1032,["class","onClick"])),ge(" Due to close btn only appears when li gets focused disappears after li gets blurred, thus keyboard navigation can never reach close btn"),ge(" This is a bug which needs to be fixed "),ge(" TODO: Fix the incorrect navigation interaction "),v(a)?ge("v-if",!0):(S(),E("i",{key:3,class:P(v(r).m("close-tip"))},Ue(v(n)("el.upload.deleteTip")),3)),u.listType==="picture-card"?(S(),E("span",{key:4,class:P(v(s).be("list","item-actions"))},[I("span",{class:P(v(s).be("list","item-preview")),onClick:f=>u.handlePreview(d)},[se(v(rt),{class:P(v(r).m("zoom-in"))},{default:ce(()=>[se(v(DC))]),_:1},8,["class"])],10,ztt),v(a)?ge("v-if",!0):(S(),E("span",{key:0,class:P(v(s).be("list","item-delete")),onClick:f=>l(d)},[se(v(rt),{class:P(v(r).m("delete"))},{default:ce(()=>[se(v(pP))]),_:1},8,["class"])],10,Btt))],2)):ge("v-if",!0)])],42,Mtt))),128)),Oe(u.$slots,"append")]),_:3},8,["class","name"]))}});var IR=je(Htt,[["__file","/home/runner/work/element-plus/element-plus/packages/components/upload/src/upload-list.vue"]]);const Wtt=qe({disabled:{type:Boolean,default:!1}}),Utt={file:t=>Qe(t)},Gtt=["onDrop","onDragover"],hB="ElUploadDrag",jtt=ue({name:hB}),Ktt=ue({...jtt,props:Wtt,emits:Utt,setup(t,{emit:e}){const n=et(jP);n||Ls(hB,"usage: <el-upload><el-upload-dragger /></el-upload>");const s=Fe("upload"),r=U(!1),o=To(),a=l=>{if(o.value)return;r.value=!1;const u=Array.from(l.dataTransfer.files),c=n.accept.value;if(!c){e("file",u);return}const d=u.filter(f=>{const{type:h,name:p}=f,m=p.includes(".")?`.${p.split(".").pop()}`:"",g=h.replace(/\/.*$/,"");return c.split(",").map(y=>y.trim()).filter(y=>y).some(y=>y.startsWith(".")?m===y:/\/\*$/.test(y)?g===y.replace(/\/\*$/,""):/^[^/]+\/[^/]+$/.test(y)?h===y:!1)});e("file",d)},i=()=>{o.value||(r.value=!0)};return(l,u)=>(S(),E("div",{class:P([v(s).b("dragger"),v(s).is("dragover",r.value)]),onDrop:yt(a,["prevent"]),onDragover:yt(i,["prevent"]),onDragleave:u[0]||(u[0]=yt(c=>r.value=!1,["prevent"]))},[Oe(l.$slots,"default")],42,Gtt))}});var qtt=je(Ktt,[["__file","/home/runner/work/element-plus/element-plus/packages/components/upload/src/upload-dragger.vue"]]);const Xtt=qe({...fB,beforeUpload:{type:Se(Function),default:gn},onRemove:{type:Se(Function),default:gn},onStart:{type:Se(Function),default:gn},onSuccess:{type:Se(Function),default:gn},onProgress:{type:Se(Function),default:gn},onError:{type:Se(Function),default:gn},onExceed:{type:Se(Function),default:gn}}),Ytt=["onKeydown"],Ztt=["name","multiple","accept"],Jtt=ue({name:"ElUploadContent",inheritAttrs:!1}),Qtt=ue({...Jtt,props:Xtt,setup(t,{expose:e}){const n=t,s=Fe("upload"),r=To(),o=Nn({}),a=Nn(),i=p=>{if(p.length===0)return;const{autoUpload:m,limit:g,fileList:y,multiple:w,onStart:b,onExceed:_}=n;if(g&&y.length+p.length>g){_(p,y);return}w||(p=p.slice(0,1));for(const $ of p){const x=$;x.uid=sx(),b(x),m&&l(x)}},l=async p=>{if(a.value.value="",!n.beforeUpload)return u(p);let m;try{m=await n.beforeUpload(p)}catch{m=!1}if(m===!1){n.onRemove(p);return}let g=p;m instanceof Blob&&(m instanceof File?g=m:g=new File([m],p.name,{type:p.type})),u(Object.assign(g,{uid:p.uid}))},u=p=>{const{headers:m,data:g,method:y,withCredentials:w,name:b,action:_,onProgress:$,onSuccess:x,onError:k,httpRequest:C}=n,{uid:T}=p,N={headers:m||{},withCredentials:w,file:p,data:g,method:y,filename:b,action:_,onProgress:R=>{$(R,p)},onSuccess:R=>{x(R,p),delete o.value[T]},onError:R=>{k(R,p),delete o.value[T]}},M=C(N);o.value[T]=M,M instanceof Promise&&M.then(N.onSuccess,N.onError)},c=p=>{const m=p.target.files;!m||i(Array.from(m))},d=()=>{r.value||(a.value.value="",a.value.click())},f=()=>{d()};return e({abort:p=>{zue(o.value).filter(p?([g])=>String(p.uid)===g:()=>!0).forEach(([g,y])=>{y instanceof XMLHttpRequest&&y.abort(),delete o.value[g]})},upload:l}),(p,m)=>(S(),E("div",{class:P([v(s).b(),v(s).m(p.listType),v(s).is("drag",p.drag)]),tabindex:"0",onClick:d,onKeydown:qt(yt(f,["self"]),["enter","space"])},[p.drag?(S(),$e(qtt,{key:0,disabled:v(r),onFile:i},{default:ce(()=>[Oe(p.$slots,"default")]),_:3},8,["disabled"])):Oe(p.$slots,"default",{key:1}),I("input",{ref_key:"inputRef",ref:a,class:P(v(s).e("input")),name:p.name,multiple:p.multiple,accept:p.accept,type:"file",onChange:c,onClick:m[0]||(m[0]=yt(()=>{},["stop"]))},null,42,Ztt)],42,Ytt))}});var ER=je(Qtt,[["__file","/home/runner/work/element-plus/element-plus/packages/components/upload/src/upload-content.vue"]]);const AR="ElUpload",ent=t=>{var e;(e=t.url)!=null&&e.startsWith("blob:")&&URL.revokeObjectURL(t.url)},tnt=(t,e)=>{const n=Oue(t,"fileList",void 0,{passive:!0}),s=f=>n.value.find(h=>h.uid===f.uid);function r(f){var h;(h=e.value)==null||h.abort(f)}function o(f=["ready","uploading","success","fail"]){n.value=n.value.filter(h=>!f.includes(h.status))}const a=(f,h)=>{const p=s(h);!p||(console.error(f),p.status="fail",n.value.splice(n.value.indexOf(p),1),t.onError(f,p,n.value),t.onChange(p,n.value))},i=(f,h)=>{const p=s(h);!p||(t.onProgress(f,p,n.value),p.status="uploading",p.percentage=Math.round(f.percent))},l=(f,h)=>{const p=s(h);!p||(p.status="success",p.response=f,t.onSuccess(f,p,n.value),t.onChange(p,n.value))},u=f=>{nr(f.uid)&&(f.uid=sx());const h={name:f.name,percentage:0,status:"ready",size:f.size,raw:f,uid:f.uid};if(t.listType==="picture-card"||t.listType==="picture")try{h.url=URL.createObjectURL(f)}catch(p){p.message,t.onError(p,h,n.value)}n.value=[...n.value,h],t.onChange(h,n.value)},c=async f=>{const h=f instanceof File?s(f):f;h||Ls(AR,"file to be removed not found");const p=m=>{r(m);const g=n.value;g.splice(g.indexOf(m),1),t.onRemove(m,g),ent(m)};t.beforeRemove?await t.beforeRemove(h,n.value)!==!1&&p(h):p(h)};function d(){n.value.filter(({status:f})=>f==="ready").forEach(({raw:f})=>{var h;return f&&((h=e.value)==null?void 0:h.upload(f))})}return Me(()=>t.listType,f=>{f!=="picture-card"&&f!=="picture"||(n.value=n.value.map(h=>{const{raw:p,url:m}=h;if(!m&&p)try{h.url=URL.createObjectURL(p)}catch(g){t.onError(g,h,n.value)}return h}))}),Me(n,f=>{for(const h of f)h.uid||(h.uid=sx()),h.status||(h.status="success")},{immediate:!0,deep:!0}),{uploadFiles:n,abort:r,clearFiles:o,handleError:a,handleProgress:i,handleStart:u,handleSuccess:l,handleRemove:c,submit:d}},nnt=ue({name:"ElUpload"}),snt=ue({...nnt,props:Rtt,setup(t,{expose:e}){const n=t,s=ir(),r=To(),o=Nn(),{abort:a,submit:i,clearFiles:l,uploadFiles:u,handleStart:c,handleError:d,handleRemove:f,handleSuccess:h,handleProgress:p}=tnt(n,o),m=A(()=>n.listType==="picture-card"),g=A(()=>({...n,fileList:u.value,onStart:c,onProgress:p,onSuccess:h,onError:d,onRemove:f}));return ts(()=>{u.value.forEach(({url:y})=>{y!=null&&y.startsWith("blob:")&&URL.revokeObjectURL(y)})}),Lt(jP,{accept:Un(n,"accept")}),e({abort:a,submit:i,clearFiles:l,handleStart:c,handleRemove:f}),(y,w)=>(S(),E("div",null,[v(m)&&y.showFileList?(S(),$e(IR,{key:0,disabled:v(r),"list-type":y.listType,files:v(u),"handle-preview":y.onPreview,onRemove:v(f)},Uu({append:ce(()=>[se(ER,zt({ref_key:"uploadRef",ref:o},v(g)),{default:ce(()=>[v(s).trigger?Oe(y.$slots,"trigger",{key:0}):ge("v-if",!0),!v(s).trigger&&v(s).default?Oe(y.$slots,"default",{key:1}):ge("v-if",!0)]),_:3},16)]),_:2},[y.$slots.file?{name:"default",fn:ce(({file:b})=>[Oe(y.$slots,"file",{file:b})])}:void 0]),1032,["disabled","list-type","files","handle-preview","onRemove"])):ge("v-if",!0),!v(m)||v(m)&&!y.showFileList?(S(),$e(ER,zt({key:1,ref_key:"uploadRef",ref:o},v(g)),{default:ce(()=>[v(s).trigger?Oe(y.$slots,"trigger",{key:0}):ge("v-if",!0),!v(s).trigger&&v(s).default?Oe(y.$slots,"default",{key:1}):ge("v-if",!0)]),_:3},16)):ge("v-if",!0),y.$slots.trigger?Oe(y.$slots,"default",{key:2}):ge("v-if",!0),Oe(y.$slots,"tip"),!v(m)&&y.showFileList?(S(),$e(IR,{key:3,disabled:v(r),"list-type":y.listType,files:v(u),"handle-preview":y.onPreview,onRemove:v(f)},Uu({_:2},[y.$slots.file?{name:"default",fn:ce(({file:b})=>[Oe(y.$slots,"file",{file:b})])}:void 0]),1032,["disabled","list-type","files","handle-preview","onRemove"])):ge("v-if",!0)]))}});var rnt=je(snt,[["__file","/home/runner/work/element-plus/element-plus/packages/components/upload/src/upload.vue"]]);const ont=Dt(rnt);var ant=[qFe,oMe,FLe,SQe,HLe,XLe,DL,lze,uze,br,zL,k7e,A7e,G7e,j7e,oVe,jBe,dVe,ka,fBe,fz,gVe,FVe,MVe,kVe,iHe,cHe,$He,xHe,SHe,CHe,kHe,RWe,WWe,UWe,rUe,Wz,yUe,uGe,cGe,dGe,Jz,Mje,Pje,rt,Zje,t7,Or,n7,dKe,AKe,OKe,RKe,BKe,Wqe,qqe,sXe,AL,c7,yz,NBe,TBe,wXe,CXe,OXe,jl,kd,Dy,mqe,$Ye,EYe,AYe,iZe,fZe,_Ze,$Ze,RZe,zJe,BJe,xQe,zQe,BQe,Sw,o7e,jQe,ZQe,JQe,No,ket,Vet,ttt,ltt,Ttt,ont];const Pa="ElInfiniteScroll",int=50,lnt=200,unt=0,cnt={delay:{type:Number,default:lnt},distance:{type:Number,default:unt},disabled:{type:Boolean,default:!1},immediate:{type:Boolean,default:!0}},Lk=(t,e)=>Object.entries(cnt).reduce((n,[s,r])=>{var o,a;const{type:i,default:l}=r,u=t.getAttribute(`infinite-scroll-${s}`);let c=(a=(o=e[u])!=null?o:u)!=null?a:l;return c=c==="false"?!1:c,c=i(c),n[s]=Number.isNaN(c)?l:c,n},{}),pB=t=>{const{observer:e}=t[Pa];e&&(e.disconnect(),delete t[Pa].observer)},dnt=(t,e)=>{const{container:n,containerEl:s,instance:r,observer:o,lastScrollTop:a}=t[Pa],{disabled:i,distance:l}=Lk(t,r),{clientHeight:u,scrollHeight:c,scrollTop:d}=s,f=d-a;if(t[Pa].lastScrollTop=d,o||i||f<0)return;let h=!1;if(n===t)h=c-(u+d)<=l;else{const{clientTop:p,scrollHeight:m}=t,g=Mue(t,s);h=d+u>=g+p+m-l}h&&e.call(r)};function f$(t,e){const{containerEl:n,instance:s}=t[Pa],{disabled:r}=Lk(t,s);r||n.clientHeight===0||(n.scrollHeight<=n.clientHeight?e.call(s):pB(t))}const fnt={async mounted(t,e){const{instance:n,value:s}=e;vt(s)||Ls(Pa,"'v-infinite-scroll' binding value must be a function"),await nt();const{delay:r,immediate:o}=Lk(t,n),a=IC(t,!0),i=a===window?document.documentElement:a,l=rd(dnt.bind(null,t,s),r);if(!!a){if(t[Pa]={instance:n,container:a,containerEl:i,delay:r,cb:s,onScroll:l,lastScrollTop:i.scrollTop},o){const u=new MutationObserver(rd(f$.bind(null,t,s),int));t[Pa].observer=u,u.observe(t,{childList:!0,subtree:!0}),f$(t,s)}a.addEventListener("scroll",l)}},unmounted(t){const{container:e,onScroll:n}=t[Pa];e==null||e.removeEventListener("scroll",n),pB(t)},async updated(t){t[Pa]||await nt();const{containerEl:e,cb:n,observer:s}=t[Pa];e.clientHeight&&s&&f$(t,n)}},rx=fnt;rx.install=t=>{t.directive("InfiniteScroll",rx)};const hnt=rx;function pnt(t){let e;const n=Fe("loading"),s=U(!1),r=on({...t,originalPosition:"",originalOverflow:"",visible:!1});function o(h){r.text=h}function a(){const h=r.parent;if(!h.vLoadingAddClassList){let p=h.getAttribute("loading-number");p=Number.parseInt(p)-1,p?h.setAttribute("loading-number",p.toString()):(mo(h,n.bm("parent","relative")),h.removeAttribute("loading-number")),mo(h,n.bm("parent","hidden"))}i(),d.unmount()}function i(){var h,p;(p=(h=f.$el)==null?void 0:h.parentNode)==null||p.removeChild(f.$el)}function l(){var h;t.beforeClose&&!t.beforeClose()||(s.value=!0,clearTimeout(e),e=window.setTimeout(u,400),r.visible=!1,(h=t.closed)==null||h.call(t))}function u(){if(!s.value)return;const h=r.parent;s.value=!1,h.vLoadingAddClassList=void 0,a()}const d=fM({name:"ElLoading",setup(){return()=>{const h=r.spinner||r.svg,p=it("svg",{class:"circular",viewBox:r.svgViewBox?r.svgViewBox:"0 0 50 50",...h?{innerHTML:h}:{}},[it("circle",{class:"path",cx:"25",cy:"25",r:"20",fill:"none"})]),m=r.text?it("p",{class:n.b("text")},[r.text]):void 0;return it(ms,{name:n.b("fade"),onAfterLeave:u},{default:ce(()=>[St(se("div",{style:{backgroundColor:r.background||""},class:[n.b("mask"),r.customClass,r.fullscreen?"is-fullscreen":""]},[it("div",{class:n.b("spinner")},[p,m])]),[[Qt,r.visible]])])})}}}),f=d.mount(document.createElement("div"));return{...Ps(r),setText:o,removeElLoadingChild:i,close:l,handleAfterLeave:u,vm:f,get $el(){return f.$el}}}let hv;const ox=function(t={}){if(!Kt)return;const e=mnt(t);if(e.fullscreen&&hv)return hv;const n=pnt({...e,closed:()=>{var r;(r=e.closed)==null||r.call(e),e.fullscreen&&(hv=void 0)}});gnt(e,e.parent,n),OR(e,e.parent,n),e.parent.vLoadingAddClassList=()=>OR(e,e.parent,n);let s=e.parent.getAttribute("loading-number");return s?s=`${Number.parseInt(s)+1}`:s="1",e.parent.setAttribute("loading-number",s),e.parent.appendChild(n.$el),nt(()=>n.visible.value=e.visible),e.fullscreen&&(hv=n),n},mnt=t=>{var e,n,s,r;let o;return wt(t.target)?o=(e=document.querySelector(t.target))!=null?e:document.body:o=t.target||document.body,{parent:o===document.body||t.body?document.body:o,background:t.background||"",svg:t.svg||"",svgViewBox:t.svgViewBox||"",spinner:t.spinner||!1,text:t.text||"",fullscreen:o===document.body&&((n=t.fullscreen)!=null?n:!0),lock:(s=t.lock)!=null?s:!1,customClass:t.customClass||"",visible:(r=t.visible)!=null?r:!0,target:o}},gnt=async(t,e,n)=>{const{nextZIndex:s}=Ul(),r={};if(t.fullscreen)n.originalPosition.value=dl(document.body,"position"),n.originalOverflow.value=dl(document.body,"overflow"),r.zIndex=s();else if(t.parent===document.body){n.originalPosition.value=dl(document.body,"position"),await nt();for(const o of["top","left"]){const a=o==="top"?"scrollTop":"scrollLeft";r[o]=`${t.target.getBoundingClientRect()[o]+document.body[a]+document.documentElement[a]-Number.parseInt(dl(document.body,`margin-${o}`),10)}px`}for(const o of["height","width"])r[o]=`${t.target.getBoundingClientRect()[o]}px`}else n.originalPosition.value=dl(e,"position");for(const[o,a]of Object.entries(r))n.$el.style[o]=a},OR=(t,e,n)=>{const s=Fe("loading");["absolute","fixed","sticky"].includes(n.originalPosition.value)?mo(e,s.bm("parent","relative")):xi(e,s.bm("parent","relative")),t.fullscreen&&t.lock?xi(e,s.bm("parent","hidden")):mo(e,s.bm("parent","hidden"))},ax=Symbol("ElLoading"),RR=(t,e)=>{var n,s,r,o;const a=e.instance,i=f=>Bt(e.value)?e.value[f]:void 0,l=f=>{const h=wt(f)&&(a==null?void 0:a[f])||f;return h&&U(h)},u=f=>l(i(f)||t.getAttribute(`element-loading-${ac(f)}`)),c=(n=i("fullscreen"))!=null?n:e.modifiers.fullscreen,d={text:u("text"),svg:u("svg"),svgViewBox:u("svgViewBox"),spinner:u("spinner"),background:u("background"),customClass:u("customClass"),fullscreen:c,target:(s=i("target"))!=null?s:c?void 0:t,body:(r=i("body"))!=null?r:e.modifiers.body,lock:(o=i("lock"))!=null?o:e.modifiers.lock};t[ax]={options:d,instance:ox(d)}},vnt=(t,e)=>{for(const n of Object.keys(e))kn(e[n])&&(e[n].value=t[n])},DR={mounted(t,e){e.value&&RR(t,e)},updated(t,e){const n=t[ax];e.oldValue!==e.value&&(e.value&&!e.oldValue?RR(t,e):e.value&&e.oldValue?Bt(e.value)&&vnt(e.value,n.options):n==null||n.instance.close())},unmounted(t){var e;(e=t[ax])==null||e.instance.close()}},ynt={install(t){t.directive("loading",DR),t.config.globalProperties.$loading=ox},directive:DR,service:ox},mB=["success","info","warning","error"],oo=Ln({customClass:"",center:!1,dangerouslyUseHTMLString:!1,duration:3e3,icon:void 0,id:"",message:"",onClose:void 0,showClose:!1,type:"info",offset:16,zIndex:0,grouping:!1,repeatNum:1,appendTo:Kt?document.body:void 0}),bnt=qe({customClass:{type:String,default:oo.customClass},center:{type:Boolean,default:oo.center},dangerouslyUseHTMLString:{type:Boolean,default:oo.dangerouslyUseHTMLString},duration:{type:Number,default:oo.duration},icon:{type:In,default:oo.icon},id:{type:String,default:oo.id},message:{type:Se([String,Object,Function]),default:oo.message},onClose:{type:Se(Function),required:!1},showClose:{type:Boolean,default:oo.showClose},type:{type:String,values:mB,default:oo.type},offset:{type:Number,default:oo.offset},zIndex:{type:Number,default:oo.zIndex},grouping:{type:Boolean,default:oo.grouping},repeatNum:{type:Number,default:oo.repeatNum}}),wnt={destroy:()=>!0},Ci=_F([]),_nt=t=>{const e=Ci.findIndex(r=>r.id===t),n=Ci[e];let s;return e>0&&(s=Ci[e-1]),{current:n,prev:s}},$nt=t=>{const{prev:e}=_nt(t);return e?e.vm.exposed.bottom.value:0},xnt=["id"],Snt=["innerHTML"],Cnt=ue({name:"ElMessage"}),knt=ue({...Cnt,props:bnt,emits:wnt,setup(t,{expose:e}){const n=t,{Close:s}=FC,r=Fe("message"),o=U(),a=U(!1),i=U(0);let l;const u=A(()=>n.type?n.type==="error"?"danger":n.type:"info"),c=A(()=>{const _=n.type;return{[r.bm("icon",_)]:_&&Gu[_]}}),d=A(()=>n.icon||Gu[n.type]||""),f=A(()=>$nt(n.id)),h=A(()=>n.offset+f.value),p=A(()=>i.value+h.value),m=A(()=>({top:`${h.value}px`,zIndex:n.zIndex}));function g(){n.duration!==0&&({stop:l}=_d(()=>{w()},n.duration))}function y(){l==null||l()}function w(){a.value=!1}function b({code:_}){_===ut.esc&&w()}return It(()=>{g(),a.value=!0}),Me(()=>n.repeatNum,()=>{y(),g()}),Rn(document,"keydown",b),Dr(o,()=>{i.value=o.value.getBoundingClientRect().height}),e({visible:a,bottom:p,close:w}),(_,$)=>(S(),$e(ms,{name:v(r).b("fade"),onBeforeLeave:_.onClose,onAfterLeave:$[0]||($[0]=x=>_.$emit("destroy")),persisted:""},{default:ce(()=>[St(I("div",{id:_.id,ref_key:"messageRef",ref:o,class:P([v(r).b(),{[v(r).m(_.type)]:_.type&&!_.icon},v(r).is("center",_.center),v(r).is("closable",_.showClose),_.customClass]),style:ot(v(m)),role:"alert",onMouseenter:y,onMouseleave:g},[_.repeatNum>1?(S(),$e(v(DL),{key:0,value:_.repeatNum,type:v(u),class:P(v(r).e("badge"))},null,8,["value","type","class"])):ge("v-if",!0),v(d)?(S(),$e(v(rt),{key:1,class:P([v(r).e("icon"),v(c)])},{default:ce(()=>[(S(),$e(Vt(v(d))))]),_:1},8,["class"])):ge("v-if",!0),Oe(_.$slots,"default",{},()=>[_.dangerouslyUseHTMLString?(S(),E(lt,{key:1},[ge(" Caution here, message could've been compromised, never use user's input as message "),I("p",{class:P(v(r).e("content")),innerHTML:_.message},null,10,Snt)],2112)):(S(),E("p",{key:0,class:P(v(r).e("content"))},Ue(_.message),3))]),_.showClose?(S(),$e(v(rt),{key:2,class:P(v(r).e("closeBtn")),onClick:yt(w,["stop"])},{default:ce(()=>[se(v(s))]),_:1},8,["class","onClick"])):ge("v-if",!0)],46,xnt),[[Qt,a.value]])]),_:3},8,["name","onBeforeLeave"]))}});var Tnt=je(knt,[["__file","/home/runner/work/element-plus/element-plus/packages/components/message/src/message.vue"]]);let Nnt=1;const gB=t=>{const e=!t||wt(t)||Bn(t)||vt(t)?{message:t}:t,n={...oo,...e};if(!n.appendTo)n.appendTo=document.body;else if(wt(n.appendTo)){let s=document.querySelector(n.appendTo);Qa(s)||(s=document.body),n.appendTo=s}return n},Int=t=>{const e=Ci.indexOf(t);if(e===-1)return;Ci.splice(e,1);const{handler:n}=t;n.close()},Ent=({appendTo:t,...e},n)=>{const{nextZIndex:s}=Ul(),r=`message_${Nnt++}`,o=e.onClose,a=document.createElement("div"),i={...e,zIndex:s()+e.zIndex,id:r,onClose:()=>{o==null||o(),Int(d)},onDestroy:()=>{ih(null,a)}},l=se(Tnt,i,vt(i.message)||Bn(i.message)?{default:vt(i.message)?i.message:()=>i.message}:null);l.appContext=n||bh._context,ih(l,a),t.appendChild(a.firstElementChild);const u=l.component,d={id:r,vnode:l,vm:u,handler:{close:()=>{u.exposed.visible.value=!1}},props:l.component.props};return d},bh=(t={},e)=>{if(!Kt)return{close:()=>{}};if(Ct(E6.max)&&Ci.length>=E6.max)return{close:()=>{}};const n=gB(t);if(n.grouping&&Ci.length){const r=Ci.find(({vnode:o})=>{var a;return((a=o.props)==null?void 0:a.message)===n.message});if(r)return r.props.repeatNum+=1,r.props.type=n.type,r.handler}const s=Ent(n,e);return Ci.push(s),s.handler};mB.forEach(t=>{bh[t]=(e={},n)=>{const s=gB(e);return bh({...s,type:t},n)}});function Ant(t){for(const e of Ci)(!t||t===e.props.type)&&e.handler.close()}bh.closeAll=Ant;bh._context=null;const vB=DP(bh,"$message"),Ont=ue({name:"ElMessageBox",directives:{TrapFocus:Vze},components:{ElButton:br,ElFocusTrap:xw,ElInput:Or,ElOverlay:dk,ElIcon:rt,...FC},inheritAttrs:!1,props:{buttonSize:{type:String,validator:Qh},modal:{type:Boolean,default:!0},lockScroll:{type:Boolean,default:!0},showClose:{type:Boolean,default:!0},closeOnClickModal:{type:Boolean,default:!0},closeOnPressEscape:{type:Boolean,default:!0},closeOnHashChange:{type:Boolean,default:!0},center:Boolean,draggable:Boolean,roundButton:{default:!1,type:Boolean},container:{type:String,default:"body"},boxType:{type:String,default:""}},emits:["vanish","action"],setup(t,{emit:e}){const{t:n}=nn(),s=Fe("message-box"),r=U(!1),{nextZIndex:o}=Ul(),a=on({autofocus:!0,beforeClose:null,callback:null,cancelButtonText:"",cancelButtonClass:"",confirmButtonText:"",confirmButtonClass:"",customClass:"",customStyle:{},dangerouslyUseHTMLString:!1,distinguishCancelAndClose:!1,icon:"",inputPattern:null,inputPlaceholder:"",inputType:"text",inputValue:null,inputValidator:null,inputErrorMessage:"",message:null,modalFade:!0,modalClass:"",showCancelButton:!1,showConfirmButton:!0,type:"",title:void 0,showInput:!1,action:"",confirmButtonLoading:!1,cancelButtonLoading:!1,confirmButtonDisabled:!1,editorErrorMessage:"",validateError:!1,zIndex:o()}),i=A(()=>{const D=a.type;return{[s.bm("icon",D)]:D&&Gu[D]}}),l=ei(),u=ei(),c=ks(A(()=>t.buttonSize),{prop:!0,form:!0,formItem:!0}),d=A(()=>a.icon||Gu[a.type]||""),f=A(()=>!!a.message),h=U(),p=U(),m=U(),g=U(),y=U(),w=A(()=>a.confirmButtonClass);Me(()=>a.inputValue,async D=>{await nt(),t.boxType==="prompt"&&D!==null&&T()},{immediate:!0}),Me(()=>r.value,D=>{var z,B;D&&(t.boxType!=="prompt"&&(a.autofocus?m.value=(B=(z=y.value)==null?void 0:z.$el)!=null?B:h.value:m.value=h.value),a.zIndex=o()),t.boxType==="prompt"&&(D?nt().then(()=>{var V;g.value&&g.value.$el&&(a.autofocus?m.value=(V=N())!=null?V:h.value:m.value=h.value)}):(a.editorErrorMessage="",a.validateError=!1))});const b=A(()=>t.draggable);ZP(h,p,b),It(async()=>{await nt(),t.closeOnHashChange&&window.addEventListener("hashchange",_)}),ts(()=>{t.closeOnHashChange&&window.removeEventListener("hashchange",_)});function _(){!r.value||(r.value=!1,nt(()=>{a.action&&e("action",a.action)}))}const $=()=>{t.closeOnClickModal&&C(a.distinguishCancelAndClose?"close":"cancel")},x=HC($),k=D=>{if(a.inputType!=="textarea")return D.preventDefault(),C("confirm")},C=D=>{var z;t.boxType==="prompt"&&D==="confirm"&&!T()||(a.action=D,a.beforeClose?(z=a.beforeClose)==null||z.call(a,D,a,_):_())},T=()=>{if(t.boxType==="prompt"){const D=a.inputPattern;if(D&&!D.test(a.inputValue||""))return a.editorErrorMessage=a.inputErrorMessage||n("el.messagebox.error"),a.validateError=!0,!1;const z=a.inputValidator;if(typeof z=="function"){const B=z(a.inputValue);if(B===!1)return a.editorErrorMessage=a.inputErrorMessage||n("el.messagebox.error"),a.validateError=!0,!1;if(typeof B=="string")return a.editorErrorMessage=B,a.validateError=!0,!1}}return a.editorErrorMessage="",a.validateError=!1,!0},N=()=>{const D=g.value.$refs;return D.input||D.textarea},M=()=>{C("close")},R=()=>{t.closeOnPressEscape&&M()};return t.lockScroll&&QP(r),rFe(r),{...Ps(a),ns:s,overlayEvent:x,visible:r,hasMessage:f,typeClass:i,contentId:l,inputId:u,btnSize:c,iconComponent:d,confirmButtonClasses:w,rootRef:h,focusStartRef:m,headerRef:p,inputRef:g,confirmRef:y,doClose:_,handleClose:M,onCloseRequested:R,handleWrapperClick:$,handleInputEnter:k,handleAction:C,t:n}}}),Rnt=["aria-label","aria-describedby"],Dnt=["aria-label"],Fnt=["id"];function Mnt(t,e,n,s,r,o){const a=pt("el-icon"),i=pt("close"),l=pt("el-input"),u=pt("el-button"),c=pt("el-focus-trap"),d=pt("el-overlay");return S(),$e(ms,{name:"fade-in-linear",onAfterLeave:e[11]||(e[11]=f=>t.$emit("vanish")),persisted:""},{default:ce(()=>[St(se(d,{"z-index":t.zIndex,"overlay-class":[t.ns.is("message-box"),t.modalClass],mask:t.modal},{default:ce(()=>[I("div",{role:"dialog","aria-label":t.title,"aria-modal":"true","aria-describedby":t.showInput?void 0:t.contentId,class:P(`${t.ns.namespace.value}-overlay-message-box`),onClick:e[8]||(e[8]=(...f)=>t.overlayEvent.onClick&&t.overlayEvent.onClick(...f)),onMousedown:e[9]||(e[9]=(...f)=>t.overlayEvent.onMousedown&&t.overlayEvent.onMousedown(...f)),onMouseup:e[10]||(e[10]=(...f)=>t.overlayEvent.onMouseup&&t.overlayEvent.onMouseup(...f))},[se(c,{loop:"",trapped:t.visible,"focus-trap-el":t.rootRef,"focus-start-el":t.focusStartRef,onReleaseRequested:t.onCloseRequested},{default:ce(()=>[I("div",{ref:"rootRef",class:P([t.ns.b(),t.customClass,t.ns.is("draggable",t.draggable),{[t.ns.m("center")]:t.center}]),style:ot(t.customStyle),tabindex:"-1",onClick:e[7]||(e[7]=yt(()=>{},["stop"]))},[t.title!==null&&t.title!==void 0?(S(),E("div",{key:0,ref:"headerRef",class:P(t.ns.e("header"))},[I("div",{class:P(t.ns.e("title"))},[t.iconComponent&&t.center?(S(),$e(a,{key:0,class:P([t.ns.e("status"),t.typeClass])},{default:ce(()=>[(S(),$e(Vt(t.iconComponent)))]),_:1},8,["class"])):ge("v-if",!0),I("span",null,Ue(t.title),1)],2),t.showClose?(S(),E("button",{key:0,type:"button",class:P(t.ns.e("headerbtn")),"aria-label":t.t("el.messagebox.close"),onClick:e[0]||(e[0]=f=>t.handleAction(t.distinguishCancelAndClose?"close":"cancel")),onKeydown:e[1]||(e[1]=qt(yt(f=>t.handleAction(t.distinguishCancelAndClose?"close":"cancel"),["prevent"]),["enter"]))},[se(a,{class:P(t.ns.e("close"))},{default:ce(()=>[se(i)]),_:1},8,["class"])],42,Dnt)):ge("v-if",!0)],2)):ge("v-if",!0),I("div",{id:t.contentId,class:P(t.ns.e("content"))},[I("div",{class:P(t.ns.e("container"))},[t.iconComponent&&!t.center&&t.hasMessage?(S(),$e(a,{key:0,class:P([t.ns.e("status"),t.typeClass])},{default:ce(()=>[(S(),$e(Vt(t.iconComponent)))]),_:1},8,["class"])):ge("v-if",!0),t.hasMessage?(S(),E("div",{key:1,class:P(t.ns.e("message"))},[Oe(t.$slots,"default",{},()=>[t.dangerouslyUseHTMLString?(S(),$e(Vt(t.showInput?"label":"p"),{key:1,for:t.showInput?t.inputId:void 0,innerHTML:t.message},null,8,["for","innerHTML"])):(S(),$e(Vt(t.showInput?"label":"p"),{key:0,for:t.showInput?t.inputId:void 0},{default:ce(()=>[Yt(Ue(t.dangerouslyUseHTMLString?"":t.message),1)]),_:1},8,["for"]))])],2)):ge("v-if",!0)],2),St(I("div",{class:P(t.ns.e("input"))},[se(l,{id:t.inputId,ref:"inputRef",modelValue:t.inputValue,"onUpdate:modelValue":e[2]||(e[2]=f=>t.inputValue=f),type:t.inputType,placeholder:t.inputPlaceholder,"aria-invalid":t.validateError,class:P({invalid:t.validateError}),onKeydown:qt(t.handleInputEnter,["enter"])},null,8,["id","modelValue","type","placeholder","aria-invalid","class","onKeydown"]),I("div",{class:P(t.ns.e("errormsg")),style:ot({visibility:t.editorErrorMessage?"visible":"hidden"})},Ue(t.editorErrorMessage),7)],2),[[Qt,t.showInput]])],10,Fnt),I("div",{class:P(t.ns.e("btns"))},[t.showCancelButton?(S(),$e(u,{key:0,loading:t.cancelButtonLoading,class:P([t.cancelButtonClass]),round:t.roundButton,size:t.btnSize,onClick:e[3]||(e[3]=f=>t.handleAction("cancel")),onKeydown:e[4]||(e[4]=qt(yt(f=>t.handleAction("cancel"),["prevent"]),["enter"]))},{default:ce(()=>[Yt(Ue(t.cancelButtonText||t.t("el.messagebox.cancel")),1)]),_:1},8,["loading","class","round","size"])):ge("v-if",!0),St(se(u,{ref:"confirmRef",type:"primary",loading:t.confirmButtonLoading,class:P([t.confirmButtonClasses]),round:t.roundButton,disabled:t.confirmButtonDisabled,size:t.btnSize,onClick:e[5]||(e[5]=f=>t.handleAction("confirm")),onKeydown:e[6]||(e[6]=qt(yt(f=>t.handleAction("confirm"),["prevent"]),["enter"]))},{default:ce(()=>[Yt(Ue(t.confirmButtonText||t.t("el.messagebox.confirm")),1)]),_:1},8,["loading","class","round","disabled","size"]),[[Qt,t.showConfirmButton]])],2)],6)]),_:3},8,["trapped","focus-trap-el","focus-start-el","onReleaseRequested"])],42,Rnt)]),_:3},8,["z-index","overlay-class","mask"]),[[Qt,t.visible]])]),_:3})}var Pnt=je(Ont,[["render",Mnt],["__file","/home/runner/work/element-plus/element-plus/packages/components/message-box/src/index.vue"]]);const X0=new Map,Lnt=t=>{let e=document.body;return t.appendTo&&(wt(t.appendTo)&&(e=document.querySelector(t.appendTo)),Qa(t.appendTo)&&(e=t.appendTo),Qa(e)||(e=document.body)),e},znt=(t,e,n=null)=>{const s=se(Pnt,t,vt(t.message)||Bn(t.message)?{default:vt(t.message)?t.message:()=>t.message}:null);return s.appContext=n,ih(s,e),Lnt(t).appendChild(e.firstElementChild),s.component},Bnt=()=>document.createElement("div"),Vnt=(t,e)=>{const n=Bnt();t.onVanish=()=>{ih(null,n),X0.delete(r)},t.onAction=o=>{const a=X0.get(r);let i;t.showInput?i={value:r.inputValue,action:o}:i=o,t.callback?t.callback(i,s.proxy):o==="cancel"||o==="close"?t.distinguishCancelAndClose&&o!=="cancel"?a.reject("close"):a.reject("cancel"):a.resolve(i)};const s=znt(t,n,e),r=s.proxy;for(const o in t)Ut(t,o)&&!Ut(r.$props,o)&&(r[o]=t[o]);return r.visible=!0,r};function tp(t,e=null){if(!Kt)return Promise.reject();let n;return wt(t)||Bn(t)?t={message:t}:n=t.callback,new Promise((s,r)=>{const o=Vnt(t,e??tp._context);X0.set(o,{options:t,callback:n,resolve:s,reject:r})})}const Hnt=["alert","confirm","prompt"],Wnt={alert:{closeOnPressEscape:!1,closeOnClickModal:!1},confirm:{showCancelButton:!0},prompt:{showCancelButton:!0,showInput:!0}};Hnt.forEach(t=>{tp[t]=Unt(t)});function Unt(t){return(e,n,s,r)=>{let o="";return Bt(n)?(s=n,o=""):er(n)?o="":o=n,tp(Object.assign({title:o,message:e,type:"",...Wnt[t]},s,{boxType:t}),r)}}tp.close=()=>{X0.forEach((t,e)=>{e.doClose()}),X0.clear()};tp._context=null;const hu=tp;hu.install=t=>{hu._context=t._context,t.config.globalProperties.$msgbox=hu,t.config.globalProperties.$messageBox=hu,t.config.globalProperties.$alert=hu.alert,t.config.globalProperties.$confirm=hu.confirm,t.config.globalProperties.$prompt=hu.prompt};const Gnt=hu,yB=["success","info","warning","error"],jnt=qe({customClass:{type:String,default:""},dangerouslyUseHTMLString:{type:Boolean,default:!1},duration:{type:Number,default:4500},icon:{type:In},id:{type:String,default:""},message:{type:Se([String,Object]),default:""},offset:{type:Number,default:0},onClick:{type:Se(Function),default:()=>{}},onClose:{type:Se(Function),required:!0},position:{type:String,values:["top-right","top-left","bottom-right","bottom-left"],default:"top-right"},showClose:{type:Boolean,default:!0},title:{type:String,default:""},type:{type:String,values:[...yB,""],default:""},zIndex:{type:Number,default:0}}),Knt={destroy:()=>!0},qnt=["id"],Xnt=["textContent"],Ynt={key:0},Znt=["innerHTML"],Jnt=ue({name:"ElNotification"}),Qnt=ue({...Jnt,props:jnt,emits:Knt,setup(t,{expose:e}){const n=t,s=Fe("notification"),{Close:r}=OP,o=U(!1);let a;const i=A(()=>{const g=n.type;return g&&Gu[n.type]?s.m(g):""}),l=A(()=>n.type&&Gu[n.type]||n.icon),u=A(()=>n.position.endsWith("right")?"right":"left"),c=A(()=>n.position.startsWith("top")?"top":"bottom"),d=A(()=>({[c.value]:`${n.offset}px`,zIndex:n.zIndex}));function f(){n.duration>0&&({stop:a}=_d(()=>{o.value&&p()},n.duration))}function h(){a==null||a()}function p(){o.value=!1}function m({code:g}){g===ut.delete||g===ut.backspace?h():g===ut.esc?o.value&&p():f()}return It(()=>{f(),o.value=!0}),Rn(document,"keydown",m),e({visible:o,close:p}),(g,y)=>(S(),$e(ms,{name:v(s).b("fade"),onBeforeLeave:g.onClose,onAfterLeave:y[1]||(y[1]=w=>g.$emit("destroy")),persisted:""},{default:ce(()=>[St(I("div",{id:g.id,class:P([v(s).b(),g.customClass,v(u)]),style:ot(v(d)),role:"alert",onMouseenter:h,onMouseleave:f,onClick:y[0]||(y[0]=(...w)=>g.onClick&&g.onClick(...w))},[v(l)?(S(),$e(v(rt),{key:0,class:P([v(s).e("icon"),v(i)])},{default:ce(()=>[(S(),$e(Vt(v(l))))]),_:1},8,["class"])):ge("v-if",!0),I("div",{class:P(v(s).e("group"))},[I("h2",{class:P(v(s).e("title")),textContent:Ue(g.title)},null,10,Xnt),St(I("div",{class:P(v(s).e("content")),style:ot(g.title?void 0:{margin:0})},[Oe(g.$slots,"default",{},()=>[g.dangerouslyUseHTMLString?(S(),E(lt,{key:1},[ge(" Caution here, message could've been compromised, never use user's input as message "),I("p",{innerHTML:g.message},null,8,Znt)],2112)):(S(),E("p",Ynt,Ue(g.message),1))])],6),[[Qt,g.message]]),g.showClose?(S(),$e(v(rt),{key:0,class:P(v(s).e("closeBtn")),onClick:yt(p,["stop"])},{default:ce(()=>[se(v(r))]),_:1},8,["class","onClick"])):ge("v-if",!0)],2)],46,qnt),[[Qt,o.value]])]),_:3},8,["name","onBeforeLeave"]))}});var est=je(Qnt,[["__file","/home/runner/work/element-plus/element-plus/packages/components/notification/src/notification.vue"]]);const Wy={"top-left":[],"top-right":[],"bottom-left":[],"bottom-right":[]},ix=16;let tst=1;const wh=function(t={},e=null){if(!Kt)return{close:()=>{}};(typeof t=="string"||Bn(t))&&(t={message:t});const n=t.position||"top-right";let s=t.offset||0;Wy[n].forEach(({vm:d})=>{var f;s+=(((f=d.el)==null?void 0:f.offsetHeight)||0)+ix}),s+=ix;const{nextZIndex:r}=Ul(),o=`notification_${tst++}`,a=t.onClose,i={...t,zIndex:r(),offset:s,id:o,onClose:()=>{nst(o,n,a)}};let l=document.body;Qa(t.appendTo)?l=t.appendTo:wt(t.appendTo)&&(l=document.querySelector(t.appendTo)),Qa(l)||(l=document.body);const u=document.createElement("div"),c=se(est,i,Bn(i.message)?{default:()=>i.message}:null);return c.appContext=e??wh._context,c.props.onDestroy=()=>{ih(null,u)},ih(c,u),Wy[n].push({vm:c}),l.appendChild(u.firstElementChild),{close:()=>{c.component.exposed.visible.value=!1}}};yB.forEach(t=>{wh[t]=(e={})=>((typeof e=="string"||Bn(e))&&(e={message:e}),wh({...e,type:t}))});function nst(t,e,n){const s=Wy[e],r=s.findIndex(({vm:u})=>{var c;return((c=u.component)==null?void 0:c.props.id)===t});if(r===-1)return;const{vm:o}=s[r];if(!o)return;n==null||n(o);const a=o.el.offsetHeight,i=e.split("-")[0];s.splice(r,1);const l=s.length;if(!(l<1))for(let u=r;u<l;u++){const{el:c,component:d}=s[u].vm,f=Number.parseInt(c.style[i],10)-a-ix;d.props.offset=f}}function sst(){for(const t of Object.values(Wy))t.forEach(({vm:e})=>{e.component.exposed.visible.value=!1})}wh.closeAll=sst;wh._context=null;const rst=DP(wh,"$notify");var ost=[hnt,ynt,vB,Gnt,rst,u7],ast=HFe([...ant,...ost]),Zo={},cc={};const ist=1e-7,lst=1e-4;let zk=class{constructor(e,n){this.backend=e,this.dataMover=n,this.data=new WeakMap,this.dataIdsCount=0}get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,n){this.dataIdsCount++,this.data.set(e,n)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}},Nw=class{refCount(e){return ro("refCount")}incRef(e){return ro("incRef")}timerAvailable(){return!0}time(e){return ro("time")}read(e){return ro("read")}readSync(e){return ro("readSync")}readToGPU(e,n){return ro("readToGPU")}numDataIds(){return ro("numDataIds")}disposeData(e,n){return ro("disposeData")}write(e,n,s){return ro("write")}move(e,n,s,r,o){return ro("move")}createTensorFromTexture(e,n,s){return ro("createTensorFromTexture")}memory(){return ro("memory")}floatPrecision(){return ro("floatPrecision")}epsilon(){return this.floatPrecision()===32?ist:lst}dispose(){return ro("dispose")}};function ro(t){throw new Error(`'${t}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}function Bk(t){let e=t.length,n=0;for(;e>0;)n=Math.random()*e|0,e--,hl(t,e,n)}function ust(t,e){if(t.length!==e.length)throw new Error(`Array sizes must match to be shuffled together First array length was ${t.length}Second array length was ${e.length}`);let n=t.length,s=0;for(;n>0;)s=Math.random()*n|0,n--,hl(t,n,s),hl(e,n,s)}function qu(t,e,n){return Math.max(t,Math.min(e,n))}function Iw(t){return t%2===0?t:t+1}function hl(t,e,n){const s=t[e];t[e]=t[n],t[n]=s}function bB(t){let e=0;for(let n=0;n<t.length;n++)e+=t[n];return e}function cst(t,e){const n=Math.random();return e*n+(1-n)*t}function dst(t,e){let n=0;for(let s=0;s<t.length;s++){const r=Number(t[s])-Number(e[s]);n+=r*r}return n}function q(t,e){if(!t)throw new Error(typeof e=="string"?e:e())}function lr(t,e,n=""){q(hn(t,e),()=>n+` Shapes ${t} and ${e} must match`)}function ef(t){q(t!=null,()=>"The input to the tensor constructor must be a non-null value.")}function Tl(t,e=[],n=!1){if(e==null&&(e=[]),Array.isArray(t)||Zs(t)&&!n)for(let s=0;s<t.length;++s)Tl(t[s],e,n);else e.push(t);return e}function Ge(t){if(t.length===0)return 1;let e=t[0];for(let n=1;n<t.length;n++)e*=t[n];return e}function fst(t){return t.length===0}function hn(t,e){if(t===e)return!0;if(t==null||e==null||t.length!==e.length)return!1;for(let n=0;n<t.length;n++)if(t[n]!==e[n])return!1;return!0}function Nd(t){return t%1===0}function hst(t){if(Math.tanh!=null)return Math.tanh(t);if(t===1/0)return 1;if(t===-1/0)return-1;{const e=Math.exp(2*t);return(e-1)/(e+1)}}function Uy(t){const e=Math.ceil(Math.sqrt(t));return[e,Math.ceil(t/e)]}function pst(t){const e=new Uint32Array(t);for(let n=0;n<t;++n)e[n]=n;return Bk(e),e}function id(t,e){return e<=t.length?t:t+" ".repeat(e-t.length)}function lx(t,e=r=>0,n,s){return new Promise((r,o)=>{let a=0;const i=()=>{if(t()){r();return}a++;const l=e(a);if(n!=null&&a>=n){o();return}s!=null?s(i,l):setTimeout(i,l)};i()})}function Vk(t,e){let n=1,s=-1;for(let o=0;o<t.length;++o)if(t[o]>=0)n*=t[o];else if(t[o]===-1){if(s!==-1)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${s} and dim ${o}`);s=o}else if(t[o]<0)throw Error(`Shapes can not be < 0. Found ${t[o]} at dim ${o}`);if(s===-1){if(e>0&&e!==n)throw Error(`Size(${e}) must match the product of shape ${t}`);return t}if(n===0)throw Error(`Cannot infer the missing size in [${t}] when there are 0 elements`);if(e%n!==0)throw Error(`The implicit shape can't be a fractional number. Got ${e} / ${n}`);const r=t.slice();return r[s]=e/n,r}function un(t,e){const n=e.length;return t=t==null?e.map((s,r)=>r):[].concat(t),q(t.every(s=>s>=-n&&s<n),()=>`All values in axis param must be in range [-${n}, ${n}) but got axis ${t}`),q(t.every(s=>Nd(s)),()=>`All values in axis param must be integers but got axis ${t}`),t.map(s=>s<0?n+s:s)}function Kl(t,e){const n=[],s=[],r=e!=null&&Array.isArray(e)&&e.length===0,o=e==null||r?null:un(e,t).sort();let a=0;for(let i=0;i<t.length;++i){if(o!=null){if(o[a]===i&&t[i]!==1)throw new Error(`Can't squeeze axis ${i} since its dim '${t[i]}' is not 1`);(o[a]==null||o[a]>i)&&t[i]===1&&(n.push(t[i]),s.push(i)),o[a]<=i&&a++}t[i]!==1&&(n.push(t[i]),s.push(i))}return{newShape:n,keptDims:s}}function zs(t,e){let n=null;if(t==null||t==="float32")n=new Float32Array(e);else if(t==="int32")n=new Int32Array(e);else if(t==="bool")n=new Uint8Array(e);else throw new Error(`Unknown data type ${t}`);return n}function gs(t,e){let n=null;if(t==null||t==="float32")n=new Float32Array(e);else if(t==="int32")n=new Int32Array(e);else if(t==="bool")n=new Uint8Array(e);else if(t==="string")n=new Array(e);else throw new Error(`Unknown data type ${t}`);return n}function wB(t,e){for(let n=0;n<t.length;n++){const s=t[n];if(isNaN(s)||!isFinite(s))throw Error(`A tensor of type ${e} being uploaded contains ${s}.`)}}function _B(t){return t==="bool"||t==="complex64"||t==="float32"||t==="int32"||t==="string"}function Hk(t,e){return!(e==="complex64"||e==="float32"&&t!=="complex64"||e==="int32"&&t!=="float32"&&t!=="complex64"||e==="bool"&&t==="bool")}function Zs(t){return t instanceof Float32Array||t instanceof Int32Array||t instanceof Uint8Array||t instanceof Uint8ClampedArray}function Gy(t){if(t==="float32"||t==="int32")return 4;if(t==="complex64")return 8;if(t==="bool")return 1;throw new Error(`Unknown dtype ${t}`)}function $B(t){if(t==null)return 0;let e=0;return t.forEach(n=>e+=n.length),e}function ki(t){return typeof t=="string"||t instanceof String}function xB(t){return typeof t=="boolean"}function jy(t){return typeof t=="number"}function np(t){return Array.isArray(t)?np(t[0]):t instanceof Float32Array?"float32":t instanceof Int32Array||t instanceof Uint8Array||t instanceof Uint8ClampedArray?"int32":jy(t)?"float32":ki(t)?"string":xB(t)?"bool":"float32"}function Xu(t){return!!(t&&t.constructor&&t.call&&t.apply)}function Ky(t,e){for(let n=e;n<t;++n)if(t%n===0)return n;return t}function Mt(t){const e=t.length;if(e<2)return[];const n=new Array(e-1);n[e-2]=t[e-1];for(let s=e-3;s>=0;--s)n[s]=n[s+1]*t[s+1];return n}function SB(t,e,n,s=!1){const r=new Array;if(e.length===1){const o=e[0]*(s?2:1);for(let a=0;a<o;a++)r[a]=n[t+a]}else{const o=e[0],a=e.slice(1),i=a.reduce((l,u)=>l*u)*(s?2:1);for(let l=0;l<o;l++)r[l]=SB(t+l*i,a,n,s)}return r}function Uo(t,e,n=!1){if(t.length===0)return e[0];const s=t.reduce((r,o)=>r*o)*(n?2:1);if(s===0)return[];if(s!==e.length)throw new Error(`[${t}] does not match the input size ${e.length}${n?" for a complex tensor":""}.`);return SB(0,t,e,n)}function Ew(t,e){const n=or(t,e);for(let s=0;s<n.length;s++)n[s]=1;return n}function or(t,e){if(e==null||e==="float32"||e==="complex64")return new Float32Array(t);if(e==="int32")return new Int32Array(t);if(e==="bool")return new Uint8Array(t);throw new Error(`Unknown data type ${e}`)}function Wk(t,e){const n=t.reduce((s,r)=>s*r,1);if(e==null||e==="float32")return Uo(t,new Float32Array(n));if(e==="int32")return Uo(t,new Int32Array(n));if(e==="bool")return Uo(t,new Uint8Array(n));throw new Error(`Unknown data type ${e}`)}function Io(t){t.forEach(e=>{q(Number.isInteger(e)&&e>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${t}].`)})}function Ka(t,e,n){if(e===0)return 0;if(e===1)return t[0];let s=t[t.length-1];for(let r=0;r<t.length-1;++r)s+=n[r]*t[r];return s}function tf(t,e,n){if(e===0)return[];if(e===1)return[t];const s=new Array(e);for(let r=0;r<s.length-1;++r)s[r]=Math.floor(t/n[r]),t-=s[r]*n[r];return s[s.length-1]=t,s}function Yu(t){return t&&t.then&&typeof t.then=="function"}const FR="tfjsflags";let CB=class{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=mst,this.populateURLFlags()}setPlatform(e,n){this.platform!=null&&(Be().getBool("IS_TEST")||Be().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${e}.`)),this.platformName=e,this.platform=n}registerFlag(e,n,s){if(this.flagRegistry[e]={evaluationFn:n,setHook:s},this.urlFlags[e]!=null){const r=this.urlFlags[e];Be().getBool("IS_TEST")||Be().getBool("PROD")||console.warn(`Setting feature override from URL ${e}: ${r}.`),this.set(e,r)}}async getAsync(e){return e in this.flags?this.flags[e]:(this.flags[e]=await this.evaluateFlag(e),this.flags[e])}get(e){if(e in this.flags)return this.flags[e];const n=this.evaluateFlag(e);if(Yu(n))throw new Error(`Flag ${e} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[e]=n,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,n){if(this.flagRegistry[e]==null)throw new Error(`Cannot set flag ${e} as it has not been registered.`);this.flags[e]=n,this.flagRegistry[e].setHook!=null&&this.flagRegistry[e].setHook(n)}evaluateFlag(e){if(this.flagRegistry[e]==null)throw new Error(`Cannot evaluate flag '${e}': no evaluation function found.`);return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global>"u"||typeof this.global.location>"u"||typeof this.global.location.search>"u")return;const e=this.getQueryParams(this.global.location.search);FR in e&&e[FR].split(",").forEach(s=>{const[r,o]=s.split(":");this.urlFlags[r]=vst(r,o)})}};function mst(t){const e={};return t.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(n,...s)=>(gst(e,s[0],s[1]),s.join("="))),e}function gst(t,e,n){t[decodeURIComponent(e)]=decodeURIComponent(n||"")}function vst(t,e){if(e=e.toLowerCase(),e==="true"||e==="false")return e==="true";if(`${+e}`===e)return+e;throw new Error(`Could not parse value flag value ${e} for flag ${t}.`)}function Be(){return Uk}let Uk=null;function yst(t){Uk=t}let h$;function kB(){if(h$==null){let t;if(typeof window<"u")t=window;else if(typeof global<"u")t=global;else if(typeof process<"u")t=process;else if(typeof self<"u")t=self;else throw new Error("Could not find a global object");h$=t}return h$}function bst(){const t=kB();return t._tfGlobals==null&&(t._tfGlobals=new Map),t._tfGlobals}function Gk(t,e){const n=bst();if(n.has(t))return n.get(t);{const s=e();return n.set(t,s),n.get(t)}}const Vg="Abs",sp="Acos",rp="Acosh",nf="Add",Hg="AddN",Aw="All",Ow="Any",Wg="ArgMax",Ug="ArgMin",op="Asin",ap="Asinh",ip="Atan",lp="Atanh",up="Atan2",Gg="AvgPool",Rw="AvgPoolGrad",jg="AvgPool3D",Dw="AvgPool3DGrad",Kg="BatchMatMul",qg="BatchToSpaceND",Fw="Bincount",TB="BroadcastTo",Mw="BroadcastArgs",cp="Cast",dp="Ceil",fp="ClipByValue",Pw="Complex",Xg="ComplexAbs",Yg="Concat",Zg="Conv2D",Lw="Conv2DBackpropFilter",Jg="Conv2DBackpropInput",Qg="Conv3D",zw="Conv3DBackpropFilterV2",Bw="Conv3DBackpropInputV2",hp="Cos",pp="Cosh",Vw="Cumprod",e1="Cumsum",Hw="CropAndResize",Ww="DenseBincount",Uw="DepthToSpace",t1="DepthwiseConv2dNative",Gw="DepthwiseConv2dNativeBackpropFilter",jw="DepthwiseConv2dNativeBackpropInput",Kw="Diag",n1="Dilation2D",qy="Dilation2DBackpropInput",Xy="Dilation2DBackpropFilter",mp="RealDiv",qw="Einsum",gp="Elu",Xw="EluGrad",vp="Erf",s1="Equal",yp="Exp",r1="ExpandDims",bp="Expm1",Yw="FFT",Zw="Fill",Jw="FlipLeftRight",wp="Floor",_p="FloorDiv",o1="FusedBatchNorm",a1="GatherV2",Qw="GatherNd",i1="Greater",$p="GreaterEqual",xp="Identity",e_="IFFT",t_="Imag",Sp="IsFinite",Cp="IsInf",kp="IsNan",l1="LeakyRelu",u1="Less",c1="LessEqual",n_="LinSpace",Tp="Log",Np="Log1p",d1="LogicalAnd",f1="LogicalNot",h1="LogicalOr",wst="LogicalXor",NB="LogSoftmax",_st="LowerBound",p1="LRN",s_="LRNGrad",m1="Max",Ip="Maximum",g1="MaxPool",r_="MaxPoolGrad",v1="MaxPool3D",o_="MaxPool3DGrad",a_="MaxPoolWithArgmax",y1="Mean",b1="Min",Ep="Minimum",w1="MirrorPad",Ap="Mod",i_="Multinomial",Op="Multiply",_1="Neg",$1="NotEqual",l_="NonMaxSuppressionV3",u_="NonMaxSuppressionV4",c_="NonMaxSuppressionV5",x1="OnesLike",S1="OneHot",C1="Pack",k1="PadV2",$st="Pool",Rp="Pow",T1="Prelu",N1="Prod",d_="RaggedGather",f_="RaggedRange",h_="RaggedTensorToTensor",p_="Range",m_="Real",Dp="Reciprocal",Fp="Relu",I1="Reshape",E1="ResizeNearestNeighbor",g_="ResizeNearestNeighborGrad",A1="ResizeBilinear",v_="ResizeBilinearGrad",Mp="Relu6",O1="Reverse",Pp="Round",Lp="Rsqrt",y_="ScatterNd",b_="SearchSorted",R1="Select",zp="Selu",D1="Slice",Bp="Sin",Vp="Sinh",Hp="Sign",Wp="Sigmoid",Up="Softplus",Gp="Sqrt",F1="Sum",M1="SpaceToBatchND",P1="SplitV",L1="Softmax",w_="SparseFillEmptyRows",__="SparseReshape",$_="SparseSegmentMean",x_="SparseSegmentSum",S_="SparseToDense",jp="SquaredDifference",C_="Square",k_="StridedSlice",T_="StringNGrams",N_="StringSplit",I_="StringToHashBucketFast",Kp="Sub",qp="Tan",Xp="Tanh",Yp="Tile",E_="TopK",A_="Transform",ld="Transpose",O_="Unique",z1="Unpack",B1="UnsortedSegmentSum",xst="UpperBound",V1="ZerosLike",Zp="Step",Yy="FromPixels",R_="RotateWithOffset",Y0="_FusedMatMul",Z0="FusedConv2D",J0="FusedDepthwiseConv2D";function Fo(...t){Be().getBool("IS_TEST")||Be().getBool("PROD")||console.warn(...t)}function Sst(...t){Be().getBool("IS_TEST")||Be().getBool("PROD")||console.log(...t)}const _h=Gk("kernelRegistry",()=>new Map),Q0=Gk("gradRegistry",()=>new Map);function Zy(t,e){const n=jk(t,e);return _h.get(n)}function ux(t){return Q0.get(t)}function Jy(t){const e=_h.entries(),n=[];for(;;){const{done:s,value:r}=e.next();if(s)break;const[o,a]=r,[i]=o.split("_");i===t&&n.push(a)}return n}function D_(t){const{kernelName:e,backendName:n}=t,s=jk(e,n);_h.has(s)&&Fo(`The kernel '${e}' for backend '${n}' is already registered`),_h.set(s,t)}function IB(t){const{kernelName:e}=t;Q0.has(e)&&Be().getBool("DEBUG")&&Fo(`Overriding the gradient for '${e}'`),Q0.set(e,t)}function Cst(t,e){const n=jk(t,e);if(!_h.has(n))throw new Error(`The kernel '${t}' for backend '${e}' is not registered`);_h.delete(n)}function kst(t){if(!Q0.has(t))throw new Error(`The gradient '${t}' for backend is not registered`);Q0.delete(t)}function Tst(t,e){Jy(t).forEach(s=>{const r=Object.assign({},s,{backendName:e});D_(r)})}function jk(t,e){return`${e}_${t}`}var Qy=Yn,da=null;try{da=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}function Yn(t,e,n){this.low=t|0,this.high=e|0,this.unsigned=!!n}Yn.prototype.__isLong__;Object.defineProperty(Yn.prototype,"__isLong__",{value:!0});function Eo(t){return(t&&t.__isLong__)===!0}Yn.isLong=Eo;var MR={},PR={};function sf(t,e){var n,s,r;return e?(t>>>=0,(r=0<=t&&t<256)&&(s=PR[t],s)?s:(n=Zn(t,(t|0)<0?-1:0,!0),r&&(PR[t]=n),n)):(t|=0,(r=-128<=t&&t<128)&&(s=MR[t],s)?s:(n=Zn(t,t<0?-1:0,!1),r&&(MR[t]=n),n))}Yn.fromInt=sf;function fa(t,e){if(isNaN(t))return e?Jc:ha;if(e){if(t<0)return Jc;if(t>=EB)return RB}else{if(t<=-zR)return ho;if(t+1>=zR)return OB}return t<0?fa(-t,e).neg():Zn(t%$h|0,t/$h|0,e)}Yn.fromNumber=fa;function Zn(t,e,n){return new Yn(t,e,n)}Yn.fromBits=Zn;var eb=Math.pow;function Kk(t,e,n){if(t.length===0)throw Error("empty string");if(t==="NaN"||t==="Infinity"||t==="+Infinity"||t==="-Infinity")return ha;if(typeof e=="number"?(n=e,e=!1):e=!!e,n=n||10,n<2||36<n)throw RangeError("radix");var s;if((s=t.indexOf("-"))>0)throw Error("interior hyphen");if(s===0)return Kk(t.substring(1),e,n).neg();for(var r=fa(eb(n,8)),o=ha,a=0;a<t.length;a+=8){var i=Math.min(8,t.length-a),l=parseInt(t.substring(a,a+i),n);if(i<8){var u=fa(eb(n,i));o=o.mul(u).add(fa(l))}else o=o.mul(r),o=o.add(fa(l))}return o.unsigned=e,o}Yn.fromString=Kk;function ii(t,e){return typeof t=="number"?fa(t,e):typeof t=="string"?Kk(t,e):Zn(t.low,t.high,typeof e=="boolean"?e:t.unsigned)}Yn.fromValue=ii;var LR=1<<16,Nst=1<<24,$h=LR*LR,EB=$h*$h,zR=EB/2,BR=sf(Nst),ha=sf(0);Yn.ZERO=ha;var Jc=sf(0,!0);Yn.UZERO=Jc;var Lf=sf(1);Yn.ONE=Lf;var AB=sf(1,!0);Yn.UONE=AB;var cx=sf(-1);Yn.NEG_ONE=cx;var OB=Zn(-1,2147483647,!1);Yn.MAX_VALUE=OB;var RB=Zn(-1,-1,!0);Yn.MAX_UNSIGNED_VALUE=RB;var ho=Zn(0,-2147483648,!1);Yn.MIN_VALUE=ho;var mt=Yn.prototype;mt.toInt=function(){return this.unsigned?this.low>>>0:this.low};mt.toNumber=function(){return this.unsigned?(this.high>>>0)*$h+(this.low>>>0):this.high*$h+(this.low>>>0)};mt.toString=function(e){if(e=e||10,e<2||36<e)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative())if(this.eq(ho)){var n=fa(e),s=this.div(n),r=s.mul(n).sub(this);return s.toString(e)+r.toInt().toString(e)}else return"-"+this.neg().toString(e);for(var o=fa(eb(e,6),this.unsigned),a=this,i="";;){var l=a.div(o),u=a.sub(l.mul(o)).toInt()>>>0,c=u.toString(e);if(a=l,a.isZero())return c+i;for(;c.length<6;)c="0"+c;i=""+c+i}};mt.getHighBits=function(){return this.high};mt.getHighBitsUnsigned=function(){return this.high>>>0};mt.getLowBits=function(){return this.low};mt.getLowBitsUnsigned=function(){return this.low>>>0};mt.getNumBitsAbs=function(){if(this.isNegative())return this.eq(ho)?64:this.neg().getNumBitsAbs();for(var e=this.high!=0?this.high:this.low,n=31;n>0&&(e&1<<n)==0;n--);return this.high!=0?n+33:n+1};mt.isZero=function(){return this.high===0&&this.low===0};mt.eqz=mt.isZero;mt.isNegative=function(){return!this.unsigned&&this.high<0};mt.isPositive=function(){return this.unsigned||this.high>=0};mt.isOdd=function(){return(this.low&1)===1};mt.isEven=function(){return(this.low&1)===0};mt.equals=function(e){return Eo(e)||(e=ii(e)),this.unsigned!==e.unsigned&&this.high>>>31===1&&e.high>>>31===1?!1:this.high===e.high&&this.low===e.low};mt.eq=mt.equals;mt.notEquals=function(e){return!this.eq(e)};mt.neq=mt.notEquals;mt.ne=mt.notEquals;mt.lessThan=function(e){return this.comp(e)<0};mt.lt=mt.lessThan;mt.lessThanOrEqual=function(e){return this.comp(e)<=0};mt.lte=mt.lessThanOrEqual;mt.le=mt.lessThanOrEqual;mt.greaterThan=function(e){return this.comp(e)>0};mt.gt=mt.greaterThan;mt.greaterThanOrEqual=function(e){return this.comp(e)>=0};mt.gte=mt.greaterThanOrEqual;mt.ge=mt.greaterThanOrEqual;mt.compare=function(e){if(Eo(e)||(e=ii(e)),this.eq(e))return 0;var n=this.isNegative(),s=e.isNegative();return n&&!s?-1:!n&&s?1:this.unsigned?e.high>>>0>this.high>>>0||e.high===this.high&&e.low>>>0>this.low>>>0?-1:1:this.sub(e).isNegative()?-1:1};mt.comp=mt.compare;mt.negate=function(){return!this.unsigned&&this.eq(ho)?ho:this.not().add(Lf)};mt.neg=mt.negate;mt.add=function(e){Eo(e)||(e=ii(e));var n=this.high>>>16,s=this.high&65535,r=this.low>>>16,o=this.low&65535,a=e.high>>>16,i=e.high&65535,l=e.low>>>16,u=e.low&65535,c=0,d=0,f=0,h=0;return h+=o+u,f+=h>>>16,h&=65535,f+=r+l,d+=f>>>16,f&=65535,d+=s+i,c+=d>>>16,d&=65535,c+=n+a,c&=65535,Zn(f<<16|h,c<<16|d,this.unsigned)};mt.subtract=function(e){return Eo(e)||(e=ii(e)),this.add(e.neg())};mt.sub=mt.subtract;mt.multiply=function(e){if(this.isZero())return ha;if(Eo(e)||(e=ii(e)),da){var n=da.mul(this.low,this.high,e.low,e.high);return Zn(n,da.get_high(),this.unsigned)}if(e.isZero())return ha;if(this.eq(ho))return e.isOdd()?ho:ha;if(e.eq(ho))return this.isOdd()?ho:ha;if(this.isNegative())return e.isNegative()?this.neg().mul(e.neg()):this.neg().mul(e).neg();if(e.isNegative())return this.mul(e.neg()).neg();if(this.lt(BR)&&e.lt(BR))return fa(this.toNumber()*e.toNumber(),this.unsigned);var s=this.high>>>16,r=this.high&65535,o=this.low>>>16,a=this.low&65535,i=e.high>>>16,l=e.high&65535,u=e.low>>>16,c=e.low&65535,d=0,f=0,h=0,p=0;return p+=a*c,h+=p>>>16,p&=65535,h+=o*c,f+=h>>>16,h&=65535,h+=a*u,f+=h>>>16,h&=65535,f+=r*c,d+=f>>>16,f&=65535,f+=o*u,d+=f>>>16,f&=65535,f+=a*l,d+=f>>>16,f&=65535,d+=s*c+r*u+o*l+a*i,d&=65535,Zn(h<<16|p,d<<16|f,this.unsigned)};mt.mul=mt.multiply;mt.divide=function(e){if(Eo(e)||(e=ii(e)),e.isZero())throw Error("division by zero");if(da){if(!this.unsigned&&this.high===-2147483648&&e.low===-1&&e.high===-1)return this;var n=(this.unsigned?da.div_u:da.div_s)(this.low,this.high,e.low,e.high);return Zn(n,da.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?Jc:ha;var s,r,o;if(this.unsigned){if(e.unsigned||(e=e.toUnsigned()),e.gt(this))return Jc;if(e.gt(this.shru(1)))return AB;o=Jc}else{if(this.eq(ho)){if(e.eq(Lf)||e.eq(cx))return ho;if(e.eq(ho))return Lf;var a=this.shr(1);return s=a.div(e).shl(1),s.eq(ha)?e.isNegative()?Lf:cx:(r=this.sub(e.mul(s)),o=s.add(r.div(e)),o)}else if(e.eq(ho))return this.unsigned?Jc:ha;if(this.isNegative())return e.isNegative()?this.neg().div(e.neg()):this.neg().div(e).neg();if(e.isNegative())return this.div(e.neg()).neg();o=ha}for(r=this;r.gte(e);){s=Math.max(1,Math.floor(r.toNumber()/e.toNumber()));for(var i=Math.ceil(Math.log(s)/Math.LN2),l=i<=48?1:eb(2,i-48),u=fa(s),c=u.mul(e);c.isNegative()||c.gt(r);)s-=l,u=fa(s,this.unsigned),c=u.mul(e);u.isZero()&&(u=Lf),o=o.add(u),r=r.sub(c)}return o};mt.div=mt.divide;mt.modulo=function(e){if(Eo(e)||(e=ii(e)),da){var n=(this.unsigned?da.rem_u:da.rem_s)(this.low,this.high,e.low,e.high);return Zn(n,da.get_high(),this.unsigned)}return this.sub(this.div(e).mul(e))};mt.mod=mt.modulo;mt.rem=mt.modulo;mt.not=function(){return Zn(~this.low,~this.high,this.unsigned)};mt.and=function(e){return Eo(e)||(e=ii(e)),Zn(this.low&e.low,this.high&e.high,this.unsigned)};mt.or=function(e){return Eo(e)||(e=ii(e)),Zn(this.low|e.low,this.high|e.high,this.unsigned)};mt.xor=function(e){return Eo(e)||(e=ii(e)),Zn(this.low^e.low,this.high^e.high,this.unsigned)};mt.shiftLeft=function(e){return Eo(e)&&(e=e.toInt()),(e&=63)===0?this:e<32?Zn(this.low<<e,this.high<<e|this.low>>>32-e,this.unsigned):Zn(0,this.low<<e-32,this.unsigned)};mt.shl=mt.shiftLeft;mt.shiftRight=function(e){return Eo(e)&&(e=e.toInt()),(e&=63)===0?this:e<32?Zn(this.low>>>e|this.high<<32-e,this.high>>e,this.unsigned):Zn(this.high>>e-32,this.high>=0?0:-1,this.unsigned)};mt.shr=mt.shiftRight;mt.shiftRightUnsigned=function(e){if(Eo(e)&&(e=e.toInt()),e&=63,e===0)return this;var n=this.high;if(e<32){var s=this.low;return Zn(s>>>e|n<<32-e,n>>>e,this.unsigned)}else return e===32?Zn(n,0,this.unsigned):Zn(n>>>e-32,0,this.unsigned)};mt.shru=mt.shiftRightUnsigned;mt.shr_u=mt.shiftRightUnsigned;mt.toSigned=function(){return this.unsigned?Zn(this.low,this.high,!1):this};mt.toUnsigned=function(){return this.unsigned?this:Zn(this.low,this.high,!0)};mt.toBytes=function(e){return e?this.toBytesLE():this.toBytesBE()};mt.toBytesLE=function(){var e=this.high,n=this.low;return[n&255,n>>>8&255,n>>>16&255,n>>>24,e&255,e>>>8&255,e>>>16&255,e>>>24]};mt.toBytesBE=function(){var e=this.high,n=this.low;return[e>>>24,e>>>16&255,e>>>8&255,e&255,n>>>24,n>>>16&255,n>>>8&255,n&255]};Yn.fromBytes=function(e,n,s){return s?Yn.fromBytesLE(e,n):Yn.fromBytesBE(e,n)};Yn.fromBytesLE=function(e,n){return new Yn(e[0]|e[1]<<8|e[2]<<16|e[3]<<24,e[4]|e[5]<<8|e[6]<<16|e[7]<<24,n)};Yn.fromBytesBE=function(e,n){return new Yn(e[4]<<24|e[5]<<16|e[6]<<8|e[7],e[0]<<24|e[1]<<16|e[2]<<8|e[3],n)};const DB=$Q({__proto__:null,default:Qy},[Qy]);const Vc=Qy||DB;function H1(t){return Vc.fromString(t,!0,16)}const FB=H1("c3a5c85c97cb3127"),Rc=H1("b492b66fbe98f273"),Sr=H1("9ae16a3b2f90404f");function dx(t){return t.xor(t.shru(47))}function MB(t,e,n){const s=t.slice(e,e+n);return Vc.fromBytes(Array.from(s),!0,!0)}function Vn(t,e){return MB(t,e,8)}function VR(t,e){return MB(t,e,4)}function Bs(t,e){return e===0?t:t.shru(e).or(t.shl(64-e))}function Fu(t,e,n=H1("9ddfea08eb382d69")){let s=t.xor(e).mul(n);s=s.xor(s.shru(47));let r=e.xor(s).mul(n);return r=r.xor(r.shru(47)),r=r.mul(n),r}function Ist(t,e,n,s,r,o){r=r.add(t),o=Bs(o.add(r).add(s),21);const a=r;return r=r.add(e),r=r.add(n),o=o.add(Bs(r,44)),[r.add(s),o.add(a)]}function pv(t,e,n,s){return Ist(Vn(t,e),Vn(t,e+8),Vn(t,e+16),Vn(t,e+24),n,s)}function Est(t,e=t.length){if(e>=8){const n=Sr.add(e*2),s=Vn(t,0).add(Sr),r=Vn(t,e-8),o=Bs(r,37).mul(n).add(s),a=Bs(s,25).add(r).mul(n);return Fu(o,a,n)}if(e>=4){const n=Sr.add(e*2),s=VR(t,0);return Fu(s.shl(3).add(e),VR(t,e-4),n)}if(e>0){const n=t[0],s=t[e>>1],r=t[e-1],o=n+(s<<8),a=e+(r<<2);return dx(Sr.mul(o).xor(FB.mul(a))).mul(Sr)}return Sr}function Ast(t,e=t.length){const n=Sr.add(e*2),s=Vn(t,0).mul(Rc),r=Vn(t,8),o=Vn(t,e-8).mul(n),a=Vn(t,e-16).mul(Sr);return Fu(Bs(s.add(r),43).add(Bs(o,30)).add(a),s.add(Bs(r.add(Sr),18)).add(o),n)}function Ost(t,e=t.length){const n=Sr.add(e*2),s=Vn(t,0).mul(Sr),r=Vn(t,8),o=Vn(t,e-8).mul(n),a=Vn(t,e-16).mul(Sr),i=Bs(s.add(r),43).add(Bs(o,30)).add(a),l=Fu(i,s.add(Bs(r.add(Sr),18)).add(o),n),u=Vn(t,16).mul(n),c=Vn(t,24),d=i.add(Vn(t,e-32)).mul(n),f=l.add(Vn(t,e-24)).mul(n);return Fu(Bs(u.add(c),43).add(Bs(d,30)).add(f),u.add(Bs(c.add(s),18)).add(d),n)}function PB(t,e=t.length){const n=Vc.fromNumber(81,!0);if(e<=32)return e<=16?Est(t,e):Ast(t,e);if(e<=64)return Ost(t,e);let s=n,r=n.mul(Rc).add(113),o=dx(r.mul(Sr).add(113)).mul(Sr),a=[Vc.UZERO,Vc.UZERO],i=[Vc.UZERO,Vc.UZERO];s=s.mul(Sr).add(Vn(t,0));let l=0;const u=(e-1>>6)*64,c=u+(e-1&63)-63;do s=Bs(s.add(r).add(a[0]).add(Vn(t,l+8)),37).mul(Rc),r=Bs(r.add(a[1]).add(Vn(t,l+48)),42).mul(Rc),s=s.xor(i[1]),r=r.add(a[0]).add(Vn(t,l+40)),o=Bs(o.add(i[0]),33).mul(Rc),a=pv(t,l,a[1].mul(Rc),s.add(i[0])),i=pv(t,l+32,o.add(i[1]),r.add(Vn(t,l+16))),[o,s]=[s,o],l+=64;while(l!==u);const d=Rc.add(o.and(255).shl(1));return l=c,i[0]=i[0].add(e-1&63),a[0]=a[0].add(i[0]),i[0]=i[0].add(a[0]),s=Bs(s.add(r).add(a[0]).add(Vn(t,l+8)),37).mul(d),r=Bs(r.add(a[1]).add(Vn(t,l+48)),42).mul(d),s=s.xor(i[1].mul(9)),r=r.add(a[0].mul(9).add(Vn(t,l+40))),o=Bs(o.add(i[0]),33).mul(d),a=pv(t,l,a[1].mul(d),s.add(i[0])),i=pv(t,l+32,o.add(i[1]),r.add(Vn(t,l+16))),[o,s]=[s,o],Fu(Fu(a[0],i[0],d).add(dx(r).mul(FB)).add(o),Fu(a[1],i[1],d).add(s),d)}function ql(t,e){return e==="string"?Oi(t):dc([t],e)}function Rst(t,e){return t instanceof Float32Array&&e==="float32"||t instanceof Int32Array&&e==="int32"||t instanceof Uint8Array&&e==="bool"}function dc(t,e){if(e==="string")throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(t)&&(t=Tl(t)),Be().getBool("DEBUG")&&wB(t,e),Rst(t,e))return t;if(e==null||e==="float32"||e==="complex64")return new Float32Array(t);if(e==="int32")return new Int32Array(t);if(e==="bool"){const n=new Uint8Array(t.length);for(let s=0;s<n.length;++s)Math.round(t[s])!==0&&(n[s]=1);return n}else throw new Error(`Unknown data type ${e}`)}function Ys(){return Be().platform.now()}function LB(t,e){return Be().platform.fetch(t,e)}function Oi(t,e="utf-8"){return e=e||"utf-8",Be().platform.encode(t,e)}function Nl(t,e="utf-8"){return e=e||"utf-8",Be().platform.decode(t,e)}const Dst=Object.freeze(Object.defineProperty({__proto__:null,createScalarValue:ql,toTypedArray:dc,now:Ys,fetch:LB,encodeString:Oi,decodeString:Nl,shuffle:Bk,shuffleCombo:ust,clamp:qu,nearestLargerEven:Iw,swap:hl,sum:bB,randUniform:cst,distSquared:dst,assert:q,assertShapesMatch:lr,assertNonNull:ef,flatten:Tl,sizeFromShape:Ge,isScalarShape:fst,arraysEqual:hn,isInt:Nd,tanh:hst,sizeToSquarishShape:Uy,createShuffledIndices:pst,rightPad:id,repeatedTry:lx,inferFromImplicitShape:Vk,parseAxisParam:un,squeezeShape:Kl,getTypedArrayFromDType:zs,getArrayFromDType:gs,checkConversionForErrors:wB,isValidDtype:_B,hasEncodingLoss:Hk,isTypedArray:Zs,bytesPerElement:Gy,bytesFromStringArray:$B,isString:ki,isBoolean:xB,isNumber:jy,inferDtype:np,isFunction:Xu,nearestDivisor:Ky,computeStrides:Mt,toNestedArray:Uo,makeOnesTypedArray:Ew,makeZerosTypedArray:or,makeZerosNestedTypedArray:Wk,assertNonNegativeIntegerDimensions:Io,locToIndex:Ka,indexToLoc:tf,isPromise:Yu,hexToLong:H1,fingerPrint64:PB},Symbol.toStringTag,{value:"Module"}));let Fst=class{constructor(e,n){this.backendTimer=e,this.logger=n,n==null&&(this.logger=new Pst)}profileKernel(e,n,s){let r;const o=()=>{r=s()};let a;const i=Ys();if(this.backendTimer.timerAvailable())a=this.backendTimer.time(o);else{o();for(const u of r)u.dataSync();a=Promise.resolve({kernelMs:Ys()-i})}if(Be().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let u=0;u<r.length;u++){const c=r[u];c.data().then(d=>{Mst(d,c.dtype,e)})}return{kernelName:e,outputs:r,inputs:n,timeMs:a.then(u=>u.kernelMs),extraInfo:a.then(u=>u.getExtraProfileInfo!=null?u.getExtraProfileInfo():"")}}logKernelProfile(e){const{kernelName:n,outputs:s,timeMs:r,inputs:o,extraInfo:a}=e;s.forEach(i=>{Promise.all([i.data(),r,a]).then(l=>{this.logger.logKernelProfile(n,i,l[0],l[1],o,l[2])})})}};function Mst(t,e,n){if(e!=="float32")return!1;for(let s=0;s<t.length;s++){const r=t[s];if(isNaN(r)||!isFinite(r))return console.warn(`Found ${r} in the result of '${n}'`),!0}return!1}let Pst=class{logKernelProfile(e,n,s,r,o,a){const i=typeof r=="number"?id(`${r}ms`,9):r.error,l=id(e,25),u=n.rank,c=n.size,d=id(n.shape.toString(),14);let f="";for(const h in o){const p=o[h];if(p!=null){const m=p.shape||n.shape,g=m.length;f+=`${h}: ${g}D ${g>0?m:""} `}}console.log(`%c${l}	%c${i}	%c${u}D ${d}	%c${c}	%c${f}	%c${a}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}};function Lst(t,e,n){const s={},r={};for(let l=0;l<e.length;l++)s[e[l].id]=!0;for(let l=0;l<t.length;l++){const u=t[l],c=u.inputs;for(const d in c){const f=c[d];let h=!1;for(let p=0;p<e.length;p++)if(s[f.id]){u.outputs.forEach(m=>s[m.id]=!0),h=!0,r[u.id]=!0;break}if(h)break}}const o={};o[n.id]=!0;const a={};for(let l=t.length-1;l>=0;l--){const u=t[l],c=u.inputs;for(let d=0;d<u.outputs.length;d++)if(o[u.outputs[d].id]){for(const f in c)o[c[f].id]=!0,a[u.id]=!0;break}}const i=[];for(let l=0;l<t.length;l++){const u=t[l];if(r[u.id]&&a[u.id]){const c={};for(const f in u.inputs){const h=u.inputs[f];s[h.id]&&(c[f]=h)}const d=Object.assign({},u);d.inputs=c,d.outputs=u.outputs,i.push(d)}}return i}function zst(t,e,n,s){for(let r=e.length-1;r>=0;r--){const o=e[r],a=[];if(o.outputs.forEach(l=>{const u=t[l.id];u!=null?a.push(u):a.push(null)}),o.gradient==null)throw new Error(`Cannot compute gradient: gradient function not found for ${o.kernelName}.`);const i=o.gradient(a);for(const l in o.inputs){if(!(l in i))throw new Error(`Cannot backprop through input ${l}. Available gradients found: ${Object.keys(i)}.`);const u=n(()=>i[l]());if(u.dtype!=="float32")throw new Error(`Error in gradient for op ${o.kernelName}. The gradient of input ${l} must have 'float32' dtype, but has '${u.dtype}'`);const c=o.inputs[l];if(!hn(u.shape,c.shape))throw new Error(`Error in gradient for op ${o.kernelName}. The gradient of input '${l}' has shape '${u.shape}', which does not match the shape of the input '${c.shape}'`);if(t[c.id]==null)t[c.id]=u;else{const d=t[c.id];t[c.id]=s(d,u),d.dispose()}}}}const HR=20,Dm=3,p$=7;function Bst(t,e,n,s){const r=Mt(e),o=Vst(t,e,n,r),a=e.length,i=dy(t,e,n,r,o),l=["Tensor"];return s&&(l.push(`  dtype: ${n}`),l.push(`  rank: ${a}`),l.push(`  shape: [${e}]`),l.push("  values:")),l.push(i.map(u=>"    "+u).join(`
`)),l.join(`
`)}function Vst(t,e,n,s){const r=Ge(e),o=s[s.length-1],a=new Array(o).fill(0),i=e.length,l=n==="complex64"?jm(t):t;if(i>1)for(let u=0;u<r/o;u++){const c=u*o;for(let d=0;d<o;d++)a[d]=Math.max(a[d],Gm(l[c+d],0,n).length)}return a}function Gm(t,e,n){let s;return Array.isArray(t)?s=`${parseFloat(t[0].toFixed(p$))} + ${parseFloat(t[1].toFixed(p$))}j`:ki(t)?s=`'${t}'`:n==="bool"?s=zB(t):s=parseFloat(t.toFixed(p$)).toString(),id(s,e)}function zB(t){return t===0?"false":"true"}function dy(t,e,n,s,r,o=!0){const a=n==="complex64"?2:1,i=e[0],l=e.length;if(l===0){if(n==="complex64"){const m=jm(t);return[Gm(m[0],0,n)]}return n==="bool"?[zB(t[0])]:[t[0].toString()]}if(l===1){if(i>HR){const g=Dm*a;let y=Array.from(t.slice(0,g)),w=Array.from(t.slice((i-Dm)*a,i*a));return n==="complex64"&&(y=jm(y),w=jm(w)),["["+y.map((b,_)=>Gm(b,r[_],n)).join(", ")+", ..., "+w.map((b,_)=>Gm(b,r[i-Dm+_],n)).join(", ")+"]"]}return["["+(n==="complex64"?jm(t):Array.from(t)).map((g,y)=>Gm(g,r[y],n)).join(", ")+"]"]}const u=e.slice(1),c=s.slice(1),d=s[0]*a,f=[];if(i>HR){for(let m=0;m<Dm;m++){const g=m*d,y=g+d;f.push(...dy(t.slice(g,y),u,n,c,r,!1))}f.push("...");for(let m=i-Dm;m<i;m++){const g=m*d,y=g+d;f.push(...dy(t.slice(g,y),u,n,c,r,m===i-1))}}else for(let m=0;m<i;m++){const g=m*d,y=g+d;f.push(...dy(t.slice(g,y),u,n,c,r,m===i-1))}const h=l===2?",":"";f[0]="["+f[0]+h;for(let m=1;m<f.length-1;m++)f[m]=" "+f[m]+h;let p=`,
`;for(let m=2;m<l;m++)p+=`
`;return f[f.length-1]=" "+f[f.length-1]+"]"+(o?"":p),f}function jm(t){const e=[];for(let n=0;n<t.length;n+=2)e.push([t[n],t[n+1]]);return e}let Ds=class{constructor(e,n,s){if(this.dtype=n,this.shape=e.slice(),this.size=Ge(e),s!=null){const r=s.length;q(r===this.size,()=>`Length of values '${r}' does not match the size inferred by the shape '${this.size}'.`)}if(n==="complex64")throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=s||gs(n,this.size),this.strides=Mt(e)}set(e,...n){n.length===0&&(n=[0]),q(n.length===this.rank,()=>`The number of provided coordinates (${n.length}) must match the rank (${this.rank})`);const s=this.locToIndex(n);this.values[s]=e}get(...e){e.length===0&&(e=[0]);let n=0;for(const r of e){if(r<0||r>=this.shape[n]){const o=`Requested out of range element at ${e}.   Buffer shape=${this.shape}`;throw new Error(o)}n++}let s=e[e.length-1];for(let r=0;r<e.length-1;++r)s+=this.strides[r]*e[r];return this.values[s]}locToIndex(e){if(this.rank===0)return 0;if(this.rank===1)return e[0];let n=e[e.length-1];for(let s=0;s<e.length-1;++s)n+=this.strides[s]*e[s];return n}indexToLoc(e){if(this.rank===0)return[];if(this.rank===1)return[e];const n=new Array(this.shape.length);for(let s=0;s<n.length-1;++s)n[s]=Math.floor(e/this.strides[s]),e-=n[s]*this.strides[s];return n[n.length-1]=e,n}get rank(){return this.shape.length}toTensor(){return La().makeTensor(this.values,this.shape,this.dtype)}},La=null,Ef=null;function Hst(t){La=t}function Wst(t){Ef=t}let $n=class{constructor(e,n,s,r){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=n||"float32",this.size=Ge(e),this.strides=Mt(e),this.dataId=s,this.id=r,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const e=await this.data();return Ef.buffer(this.shape,this.dtype,e)}bufferSync(){return Ef.buffer(this.shape,this.dtype,this.dataSync())}async array(){const e=await this.data();return Uo(this.shape,e,this.dtype==="complex64")}arraySync(){return Uo(this.shape,this.dataSync(),this.dtype==="complex64")}async data(){this.throwIfDisposed();const e=La().read(this.dataId);if(this.dtype==="string"){const n=await e;try{return n.map(s=>Nl(s))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e}dataToGPU(e){return this.throwIfDisposed(),La().readToGPU(this.dataId,e)}dataSync(){this.throwIfDisposed();const e=La().readSync(this.dataId);if(this.dtype==="string")try{return e.map(n=>Nl(n))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}async bytes(){this.throwIfDisposed();const e=await La().read(this.dataId);return this.dtype==="string"?e:new Uint8Array(e.buffer)}dispose(){this.isDisposed||(La().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(e=!1){return Ef.print(this,e)}clone(){return this.throwIfDisposed(),Ef.clone(this)}toString(e=!1){const n=this.dataSync();return Bst(n,this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),Ef.cast(this,e)}variable(e=!0,n,s){return this.throwIfDisposed(),La().makeVariable(this,e,n,s)}};Object.defineProperty($n,Symbol.hasInstance,{value:t=>!!t&&t.data!=null&&t.dataSync!=null&&t.throwIfDisposed!=null});function Xe(){return Gk("Tensor",()=>$n)}Xe();let eg=class extends $n{constructor(e,n,s,r){super(e.shape,e.dtype,e.dataId,r),this.trainable=n,this.name=s}assign(e){if(e.dtype!==this.dtype)throw new Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);if(!hn(e.shape,this.shape))throw new Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);La().disposeTensor(this),this.dataId=e.dataId,La().incRef(this,null)}dispose(){La().disposeVariable(this),this.isDisposedInternal=!0}};Object.defineProperty(eg,Symbol.hasInstance,{value:t=>t instanceof $n&&t.assign!=null&&t.assign instanceof Function});var fx;(function(t){t.R0="R0",t.R1="R1",t.R2="R2",t.R3="R3",t.R4="R4",t.R5="R5",t.R6="R6"})(fx||(fx={}));var hx;(function(t){t.float32="float32",t.int32="int32",t.bool="int32",t.complex64="complex64"})(hx||(hx={}));var px;(function(t){t.float32="float32",t.int32="int32",t.bool="bool",t.complex64="complex64"})(px||(px={}));var mx;(function(t){t.float32="float32",t.int32="float32",t.bool="float32",t.complex64="complex64"})(mx||(mx={}));var gx;(function(t){t.float32="complex64",t.int32="complex64",t.bool="complex64",t.complex64="complex64"})(gx||(gx={}));const Ust={float32:mx,int32:hx,bool:px,complex64:gx};function Yr(t,e){if(t==="string"||e==="string"){if(t==="string"&&e==="string")return"string";throw new Error(`Can not upcast ${t} with ${e}`)}return Ust[t][e]}function F_(t){return Yr(t,"int32")}function ds(t,e){if(t.dtype===e.dtype)return[t,e];const n=Yr(t.dtype,e.dtype);return[t.cast(n),e.cast(n)]}function BB(t,e){q(t.dtype===e.dtype,()=>`The dtypes of the first(${t.dtype}) and second(${e.dtype}) input must match`)}function M_(t,e){return e.some(n=>n.id===t.id)}function Il(t){const e=[];return VB(t,e,new Set),e}function VB(t,e,n){if(t==null)return;if(t instanceof $n){e.push(t);return}if(!Gst(t))return;const s=t;for(const r in s){const o=s[r];n.has(o)||(n.add(o),VB(o,e,n))}}function Gst(t){return Array.isArray(t)||typeof t=="object"}const jst=Object.freeze(Object.defineProperty({__proto__:null,makeTypesMatch:ds,assertTypesMatch:BB,isTensorInList:M_,getTensorsInContainer:Il},Symbol.toStringTag,{value:"Module"}));function m$(t){return t.kernelName!=null}let WR=class{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(e=>e.name)))}}}dispose(){for(const e in this.registeredVariables)this.registeredVariables[e].dispose()}},tg=class{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new WR}async ready(){if(this.pendingBackendInit!=null)return this.pendingBackendInit.then(()=>{});if(this.backendInstance!=null)return;const e=this.getSortedBackends();for(let n=0;n<e.length;n++){const s=e[n];if(await this.initializeBackend(s).success){await this.setBackend(s);return}}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(this.pendingBackendInit!=null)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(this.backendInstance==null){const{name:e,asyncInit:n}=this.initializeBackendsAndReturnBest();if(n)throw new Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry))if(e in this.registryFactory){const{asyncInit:n}=this.initializeBackend(e);if(n)return null}else return null;return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,n,s=1){return e in this.registryFactory?(Fo(`${e} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[e]={factory:n,priority:s},!0)}async setBackend(e){if(this.registryFactory[e]==null)throw new Error(`Backend name '${e}' not found in registry`);if(this.backendName=e,this.registry[e]==null){this.backendInstance=null;const{success:n,asyncInit:s}=this.initializeBackend(e);if(!(s?await n:n))return!1}return this.backendInstance=this.registry[e],this.setupRegisteredKernels(),this.profiler=new Fst(this.backendInstance),!0}setupRegisteredKernels(){Jy(this.backendName).forEach(n=>{n.setupFunc!=null&&n.setupFunc(this.backendInstance)})}disposeRegisteredKernels(e){Jy(e).forEach(s=>{s.disposeFunc!=null&&s.disposeFunc(this.registry[e])})}initializeBackend(e){const n=this.registryFactory[e];if(n==null)throw new Error(`Cannot initialize backend ${e}, no registration found.`);try{const s=n.factory();if(s&&!(s instanceof Nw)&&typeof s.then=="function"){const r=++this.pendingBackendInitId,o=s.then(a=>r<this.pendingBackendInitId?!1:(this.registry[e]=a,this.pendingBackendInit=null,!0)).catch(a=>(r<this.pendingBackendInitId||(this.pendingBackendInit=null,Fo(`Initialization of backend ${e} failed`),Fo(a.stack||a.message)),!1));return this.pendingBackendInit=o,{success:o,asyncInit:!0}}else return this.registry[e]=s,{success:!0,asyncInit:!1}}catch(s){return Fo(`Initialization of backend ${e} failed`),Fo(s.stack||s.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error(`${e} backend not found in registry`);this.backendName===e&&this.pendingBackendInit!=null&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(Object.keys(this.registryFactory).length===0)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((e,n)=>this.registryFactory[n].priority-this.registryFactory[e].priority)}initializeBackendsAndReturnBest(){const e=this.getSortedBackends();for(let n=0;n<e.length;n++){const s=e[n],{success:r,asyncInit:o}=this.initializeBackend(s);if(o||r)return{name:s,asyncInit:o}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,n){const s=this.state.tensorInfo.get(n),r=s.backend,o=this.readSync(n),a=r.refCount(n);r.disposeData(n,!0),s.backend=e,e.move(n,o,s.shape,s.dtype,a),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,n){let s=null;if(n==null){if(typeof e!="function")throw new Error("Please provide a function to tidy()");n=e}else{if(typeof e!="string"&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if(typeof n!="function")throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");s=e}let r;return this.scopedRun(()=>this.startScope(s),()=>this.endScope(r),()=>(r=n(),r instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),r))}scopedRun(e,n,s){e();try{const r=s();return n(),r}catch(r){throw n(),r}}nextTensorId(){return tg.nextTensorId++}nextVariableId(){return tg.nextVariableId++}clone(e){const n=ye.runKernel(xp,{x:e}),s={x:e},r=a=>({x:()=>{const i="float32",l={x:a},u={dtype:i};return ye.runKernel(cp,l,u)}}),o=[];return this.addTapeNode(this.state.activeScope.name,s,[n],r,o,{}),n}runKernel(e,n,s){if(this.backendName==null&&this.backend,!(Zy(e,this.backendName)!=null))throw new Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:e,inputs:n,attrs:s})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,n,s){const r=this.backend.numDataIds();let o=0;s.forEach(l=>{o+=l.dtype==="complex64"?3:1});const a=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],i=r-n-o-a;if(i>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${i} data ids) after running '${e}'`)}runKernelFunc(e){let n,s=[];const r=this.isTapeOn(),o=this.state.numBytes,a=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);let i;this.backendName==null&&this.backend;let l;const u=m$(e)?e.kernelName:this.state.activeScope!=null?this.state.activeScope.name:"";if(m$(e)){const{kernelName:p,inputs:m,attrs:g}=e;this.backendName==null&&this.backend;const y=Zy(p,this.backendName);q(y!=null,()=>`Cannot find registered kernel '${p}' for backend '${this.backendName}'`),i=()=>{const w=this.backend.numDataIds();l=y.kernelFunc({inputs:m,attrs:g,backend:this.backend});const b=Array.isArray(l)?l:[l];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(p,w,b);const _=b.map($=>$.rank!=null?$:this.makeTensorFromTensorInfo($));if(r){const $=this.getTensorsForGradient(p,m,_);s=this.saveTensorsForBackwardMode($)}return _}}else{const{forwardFunc:p}=e,m=g=>{!r||(s=g.map(y=>this.keep(this.clone(y))))};i=()=>{const g=this.backend.numDataIds();l=this.tidy(()=>p(this.backend,m));const y=Array.isArray(l)?l:[l];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(u,g,y),y}}const{inputs:c,attrs:d}=e,f=m$(e)?null:e.backwardsFunc;let h;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{!this.ENV.getBool("DEBUG")&&!this.state.profiling?n=i():(h=this.profiler.profileKernel(u,c,()=>i()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(h),n=h.outputs)}),r&&this.addTapeNode(u,c,n,f,s,d),this.state.profiling&&this.state.activeProfile.kernels.push({name:u,bytesAdded:this.state.numBytes-o,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-a,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(c).map(p=>c[p]!=null?c[p].shape:null),outputShapes:n.map(p=>p.shape),kernelTimeMs:h.timeMs,extraInfo:h.extraInfo}),Array.isArray(l)?n:n[0]}saveTensorsForBackwardMode(e){return e.map(s=>this.keep(this.clone(s)))}getTensorsForGradient(e,n,s){const r=ux(e);if(r!=null){const o=r.inputsToSave||[],a=r.outputsToSave||[];let i;r.saveAllInputs?(q(Array.isArray(n),()=>"saveAllInputs is true, expected inputs to be an array."),i=Object.keys(n).map(u=>n[u])):i=o.map(u=>n[u]);const l=s.filter((u,c)=>a[c]);return i.concat(l)}return[]}makeTensor(e,n,s,r){if(e==null)throw new Error("Values passed to engine.makeTensor() are null");s=s||"float32",r=r||this.backend;let o=e;s==="string"&&ki(e[0])&&(o=e.map(l=>Oi(l)));const a=r.write(o,n,s),i=new $n(n,s,a,this.nextTensorId());if(this.trackTensor(i,r),s==="string"){const l=this.state.tensorInfo.get(a),u=$B(o);this.state.numBytes+=u-l.bytes,l.bytes=u}return i}makeTensorFromDataId(e,n,s,r){s=s||"float32";const o={dataId:e,shape:n,dtype:s};return this.makeTensorFromTensorInfo(o,r)}makeTensorFromTensorInfo(e,n){const{dataId:s,shape:r,dtype:o}=e,a=new $n(r,o,s,this.nextTensorId());return this.trackTensor(a,n),a}makeVariable(e,n=!0,s,r){s=s||this.nextVariableId().toString(),r!=null&&r!==e.dtype&&(e=e.cast(r));const o=new eg(e,n,s,this.nextTensorId());if(this.state.registeredVariables[o.name]!=null)throw new Error(`Variable with name ${o.name} was already registered`);return this.state.registeredVariables[o.name]=o,this.incRef(o,this.backend),o}trackTensor(e,n){this.state.numTensors++,e.dtype==="string"&&this.state.numStringTensors++;let s=0;e.dtype!=="complex64"&&e.dtype!=="string"&&(s=e.size*Gy(e.dtype)),this.state.numBytes+=s,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:n||this.backend,dtype:e.dtype,shape:e.shape,bytes:s})),e instanceof eg||this.track(e)}incRef(e,n){this.trackTensor(e,n),this.backend.incRef(e.dataId)}removeDataId(e,n){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===n&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;const n=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,e.dtype==="string"&&(this.state.numStringTensors--,this.state.numBytes-=n.bytes),e.dtype!=="complex64"&&e.dtype!=="string"){const s=e.size*Gy(e.dtype);this.state.numBytes-=s}n.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,n.backend)}disposeVariables(){for(const e in this.state.registeredVariables){const n=this.state.registeredVariables[e];this.disposeVariable(n)}}disposeVariable(e){this.disposeTensor(e),this.state.registeredVariables[e.name]!=null&&delete this.state.registeredVariables[e.name]}memory(){const e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,e.reasons==null&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}async profile(e){this.state.profiling=!0;const n=this.state.numBytes,s=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await e(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(r=>r.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-n,this.state.activeProfile.newTensors=this.state.numTensors-s;for(const r of this.state.activeProfile.kernels)r.kernelTimeMs=await r.kernelTimeMs,r.extraInfo=await r.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(e,n,s,r,o,a){const i={id:this.state.nextTapeNodeId++,kernelName:e,inputs:n,outputs:s,saved:o},l=ux(e);l!=null&&(r=l.gradFunc),r!=null&&(i.gradient=u=>(u=u.map((c,d)=>{if(c==null){const f=s[d],h=or(f.size,f.dtype);return this.makeTensor(h,f.shape,f.dtype)}return c}),r(u.length>1?u:u[0],o,a))),this.state.activeTape.push(i)}keep(e){return e.kept=!0,e}startTape(){this.state.gradientDepth===0&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){const n={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(n.name=e),this.state.scopeStack.push(n),this.state.activeScope=n}endScope(e){const n=Il(e),s=new Set(n.map(o=>o.id));for(let o=0;o<this.state.activeScope.track.length;o++){const a=this.state.activeScope.track[o];!a.kept&&!s.has(a.id)&&a.dispose()}const r=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1],n.forEach(o=>{!o.kept&&o.scopeId===r.id&&this.track(o)})}gradients(e,n,s,r=!1){if(q(n.length>0,()=>"gradients() received an empty list of xs."),s!=null&&s.dtype!=="float32")throw new Error(`dy must have 'float32' dtype, but has '${s.dtype}'`);const o=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",e));q(o instanceof $n,()=>"The result y returned by f() must be a tensor.");const a=Lst(this.state.activeTape,n,o);if(!r&&a.length===0&&n.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{const i={};i[o.id]=s??Kst(o.shape),zst(i,a,u=>this.tidy(u),qst);const l=n.map(u=>i[u.id]);return this.state.gradientDepth===0&&(this.state.activeTape.forEach(u=>{for(const c of u.saved)c.dispose()}),this.state.activeTape=null),{value:o,grads:l}})}customGrad(e){return q(Xu(e),()=>"The f passed in customGrad(f) must be a function."),(...n)=>{q(n.every(i=>i instanceof $n),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");let s;const r={};n.forEach((i,l)=>{r[l]=i});const o=(i,l)=>(s=e(...n,l),q(s.value instanceof $n,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),q(Xu(s.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),s.value),a=(i,l)=>{const u=s.gradFunc(i,l),c=Array.isArray(u)?u:[u];q(c.length===n.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),q(c.every(f=>f instanceof $n),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const d={};return c.forEach((f,h)=>{d[h]=()=>f}),d};return this.runKernelFunc({forwardFunc:o,backwardsFunc:a,inputs:r})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}readToGPU(e,n){return this.state.tensorInfo.get(e).backend.readToGPU(e,n)}async time(e){const n=Ys(),s=await this.backend.time(e);return s.wallMs=Ys()-n,s}track(e){return this.state.activeScope!=null&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new WR;for(const e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}};tg.nextTensorId=0;tg.nextVariableId=0;function Kst(t){const e=Ew(Ge(t),"float32");return ye.makeTensor(e,t,"float32")}function HB(){const t=kB();if(t._tfengine==null){const e=new CB(t);t._tfengine=new tg(e)}return yst(t._tfengine.ENV),Hst(()=>t._tfengine),t._tfengine}const ye=HB();function qst(t,e){const n={a:t,b:e};return ye.runKernel(nf,n)}function Xst(){return typeof navigator<"u"&&navigator!=null}let vx;function Yst(t){vx=t}function qk(t){if(vx!==void 0)return vx;if(t||Xst()){if(t||(t=navigator),t.product==="ReactNative")return!0;const e=t.userAgent||t.vendor||(typeof window<"u"?window.opera:"");if(!e){const n=t;return n.userAgentData&&n.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(e)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(e.substr(0,4))}return!1}function Xk(){return typeof window<"u"&&window.document!=null||typeof WorkerGlobalScope<"u"}const Zst=Object.freeze(Object.defineProperty({__proto__:null,mockIsMobile:Yst,isMobile:qk,isBrowser:Xk},Symbol.toStringTag,{value:"Module"}));const qo=Be();qo.registerFlag("DEBUG",()=>!1,t=>{t&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")});qo.registerFlag("IS_BROWSER",()=>Xk());qo.registerFlag("IS_NODE",()=>typeof process<"u"&&typeof process.versions<"u"&&typeof process.versions.node<"u");qo.registerFlag("IS_CHROME",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor));qo.registerFlag("PROD",()=>!1);qo.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>qo.getBool("DEBUG"));qo.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0);qo.registerFlag("IS_TEST",()=>!1);qo.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>!0);qo.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1);qo.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>!1);qo.registerFlag("USE_SETTIMEOUTCUSTOM",()=>!1);function Vi(t,e){let n=t;if(Zs(t))return e==="string"?[]:[t.length];if(typeof t=="object"&&"texture"in t){const r=t.channels||"RGBA";return[t.height,t.width*r.length]}if(!Array.isArray(t))return[];const s=[];for(;Array.isArray(n)||Zs(n)&&e!=="string";)s.push(n.length),n=n[0];return Array.isArray(t)&&Be().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&WB(t,s,[]),s}function WB(t,e,n){if(n=n||[],!Array.isArray(t)&&!Zs(t)){q(e.length===0,()=>`Element arr[${n.join("][")}] is a primitive, but should be an array/TypedArray of ${e[0]} elements`);return}q(e.length>0,()=>`Element arr[${n.join("][")}] should be a primitive, but is an array of ${t.length} elements`),q(t.length===e[0],()=>`Element arr[${n.join("][")}] should have ${e[0]} elements, but has ${t.length} elements`);const s=e.slice(1);for(let r=0;r<t.length;++r)WB(t[r],s,n.concat(r))}function UR(t,e,n,s){if(t!=="string_or_numeric"){if(t==null)throw new Error("Expected dtype cannot be null.");if(t!=="numeric"&&t!==e||t==="numeric"&&e==="string")throw new Error(`Argument '${n}' passed to '${s}' must be ${t} tensor, but got ${e} tensor`)}}function te(t,e,n,s="numeric"){if(t instanceof $n)return UR(s,t.dtype,e,n),t;let r=np(t);if(r!=="string"&&["bool","int32","float32"].indexOf(s)>=0&&(r=s),UR(s,r,e,n),t==null||!Zs(t)&&!Array.isArray(t)&&typeof t!="number"&&typeof t!="boolean"&&typeof t!="string"){const l=t==null?"null":t.constructor.name;throw new Error(`Argument '${e}' passed to '${n}' must be a Tensor or TensorLike, but got '${l}'`)}const o=Vi(t,r);!Zs(t)&&!Array.isArray(t)&&(t=[t]);const i=r!=="string"?dc(t,r):Tl(t,[],!0);return ye.makeTensor(i,o,r)}function ng(t,e,n,s="numeric"){if(!Array.isArray(t))throw new Error(`Argument ${e} passed to ${n} must be a \`Tensor[]\` or \`TensorLike[]\``);return t.map((o,a)=>te(o,`${e}[${a}]`,n,s))}const Yk="__op";function be(t){const e=Object.keys(t);if(e.length!==1)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${e.length} keys.`);let n=e[0];const s=t[n];n.endsWith("_")&&(n=n.substring(0,n.length-1)),n=n+Yk;const r=(...o)=>{ye.startScope(n);try{const a=s(...o);return Yu(a)&&console.error("Cannot return a Promise inside of tidy."),ye.endScope(a),a}catch(a){throw ye.endScope(null),a}};return Object.defineProperty(r,"name",{value:n,configurable:!0}),r}function Jst(t,e){const n=te(t,"real","complex"),s=te(e,"imag","complex");lr(n.shape,s.shape,`real and imag shapes, ${n.shape} and ${s.shape}, must match in call to tf.complex().`);const r={real:n,imag:s};return ye.runKernel(Pw,r)}const El=be({complex_:Jst});function fc(t,e,n,s){if(s==null&&(s=np(t)),s==="complex64")throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(typeof t=="object"&&"texture"in t){if(s!=="float32"&&s!=="int32")throw new Error(`Creating tensor from texture only supports 'float32'|'int32' dtype, while the dtype is ${s}.`);return t.channels=t.channels||"RGBA",ye.backend.createTensorFromTexture(t,e||n,s)}if(!Zs(t)&&!Array.isArray(t)&&typeof t!="number"&&typeof t!="boolean"&&typeof t!="string")throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(e!=null){Io(e);const r=Ge(e),o=Ge(n);q(r===o,()=>`Based on the provided shape, [${e}], the tensor should have ${r} values but has ${o}`);for(let a=0;a<n.length;++a){const i=n[a],l=a===n.length-1?i!==Ge(e.slice(a)):!0;q(n[a]===e[a]||!l,()=>`Error creating a new Tensor. Inferred shape (${n}) does not match the provided shape (${e}). `)}}return!Zs(t)&&!Array.isArray(t)&&(t=[t]),e=e||n,t=s!=="string"?dc(t,s):Tl(t,[],!0),ye.makeTensor(t,e,s)}function yo(t,e,n){const s=Vi(t,n);return fc(t,e,s,n)}const yx={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};const tb=4;async function bx(t,e){const n=[],s=[],r=Array.isArray(t)?t.map(a=>a.name):Object.keys(t);for(let a=0;a<r.length;++a){const i=r[a],l=Array.isArray(t)?t[a].tensor:t[i];if(l.dtype!=="float32"&&l.dtype!=="int32"&&l.dtype!=="bool"&&l.dtype!=="string"&&l.dtype!=="complex64")throw new Error(`Unsupported dtype in weight '${i}': ${l.dtype}`);const u={name:i,shape:l.shape,dtype:l.dtype};if(l.dtype==="string"){const c=new Promise(async d=>{const f=await l.bytes(),h=f.reduce((g,y)=>g+y.length,0)+tb*f.length,p=new Uint8Array(h);let m=0;for(let g=0;g<f.length;g++){const y=f[g],w=new Uint8Array(new Uint32Array([y.length]).buffer);p.set(w,m),m+=tb,p.set(y,m),m+=y.length}d(p)});s.push(c)}else s.push(l.data());e!=null&&(u.group=e),n.push(u)}const o=await Promise.all(s);return{data:Qst(o),specs:n}}function Zk(t,e){const n={};let s,r=0;for(const o of e){const a=o.name,i=o.dtype,l=o.shape,u=Ge(l);let c;if("quantization"in o){const d=o.quantization;if(d.dtype==="uint8"||d.dtype==="uint16"){if(!("min"in d&&"scale"in d))throw new Error(`Weight ${o.name} with quantization ${d.dtype} doesn't have corresponding metadata min and scale.`)}else if(d.dtype==="float16"){if(i!=="float32")throw new Error(`Weight ${o.name} is quantized with ${d.dtype} which only supports weights of type float32 not ${i}.`)}else throw new Error(`Weight ${o.name} has unknown quantization dtype ${d.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);const f=yx[d.dtype],h=t.slice(r,r+u*f),p=d.dtype==="uint8"?new Uint8Array(h):new Uint16Array(h);if(i==="float32")if(d.dtype==="uint8"||d.dtype==="uint16"){c=new Float32Array(p.length);for(let m=0;m<p.length;m++){const g=p[m];c[m]=g*d.scale+d.min}}else if(d.dtype==="float16")s===void 0&&(s=ort()),c=s(p);else throw new Error(`Unsupported quantization type ${d.dtype} for weight type float32.`);else if(i==="int32"){if(d.dtype!=="uint8"&&d.dtype!=="uint16")throw new Error(`Unsupported quantization type ${d.dtype} for weight type int32.`);c=new Int32Array(p.length);for(let m=0;m<p.length;m++){const g=p[m];c[m]=Math.round(g*d.scale+d.min)}}else throw new Error(`Unsupported dtype in weight '${a}': ${i}`);r+=u*f}else if(i==="string"){const d=Ge(o.shape);c=[];for(let f=0;f<d;f++){const h=new Uint32Array(t.slice(r,r+tb))[0];r+=tb;const p=new Uint8Array(t.slice(r,r+h));c.push(p),r+=h}}else{const d=yx[i],f=t.slice(r,r+u*d);if(i==="float32")c=new Float32Array(f);else if(i==="int32")c=new Int32Array(f);else if(i==="bool")c=new Uint8Array(f);else if(i==="complex64"){c=new Float32Array(f);const h=new Float32Array(c.length/2),p=new Float32Array(c.length/2);for(let y=0;y<h.length;y++)h[y]=c[y*2],p[y]=c[y*2+1];const m=yo(h,l,"float32"),g=yo(p,l,"float32");n[a]=El(m,g),m.dispose(),g.dispose()}else throw new Error(`Unsupported dtype in weight '${a}': ${i}`);r+=u*d}i!=="complex64"&&(n[a]=yo(c,l,i))}return n}function Qst(t){if(t===null)throw new Error(`Invalid input value: ${JSON.stringify(t)}`);let e=0;const n=[];t.forEach(o=>{if(e+=o.byteLength,n.push(o.byteLength===o.buffer.byteLength?o:new o.constructor(o)),!(o instanceof Float32Array||o instanceof Int32Array||o instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${o.constructor.name}`)});const s=new Uint8Array(e);let r=0;return n.forEach(o=>{s.set(new Uint8Array(o.buffer),r),r+=o.byteLength}),s.buffer}const Jk=typeof Buffer<"u"&&(typeof Blob>"u"||typeof atob>"u"||typeof btoa>"u");function GR(t){return Jk?Buffer.byteLength(t):new Blob([t]).size}function ert(t){if(Jk)return Buffer.from(t).toString("base64");const e=new Uint8Array(t);let n="";for(let s=0,r=e.length;s<r;s++)n+=String.fromCharCode(e[s]);return btoa(n)}function trt(t){if(Jk){const s=Buffer.from(t,"base64");return s.buffer.slice(s.byteOffset,s.byteOffset+s.byteLength)}const e=atob(t),n=new Uint8Array(e.length);for(let s=0;s<e.length;++s)n.set([e.charCodeAt(s)],s);return n.buffer}function P_(t){if(t.length===1)return t[0];let e=0;t.forEach(r=>{e+=r.byteLength});const n=new Uint8Array(e);let s=0;return t.forEach(r=>{n.set(new Uint8Array(r),s),s+=r.byteLength}),n.buffer}function jR(t){const e="/";for(t=t.trim();t.endsWith(e);)t=t.slice(0,t.length-1);const n=t.split(e);return n[n.length-1]}function UB(t,e){const n={modelTopology:t.modelTopology,format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy,weightsManifest:e};return t.signature!=null&&(n.signature=t.signature),t.userDefinedMetadata!=null&&(n.userDefinedMetadata=t.userDefinedMetadata),t.modelInitializer!=null&&(n.modelInitializer=t.modelInitializer),t.initializerSignature!=null&&(n.initializerSignature=t.initializerSignature),t.trainingConfig!=null&&(n.trainingConfig=t.trainingConfig),n}function Qk(t,e,n){const s={modelTopology:t.modelTopology,format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy};if(t.trainingConfig!=null&&(s.trainingConfig=t.trainingConfig),t.weightsManifest!=null){if(!e)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!n)throw new Error("modelJSON has weightsManifest but weightData is null");s.weightSpecs=e,s.weightData=n}return t.signature!=null&&(s.signature=t.signature),t.userDefinedMetadata!=null&&(s.userDefinedMetadata=t.userDefinedMetadata),t.modelInitializer!=null&&(s.modelInitializer=t.modelInitializer),t.initializerSignature!=null&&(s.initializerSignature=t.initializerSignature),s}async function e8(t,e){let n,s;return t.weightsManifest!=null&&([n,s]=await e(t.weightsManifest)),Qk(t,n,s)}function W1(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:t.modelTopology==null?0:GR(JSON.stringify(t.modelTopology)),weightSpecsBytes:t.weightSpecs==null?0:GR(JSON.stringify(t.weightSpecs)),weightDataBytes:t.weightData==null?0:t.weightData.byteLength}}function t8(t){const e=[];for(const n of t)e.push(...n.weights);return e}function nrt(){const t=n=>{let s=n<<13,r=0;for(;(s&8388608)===0;)r-=8388608,s<<=1;return s&=-8388609,r+=947912704,s|r},e=new Uint32Array(2048);e[0]=0;for(let n=1;n<1024;n++)e[n]=t(n);for(let n=1024;n<2048;n++)e[n]=939524096+(n-1024<<13);return e}function srt(){const t=new Uint32Array(64);t[0]=0,t[31]=1199570944,t[32]=2147483648,t[63]=3347054592;for(let e=1;e<31;e++)t[e]=e<<23;for(let e=33;e<63;e++)t[e]=2147483648+(e-32<<23);return t}function rrt(){const t=new Uint32Array(64);for(let e=0;e<64;e++)t[e]=1024;return t[0]=t[32]=0,t}function ort(){const t=nrt(),e=srt(),n=rrt();return s=>{const r=new ArrayBuffer(4*s.length),o=new Uint32Array(r);for(let a=0;a<s.length;a++){const i=s[a],l=t[n[i>>10]+(i&1023)]+e[i>>10];o[a]=l}return new Float32Array(r)}}let ps=class{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return ps.instance==null&&(ps.instance=new ps),ps.instance}static registerSaveRouter(e){ps.getInstance().saveRouters.push(e)}static registerLoadRouter(e){ps.getInstance().loadRouters.push(e)}static getSaveHandlers(e){return ps.getHandlers(e,"save")}static getLoadHandlers(e,n){return ps.getHandlers(e,"load",n)}static getHandlers(e,n,s){const r=[];return(n==="load"?ps.getInstance().loadRouters:ps.getInstance().saveRouters).forEach(a=>{const i=a(e,s);i!==null&&r.push(i)}),r}};const art=t=>ps.registerSaveRouter(t),irt=t=>ps.registerLoadRouter(t),GB=t=>ps.getSaveHandlers(t),jB=(t,e)=>ps.getLoadHandlers(t,e);const wx="tensorflowjs",_x=1,Qc="models_store",Cu="model_info_store";function KB(){if(!Be().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const t=typeof window>"u"?self:window,e=t.indexedDB||t.mozIndexedDB||t.webkitIndexedDB||t.msIndexedDB||t.shimIndexedDB;if(e==null)throw new Error("The current browser does not appear to support IndexedDB.");return e}function $x(t){const e=t.result;e.createObjectStore(Qc,{keyPath:"modelPath"}),e.createObjectStore(Cu,{keyPath:"modelPath"})}let Id=class{constructor(e){if(this.indexedDB=KB(),e==null||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,e)}async load(){return this.databaseAction(this.modelPath)}databaseAction(e,n){return new Promise((s,r)=>{const o=this.indexedDB.open(wx,_x);o.onupgradeneeded=()=>$x(o),o.onsuccess=()=>{const a=o.result;if(n==null){const i=a.transaction(Qc,"readonly"),u=i.objectStore(Qc).get(this.modelPath);u.onsuccess=()=>{if(u.result==null)return a.close(),r(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));s(u.result.modelArtifacts)},u.onerror=c=>(a.close(),r(u.error)),i.oncomplete=()=>a.close()}else{const i=W1(n),l=a.transaction(Cu,"readwrite");let u=l.objectStore(Cu);const c=u.put({modelPath:this.modelPath,modelArtifactsInfo:i});let d;c.onsuccess=()=>{d=a.transaction(Qc,"readwrite");const h=d.objectStore(Qc).put({modelPath:this.modelPath,modelArtifacts:n,modelArtifactsInfo:i});h.onsuccess=()=>s({modelArtifactsInfo:i}),h.onerror=p=>{u=l.objectStore(Cu);const m=u.delete(this.modelPath);m.onsuccess=()=>(a.close(),r(h.error)),m.onerror=g=>(a.close(),r(h.error))}},c.onerror=f=>(a.close(),r(c.error)),l.oncomplete=()=>{d==null?a.close():d.oncomplete=()=>a.close()}}},o.onerror=a=>r(o.error)})}};Id.URL_SCHEME="indexeddb://";const qB=t=>Be().getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(Id.URL_SCHEME)?lrt(t.slice(Id.URL_SCHEME.length)):null;ps.registerSaveRouter(qB);ps.registerLoadRouter(qB);function lrt(t){return new Id(t)}function urt(t){return t.startsWith(Id.URL_SCHEME)?t.slice(Id.URL_SCHEME.length):t}let crt=class{constructor(){this.indexedDB=KB()}async listModels(){return new Promise((e,n)=>{const s=this.indexedDB.open(wx,_x);s.onupgradeneeded=()=>$x(s),s.onsuccess=()=>{const r=s.result,o=r.transaction(Cu,"readonly"),i=o.objectStore(Cu).getAll();i.onsuccess=()=>{const l={};for(const u of i.result)l[u.modelPath]=u.modelArtifactsInfo;e(l)},i.onerror=l=>(r.close(),n(i.error)),o.oncomplete=()=>r.close()},s.onerror=r=>n(s.error)})}async removeModel(e){return e=urt(e),new Promise((n,s)=>{const r=this.indexedDB.open(wx,_x);r.onupgradeneeded=()=>$x(r),r.onsuccess=()=>{const o=r.result,a=o.transaction(Cu,"readwrite"),i=a.objectStore(Cu),l=i.get(e);let u;l.onsuccess=()=>{if(l.result==null)return o.close(),s(new Error(`Cannot find model with path '${e}' in IndexedDB.`));{const c=i.delete(e),d=()=>{u=o.transaction(Qc,"readwrite");const h=u.objectStore(Qc).delete(e);h.onsuccess=()=>n(l.result.modelArtifactsInfo),h.onerror=p=>s(l.error)};c.onsuccess=d,c.onerror=f=>(d(),o.close(),s(l.error))}},l.onerror=c=>(o.close(),s(l.error)),a.oncomplete=()=>{u==null?o.close():u.oncomplete=()=>o.close()}},r.onerror=o=>s(r.error)})}};const pl="/",Af="tensorflowjs_models",XB="info",drt="model_topology",frt="weight_specs",hrt="weight_data",prt="model_metadata";function YB(t){return{info:[Af,t,XB].join(pl),topology:[Af,t,drt].join(pl),weightSpecs:[Af,t,frt].join(pl),weightData:[Af,t,hrt].join(pl),modelMetadata:[Af,t,prt].join(pl)}}function ZB(t){for(const e of Object.values(t))window.localStorage.removeItem(e)}function mrt(t){const e=t.split(pl);if(e.length<3)throw new Error(`Invalid key format: ${t}`);return e.slice(1,e.length-1).join(pl)}function grt(t){return t.startsWith(Ed.URL_SCHEME)?t.slice(Ed.URL_SCHEME.length):t}let Ed=class{constructor(e){if(!Be().getBool("IS_BROWSER")||typeof window>"u"||typeof window.localStorage>"u")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,e==null||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=YB(this.modelPath)}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const n=JSON.stringify(e.modelTopology),s=JSON.stringify(e.weightSpecs),r=W1(e);try{this.LS.setItem(this.keys.info,JSON.stringify(r)),this.LS.setItem(this.keys.topology,n),this.LS.setItem(this.keys.weightSpecs,s),this.LS.setItem(this.keys.weightData,ert(e.weightData));const o={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:e.signature!=null?e.signature:void 0,userDefinedMetadata:e.userDefinedMetadata!=null?e.userDefinedMetadata:void 0,modelInitializer:e.modelInitializer!=null?e.modelInitializer:void 0,initializerSignature:e.initializerSignature!=null?e.initializerSignature:void 0,trainingConfig:e.trainingConfig!=null?e.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(o)),{modelArtifactsInfo:r}}catch{throw ZB(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${r.modelTopologyBytes}, weightSpecsBytes=${r.weightSpecsBytes}, weightDataBytes=${r.weightDataBytes}.`)}}}async load(){const e=JSON.parse(this.LS.getItem(this.keys.info));if(e==null)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if(e.modelTopologyType!=="JSON")throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const n={},s=JSON.parse(this.LS.getItem(this.keys.topology));if(s==null)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);n.modelTopology=s;const r=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(r==null)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);n.weightSpecs=r;const o=this.LS.getItem(this.keys.modelMetadata);if(o!=null){const i=JSON.parse(o);n.format=i.format,n.generatedBy=i.generatedBy,n.convertedBy=i.convertedBy,i.signature!=null&&(n.signature=i.signature),i.userDefinedMetadata!=null&&(n.userDefinedMetadata=i.userDefinedMetadata),i.modelInitializer!=null&&(n.modelInitializer=i.modelInitializer),i.initializerSignature!=null&&(n.initializerSignature=i.initializerSignature),i.trainingConfig!=null&&(n.trainingConfig=i.trainingConfig)}const a=this.LS.getItem(this.keys.weightData);if(a==null)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return n.weightData=trt(a),n}};Ed.URL_SCHEME="localstorage://";const JB=t=>Be().getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(Ed.URL_SCHEME)?vrt(t.slice(Ed.URL_SCHEME.length)):null;ps.registerSaveRouter(JB);ps.registerLoadRouter(JB);function vrt(t){return new Ed(t)}let yrt=class{constructor(){q(Be().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),q(typeof window>"u"||typeof window.localStorage<"u",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){const e={},n=Af+pl,s=pl+XB;for(let r=0;r<this.LS.length;++r){const o=this.LS.key(r);if(o.startsWith(n)&&o.endsWith(s)){const a=mrt(o);e[a]=JSON.parse(this.LS.getItem(o))}}return e}async removeModel(e){e=grt(e);const n=YB(e);if(this.LS.getItem(n.info)==null)throw new Error(`Cannot find model at path '${e}'`);const s=JSON.parse(this.LS.getItem(n.info));return ZB(n),s}};const Yf="://";let Wr=class{constructor(){this.managers={}}static getInstance(){return Wr.instance==null&&(Wr.instance=new Wr),Wr.instance}static registerManager(e,n){q(e!=null,()=>"scheme must not be undefined or null."),e.endsWith(Yf)&&(e=e.slice(0,e.indexOf(Yf))),q(e.length>0,()=>"scheme must not be an empty string.");const s=Wr.getInstance();q(s.managers[e]==null,()=>`A model store manager is already registered for scheme '${e}'.`),s.managers[e]=n}static getManager(e){const n=Wr.getInstance().managers[e];if(n==null)throw new Error(`Cannot find model manager for scheme '${e}'`);return n}static getSchemes(){return Object.keys(Wr.getInstance().managers)}};function fy(t){if(t.indexOf(Yf)===-1)throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${Wr.getSchemes().join(",")}`);return{scheme:t.split(Yf)[0],path:t.split(Yf)[1]}}async function QB(t,e,n=!1){q(t!==e,()=>`Old path and new path are the same: '${t}'`);const s=ps.getLoadHandlers(t);q(s.length>0,()=>`Copying failed because no load handler is found for source URL ${t}.`),q(s.length<2,()=>`Copying failed because more than one (${s.length}) load handlers for source URL ${t}.`);const r=s[0],o=ps.getSaveHandlers(e);q(o.length>0,()=>`Copying failed because no save handler is found for destination URL ${e}.`),q(o.length<2,()=>`Copying failed because more than one (${s.length}) save handlers for destination URL ${e}.`);const a=o[0],i=fy(t).scheme,l=fy(t).path,u=i===fy(t).scheme,c=await r.load();n&&u&&await Wr.getManager(i).removeModel(l);const d=await a.save(c);return n&&!u&&await Wr.getManager(i).removeModel(l),d.modelArtifactsInfo}async function brt(){const t=Wr.getSchemes(),e={};for(const n of t){const s=await Wr.getManager(n).listModels();for(const r in s){const o=n+Yf+r;e[o]=s[r]}}return e}async function wrt(t){const e=fy(t);return Wr.getManager(e.scheme).removeModel(e.path)}async function _rt(t,e){return QB(t,e,!1)}async function $rt(t,e){return QB(t,e,!0)}let xrt=class{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(e,n){return fetch(e,n)}now(){return performance.now()}encode(e,n){if(n!=="utf-8"&&n!=="utf8")throw new Error(`Browser's encoder only supports utf-8, but got ${n}`);return this.textEncoder==null&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,n){return new TextDecoder(n).decode(e)}setTimeoutCustom(e,n){if(typeof window>"u"||!Be().getBool("USE_SETTIMEOUTCUSTOM")){setTimeout(e,n);return}this.functionRefs.push(e),setTimeout(()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")},n),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",s=>{if(s.source===window&&s.data.name===this.messageName){s.stopPropagation();const r=this.functionRefs[s.data.index];r(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0)}},!0))}};if(Be().get("IS_BROWSER")){Be().setPlatform("browser",new xrt);try{Wr.registerManager(Ed.URL_SCHEME,new yrt)}catch{}try{Wr.registerManager(Id.URL_SCHEME,new crt)}catch{}}const Srt={importFetch:()=>require("node-fetch")};let g$,Crt=class{constructor(){this.util=require("util"),this.textEncoder=new this.util.TextEncoder}fetch(e,n){return Be().global.fetch!=null?Be().global.fetch(e,n):(g$==null&&(g$=Srt.importFetch()),g$(e,n))}now(){const e=process.hrtime();return e[0]*1e3+e[1]/1e6}encode(e,n){if(n!=="utf-8"&&n!=="utf8")throw new Error(`Node built-in encoder only supports utf-8, but got ${n}`);return this.textEncoder.encode(e)}decode(e,n){return e.length===0?"":new this.util.TextDecoder(n).decode(e)}};Be().get("IS_NODE")&&!Be().get("IS_BROWSER")&&Be().setPlatform("node",new Crt);function tn(t,e="float32",n){return e=e||"float32",Io(t),new Ds(t,e,n)}function krt(t,e){const n=te(t,"x","cast");if(!_B(e))throw new Error(`Failed to cast to unknown dtype ${e}`);if(e==="string"&&n.dtype!=="string"||e!=="string"&&n.dtype==="string")throw new Error("Only strings can be casted to strings");const s={x:n},r={dtype:e};return ye.runKernel(cp,s,r)}const ht=be({cast_:krt});function Trt(t){const n={x:te(t,"x","clone","string_or_numeric")};return ye.runKernel(xp,n)}const Ri=be({clone_:Trt});function n8(t,e=!1){console.log(t.toString(e))}HB();const Nrt={buffer:tn,cast:ht,clone:Ri,print:n8};Wst(Nrt);const Irt="model",Ert=".json",Art=".weights.bin";function KR(t){return new Promise(e=>setTimeout(e)).then(t)}let xh=class{constructor(e){if(!Be().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");e.startsWith(xh.URL_SCHEME)&&(e=e.slice(xh.URL_SCHEME.length)),(e==null||e.length===0)&&(e=Irt),this.modelJsonFileName=e+Ert,this.weightDataFileName=e+Art}async save(e){if(typeof document>"u")throw new Error("Browser downloads are not supported in this environment since `document` is not present");const n=window.URL.createObjectURL(new Blob([e.weightData],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const s=[{paths:["./"+this.weightDataFileName],weights:e.weightSpecs}],r=UB(e,s),o=window.URL.createObjectURL(new Blob([JSON.stringify(r)],{type:"application/json"})),a=this.modelJsonAnchor==null?document.createElement("a"):this.modelJsonAnchor;if(a.download=this.modelJsonFileName,a.href=o,await KR(()=>a.dispatchEvent(new MouseEvent("click"))),e.weightData!=null){const i=this.weightDataAnchor==null?document.createElement("a"):this.weightDataAnchor;i.download=this.weightDataFileName,i.href=n,await KR(()=>i.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:W1(e)}}}};xh.URL_SCHEME="downloads://";let Ort=class{constructor(e){if(e==null||e.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${e}`);this.jsonFile=e[0],this.weightsFiles=e.slice(1)}async load(){return new Promise((e,n)=>{const s=new FileReader;s.onload=r=>{const o=JSON.parse(r.target.result),a=o.modelTopology;if(a==null){n(new Error(`modelTopology field is missing from file ${this.jsonFile.name}`));return}if(o.weightsManifest==null){n(new Error(`weightManifest field is missing from file ${this.jsonFile.name}`));return}if(this.weightsFiles.length===0){e({modelTopology:a});return}const l=e8(o,u=>this.loadWeights(u));e(l)},s.onerror=r=>n(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),s.readAsText(this.jsonFile)})}loadWeights(e){const n=[],s=[];for(const a of e)n.push(...a.weights),s.push(...a.paths);const r=this.checkManifestAndWeightFiles(e),o=s.map(a=>this.loadWeightsFile(a,r[a]));return Promise.all(o).then(a=>[n,P_(a)])}loadWeightsFile(e,n){return new Promise((s,r)=>{const o=new FileReader;o.onload=a=>{const i=a.target.result;s(i)},o.onerror=a=>r(`Failed to weights data from file of path '${e}'.`),o.readAsArrayBuffer(n)})}checkManifestAndWeightFiles(e){const n=[],s=this.weightsFiles.map(o=>jR(o.name)),r={};for(const o of e)o.paths.forEach(a=>{const i=jR(a);if(n.indexOf(i)!==-1)throw new Error(`Duplicate file basename found in weights manifest: '${i}'`);if(n.push(i),s.indexOf(i)===-1)throw new Error(`Weight file with basename '${i}' is not provided.`);r[a]=this.weightsFiles[s.indexOf(i)]});if(n.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${n.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return r}};const Rrt=t=>Be().getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(xh.URL_SCHEME)?Drt(t.slice(xh.URL_SCHEME.length)):null;ps.registerSaveRouter(Rrt);function Drt(t="model"){return new xh(t)}function Frt(t){return new Ort(t)}function qR(t,e,n,s){a(t),n=n??0,s=s??1,i(n,s);let r=0;const o=l=>(l.then(u=>{const c=n+ ++r/t.length*(s-n);return e(c),u}),l);function a(l){q(l!=null&&Array.isArray(l)&&l.length>0,()=>"promises must be a none empty array")}function i(l,u){q(l>=0&&l<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${l}`),q(u>=0&&u<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${u}`),q(u>=l,()=>`startFraction must be no more than endFraction, but got startFraction ${l} and endFraction ${u}`)}return Promise.all(t.map(o))}async function eV(t,e){e==null&&(e={});const n=e.fetchFunc==null?Be().platform.fetch:e.fetchFunc,s=t.map(d=>n(d,e.requestInit,{isBinary:!0})),r=0,o=.5,i=(e.onProgress==null?await Promise.all(s):await qR(s,e.onProgress,r,o)).map(d=>d.arrayBuffer()),l=.5,u=1;return e.onProgress==null?await Promise.all(i):await qR(i,e.onProgress,l,u)}async function tV(t,e="",n,s){return nV(a=>eV(a,{requestInit:s}))(t,e,n)}function nV(t){return async(e,n="",s)=>{const r=e.map(()=>!1),o={},a=s!=null?s.map(()=>!1):[],i=[];if(e.forEach((h,p)=>{let m=0;h.weights.forEach(g=>{const y="quantization"in g?g.quantization.dtype:g.dtype,w=yx[y]*Ge(g.shape),b=()=>{r[p]=!0,o[p]==null&&(o[p]=[]),o[p].push({manifestEntry:g,groupOffset:m,sizeBytes:w})};s!=null?s.forEach((_,$)=>{_===g.name&&(b(),a[$]=!0)}):b(),i.push(g.name),m+=w})}),!a.every(h=>h)){const h=s.filter((p,m)=>!a[m]);throw new Error(`Could not find weights in manifest with names: ${h.join(", ")}. 
Manifest JSON has weights with names: ${i.join(", ")}.`)}const l=r.reduce((h,p,m)=>(p&&h.push(m),h),[]),u=[];l.forEach(h=>{e[h].paths.forEach(p=>{const m=n+(n.endsWith("/")?"":"/")+p;u.push(m)})});const c=await t(u),d={};let f=0;return l.forEach(h=>{const p=e[h].paths.length;let m=0;for(let _=0;_<p;_++)m+=c[f+_].byteLength;const g=new ArrayBuffer(m),y=new Uint8Array(g);let w=0;for(let _=0;_<p;_++){const $=new Uint8Array(c[f+_]);y.set($,w),w+=$.byteLength}o[h].forEach(_=>{const $=g.slice(_.groupOffset,_.groupOffset+_.sizeBytes),x=Zk($,[_.manifestEntry]);for(const k in x)d[k]=x[k]}),f+=p}),d}}const Mrt="application/octet-stream",Prt="application/json";let s8=class{constructor(e,n){if(this.DEFAULT_METHOD="POST",n==null&&(n={}),this.weightPathPrefix=n.weightPathPrefix,this.onProgress=n.onProgress,this.weightUrlConverter=n.weightUrlConverter,n.fetchFunc!=null?(q(typeof n.fetchFunc=="function",()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=n.fetchFunc):this.fetch=Be().platform.fetch,q(e!=null&&e.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(e)&&q(e.length===2,()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`),this.path=e,n.requestInit!=null&&n.requestInit.body!=null)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=n.requestInit||{}}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const n=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);n.body=new FormData;const s=[{paths:["./model.weights.bin"],weights:e.weightSpecs}],r=UB(e,s);n.body.append("model.json",new Blob([JSON.stringify(r)],{type:Prt}),"model.json"),e.weightData!=null&&n.body.append("model.weights.bin",new Blob([e.weightData],{type:Mrt}),"model.weights.bin");const o=await this.fetch(this.path,n);if(o.ok)return{modelArtifactsInfo:W1(e),responses:[o]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${o.status}.`)}async load(){const e=await this.fetch(this.path,this.requestInit);if(!e.ok)throw new Error(`Request to ${this.path} failed with status code ${e.status}. Please verify this URL points to the model JSON of the model to load.`);let n;try{n=await e.json()}catch{let a=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?a+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":a+=" Please make sure the server is serving valid JSON for this request.",new Error(a)}const s=n.modelTopology,r=n.weightsManifest;if(s==null&&r==null)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return e8(n,o=>this.loadWeights(o))}async loadWeights(e){const n=Array.isArray(this.path)?this.path[1]:this.path,[s,r]=Lrt(n),o=this.weightPathPrefix||s,a=t8(e),i=[],l=[];for(const c of e)for(const d of c.paths)this.weightUrlConverter!=null?l.push(this.weightUrlConverter(d)):i.push(o+d+r);this.weightUrlConverter&&i.push(...await Promise.all(l));const u=await eV(i,{requestInit:this.requestInit,fetchFunc:this.fetch,onProgress:this.onProgress});return[a,P_(u)]}};s8.URL_SCHEME_REGEX=/^https?:\/\//;function Lrt(t){const e=t.lastIndexOf("/"),n=t.lastIndexOf("?"),s=t.substring(0,e),r=n>e?t.substring(n):"";return[s+"/",r]}function xx(t){return t.match(s8.URL_SCHEME_REGEX)!=null}const sV=(t,e)=>{if(typeof fetch>"u"&&(e==null||e.fetchFunc==null))return null;{let n=!0;if(Array.isArray(t)?n=t.every(s=>xx(s)):n=xx(t),n)return r8(t,e)}return null};ps.registerSaveRouter(sV);ps.registerLoadRouter(sV);function r8(t,e){return new s8(t,e)}function rV(t,e){return r8(t,e)}let v$=class{constructor(e){this.modelArtifacts=e}load(){return this.modelArtifacts}},oV=class{constructor(e){this.saveHandler=e}save(e){return this.saveHandler(e)}},zrt=class{constructor(e){e.load&&(this.load=()=>Promise.resolve(e.load())),e.save&&(this.save=n=>Promise.resolve(e.save(n)))}};function Brt(t,e,n,s){const r=arguments;return new zrt(nb(...r))}function nb(t,e,n,s){return arguments.length===1?t.modelTopology!=null||t.weightSpecs!=null?new v$(t):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new v$({modelTopology:t})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new v$({modelTopology:t,weightSpecs:e,weightData:n,trainingConfig:s}))}function Vrt(t){return new oV(t)}function Hrt(t){return new oV(t)}const o8=Object.freeze(Object.defineProperty({__proto__:null,browserFiles:Frt,browserHTTPRequest:rV,concatenateArrayBuffers:P_,decodeWeights:Zk,encodeWeights:bx,fromMemory:Brt,fromMemorySync:nb,getLoadHandlers:jB,getModelArtifactsForJSON:e8,getModelArtifactsForJSONSync:Qk,getModelArtifactsInfoForJSON:W1,getSaveHandlers:GB,getWeightSpecs:t8,http:r8,isHTTPScheme:xx,loadWeights:tV,registerLoadRouter:irt,registerSaveRouter:art,weightsLoaderFactory:nV,withSaveHandler:Vrt,withSaveHandlerSync:Hrt,copyModel:_rt,listModels:brt,moveModel:$rt,removeModel:wrt},Symbol.toStringTag,{value:"Module"}));function Wrt(t,e,n=!1,s=!1){let r=te(t,"a","matMul"),o=te(e,"b","matMul");[r,o]=ds(r,o);const a={a:r,b:o},i={transposeA:n,transposeB:s};return ye.runKernel(Kg,a,i)}const ln=be({matMul_:Wrt});function Urt(t,e,n=1,s=0,r="int32"){if(e<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${e}`);const a={indices:te(t,"indices","oneHot","int32")},i={dtype:r,depth:e,onValue:n,offValue:s};return ye.runKernel(S1,a,i)}const Sh=be({oneHot_:Urt});function Grt(){Be().set("PROD",!0)}function jrt(){Be().set("DEBUG",!0)}function Krt(){Be().set("DEPRECATION_WARNINGS_ENABLED",!1),console.warn("TensorFlow.js deprecation warnings have been disabled.")}function qrt(t){Be().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(t+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")}function Xrt(){ye.disposeVariables()}function Ma(){return ye}function sb(){return ye.memory()}function Yrt(t){return ye.profile(t)}function Le(t,e){return ye.tidy(t,e)}function Xt(t){Il(t).forEach(n=>n.dispose())}function As(t){return ye.keep(t)}function Zrt(t){return ye.time(t)}function Jrt(t){return ye.setBackend(t)}function Qrt(){return ye.ready()}function eot(){return ye.backendName}function tot(t){ye.removeBackend(t)}function not(t){return ye.findBackend(t)}function sot(t){return ye.findBackendFactory(t)}function a8(t,e,n=1){return ye.registerBackend(t,e,n)}function aV(){return ye.backend}function rot(t,e){Be().setPlatform(t,e)}function oot(t){const n={input:te(t,"input","imag")};return ye.runKernel(t_,n)}const U1=be({imag_:oot});function aot(t){const n={x:te(t,"x","neg")};return ye.runKernel(_1,n)}const Jn=be({neg_:aot});function iot(t){const n={input:te(t,"input","real")};return ye.runKernel(m_,n)}const Ch=be({real_:iot});function lot(t,e,n){const s=te(t,"x","transpose");if(e==null&&(e=s.shape.map((a,i)=>i).reverse()),q(s.rank===e.length,()=>`Error in transpose: rank of input ${s.rank} must match length of perm ${e}.`),e.forEach(a=>{q(a>=0&&a<s.rank,()=>`All entries in 'perm' must be between 0 and ${s.rank-1} but got ${e}`)}),s.rank<=1)return s.clone();const r={x:s},o={perm:e};return s.dtype==="complex64"?Le(()=>{let a=Ch(s),i=U1(s);return a=ye.runKernel(ld,{x:a},o),i=ye.runKernel(ld,{x:i},o),n&&(i=Jn(i)),El(a,i)}):ye.runKernel(ld,r,o)}const dn=be({transpose_:lot});function uot(t,e,n){const s=te(t,"labels","confusionMatrix"),r=te(e,"predictions","confusionMatrix");q(n==null||n>0&&Number.isInteger(n),()=>`If provided, numClasses must be a positive integer, but got ${n}`),q(s.rank===1,()=>`Expected the rank of labels to be 1, but got ${s.rank}`),q(r.rank===1,()=>`Expected the rank of predictions to be 1, but got ${r.rank}`),q(s.shape[0]===r.shape[0],()=>`Mismatch in the number of examples: ${s.shape[0]} vs. ${r.shape[0]}. Labels and predictions should have the same number of elements.`),q(n>0&&Number.isInteger(n),()=>`numClasses is required to be a positive integer, but got ${n}`);const o=Sh(ht(s,"int32"),n),a=Sh(ht(r,"int32"),n),i=dn(o),l=ln(i,a);return ht(l,"int32")}const cot=be({confusionMatrix_:uot});const dot=Object.freeze(Object.defineProperty({__proto__:null,confusionMatrix:cot},Symbol.toStringTag,{value:"Module"}));function Ad(t,e){const n=t.length,s=[];for(let r=0;r<n;r++){const o=n-1-r,a=t[o]||1;(e[e.length-1-r]||1)>1&&a===1&&s.unshift(o)}return s}function Ts(t,e){const n=[];for(let s=0;s<e.length;s++){const r=t[t.length-s-1],o=e.length-s-1,a=e[o];(r==null||r===1&&a>1)&&n.unshift(o)}return n}function Zt(t,e){const n=[],s=Math.max(t.length,e.length);for(let r=0;r<s;r++){let o=t[t.length-r-1];o==null&&(o=1);let a=e[e.length-r-1];if(a==null&&(a=1),o===1)n.unshift(a);else if(a===1)n.unshift(o);else if(o!==a){const i=`Operands could not be broadcast together with shapes ${t} and ${e}.`;throw Error(i)}else n.unshift(o)}return n}const fot=Object.freeze(Object.defineProperty({__proto__:null,getBroadcastDims:Ad,getReductionAxes:Ts,assertAndGetBroadcastShape:Zt},Symbol.toStringTag,{value:"Module"}));function i8(t,e,n){if(ef(t),e!=null&&e.length!==3)throw new Error("tensor3d() requires shape to have three numbers");const s=Vi(t,n);if(s.length!==3&&s.length!==1)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(s.length===1&&e==null)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return fc(t,e,s,n)}let Nc;function iV(t,e=3){if(e>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(t==null)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let n=!1,s=!1,r=!1,o=!1,a=!1,i=!1;if(t.data instanceof Uint8Array)n=!0;else if(typeof ImageData<"u"&&t instanceof ImageData)s=!0;else if(typeof HTMLVideoElement<"u"&&t instanceof HTMLVideoElement)r=!0;else if(typeof HTMLImageElement<"u"&&t instanceof HTMLImageElement)o=!0;else if(t.getContext!=null)a=!0;else if(typeof ImageBitmap<"u"&&t instanceof ImageBitmap)i=!0;else throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${t.constructor.name}`);if(Zy(Yy,ye.backendName)!=null){const p={pixels:t},m={numChannels:e};return ye.runKernel(Yy,p,m)}const[u,c]=r?[t.videoWidth,t.videoHeight]:[t.width,t.height];let d;if(a)d=t.getContext("2d").getImageData(0,0,u,c).data;else if(s||n)d=t.data;else if(o||r||i){if(Nc==null)if(typeof document>"u")if(typeof OffscreenCanvas<"u"&&typeof OffscreenCanvasRenderingContext2D<"u")Nc=new OffscreenCanvas(1,1).getContext("2d");else throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");else Nc=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});Nc.canvas.width=u,Nc.canvas.height=c,Nc.drawImage(t,0,0,u,c),d=Nc.getImageData(0,0,u,c).data}let f;if(e===4)f=new Int32Array(d);else{const p=u*c;f=new Int32Array(p*e);for(let m=0;m<p;m++)for(let g=0;g<e;++g)f[m*e+g]=d[m*4+g]}return i8(f,[c,u,e],"int32")}function hot(t){return t!=null&&t.data instanceof Uint8Array}function pot(){return typeof window<"u"&&typeof ImageBitmap<"u"&&window.hasOwnProperty("createImageBitmap")}function mot(t){return t!=null&&t.width!==0&&t.height!==0}function got(t){return pot()&&!(t instanceof ImageBitmap)&&mot(t)&&!hot(t)}async function vot(t,e=3){let n=null;if(Be().getBool("WRAP_TO_IMAGEBITMAP")&&got(t)){let s;try{s=await createImageBitmap(t,{premultiplyAlpha:"none"})}catch{s=null}s!=null&&s.width===t.width&&s.height===t.height?n=s:n=t}else n=t;return iV(n,e)}async function yot(t,e){let n=te(t,"img","toPixels");if(!(t instanceof $n)){const u=n;n=ht(u,"int32"),u.dispose()}if(n.rank!==2&&n.rank!==3)throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${n.rank}.`);const[s,r]=n.shape.slice(0,2),o=n.rank===2?1:n.shape[2];if(o>4||o===2)throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${o}`);if(n.dtype!=="float32"&&n.dtype!=="int32")throw new Error(`Unsupported type for toPixels: ${n.dtype}. Please use float32 or int32 tensors.`);const a=await n.data(),i=n.dtype==="float32"?255:1,l=new Uint8ClampedArray(r*s*4);for(let u=0;u<s*r;++u){const c=[0,0,0,255];for(let f=0;f<o;f++){const h=a[u*o+f];if(n.dtype==="float32"){if(h<0||h>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${h}.`)}else if(n.dtype==="int32"&&(h<0||h>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${h}.`);o===1?(c[0]=h*i,c[1]=h*i,c[2]=h*i):c[f]=h*i}const d=u*4;l[d+0]=Math.round(c[0]),l[d+1]=Math.round(c[1]),l[d+2]=Math.round(c[2]),l[d+3]=Math.round(c[3])}if(e!=null){e.width=r,e.height=s;const u=e.getContext("2d"),c=new ImageData(l,r,s);u.putImageData(c,0,0)}return n!==t&&n.dispose(),l}const lV=be({fromPixels_:iV}),bot=Object.freeze(Object.defineProperty({__proto__:null,fromPixelsAsync:vot,toPixels:yot,fromPixels:lV},Symbol.toStringTag,{value:"Module"}));function L_(t,e){const n=t.shape.length,s=e.shape.length;if(n<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${n}.`);if(s<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${s}.`);if(e.dtype!=="int32")throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.shape[s-1]>n)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${e.shape[s-1]} vs. ${n}`);if(Ge(t.shape)===0)throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${t.shape}.`);const r=e.shape,o=r[r.length-1];let a=1;for(let d=0;d<r.length-1;++d)a*=r[d];const i=t.shape,l=r.slice();l.pop();let u=1;for(let d=o;d<n;++d)u*=i[d],l.push(i[d]);const c=[...Mt(t.shape).map(d=>d/u),1].slice(0,o);return[l,a,u,c]}const wot=Object.freeze(Object.defineProperty({__proto__:null,prepareAndValidate:L_},Symbol.toStringTag,{value:"Module"}));function l8(t,e,n){const s=e.rank>1?e.shape[e.rank-1]:1,r=e.rank>1?e.rank-1:1,o=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${n.shape}, indices.shape: ${e.shape}, shape: ${t}, sliceDim: ${s}, and batchDim: ${r}.`;if(n.rank<r)throw new Error(o+` update.rank < ${r}. `);if(t.length<s+(n.rank-r))throw new Error(o+` Output shape length < ${s+(n.rank-r)}`);if(n.rank!==r+t.length-s)throw new Error(o+` update.rank != ${r+t.length-s}`);for(let a=0;a<r;++a)if(n.shape[a]!==e.shape[a])throw new Error(o+` updates.shape[${a}] (${n.shape[a]}) != indices.shape[${a}] (${e.shape[a]}).`);for(let a=0;a<n.rank-r;++a)if(n.shape[a+r]!==t[a+s])throw new Error(o+` updates.shape[${a+r}] (${n.shape[a+r]}) != shape[${a+r}] (${t[a+r]})`)}function u8(t,e,n){if(e.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${e.rank}.`);if(t.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${t.rank}.`);if(e.dtype!=="int32")throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${e.dtype}`);if(n.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${n}`);if(n.length===0){if(e.size===0)throw new Error(`Indices specified for empty output. indices shape: ${e.shape}`);if(t.size===0)throw new Error(`Updates specified for empty output. updates shape: ${t.shape}`)}l8(n,e,t)}function Jp(t,e,n){const s=e.shape.length,r=s>1?e.shape[s-1]:1,o=n.length;let a=1;for(let d=r;d<o;++d)a*=n[d];const i=r<1?1:r,l=Ge(e.shape)/i,u=[...Mt(n.slice(0,r)),1],c=Ge(n);return{sliceRank:r,numUpdates:l,sliceSize:a,strides:u,outputSize:c}}const _ot=Object.freeze(Object.defineProperty({__proto__:null,validateUpdateShape:l8,validateInput:u8,calculateShapes:Jp},Symbol.toStringTag,{value:"Module"}));const Sx=-2,$ot=-1;function c8(t,e,n){const s=t.shape.length;q(s===e.length,()=>`Error in slice${s}D: Length of begin ${e} must match the rank of the array (${s}).`),q(s===n.length,()=>`Error in slice${s}D: Length of size ${n} must match the rank of the array (${s}).`);for(let r=0;r<s;++r)q(e[r]+n[r]<=t.shape[r],()=>`Error in slice${s}D: begin[${r}] + size[${r}] (${e[r]+n[r]}) would overflow input.shape[${r}] (${t.shape[r]})`)}function xot(t){const e=[];let n=0;for(;t>0;)t&1&&e.push(n),t/=2,n++;return e}function d8(t,e,n){const s=[];for(let r=0;r<t.length;r++)s[r]=Math.ceil((e[r]-t[r])/n[r]);return s}function uV(t,e,n,s){const r=[...t];for(let o=r.length;o<s.length;o++)r.push(1);for(let o=0;o<n;o++)o===0?r[e]=1:(r.splice(e,0,1),r.pop());return r}function cV(t,e,n){return n<=t?n:n-(e-1)}function dV(t,e){const n=[];for(let s=0;s<t;s++)n.push(e+s);return n}function Sot(t,e,n,s,r,o,a,i,l){const u=t.length;let c=new Array(u),d=new Array(u),f=new Array(u);if(e.length&&n>0){const h=e[0],p=n+1;c=fV(a,h,p,s,t),d=hV(i,h,p,r,t),f=uV(o,h,p,t)}else for(let h=0;h<u;h++)c[h]=mV(a,s,o,t,h,l),d[h]=gV(i,r,o,t,h,l),f[h]=pV(o,h,l);return{begin:c,end:d,strides:f}}function fV(t,e,n,s,r){const o=[...r],a=dV(n,e);for(let i=0;i<o.length;i++)if(a.indexOf(i)>-1)o[i]=0;else{const l=cV(e,n,i);let u=s[l];t&1<<l&&(u=0),o[i]=u}return o}function hV(t,e,n,s,r){const o=[...r],a=dV(n,e);for(let i=0;i<o.length;i++)if(a.indexOf(i)>-1)o[i]=Number.MAX_SAFE_INTEGER;else{const l=cV(e,n,i);let u=s[l];t&1<<l&&(u=Number.MAX_SAFE_INTEGER),o[i]=u}for(let i=0;i<o.length;i++){const l=r[i];o[i]<0&&(o[i]+=l),o[i]=qu(0,o[i],r[i])}return o}function pV(t,e,n){let s=t[e];return(n&1<<e||s==null)&&(s=1),s}function mV(t,e,n,s,r,o){let a=e[r];const i=n[r]||1;(t&1<<r||o&1<<r||a==null)&&(i>0?a=Number.MIN_SAFE_INTEGER:a=Number.MAX_SAFE_INTEGER);const l=s[r];return a<0&&(a+=l),a=qu(0,a,l-1),a}function gV(t,e,n,s,r,o){let a=e[r];const i=n[r]||1;(t&1<<r||o&1<<r||a==null)&&(i>0?a=Number.MAX_SAFE_INTEGER:a=Number.MIN_SAFE_INTEGER);const l=s[r];return a<0&&(a+=l),i>0?a=qu(0,a,l):a=qu(-1,a,l-1),a}function f8(t,e,n){let s=n.length;for(let r=0;r<n.length;r++)if(n[r]>1){s=r;break}for(let r=s+1;r<n.length;r++)if(e[r]>0||n[r]!==t[r])return!1;return!0}function h8(t,e){let n=t.length>0?t[t.length-1]:1;for(let s=0;s<t.length-1;s++)n+=t[s]*e[s];return n}function z_(t,e,n){let s;const r=t.shape.length;typeof e=="number"?s=[e,...new Array(r-1).fill(0)]:e.length<r?s=e.concat(new Array(r-e.length).fill(0)):s=e.slice(),s.forEach(a=>{q(a!==-1,()=>"slice() does not support negative begin indexing.")});let o;return n==null?o=new Array(r).fill(-1):typeof n=="number"?o=[n,...new Array(r-1).fill(-1)]:n.length<r?o=n.concat(new Array(r-n.length).fill(-1)):o=n,o=o.map((a,i)=>a>=0?a:(q(a===-1,()=>`Negative size values should be exactly -1 but got ${a} for the slice() size at index ${i}.`),t.shape[i]-s[i])),[s,o]}function p8(t,e,n,s,r,o,a,i,l){let u;if(s==null?(u=new Array(e.length),u.fill(1)):u=s,a!=null&&(a&a-1)!==0)throw new Error("Multiple ellipses in slice is not allowed.");let c=!1;const d={dims:u.length,numAddAxisAfterEllipsis:0,begin:e.slice(),end:n.slice(),strides:u.slice(),beginMask:r,endMask:o,ellipsisMask:a,newAxisMask:i,shrinkAxisMask:l};for(let b=0;b<d.dims;b++)c&&(1<<b&i)!==0&&d.numAddAxisAfterEllipsis++,1<<b&a&&(c=!0);c||(d.ellipsisMask|=1<<d.dims,d.dims++);const f={dims:t.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};Cot(d,f);let h=!0,p=!0,m=!0;const g=[],y=[];for(let b=0;b<t.length;++b){if(f.strides[b]===0)throw Error(`strides[${b}] must be non-zero`);const _=!!(f.shrinkAxisMask&1<<b),$=t[b];if($===-1){g.push(_?1:-1);continue}const x=[f.beginMask&1<<b,f.endMask&1<<b],k=[f.strides[b]>0?0:-1,f.strides[b]>0?$:$-1];if(_&&f.strides[b]<=0)throw Error("only stride 1 allowed on non-range indexing.");m=m&&f.strides[b]===1;const C=!!(f.beginMask&1<<b&&f.endMask&1<<b);if(f.beginValid&&f.endValid){if(_){const R=f.begin[b]<0?$+f.begin[b]:f.begin[b];if(f.begin[b]=R,f.end[b]=f.begin[b]+1,R<0||R>=$)throw Error(`slice index ${f.begin[b]} of dimension ${b} out of bounds.`)}else f.begin[b]=XR(f.begin[b],0,f.strides[b],$,x,k),f.end[b]=XR(f.end[b],1,f.strides[b],$,x,k);const M=f.strides[b]===1&&f.begin[b]===0&&f.end[b]===$;h=h&&M,p=p&&(b===0&&f.strides[b]===1||M)}else h=h&&f.strides[b]===1&&C,p=p&&(b===0&&f.strides[b]===1||C);let T,N=!1;if(f.beginValid&&f.endValid?(T=f.end[b]-f.begin[b],N=!0):_?(T=1,N=!0):C&&$>=0&&(f.strides[b]<0?T=-$:T=$,N=!0),N){let M;T===0||T<0!=f.strides[b]<0?M=0:M=Math.trunc(T/f.strides[b])+(T%f.strides[b]!==0?1:0),g.push(M)}else g.push(-1)}for(let b=0;b<f.finalShapeGatherIndices.length;++b){const _=f.finalShapeGatherIndices[b];_>=0?y.push(g[_]):_===Sx&&y.push(1)}return{finalShapeSparse:y.filter((b,_)=>f.finalShapeGatherIndices[_]!==Sx),finalShape:y,isIdentity:h,sliceDim0:p,isSimpleSlice:m,begin:f.begin,end:f.end,strides:f.strides}}function Cot(t,e){e.beginMask=0,e.endMask=0,e.shrinkAxisMask=0;let n=0;e.beginValid=t.begin!=null,e.endValid=t.end!=null,e.begin=new Array(e.dims),e.end=new Array(e.dims),e.strides=new Array(e.dims),e.finalShapeGatherIndices=[],e.finalShapeGatherIndicesSparse=[],e.inputShapeGatherIndicesSparse=new Array(e.dims);for(let s=0;s<t.dims;s++)if(1<<s&t.ellipsisMask){const r=Math.min(e.dims-(t.dims-s)+1+t.numAddAxisAfterEllipsis,e.dims);for(;n<r;n++)e.begin[n]=0,e.end[n]=0,e.strides[n]=1,e.beginMask|=1<<n,e.endMask|=1<<n,e.finalShapeGatherIndices.push(n),e.finalShapeGatherIndicesSparse.push(-1),e.inputShapeGatherIndicesSparse[n]=s}else if(1<<s&t.newAxisMask)e.finalShapeGatherIndices.push(Sx),e.finalShapeGatherIndicesSparse.push(-1);else{if(n===e.begin.length)throw Error(`Index out of range using input dim ${n}; input has only ${e.dims} dims, ${e.begin.length}.`);t.begin!=null&&(e.begin[n]=t.begin[s]),t.end!=null&&(e.end[n]=t.end[s]),e.strides[n]=t.strides[s],t.beginMask&1<<s&&(e.beginMask|=1<<n),t.endMask&1<<s&&(e.endMask|=1<<n),t.shrinkAxisMask&1<<s?(e.finalShapeGatherIndices.push($ot),e.finalShapeGatherIndicesSparse.push(-1),e.shrinkAxisMask|=1<<n):(e.finalShapeGatherIndices.push(n),e.finalShapeGatherIndicesSparse.push(s)),e.inputShapeGatherIndicesSparse[n]=s,n++}}function XR(t,e,n,s,r,o){if(r[e])return n>0?o[e]:o[e+1&1];{const a=t<0?s+t:t;return a<o[0]?o[0]:a>o[1]?o[1]:a}}const vV=Object.freeze(Object.defineProperty({__proto__:null,assertParamsValid:c8,maskToAxes:xot,computeOutShape:d8,stridesWithElidedDims:uV,getNormalizedAxes:Sot,startIndicesWithElidedDims:fV,stopIndicesWithElidedDims:hV,stridesForAxis:pV,startForAxis:mV,stopForAxis:gV,isSliceContinous:f8,computeFlatOffset:h8,parseSliceParams:z_,sliceInfo:p8},Symbol.toStringTag,{value:"Module"}));let rf=class{getClassName(){return this.constructor.className}static fromConfig(e,n){return new e(n)}},ua=class{constructor(){this.classNameMap={}}static getMap(){return ua.instance==null&&(ua.instance=new ua),ua.instance}static register(e){ua.getMap().classNameMap[e.className]=[e,e.fromConfig]}};function tt(t){q(t.className!=null,()=>"Class being registered does not have the static className property defined."),q(typeof t.className=="string",()=>"className is required to be a string, but got type "+typeof t.className),q(t.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),ua.register(t)}const kot=Object.freeze(Object.defineProperty({__proto__:null,Serializable:rf,SerializationMap:ua,registerClass:tt},Symbol.toStringTag,{value:"Module"}));const Tot=.001,yV=.1;function Not(t,e,n){return n==null&&(n=m8()),Cx(t,e,(s,r)=>g8(s,r,n))}function m8(){return ye.backend.floatPrecision()===32?Tot:yV}function Cx(t,e,n){let s=!0;if((Zs(t)||Zs(e))&&(s=!1),Zs(t)&&Zs(e)&&(s=!0),s){const a=t.constructor.name,i=e.constructor.name;if(a!==i)throw new Error(`Arrays are of different type. Actual: ${a}. Expected: ${i}`)}if(Array.isArray(t)&&Array.isArray(e)){const a=Vi(t),i=Vi(e);if(!hn(a,i))throw new Error(`Arrays have different shapes. Actual: [${a}]. Expected: [${i}]`)}const r=Zs(t)?t:Tl(t),o=Zs(e)?e:Tl(e);if(r.length!==o.length)throw new Error(`Arrays have different lengths actual: ${r.length} vs expected: ${o.length}.
Actual:   ${r}.
Expected: ${o}.`);for(let a=0;a<o.length;++a){const i=r[a],l=o[a];if(!n(i,l))throw new Error(`Arrays differ: actual[${a}] = ${i}, expected[${a}] = ${l}.
Actual:   ${r}.
Expected: ${o}.`)}typeof expect<"u"&&expect().nothing()}function Iot(t,e){t().then(()=>e.fail(),()=>e()),typeof expect<"u"&&expect().nothing()}function Eot(t,e){const n=typeof e=="string"||typeof e=="number"||typeof e=="boolean"?[e]:e;return ki(t)||ki(t[0])||ki(e)||ki(e[0])?Cx(t,n,(s,r)=>s==r):Cx(t,e,(s,r)=>g8(s,r,0))}function Aot(t,e,n){if(n==null&&(n=m8()),!g8(t,e,n))throw new Error(`Numbers differ: actual === ${t}, expected === ${e}`);typeof expect<"u"&&expect().nothing()}function g8(t,e,n){return!isFinite(t)&&!isFinite(e)?!0:!(isNaN(t)||isNaN(e)||Math.abs(t-e)>n)}function Oot(t,e,n){for(let s=0;s<t.length;s++)if(t[s]<e||t[s]>n)throw new Error(`Value out of range:${t[s]} low: ${e}, high: ${n}`)}function Rot(t,e){const n=new Float32Array(t),s=new Float32Array(e);if(n.length!==s.length)throw new Error(`Expected ArrayBuffer to be of length ${s.length}, but it was ${n.length}`);for(let r=0;r<s.length;r++)if(n[r]!==s[r])throw new Error(`Expected ArrayBuffer value at ${r} to be ${s[r]} but got ${n[r]} instead`)}function bV(t){for(let e=0;e<t.length;e++){const n=t[e];Array.isArray(n)?bV(n):t[e]=Oi(n)}return t}function Dot(t){const e=document.createElement("video");return"playsInline"in e&&(e.playsInline=!0),e.muted=!0,e.loop=!0,e.style.position="fixed",e.style.left="0px",e.style.top="0px",e.preload="auto",e.appendChild(t),new Promise(n=>{e.addEventListener("loadeddata",s=>n(e)),e.load()})}async function Fot(t){await t.play(),"requestVideoFrameCallback"in t&&await new Promise(e=>{t.requestVideoFrameCallback(e)})}const Mot=Object.freeze(Object.defineProperty({__proto__:null,TEST_EPSILON_FLOAT16:yV,expectArraysClose:Not,testEpsilon:m8,expectPromiseToFail:Iot,expectArraysEqual:Eot,expectNumbersClose:Aot,expectValuesInRange:Oot,expectArrayBuffersEqual:Rot,encodeStrings:bV,createVideoElement:Dot,play:Fot},Symbol.toStringTag,{value:"Module"}));const wV="4.1.0";function Pot(t,e){let n=te(t,"a","add"),s=te(e,"b","add");[n,s]=ds(n,s);const r={a:n,b:s};return ye.runKernel(nf,r)}const st=be({add_:Pot});function Lot(t,e){let n=te(t,"a","floorDiv"),s=te(e,"b","floorDiv");[n,s]=ds(n,s);const r={a:n,b:s};return ye.runKernel(_p,r)}const B_=be({floorDiv_:Lot});function zot(t,e){let n=te(t,"a","div"),s=te(e,"b","div");if([n,s]=ds(n,s),n.dtype==="int32"&&s.dtype==="int32")return B_(n,s);const r={a:n,b:s},o={};return ye.runKernel(mp,r,o)}const Et=be({div_:zot});function Bot(t,e){let n=te(t,"a","mul"),s=te(e,"b","mul");[n,s]=ds(n,s);const r={a:n,b:s};return ye.runKernel(Op,r)}const Te=be({mul_:Bot});function Vot(t){const e=te(t,"x","abs");if(e.dtype==="complex64"){const n={x:e};return ye.runKernel(Xg,n)}else{const n={x:e};return ye.runKernel(Vg,n)}}const $s=be({abs_:Vot});function Hot(t){const n={x:te(t,"x","acos")};return ye.runKernel(sp,n)}const v8=be({acos_:Hot});function Wot(t){const n={x:te(t,"x","acosh")};return ye.runKernel(rp,n)}const y8=be({acosh_:Wot});function Uot(t){q(Array.isArray(t),()=>"The argument passed to tf.addN() must be a list of tensors"),q(t.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${t.length}`);const e=t.map((r,o)=>te(r,`tensors${o}`,"addN")),n=e[0];e.forEach(r=>{if(r.dtype!==n.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),e.forEach(r=>{if(!hn(r.shape,n.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")});const s=e;return ye.runKernel(Hg,s)}const _V=be({addN_:Uot});function Got(t,e=null,n=!1){const r={x:te(t,"x","all","bool")},o={axis:e,keepDims:n};return ye.runKernel(Aw,r,o)}const V_=be({all_:Got});function jot(t,e=null,n=!1){const r={x:te(t,"x","any","bool")},o={axis:e,keepDims:n};return ye.runKernel(Ow,r,o)}const sg=be({any_:jot});function Kot(t,e=0){const s={x:te(t,"x","argMax")},r={axis:e};return ye.runKernel(Wg,s,r)}const Od=be({argMax_:Kot});function qot(t,e=0){const s={x:te(t,"x","argMin")},r={axis:e};return ye.runKernel(Ug,s,r)}const b8=be({argMin_:qot});function Xot(t){const n={x:te(t,"x","asin")};return ye.runKernel(op,n)}const w8=be({asin_:Xot});function Yot(t){const n={x:te(t,"x","asinh")};return ye.runKernel(ap,n)}const _8=be({asinh_:Yot});function Zot(t){const n={x:te(t,"x","atan")};return ye.runKernel(ip,n)}const $8=be({atan_:Zot});function Jot(t,e){let n=te(t,"a","atan2"),s=te(e,"b","atan2");[n,s]=ds(n,s);const r={a:n,b:s};return ye.runKernel(up,r)}const x8=be({atan2_:Jot});function Qot(t){const n={x:te(t,"x","atanh")};return ye.runKernel(lp,n)}const S8=be({atanh_:Qot});function G1(t,e,n,s,r="NHWC",o){const a=t[3],i=[...e,a],l=Yl(r);return Gs(t,i,n,o,s,null,null,l)}function Na(t,e,n,s,r,o,a="channelsLast"){const[i,l]=rb(e);let u;if(a==="channelsLast")u=[i,l,t[3],t[3]];else if(a==="channelsFirst")u=[i,l,t[1],t[1]];else throw new Error(`Unknown dataFormat ${a}`);return Gs(t,u,n,s,r,o,!1,a)}function Xl(t,e,n,s,r,o,a="NDHWC"){const[i,l,u]=kx(e);let c,d;if(a==="NDHWC")d="channelsLast",c=[i,l,u,t[4],t[4]];else if(a==="NCDHW")d="channelsFirst",c=[i,l,u,t[1],t[1]];else throw new Error(`Unknown dataFormat ${a}`);return hc(t,c,n,s,r,!1,d,o)}function Gs(t,e,n,s,r,o,a=!1,i="channelsLast"){let[l,u,c,d]=[-1,-1,-1,-1];if(i==="channelsLast")[l,u,c,d]=t;else if(i==="channelsFirst")[l,d,u,c]=t;else throw new Error(`Unknown dataFormat ${i}`);const[f,h,,p]=e,[m,g]=rb(n),[y,w]=rb(s),b=Zf(f,y),_=Zf(h,w),{padInfo:$,outHeight:x,outWidth:k}=nat(r,u,c,m,g,b,_,o,i),C=a?p*d:p;let T;return i==="channelsFirst"?T=[l,C,x,k]:i==="channelsLast"&&(T=[l,x,k,C]),{batchSize:l,dataFormat:i,inHeight:u,inWidth:c,inChannels:d,outHeight:x,outWidth:k,outChannels:C,padInfo:$,strideHeight:m,strideWidth:g,filterHeight:f,filterWidth:h,effectiveFilterHeight:b,effectiveFilterWidth:_,dilationHeight:y,dilationWidth:w,inShape:t,outShape:T,filterShape:e}}function hc(t,e,n,s,r,o=!1,a="channelsLast",i){let[l,u,c,d,f]=[-1,-1,-1,-1,-1];if(a==="channelsLast")[l,u,c,d,f]=t;else if(a==="channelsFirst")[l,f,u,c,d]=t;else throw new Error(`Unknown dataFormat ${a}`);const[h,p,m,,g]=e,[y,w,b]=kx(n),[_,$,x]=kx(s),k=Zf(h,_),C=Zf(p,$),T=Zf(m,x),{padInfo:N,outDepth:M,outHeight:R,outWidth:D}=sat(r,u,c,d,y,w,b,k,C,T,i),z=o?g*f:g;let B;return a==="channelsFirst"?B=[l,z,M,R,D]:a==="channelsLast"&&(B=[l,M,R,D,z]),{batchSize:l,dataFormat:a,inDepth:u,inHeight:c,inWidth:d,inChannels:f,outDepth:M,outHeight:R,outWidth:D,outChannels:z,padInfo:N,strideDepth:y,strideHeight:w,strideWidth:b,filterDepth:h,filterHeight:p,filterWidth:m,effectiveFilterDepth:k,effectiveFilterHeight:C,effectiveFilterWidth:T,dilationDepth:_,dilationHeight:$,dilationWidth:x,inShape:t,outShape:B,filterShape:e}}function eat(t,e,n,s,r){s==null&&(s=C8(t,e,n));const o=t[0],a=t[1],i=ud((o-e+2*s)/n+1,r),l=ud((a-e+2*s)/n+1,r);return[i,l]}function tat(t,e,n,s,r,o){r==null&&(r=C8(t,e,s));const a=t[0],i=t[1],l=t[2],u=ud((a-e+2*r)/s+1,o),c=ud((i-e+2*r)/s+1,o),d=ud((l-e+2*r)/s+1,o);return[u,c,d,n]}function C8(t,e,n,s=1){const r=Zf(e,s);return Math.floor((t[0]*(n-1)-n+r)/2)}function rb(t){return typeof t=="number"?[t,t,t]:t.length===2?[t[0],t[1],1]:t}function kx(t){return typeof t=="number"?[t,t,t]:t}function Zf(t,e){return e<=1?t:t+(t-1)*(e-1)}function nat(t,e,n,s,r,o,a,i,l){let u,c,d;if(typeof t=="number"){u={top:t,bottom:t,left:t,right:t,type:t===0?"VALID":"NUMBER"};const h=eat([e,n],o,s,t,i);c=h[0],d=h[1]}else if(t==="same"){c=Math.ceil(e/s),d=Math.ceil(n/r);const f=Math.max(0,(c-1)*s+o-e),h=Math.max(0,(d-1)*r+a-n),p=Math.floor(f/2),m=f-p,g=Math.floor(h/2),y=h-g;u={top:p,bottom:m,left:g,right:y,type:"SAME"}}else if(t==="valid")u={top:0,bottom:0,left:0,right:0,type:"VALID"},c=Math.ceil((e-o+1)/s),d=Math.ceil((n-a+1)/r);else if(typeof t=="object"){const f=l==="channelsLast"?t[1][0]:t[2][0],h=l==="channelsLast"?t[1][1]:t[2][1],p=l==="channelsLast"?t[2][0]:t[3][0],m=l==="channelsLast"?t[2][1]:t[3][1];u={top:f,bottom:h,left:p,right:m,type:f===0&&h===0&&p===0&&m===0?"VALID":"EXPLICIT"},c=ud((e-o+f+h)/s+1,i),d=ud((n-a+p+m)/r+1,i)}else throw Error(`Unknown padding parameter: ${t}`);return{padInfo:u,outHeight:c,outWidth:d}}function sat(t,e,n,s,r,o,a,i,l,u,c){let d,f,h,p;if(typeof t=="number"){d={top:t,bottom:t,left:t,right:t,front:t,back:t,type:t===0?"VALID":"NUMBER"};const g=tat([e,n,s,1],i,1,r,t,c);f=g[0],h=g[1],p=g[2]}else if(t==="same"){f=Math.ceil(e/r),h=Math.ceil(n/o),p=Math.ceil(s/a);const m=(f-1)*r+i-e,g=(h-1)*o+l-n,y=(p-1)*a+u-s,w=Math.floor(m/2),b=m-w,_=Math.floor(g/2),$=g-_,x=Math.floor(y/2),k=y-x;d={top:_,bottom:$,left:x,right:k,front:w,back:b,type:"SAME"}}else if(t==="valid")d={top:0,bottom:0,left:0,right:0,front:0,back:0,type:"VALID"},f=Math.ceil((e-i+1)/r),h=Math.ceil((n-l+1)/o),p=Math.ceil((s-u+1)/a);else throw Error(`Unknown padding parameter: ${t}`);return{padInfo:d,outDepth:f,outHeight:h,outWidth:p}}function ud(t,e){if(!e)return Math.trunc(t);switch(e){case"round":return Math.round(t);case"ceil":return Math.ceil(t);case"floor":return Math.floor(t);default:throw new Error(`Unknown roundingMode ${e}`)}}function Zu(t){const[e,n,s]=rb(t);return e===1&&n===1&&s===1}function ur(t,e){return Zu(t)||Zu(e)}function Yl(t){if(t==="NHWC")return"channelsLast";if(t==="NCHW")return"channelsFirst";throw new Error(`Unknown dataFormat ${t}`)}function Mr(t,e,n){if(n!=null){if(typeof e=="string")throw Error(`Error in ${t}: pad must be an integer when using dimRoundingMode ${n} but got pad ${e}.`);if(typeof e=="number")q(Nd(e),()=>`Error in ${t}: pad must be an integer when using dimRoundingMode ${n} but got pad ${e}.`);else if(typeof e=="object")e.forEach(s=>{s.forEach(r=>{q(Nd(r),()=>`Error in ${t}: pad must be an integer when using dimRoundingMode ${n} but got pad ${r}.`)})});else throw Error(`Error in ${t}: Unknown padding parameter: ${e}`)}}function rat(t,e){const s={x:te(t,"x","reshape","string_or_numeric")},r={shape:e};return ye.runKernel(I1,s,r)}const Ne=be({reshape_:rat});function oat(t,e,n,s,r){const o=te(t,"x","avgPool","float32"),a=1;q(ur(n,a),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${n} and dilations '${a}'`);let i=o,l=!1;o.rank===3&&(l=!0,i=Ne(o,[1,o.shape[0],o.shape[1],o.shape[2]])),q(i.rank===4,()=>`Error in avgPool: x must be rank 4 but got rank ${i.rank}.`),Mr("avgPool",s,r);const u={x:i},c={filterSize:e,strides:n,pad:s,dimRoundingMode:r};let d=ye.runKernel(Gg,u,c);return d=ht(d,o.dtype),l?Ne(d,[d.shape[1],d.shape[2],d.shape[3]]):d}const j1=be({avgPool_:oat});function aat(t,e,n,s,r,o="NDHWC"){const a=te(t,"x","avgPool3d","float32");let i=a,l=!1;a.rank===4&&(l=!0,i=Ne(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),q(i.rank===5,()=>`Error in avgPool3d: x must be rank 5 but got rank ${i.rank}.`),q(o==="NDHWC",()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${o}`),Mr("avgPool3d",s,r);const u={x:i},c={filterSize:e,strides:n,pad:s,dimRoundingMode:r,dataFormat:o};let d=ye.runKernel(jg,u,c);return d=ht(d,i.dtype),l?Ne(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}const k8=be({avgPool3d_:aat});function iat(t,e=0){q(t.length>=1,()=>"Pass at least one tensor to concat");const n=ng(t,"tensors","concat","string_or_numeric");if(n[0].dtype==="complex64"&&n.forEach(o=>{if(o.dtype!=="complex64")throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${o.dtype}. `)}),n.length===1)return Ri(n[0]);const s=n,r={axis:e};return ye.runKernel(Yg,s,r)}const vs=be({concat_:iat});function lat(t){const n={x:te(t,"x","sigmoid","float32")};return ye.runKernel(Wp,n)}const qa=be({sigmoid_:lat});function uat(t,e,n){const s=te(t,"x","slice","string_or_numeric");if(s.rank===0)throw new Error("Slicing scalar is not possible");const r={x:s},o={begin:e,size:n};return ye.runKernel(D1,r,o)}const mn=be({slice_:uat});function cat(t){const n={x:te(t,"x","tanh","float32")};return ye.runKernel(Xp,n)}const Rd=be({tanh_:cat});function dat(t,e,n,s,r,o){const a=te(t,"forgetBias","basicLSTMCell"),i=te(e,"lstmKernel","basicLSTMCell"),l=te(n,"lstmBias","basicLSTMCell"),u=te(s,"data","basicLSTMCell"),c=te(r,"c","basicLSTMCell"),d=te(o,"h","basicLSTMCell"),f=vs([u,d],1),h=ln(f,i),p=st(h,l),m=p.shape[0],g=p.shape[1]/4,y=[m,g],w=mn(p,[0,0],y),b=mn(p,[0,g],y),_=mn(p,[0,g*2],y),$=mn(p,[0,g*3],y),x=st(Te(qa(w),Rd(b)),Te(c,qa(st(a,_)))),k=Te(Rd(x),qa($));return[x,k]}const $V=be({basicLSTMCell_:dat});function fat(t,e,n){const s=te(t,"x","batchToSpaceND"),r=e.reduce((i,l)=>i*l);q(s.rank>=1+e.length,()=>`input rank is ${s.rank} but should be > than blockShape.length ${e.length}`),q(n.length===e.length,()=>`crops.length is ${n.length} but should be equal to blockShape.length  ${e.length}`),q(s.shape[0]%r===0,()=>`input tensor batch is ${s.shape[0]} but is not divisible by the product of the elements of blockShape ${e.join(" * ")} === ${r}`);const o={x:s},a={blockShape:e,crops:n};return ye.runKernel(qg,o,a)}const K1=be({batchToSpaceND_:fat});function hat(t){let e;return t.rank===0||t.rank===1?e=Ne(t,[1,1,1,t.size]):t.rank===2?e=Ne(t,[1,1,t.shape[0],t.shape[1]]):t.rank===3?e=Ne(t,[1,t.shape[0],t.shape[1],t.shape[2]]):e=t,e}function pat(t,e,n,s,r,o){o==null&&(o=.001);const a=te(t,"x","batchNorm"),i=te(e,"mean","batchNorm"),l=te(n,"variance","batchNorm");let u;r!=null&&(u=te(r,"scale","batchNorm"));let c;s!=null&&(c=te(s,"offset","batchNorm")),q(i.rank===l.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),q(c==null||i.rank===c.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),q(u==null||i.rank===u.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");const f={x:hat(a),scale:u,offset:c,mean:i,variance:l},h={varianceEpsilon:o},p=ye.runKernel(o1,f,h);return Ne(p,a.shape)}const Qp=be({batchNorm_:pat});function mat(t,e,n,s,r,o){const a=te(t,"x","batchNorm"),i=te(e,"mean","batchNorm"),l=te(n,"variance","batchNorm");let u;r!=null&&(u=te(r,"scale","batchNorm"));let c;return s!=null&&(c=te(s,"offset","batchNorm")),q(a.rank===2,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${a.rank}.`),q(i.rank===2||i.rank===1,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${i.rank}.`),q(l.rank===2||l.rank===1,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${l.rank}.`),u!=null&&q(u.rank===2||u.rank===1,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${u.rank}.`),c!=null&&q(c.rank===2||c.rank===1,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${c.rank}.`),Qp(a,i,l,c,u,o)}const T8=be({batchNorm2d_:mat});function gat(t,e,n,s,r,o){const a=te(t,"x","batchNorm"),i=te(e,"mean","batchNorm"),l=te(n,"variance","batchNorm");let u;r!=null&&(u=te(r,"scale","batchNorm"));let c;return s!=null&&(c=te(s,"offset","batchNorm")),q(a.rank===3,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${a.rank}.`),q(i.rank===3||i.rank===1,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${i.rank}.`),q(l.rank===3||l.rank===1,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${l.rank}.`),u!=null&&q(u.rank===3||u.rank===1,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${u.rank}.`),c!=null&&q(c.rank===3||c.rank===1,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${c.rank}.`),Qp(a,i,l,c,u,o)}const N8=be({batchNorm3d_:gat});function vat(t,e,n,s,r,o){const a=te(t,"x","batchNorm"),i=te(e,"mean","batchNorm"),l=te(n,"variance","batchNorm");let u;r!=null&&(u=te(r,"scale","batchNorm"));let c;return s!=null&&(c=te(s,"offset","batchNorm")),q(a.rank===4,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${a.rank}.`),q(i.rank===4||i.rank===1,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${i.rank}.`),q(l.rank===4||l.rank===1,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${l.rank}.`),u!=null&&q(u.rank===4||u.rank===1,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${u.rank}.`),c!=null&&q(c.rank===4||c.rank===1,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${c.rank}.`),Qp(a,i,l,c,u,o)}const I8=be({batchNorm4d_:vat});function yat(t,e,n){const s=te(t,"x","bincount"),r=te(e,"weights","bincount");q(s.dtype==="int32",()=>`Error in bincount: input dtype must be int32, but got ${s.dtype}`),q(n>=0,()=>`size must be non-negative, but got ${n}.`),q(r.size===s.size||r.size===0,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${s.shape}, weights shape: ${r.shape}.`);const o={x:s,weights:r},a={size:n};return ye.runKernel(Fw,o,a)}const E8=be({bincount_:yat});function bat(t,e){const n=te(t,"s0","broadcastArgs","int32"),s=te(e,"s1","broadcastArgs","int32");if(n.rank!==1)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${n.rank}`);if(s.rank!==1)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${s.rank}`);const r={s0:n,s1:s};return ye.runKernel(Mw,r)}const xV=be({broadcastArgs_:bat});function wat(t,e){let n=te(t,"broadcastTo","x");const s=n.shape;if(Io(e),e.length<n.rank)throw new Error(`broadcastTo(): shape.length=${e.length} < input.rank=${n.rank}.`);if(e.length>n.rank){const u=n.shape.slice();for(;u.length<e.length;)u.unshift(1);n=Ne(n,u)}const r=n.shape,o=Array.from(e);for(let u=e.length-1;u>=0;u--)if(r[u]===e[u])o[u]=1;else if(n.shape[u]!==1)throw new Error(`broadcastTo(): [${s}] cannot be broadcast to [${e}].`);if(o.map((u,c)=>u>1?c:-1).filter(u=>u>=0).length===0)return Ri(n);const i={x:n},l={reps:o};return ye.runKernel(Yp,i,l)}const cd=be({broadcastTo_:wat});function _at(t){const n={x:te(t,"x","ceil","float32")};return ye.runKernel(dp,n)}const A8=be({ceil_:_at});function of(t,e,n){Io(t);const s={shape:t,value:e,dtype:n};return ye.runKernel(Zw,{},s)}function $at(t,e,n){const s=te(t,"x","clipByValue");if(q(e<=n,()=>`Error in clip: min (${e}) must be less than or equal to max (${n}).`),e===n)return of(s.shape,e,s.dtype);const r={x:s},o={clipValueMin:e,clipValueMax:n};return ye.runKernel(fp,r,o)}const Zr=be({clipByValue_:$at});function xat(t){return vs(t,0)}const O8=be({concat1d_:xat});function Sat(t,e){return vs(t,e)}const R8=be({concat2d_:Sat});function Cat(t,e){return vs(t,e)}const D8=be({concat3d_:Cat});function kat(t,e){return vs(t,e)}const F8=be({concat4d_:kat});function Tat(t,e,n,s,r="NHWC",o=[1,1],a){const i=te(t,"x","conv2d","float32"),l=te(e,"filter","conv2d","float32");let u=i,c=!1;i.rank===3&&(c=!0,u=Ne(i,[1,i.shape[0],i.shape[1],i.shape[2]])),q(u.rank===4,()=>`Error in conv2d: input must be rank 4, but got rank ${u.rank}.`),q(l.rank===4,()=>`Error in conv2d: filter must be rank 4, but got rank ${l.rank}.`),Mr("conv2d",s,a);const d=r==="NHWC"?u.shape[3]:u.shape[1];q(d===l.shape[2],()=>`Error in conv2d: depth of input (${d}) must match input depth for filter ${l.shape[2]}.`),q(ur(n,o),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${o}'`);const f={x:u,filter:l},h={strides:n,pad:s,dataFormat:r,dilations:o,dimRoundingMode:a},p=ye.runKernel(Zg,f,h);return c?Ne(p,[p.shape[1],p.shape[2],p.shape[3]]):p}const Al=be({conv2d_:Tat});function Nat(t,e,n,s,r="NWC",o=1,a){const i=te(t,"x","conv1d"),l=te(e,"filter","conv1d");let u=i,c=!1;i.rank===2&&(c=!0,u=Ne(i,[1,i.shape[0],i.shape[1]])),q(u.rank===3,()=>`Error in conv1d: input must be rank 3, but got rank ${u.rank}.`),q(l.rank===3,()=>`Error in conv1d: filter must be rank 3, but got rank ${l.rank}.`),Mr("conv1d",s,a),q(u.shape[2]===l.shape[1],()=>`Error in conv1d: depth of input (${u.shape[2]}) must match input depth for filter ${l.shape[1]}.`),q(ur(n,o),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${n} and dilation '${o}'`),q(r==="NWC",()=>`Error in conv1d: got dataFormat of ${r} but only NWC is currently supported.`);const d=Ne(l,[1,l.shape[0],l.shape[1],l.shape[2]]),f=Ne(u,[u.shape[0],1,u.shape[1],u.shape[2]]),g=Al(f,d,[1,n],s,"NHWC",[1,o],a);return c?Ne(g,[g.shape[2],g.shape[3]]):Ne(g,[g.shape[0],g.shape[2],g.shape[3]])}const H_=be({conv1d_:Nat});function Iat(t,e,n,s,r,o="NHWC",a){q(t.length===e.rank,()=>`Length of inShape (${t.length}) and rank of dy (${e.rank}) must match`);let i=t,l=e,u=!1;e.rank===3&&(u=!0,l=Ne(e,[1,e.shape[0],e.shape[1],e.shape[2]]),i=[1,t[0],t[1],t[2]]),q(i.length===4,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${i.length}.`),q(l.rank===4,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${l.rank}`),q(n.rank===4,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${n.rank}`);const c=o==="NHWC"?i[3]:i[1],d=o==="NHWC"?l.shape[3]:l.shape[1];q(c===n.shape[2],()=>`Error in conv2dDerInput: depth of input (${c}) must match input depth for filter ${n.shape[2]}.`),q(d===n.shape[3],()=>`Error in conv2dDerInput: depth of output (${d}) must match output depth for filter ${n.shape[3]}.`),Mr("conv2dDerInput",r,a);const f={dy:l,filter:n},h={strides:s,pad:r,dataFormat:o,dimRoundingMode:a,inputShape:i},p=ye.runKernel(Jg,f,h);return u?Ne(p,[p.shape[1],p.shape[2],p.shape[3]]):p}const M8=be({conv2DBackpropInput_:Iat});function Eat(t,e,n,s,r,o){const a=te(t,"x","conv2dTranspose"),i=te(e,"filter","conv2dTranspose");return M8(n,a,i,s,r,"NHWC",o)}const W_=be({conv2dTranspose_:Eat});function Aat(t,e,n,s,r="NDHWC",o=[1,1,1]){const a=te(t,"x","conv3d"),i=te(e,"filter","conv3d");let l=a,u=!1;a.rank===4&&(u=!0,l=Ne(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),q(l.rank===5,()=>`Error in conv3d: input must be rank 5, but got rank ${l.rank}.`),q(i.rank===5,()=>`Error in conv3d: filter must be rank 5, but got rank ${i.rank}.`),q(l.shape[4]===i.shape[3],()=>`Error in conv3d: depth of input (${l.shape[4]}) must match input depth for filter ${i.shape[3]}.`),q(ur(n,o),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${n} and dilations '${o}'`),q(r==="NDHWC",()=>`Error in conv3d: got dataFormat of ${r} but only NDHWC is currently supported.`);const c={x:l,filter:i},d={strides:n,pad:s,dataFormat:r,dilations:o},f=ye.runKernel(Qg,c,d);return u?Ne(f,[f.shape[1],f.shape[2],f.shape[3],f.shape[4]]):f}const P8=be({conv3d_:Aat});function Oat(t,e,n,s,r){q(t.length===e.rank,()=>`Length of inShape (${t.length}) and rank of dy (${e.rank}) must match`);let o=t,a=e,i=!1;e.rank===4&&(i=!0,a=Ne(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]),o=[1,t[0],t[1],t[2],t[3]]);const l=o[4],u=a.shape[4];q(o.length===5,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${o.length}.`),q(a.rank===5,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${a.rank}`),q(n.rank===5,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${n.rank}`),q(l===n.shape[3],()=>`Error in conv3dDerInput: depth of input (${l}) must match input depth for filter ${n.shape[3]}.`),q(u===n.shape[4],()=>`Error in conv3dDerInput: depth of output (${u}) must match output depth for filter ${n.shape[4]}.`);const c={dy:a,filter:n},d={pad:r,strides:s,inputShape:o},f=ye.runKernel(Bw,c,d);return i?Ne(f,[f.shape[1],f.shape[2],f.shape[3],f.shape[4]]):f}const SV=be({conv3DBackpropInput_:Oat});function Rat(t,e,n,s,r){const o=te(t,"x","conv3dTranspose"),a=te(e,"filter","conv3dTranspose");return SV(n,o,a,s,r)}const L8=be({conv3dTranspose_:Rat});function Dat(t){const n={x:te(t,"x","cos","float32")};return ye.runKernel(hp,n)}const q1=be({cos_:Dat});function Fat(t){const n={x:te(t,"x","cosh","float32")};return ye.runKernel(pp,n)}const U_=be({cosh_:Fat});function Mat(t,e=0,n=!1,s=!1){const o={x:te(t,"x","cumprod")},a={axis:e,exclusive:n,reverse:s};return ye.runKernel(Vw,o,a)}const rg=be({cumprod_:Mat});function Pat(t,e=0,n=!1,s=!1){const o={x:te(t,"x","cumsum")},a={axis:e,exclusive:n,reverse:s};return ye.runKernel(e1,o,a)}const G_=be({cumsum_:Pat});function Lat(t,e,n,s=!1){const r=te(t,"x","denseBincount"),o=te(e,"weights","denseBincount");q(r.dtype==="int32",()=>`Error in denseBincount: input dtype must be int32, but got ${r.dtype}`),q(r.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${r.rank}.`),q(n>=0,()=>`size must be non-negative, but got ${n}.`),q(o.size===r.size||o.size===0,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${r.shape}, weights shape: ${o.shape}.`);const a={x:r,weights:o},i={size:n,binaryOutput:s};return ye.runKernel(Ww,a,i)}const ob=be({denseBincount_:Lat});function zat(t,e,n="NHWC"){const s=te(t,"x","depthToSpace","float32"),r=n==="NHWC"?s.shape[1]:s.shape[2],o=n==="NHWC"?s.shape[2]:s.shape[3],a=n==="NHWC"?s.shape[3]:s.shape[1];q(e>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${e}`),q(r*e>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${r} and ${e}  for depthToSpace with input shape
    ${s.shape}`),q(o*e>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${o} and ${e} for depthToSpace with input shape
        ${s.shape}`),q(a%(e*e)===0,()=>`Dimension size must be evenly divisible by ${e*e} but is ${a} for depthToSpace with input shape ${s.shape}`);const i={x:s},l={blockSize:e,dataFormat:n};return ye.runKernel(Uw,i,l)}const z8=be({depthToSpace_:zat});function Bat(t,e,n,s,r="NHWC",o=[1,1],a){const i=te(t,"x","depthwiseConv2d","float32"),l=te(e,"filter","depthwiseConv2d","float32");let u=i,c=!1;i.rank===3&&(c=!0,u=Ne(i,[1,i.shape[0],i.shape[1],i.shape[2]])),q(u.rank===4,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${u.rank}.`),q(l.rank===4,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${l.rank}.`);const d=r==="NHWC"?u.shape[3]:u.shape[1];q(d===l.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${d}) must match the inChannels dimension in filter ${l.shape[2]}.`),Mr("depthwiseConv2d",s,a);const f={x:u,filter:l},h={strides:n,pad:s,dataFormat:r,dilations:o,dimRoundingMode:a},p=ye.runKernel(t1,f,h);return c?Ne(p,[p.shape[1],p.shape[2],p.shape[3]]):p}const em=be({depthwiseConv2d_:Bat});function Vat(t){const n={x:te(t,"x","diag")};return ye.runKernel(Kw,n)}const CV=be({diag_:Vat});function Hat(t,e,n,s,r=[1,1],o="NHWC"){const a=te(t,"x","dilation2d"),i=te(e,"filter","dilation2d");q(a.rank===3||a.rank===4,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${a.rank}.`),q(i.rank===3,()=>`Error in dilation2d: filter must be rank 3, but got rank ${i.rank}.`),q(o==="NHWC",()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${o}`);let l=a,u=!1;a.rank===3&&(l=Ne(a,[1,a.shape[0],a.shape[1],a.shape[2]]),u=!0);const c={x:l,filter:i},d={strides:n,pad:s,dilations:r},f=ye.runKernel(n1,c,d);return u?Ne(f,[f.shape[1],f.shape[2],f.shape[3]]):f}const B8=be({dilation2d_:Hat});function Wat(t,e){let n=te(t,"a","equal","string_or_numeric"),s=te(e,"b","equal","string_or_numeric");[n,s]=ds(n,s),Zt(n.shape,s.shape);const r={a:n,b:s};return ye.runKernel(s1,r)}const _o=be({equal_:Wat});function Uat(t,e,n){const s=te(e,"a","where"),r=te(n,"b","where"),o=te(t,"condition","where","bool"),a=Zt(Zt(o.shape,s.shape),r.shape),i=cd(o,a),l=cd(s,a),u=cd(r,a),c={condition:i,t:l,e:u};return ye.runKernel(R1,c)}const wr=be({where_:Uat});function Gat(t){const n={x:te(t,"x","zerosLike")};return ye.runKernel(V1,n)}const yn=be({zerosLike_:Gat});function jat(t,e){let n=te(t,"a","div"),s=te(e,"b","div");[n,s]=ds(n,s);const r=Et(n,s),o=yn(r),a=_o(s,o);return wr(a,o,r)}const V8=be({divNoNan_:jat});function Kat(t,e){const n=te(t,"t1","dot"),s=te(e,"t2","dot");q((n.rank===1||n.rank===2)&&(s.rank===1||s.rank===2),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${n.rank} and ${s.rank}.`);const r=n.rank===1?n.size:n.shape[1],o=s.rank===1?s.size:s.shape[0];if(q(r===o,()=>`Error in dot: inner dimensions of inputs must match, but got ${r} and ${o}.`),n.rank===1&&s.rank===1){const a=Ne(n,[1,-1]),i=Ne(s,[-1,1]),l=ln(a,i);return Ne(l,[])}else if(n.rank===1&&s.rank===2){const a=Ne(n,[1,-1]),i=Ne(s,[s.shape[0],s.shape[1]]),l=ln(a,i);return Ne(l,[l.size])}else if(n.rank===2&&s.rank===1){const a=Ne(s,[-1,1]),i=ln(n,a);return Ne(i,[i.size])}else{const a=Ne(s,[s.shape[0],s.shape[1]]);return ln(n,a)}}const H8=be({dot_:Kat});function qat(t,...e){const n=e.map((r,o)=>te(r,`tensors${o}`,"einsum")),s={equation:t};return ye.runKernel(qw,n,s)}const kV=be({einsum_:qat});function Xat(t){const n={x:te(t,"x","elu","float32")};return ye.runKernel(gp,n)}const tm=be({elu_:Xat});function Yat(t){let e=te(t,"x","erf");q(e.dtype==="int32"||e.dtype==="float32",()=>"Input dtype must be `int32` or `float32`."),e.dtype==="int32"&&(e=ht(e,"float32"));const n={x:e};return ye.runKernel(vp,n)}const W8=be({erf_:Yat});function U8(t,e){for(let n=0;n<t.length;++n)if(t[t.length-n-1]!==e-1-n)return!1;return!0}function TV(t,e,n){const s=t.length+e.length,r=[];let o=0,a=0;for(let i=0;i<s;i++)n.indexOf(i)===-1?r.push(t[o++]):r.push(e[a++]);return r}function js(t,e){const n=[],s=t.length;for(let o=0;o<s;o++)e.indexOf(o)===-1&&n.push(t[o]);const r=e.map(o=>t[o]);return[n,r]}function ys(t,e){const n=e.map(s=>1);return TV(t,n,e)}function cr(t,e,n){q(U8(e,n),()=>`${t} supports only inner-most axes for now. Got axes ${e} and rank-${n} input.`)}function hs(t,e){if(U8(t,e))return null;const n=[];for(let s=0;s<e;++s)t.indexOf(s)===-1&&n.push(s);return t.forEach(s=>n.push(s)),n}function pc(t){return t.map((e,n)=>[n,e]).sort((e,n)=>e[1]-n[1]).map(e=>e[0])}function bs(t,e){const n=[];for(let s=e-t;s<e;++s)n.push(s);return n}function Zat(t,e=null,n=!1){const r={x:te(t,"x","max")},o={reductionIndices:e,keepDims:n};return ye.runKernel(m1,r,o)}const Go=be({max_:Zat});function Jat(t,e=null,n=!1){const r={x:te(t,"x","min")},o={axis:e,keepDims:n};return ye.runKernel(b1,r,o)}const kh=be({min_:Jat});function Qat(t,e){let n=te(t,"base","pow"),s=te(e,"exp","pow");[n,s]=ds(n,s);const r={a:n,b:s};return ye.runKernel(Rp,r)}const Ol=be({pow_:Qat});function Pt(t,e){if((Zs(t)&&e!=="string"||Array.isArray(t))&&e!=="complex64")throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if(e==="string"&&Zs(t)&&!(t instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return fc(t,[],[],e)}function eit(t){const n={x:te(t,"x","sqrt","float32")};return ye.runKernel(Gp,n)}const ar=be({sqrt_:eit});function tit(t){const e=te(t,"x","square"),n={};return ye.runKernel("Square",{x:e},n)}const Dn=be({square_:tit});function nit(t,e=null,n=!1){let s=te(t,"x","sum");s.dtype==="bool"&&(s=ht(s,"int32"));const r={x:s},o={axis:e,keepDims:n};return ye.runKernel(F1,r,o)}const kt=be({sum_:nit});function sit(t,e="euclidean",n=null,s=!1){t=te(t,"x","norm");const r=NV(t,e,n);let o=r.shape;if(s){const a=un(n,t.shape);o=ys(r.shape,a)}return Ne(r,o)}function NV(t,e,n=null){if(t.rank===0)return $s(t);if(t.rank!==1&&n===null)return NV(Ne(t,[-1]),e,n);if(t.rank===1||typeof n=="number"||Array.isArray(n)&&n.length===1){if(e===1)return kt($s(t),n);if(e===1/0)return Go($s(t),n);if(e===-1/0)return kh($s(t),n);if(e==="euclidean"||e===2)return ar(kt(Ol($s(t),Pt(2,"int32")),n));throw new Error(`Error in norm: invalid ord value: ${e}`)}if(Array.isArray(n)&&n.length===2){if(e===1)return Go(kt($s(t),n[0]),n[1]-1);if(e===1/0)return Go(kt($s(t),n[1]),n[0]);if(e===-1/0)return kh(kt($s(t),n[1]),n[0]);if(e==="fro"||e==="euclidean")return ar(kt(Dn(t),n));throw new Error(`Error in norm: invalid ord value: ${e}`)}throw new Error(`Error in norm: invalid axis: ${n}`)}const nm=be({norm_:sit});function rit(t,e=null,n=!1){return nm(t,"euclidean",e,n)}const G8=be({euclideanNorm_:rit});function oit(t){const n={x:te(t,"x","exp")};return ye.runKernel(yp,n)}const $o=be({exp_:oit});function ait(t,e=0){const n=te(t,"x","expandDims","string_or_numeric");q(e<=n.rank,()=>"Axis must be <= rank of the tensor");const s={input:n},r={dim:e};return ye.runKernel(r1,s,r)}const hr=be({expandDims_:ait});function iit(t){const n={x:te(t,"x","expm1")};return ye.runKernel(bp,n)}const j8=be({expm1_:iit});function lit(t,e){const n=te(t,"x","tile","string_or_numeric");q(n.rank===e.length,()=>`Error in transpose: rank of input ${n.rank} must match length of reps ${e}.`);const s={x:n},r={reps:e};return ye.runKernel(Yp,s,r)}const Lo=be({tile_:lit});function uit(t,e,n,s="float32"){e==null&&(e=t);const r=tn([t,e],s),o=t<=e?t:e;for(let i=0;i<o;++i)r.set(1,i,i);const a=Ne(r.toTensor(),[t,e]);if(n==null)return a;if(n.length===1)return Lo(hr(a,0),[n[0],1,1]);if(n.length===2)return Lo(hr(hr(a,0),0),[n[0],n[1],1,1]);if(n.length===3)return Lo(hr(hr(hr(a,0),0),0),[n[0],n[1],n[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${n.length}D.`)}const j_=be({eye_:uit});function cit(t){const n={x:te(t,"x","floor","float32")};return ye.runKernel(wp,n)}const sm=be({floor_:cit});function dit(t,e,n=0,s=0){const r=te(t,"x","gather"),o=te(e,"indices","gather","int32"),a={x:r,indices:o},i={axis:n,batchDims:s};return ye.runKernel(a1,a,i)}const rm=be({gather_:dit});function fit(t,e){let n=te(t,"a","greater","string_or_numeric"),s=te(e,"b","greater","string_or_numeric");[n,s]=ds(n,s),Zt(n.shape,s.shape);const r={a:n,b:s};return ye.runKernel(i1,r)}const Pr=be({greater_:fit});function hit(t,e){let n=te(t,"a","greaterEqual","string_or_numeric"),s=te(e,"b","greaterEqual","string_or_numeric");[n,s]=ds(n,s),Zt(n.shape,s.shape);const r={a:n,b:s};return ye.runKernel($p,r)}const Zl=be({greaterEqual_:hit});function pit(t){const n={x:te(t,"x","isFinite")};return ye.runKernel(Sp,n)}const K8=be({isFinite_:pit});function mit(t){const n={x:te(t,"x","isInf")};return ye.runKernel(Cp,n)}const q8=be({isInf_:mit});function git(t){const n={x:te(t,"x","isNaN")};return ye.runKernel(kp,n)}const X8=be({isNaN_:git});function vit(t,e=.2){const s={x:te(t,"x","leakyRelu")},r={alpha:e};return ye.runKernel(l1,s,r)}const X1=be({leakyRelu_:vit});function yit(t,e){let n=te(t,"a","less","string_or_numeric"),s=te(e,"b","less","string_or_numeric");[n,s]=ds(n,s),Zt(n.shape,s.shape);const r={a:n,b:s};return ye.runKernel(u1,r)}const K_=be({less_:yit});function bit(t,e){let n=te(t,"a","lessEqual","string_or_numeric"),s=te(e,"b","lessEqual","string_or_numeric");[n,s]=ds(n,s),Zt(n.shape,s.shape);const r={a:n,b:s};return ye.runKernel(c1,r)}const mc=be({lessEqual_:bit});function IV(t,e,n){if(n<=0)throw new Error("The number of values should be positive.");const s={start:t,stop:e,num:n};return ye.runKernel(n_,{},s)}function wit(t,e=5,n=1,s=1,r=.5){const o=te(t,"x","localResponseNormalization");q(o.rank===4||o.rank===3,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${o.rank}.`),q(Nd(e),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${e}.`);let a=o,i=!1;o.rank===3&&(i=!0,a=Ne(o,[1,o.shape[0],o.shape[1],o.shape[2]]));const l={x:a},u={depthRadius:e,bias:n,alpha:s,beta:r},c=ye.runKernel(p1,l,u);return i?Ne(c,[c.shape[1],c.shape[2],c.shape[3]]):c}const Y8=be({localResponseNormalization_:wit});function _it(t){const n={x:te(t,"x","log","float32")};return ye.runKernel(Tp,n)}const xo=be({log_:_it});function $it(t){const n={x:te(t,"x","log1p")};return ye.runKernel(Np,n)}const Y1=be({log1p_:$it});function xit(t){return q(Xu(t),()=>"The f passed in grad(f) must be a function"),(e,n)=>{const s=te(e,"x","tf.grad","string_or_numeric"),r=n!=null?te(n,"dy","tf.grad"):null;return ye.tidy(()=>{const{value:o,grads:a}=ye.gradients(()=>t(s),[s],r);return r!=null&&lr(o.shape,r.shape,"The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)"),q_(a),a[0]})}}function Sit(t){return q(Xu(t),()=>"The f passed in grads(f) must be a function"),(e,n)=>{q(Array.isArray(e),()=>"The args passed in grads(f)(args) must be an array of `Tensor`s or `TensorLike`s");const s=ng(e,"args","tf.grads","string_or_numeric"),r=n!=null?te(n,"dy","tf.grads"):null;return ye.tidy(()=>{const{value:o,grads:a}=ye.gradients(()=>t(...s),s,r);return r!=null&&lr(o.shape,r.shape,"The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),q_(a),a})}}function Cit(t){return q(Xu(t),()=>"The f passed in valueAndGrad(f) must be a function"),(e,n)=>{q(e instanceof $n,()=>"The x passed in valueAndGrad(f)(x) must be a tensor"),q(n==null||n instanceof $n,()=>"The dy passed in valueAndGrad(f)(x, dy) must be a tensor");const{grads:s,value:r}=ye.gradients(()=>t(e),[e],n);return q_(s),{grad:s[0],value:r}}}function kit(t){return q(Xu(t),()=>"The f passed in valueAndGrads(f) must be a function"),(e,n)=>{q(Array.isArray(e)&&e.every(r=>r instanceof $n),()=>"The args passed in valueAndGrads(f)(args) must be array of tensors"),q(n==null||n instanceof $n,()=>"The dy passed in valueAndGrads(f)(args, dy) must be a tensor");const s=ye.gradients(()=>t(...e),e,n);return n!=null&&lr(s.value.shape,n.shape,"The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),q_(s.grads),s}}function EV(t,e){q(Xu(t),()=>"The f passed in variableGrads(f) must be a function"),q(e==null||Array.isArray(e)&&e.every(u=>u instanceof eg),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");const n=e!=null;if(!n){e=[];for(const u in ye.registeredVariables)e.push(ye.registeredVariables[u])}const s=n?e.filter(u=>!u.trainable):null,r=e.length;e=e.filter(u=>u.trainable),q(e.length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${r} variables is trainable.`);const o=!0,{value:a,grads:i}=ye.gradients(t,e,null,o);q(i.some(u=>u!=null),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),q(a.rank===0,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${a.rank} tensor`);const l={};return e.forEach((u,c)=>{i[c]!=null&&(l[u.name]=i[c])}),s!=null&&s.forEach(u=>l[u.name]=null),{value:a,grads:l}}function Hi(t){return ye.customGrad(t)}function q_(t){if(t.filter(n=>n==null).length>0)throw new Error(`Cannot compute gradient of y=f(x) with respect to x. Make sure that
    the f you passed encloses all operations that lead from x to y.`)}function Tit(t){const n={x:te(t,"x","softplus")};return ye.runKernel(Up,n)}const af=be({softplus_:Tit});function Nit(t){const e=te(t,"x","logSigmoid");return Hi(s=>({value:Jn(af(Jn(s))),gradFunc:a=>Te(a,qa(Jn(s)))}))(e)}const Z8=be({logSigmoid_:Nit});function Iit(t,e){let n=te(t,"a","sub"),s=te(e,"b","sub");[n,s]=ds(n,s);const r={a:n,b:s};return ye.runKernel(Kp,r)}const $t=be({sub_:Iit});function Eit(t,e=-1){const n=te(t,"logits","logSoftmax");if(e===-1&&(e=n.rank-1),e!==n.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and axis was ${e}`);return Hi((r,o)=>{const i=Go(r,e,!0),l=$t(r,i),u=$t(ht(l,"float32"),xo(kt($o(l),e,!0)));return o([u]),{value:u,gradFunc:(d,f)=>{const[h]=f,p=!0,m=$o(h);return $t(d,Te(kt(d,e,p),m))}}})(n)}const X_=be({logSoftmax_:Eit});function Ait(t,e=null,n=!1){const s=te(t,"x","logSumExp"),r=un(e,s.shape),o=Go(s,r,!0),a=$t(s,o),i=$o(a),l=kt(i,r),u=xo(l),c=st(Ne(o,u.shape),u);if(n){const d=ys(c.shape,r);return Ne(c,d)}return c}const Y_=be({logSumExp_:Ait});function Oit(t,e){const n=te(t,"a","logicalAnd","bool"),s=te(e,"b","logicalAnd","bool");Zt(n.shape,s.shape);const r={a:n,b:s};return ye.runKernel(d1,r)}const Ta=be({logicalAnd_:Oit});function Rit(t){const n={x:te(t,"x","logicalNot","bool")};return ye.runKernel(f1,n)}const Z1=be({logicalNot_:Rit});function Dit(t,e){const n=te(t,"a","logicalOr","bool"),s=te(e,"b","logicalOr","bool");Zt(n.shape,s.shape);const r={a:n,b:s};return ye.runKernel(h1,r)}const Z_=be({logicalOr_:Dit});function Fit(t,e){const n=te(t,"a","logicalXor","bool"),s=te(e,"b","logicalXor","bool");return Zt(n.shape,s.shape),Ta(Z_(t,e),Z1(Ta(t,e)))}const J8=be({logicalXor_:Fit});const mv=2147483648;function Mit(t,e,n="left"){const s=te(t,"sortedSequence","searchSorted"),r=te(e,"values","searchSorted"),o=s.shape[s.shape.length-1],a=r.shape[r.shape.length-1],i=Ne(s,[-1,o]),l=Ne(r,[-1,a]);if(i.rank<2)throw new Error("Sorted input argument must be at least 2-dimensional");if(i.shape[0]!==l.shape[0])throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");if(Ge(l.shape)>=mv)throw new Error(`values tensor size must less than ${mv}`);if(i.shape[1]>=mv)throw new Error(`trailing dim_size must less than ${mv} for int32 output type, was ${i.shape[1]}`);const u={sortedSequence:i,values:l},c={side:n};return ye.runKernel(b_,u,c)}const J_=be({searchSorted_:Mit});function AV(t,e){return J_(t,e,"left")}function Pit(t,e,n,s,r){const o=te(t,"x","maxPool"),a=1;let i=o,l=!1;o.rank===3&&(l=!0,i=Ne(o,[1,o.shape[0],o.shape[1],o.shape[2]])),q(i.rank===4,()=>`Error in maxPool: input must be rank 4 but got rank ${i.rank}.`),q(ur(n,a),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${n} and dilations '${a}'`),Mr("maxPool",s,r);const u={x:i},c={filterSize:e,strides:n,pad:s,dimRoundingMode:r},d=ye.runKernel(g1,u,c);return l?Ne(d,[d.shape[1],d.shape[2],d.shape[3]]):d}const J1=be({maxPool_:Pit});function Lit(t,e=[1,1,1],n,s,r,o="NDHWC"){const a=te(t,"x","maxPool3d");let i=a,l=!1;a.rank===4&&(l=!0,i=Ne(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),q(i.rank===5,()=>`Error in maxPool3d: x must be rank 5 but got rank ${i.rank}.`),q(o==="NDHWC",()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${o}`),Mr("maxPool3d",s,r);const u={x:i},c={filterSize:e,strides:n,pad:s,dimRoundingMode:r,dataFormat:o},d=ye.runKernel(v1,u,c);return l?Ne(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}const Q8=be({maxPool3d_:Lit});function zit(t,e,n,s,r=!1){const a={x:te(t,"x","maxPoolWithArgmax")},i={filterSize:e,strides:n,pad:s,includeBatchInIndex:r},l=ye.runKernel(a_,a,i);return{result:l[0],indexes:l[1]}}const OV=be({maxPoolWithArgmax_:zit});function Bit(t,e){let n=te(t,"a","maximum"),s=te(e,"b","maximum");[n,s]=ds(n,s),n.dtype==="bool"&&(n=ht(n,"int32"),s=ht(s,"int32")),Zt(n.shape,s.shape);const r={a:n,b:s};return ye.runKernel(Ip,r)}const Zi=be({maximum_:Bit});function Vit(t,e=null,n=!1){const r={x:te(t,"x","mean")},o={axis:e,keepDims:n};return ye.runKernel(y1,r,o)}const us=be({mean_:Vit});function xs(t,e="float32"){if(Io(t),e==="complex64"){const s=xs(t,"float32"),r=xs(t,"float32");return El(s,r)}const n=or(Ge(t),e);return ye.makeTensor(n,t,e)}function po(t,e="float32"){if(Io(t),e==="complex64"){const s=po(t,"float32"),r=xs(t,"float32");return El(s,r)}const n=Ew(Ge(t),e);return ye.makeTensor(n,t,e)}function RV(t,e,{indexing:n="xy"}={}){if(n!=="xy"&&n!=="ij")throw new TypeError(`${n} is not a valid third argument to meshgrid`);if(t===void 0)return[];let s=te(t,"x","meshgrid",t instanceof $n?t.dtype:"float32");if(e===void 0)return[s];let r=te(e,"y","meshgrid",e instanceof $n?e.dtype:"float32");const o=Ge(s.shape),a=Ge(r.shape);return n==="xy"?(s=Ne(s,[1,-1]),r=Ne(r,[-1,1]),[ln(po([a,1],s.dtype),s),ln(r,po([1,o],r.dtype))]):(s=Ne(s,[-1,1]),r=Ne(r,[1,-1]),[ln(s,po([1,a],s.dtype)),ln(po([o,1],r.dtype),r)])}function Hit(t,e){let n=te(t,"a","minimum"),s=te(e,"b","minimum");[n,s]=ds(n,s),n.dtype==="bool"&&(n=ht(n,"int32"),s=ht(s,"int32")),Zt(n.shape,s.shape);const r={a:n,b:s};return ye.runKernel(Ep,r)}const om=be({minimum_:Hit});function Wit(t,e,n){q(n==="reflect"||n==="symmetric",()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${n}.`);const s=te(t,"x","mirrorPad");if(s.rank===0)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");q(e.length===s.rank,()=>`Padding doesn't match input. Must be ${s.rank}. Got ${e.length}.`);const r=n==="reflect"?1:0;for(let i=0;i<s.rank;i++)q(e[i].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),q(e[i][0]>=0&&e[i][0]<=s.shape[i]-r&&e[i][1]>=0&&e[i][1]<=s.shape[i]-r,()=>`Padding in dimension ${i} cannot be greater than or equal to ${s.shape[i]-r} or less than 0 for input of shape ${s.shape}`);const o={paddings:e,mode:n},a={x:s};return ye.runKernel(w1,a,o)}const eT=be({mirrorPad_:Wit});function Uit(t,e){let n=te(t,"a","mod"),s=te(e,"b","mod");[n,s]=ds(n,s);const r={a:n,b:s};return ye.runKernel(Ap,r)}const tT=be({mod_:Uit});function Git(t,e=null,n=!1){t=te(t,"x","moments");const s=un(e,t.shape),r=us(t,s,n);let o=r.shape;n||(o=ys(r.shape,s));const a=Dn($t(ht(t,"float32"),Ne(r,o))),i=us(a,s,n);return{mean:r,variance:i}}const Q1=be({moments_:Git});function jit(t,e,n,s){const r=te(e,"data","multiRNNCell"),o=ng(n,"c","multiRNNCell"),a=ng(s,"h","multiRNNCell");let i=r;const l=[];for(let d=0;d<t.length;d++){const f=t[d](i,o[d],a[d]);l.push(f[0]),l.push(f[1]),i=f[1]}const u=[],c=[];for(let d=0;d<l.length;d+=2)u.push(l[d]),c.push(l[d+1]);return[u,c]}const DV=be({multiRNNCell_:jit});function Kit(t,e,n,s=!1){const r=te(t,"logits","multinomial"),o=r.size,a=r.rank;if(o<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${o}.`);if(a>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${a}`);n=n||Math.random();const l={logits:a===1?Ne(r,[1,-1]):r},u={numSamples:e,seed:n,normalized:s},c=ye.runKernel(i_,l,u);return a===1?Ne(c,[c.size]):c}const FV=be({multinomial_:Kit});function qit(t,e){let n=te(t,"a","notEqual","string_or_numeric"),s=te(e,"b","notEqual","string_or_numeric");[n,s]=ds(n,s),Zt(n.shape,s.shape);const r={a:n,b:s};return ye.runKernel($1,r)}const Dd=be({notEqual_:qit});function Xit(t){const n={x:te(t,"x","onesLike")};return ye.runKernel(x1,n)}const So=be({onesLike_:Xit});function Yit(t,e){const n=te(t,"v1","outerProduct"),s=te(e,"v2","outerProduct");q(n.rank===1&&s.rank===1,()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${n.rank} and ${s.rank}.`);const r=Ne(n,[-1,1]),o=Ne(s,[1,-1]);return ln(r,o)}const MV=be({outerProduct_:Yit});function Zit(t,e,n=0){const s=te(t,"x","pad");if(s.rank===0)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const r={paddings:e,constantValue:n},o={x:s};return ye.runKernel(k1,o,r)}const Jl=be({pad_:Zit});function Jit(t,e,n=0){return q(e.length===2,()=>"Invalid number of paddings. Must be length of 2."),Jl(t,[e],n)}const PV=be({pad1d_:Jit});function Qit(t,e,n=0){return q(e.length===2&&e[0].length===2&&e[1].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),Jl(t,e,n)}const LV=be({pad2d_:Qit});function elt(t,e,n=0){return q(e.length===3&&e[0].length===2&&e[1].length===2&&e[2].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),Jl(t,e,n)}const zV=be({pad3d_:elt});function tlt(t,e,n=0){return q(e.length===4&&e[0].length===2&&e[1].length===2&&e[2].length===2&&e[3].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),Jl(t,e,n)}const BV=be({pad4d_:tlt});function nlt(t,e,n){const s=te(t,"x","spaceToBatchND");q(s.rank>=1+e.length,()=>`input rank ${s.rank} should be > than [blockShape] ${e.length}`),q(n.length===e.length,()=>`paddings.shape[0] ${n.length} must be equal to [blockShape] ${e.length}`),q(s.shape.reduce((a,i,l)=>l>0&&l<=e.length?a&&(i+n[l-1][0]+n[l-1][1])%e[l-1]===0:a,!0),()=>`input spatial dimensions ${s.shape.slice(1)} with paddings ${n.toString()} must be divisible by blockShapes ${e.toString()}`);const r={x:s},o={blockShape:e,paddings:n};return ye.runKernel(M1,r,o)}const e2=be({spaceToBatchND_:nlt});function slt(t,e,n,s,r,o,a){r==null&&(r=[1,1]),o==null&&(o=1),s===0&&(s="valid");const i=te(t,"x","maxPool");let l=i,u=!1;i.rank===3&&(u=!0,l=Ne(i,[1,i.shape[0],i.shape[1],i.shape[2]])),q(ur(o,r),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${o} and dilations '${r}'`);const c=Na(l.shape,e,o,r,s),d=[c.dilationHeight,c.dilationWidth];let f;s==="same"?f=olt([c.filterHeight,c.filterWidth],d):f=[[0,0],[0,0]];const h=d[0]===1&&d[1]===1,[p,m]=rlt([c.inHeight,c.inWidth],d,f),g=h?s:"valid",y=h?l:e2(l,d,p),b=(n==="avg"?()=>j1(y,e,o,g,a):()=>J1(y,e,o,g,a))(),_=h?b:K1(b,d,m);return u?Ne(_,[_.shape[1],_.shape[2],_.shape[3]]):_}function rlt(t,e,n){const s=n.map(c=>c[0]),r=n.map(c=>c[1]),o=t.concat(s,r),a=e.map((c,d)=>(c-o[d]%c)%c),i=r.map((c,d)=>c+a[d]),l=e.map((c,d)=>[s[d],i[d]]),u=e.map((c,d)=>[0,a[d]]);return[l,u]}function olt(t,e){const s=t.map((a,i)=>a+(a-1)*(e[i]-1)).map(a=>a-1),r=s.map(a=>Math.floor(a/2)),o=s.map((a,i)=>a-r[i]);return s.map((a,i)=>[r[i],o[i]])}const nT=be({pool_:slt});function alt(t,e){const n=te(t,"x","prelu"),s=te(e,"alpha","prelu"),r={x:n,alpha:s};return ye.runKernel(T1,r)}const t2=be({prelu_:alt});function ilt(t,e=null,n=!1){let s=te(t,"x","prod");s.dtype==="bool"&&(s=ht(s,"int32"));const r={x:s},o={axis:e,keepDims:n};return ye.runKernel(N1,r,o)}const sT=be({prod_:ilt});function llt(t,e,n,s){const r=t.map((c,d)=>te(c,`tensors${d}`,"raggedGather","int32")),o=te(e,"paramsDenseValues","raggedGather"),a=te(n,"indices","raggedGather","int32"),i={paramsNestedSplits:r,paramsDenseValues:o,indices:a},l={outputRaggedRank:s},u=ye.runKernel(d_,i,l);return{outputNestedSplits:u.slice(0,u.length-1),outputDenseValues:u[u.length-1]}}const VV=be({raggedGather_:llt});function ult(t,e,n){const s=te(t,"starts","raggedRange"),r=te(e,"limits","raggedRange",s.dtype),o=te(n,"deltas","raggedRange",s.dtype),a={starts:s,limits:r,deltas:o},i=ye.runKernel(f_,a);return{rtNestedSplits:i[0],rtDenseValues:i[1]}}const HV=be({raggedRange_:ult});function clt(t,e,n,s,r){const o=te(t,"shape","raggedTensorToTensor","int32"),a=te(e,"values","raggedTensorToTensor"),i=te(n,"defaultValue","raggedTensorToTensor",a.dtype),l=s.map((d,f)=>te(d,`tensors${f}`,"raggedTensorToTensor","int32")),u={shape:o,values:a,defaultValue:i,rowPartitionTensors:l},c={rowPartitionTypes:r};return ye.runKernel(h_,u,c)}const WV=be({raggedTensorToTensor_:clt});function dlt(t,e,n){Io(t);const s=Ge(t);let r=null;if(n==null||n==="float32")r=new Float32Array(s);else if(n==="int32")r=new Int32Array(s);else if(n==="bool")r=new Uint8Array(s);else throw new Error(`Unknown data type ${n}`);for(let o=0;o<s;o++)r[o]=e();return ye.makeTensor(r,t,n)}const UV=be({rand_:dlt});var GV={exports:{}};(function(t){(function(e,n,s){function r(l){var u=this,c=i();u.next=function(){var d=2091639*u.s0+u.c*23283064365386963e-26;return u.s0=u.s1,u.s1=u.s2,u.s2=d-(u.c=d|0)},u.c=1,u.s0=c(" "),u.s1=c(" "),u.s2=c(" "),u.s0-=c(l),u.s0<0&&(u.s0+=1),u.s1-=c(l),u.s1<0&&(u.s1+=1),u.s2-=c(l),u.s2<0&&(u.s2+=1),c=null}function o(l,u){return u.c=l.c,u.s0=l.s0,u.s1=l.s1,u.s2=l.s2,u}function a(l,u){var c=new r(l),d=u&&u.state,f=c.next;return f.int32=function(){return c.next()*4294967296|0},f.double=function(){return f()+(f()*2097152|0)*11102230246251565e-32},f.quick=f,d&&(typeof d=="object"&&o(d,c),f.state=function(){return o(c,{})}),f}function i(){var l=4022871197,u=function(c){c=String(c);for(var d=0;d<c.length;d++){l+=c.charCodeAt(d);var f=.02519603282416938*l;l=f>>>0,f-=l,f*=l,l=f>>>0,f-=l,l+=f*4294967296}return(l>>>0)*23283064365386963e-26};return u}n&&n.exports?n.exports=a:s&&s.amd?s(function(){return a}):this.alea=a})(wn,t,!1)})(GV);var jV={exports:{}};(function(t){(function(e,n,s){function r(i){var l=this,u="";l.x=0,l.y=0,l.z=0,l.w=0,l.next=function(){var d=l.x^l.x<<11;return l.x=l.y,l.y=l.z,l.z=l.w,l.w^=l.w>>>19^d^d>>>8},i===(i|0)?l.x=i:u+=i;for(var c=0;c<u.length+64;c++)l.x^=u.charCodeAt(c)|0,l.next()}function o(i,l){return l.x=i.x,l.y=i.y,l.z=i.z,l.w=i.w,l}function a(i,l){var u=new r(i),c=l&&l.state,d=function(){return(u.next()>>>0)/4294967296};return d.double=function(){do var f=u.next()>>>11,h=(u.next()>>>0)/4294967296,p=(f+h)/(1<<21);while(p===0);return p},d.int32=u.next,d.quick=d,c&&(typeof c=="object"&&o(c,u),d.state=function(){return o(u,{})}),d}n&&n.exports?n.exports=a:s&&s.amd?s(function(){return a}):this.xor128=a})(wn,t,!1)})(jV);var KV={exports:{}};(function(t){(function(e,n,s){function r(i){var l=this,u="";l.next=function(){var d=l.x^l.x>>>2;return l.x=l.y,l.y=l.z,l.z=l.w,l.w=l.v,(l.d=l.d+362437|0)+(l.v=l.v^l.v<<4^(d^d<<1))|0},l.x=0,l.y=0,l.z=0,l.w=0,l.v=0,i===(i|0)?l.x=i:u+=i;for(var c=0;c<u.length+64;c++)l.x^=u.charCodeAt(c)|0,c==u.length&&(l.d=l.x<<10^l.x>>>4),l.next()}function o(i,l){return l.x=i.x,l.y=i.y,l.z=i.z,l.w=i.w,l.v=i.v,l.d=i.d,l}function a(i,l){var u=new r(i),c=l&&l.state,d=function(){return(u.next()>>>0)/4294967296};return d.double=function(){do var f=u.next()>>>11,h=(u.next()>>>0)/4294967296,p=(f+h)/(1<<21);while(p===0);return p},d.int32=u.next,d.quick=d,c&&(typeof c=="object"&&o(c,u),d.state=function(){return o(u,{})}),d}n&&n.exports?n.exports=a:s&&s.amd?s(function(){return a}):this.xorwow=a})(wn,t,!1)})(KV);var qV={exports:{}};(function(t){(function(e,n,s){function r(i){var l=this;l.next=function(){var c=l.x,d=l.i,f,h;return f=c[d],f^=f>>>7,h=f^f<<24,f=c[d+1&7],h^=f^f>>>10,f=c[d+3&7],h^=f^f>>>3,f=c[d+4&7],h^=f^f<<7,f=c[d+7&7],f=f^f<<13,h^=f^f<<9,c[d]=h,l.i=d+1&7,h};function u(c,d){var f,h=[];if(d===(d|0))h[0]=d;else for(d=""+d,f=0;f<d.length;++f)h[f&7]=h[f&7]<<15^d.charCodeAt(f)+h[f+1&7]<<13;for(;h.length<8;)h.push(0);for(f=0;f<8&&h[f]===0;++f);for(f==8?h[7]=-1:h[f],c.x=h,c.i=0,f=256;f>0;--f)c.next()}u(l,i)}function o(i,l){return l.x=i.x.slice(),l.i=i.i,l}function a(i,l){i==null&&(i=+new Date);var u=new r(i),c=l&&l.state,d=function(){return(u.next()>>>0)/4294967296};return d.double=function(){do var f=u.next()>>>11,h=(u.next()>>>0)/4294967296,p=(f+h)/(1<<21);while(p===0);return p},d.int32=u.next,d.quick=d,c&&(c.x&&o(c,u),d.state=function(){return o(u,{})}),d}n&&n.exports?n.exports=a:s&&s.amd?s(function(){return a}):this.xorshift7=a})(wn,t,!1)})(qV);var XV={exports:{}};(function(t){(function(e,n,s){function r(i){var l=this;l.next=function(){var c=l.w,d=l.X,f=l.i,h,p;return l.w=c=c+1640531527|0,p=d[f+34&127],h=d[f=f+1&127],p^=p<<13,h^=h<<17,p^=p>>>15,h^=h>>>12,p=d[f]=p^h,l.i=f,p+(c^c>>>16)|0};function u(c,d){var f,h,p,m,g,y=[],w=128;for(d===(d|0)?(h=d,d=null):(d=d+"\0",h=0,w=Math.max(w,d.length)),p=0,m=-32;m<w;++m)d&&(h^=d.charCodeAt((m+32)%d.length)),m===0&&(g=h),h^=h<<10,h^=h>>>15,h^=h<<4,h^=h>>>13,m>=0&&(g=g+1640531527|0,f=y[m&127]^=h+g,p=f==0?p+1:0);for(p>=128&&(y[(d&&d.length||0)&127]=-1),p=127,m=4*128;m>0;--m)h=y[p+34&127],f=y[p=p+1&127],h^=h<<13,f^=f<<17,h^=h>>>15,f^=f>>>12,y[p]=h^f;c.w=g,c.X=y,c.i=p}u(l,i)}function o(i,l){return l.i=i.i,l.w=i.w,l.X=i.X.slice(),l}function a(i,l){i==null&&(i=+new Date);var u=new r(i),c=l&&l.state,d=function(){return(u.next()>>>0)/4294967296};return d.double=function(){do var f=u.next()>>>11,h=(u.next()>>>0)/4294967296,p=(f+h)/(1<<21);while(p===0);return p},d.int32=u.next,d.quick=d,c&&(c.X&&o(c,u),d.state=function(){return o(u,{})}),d}n&&n.exports?n.exports=a:s&&s.amd?s(function(){return a}):this.xor4096=a})(wn,t,!1)})(XV);var YV={exports:{}};(function(t){(function(e,n,s){function r(i){var l=this,u="";l.next=function(){var d=l.b,f=l.c,h=l.d,p=l.a;return d=d<<25^d>>>7^f,f=f-h|0,h=h<<24^h>>>8^p,p=p-d|0,l.b=d=d<<20^d>>>12^f,l.c=f=f-h|0,l.d=h<<16^f>>>16^p,l.a=p-d|0},l.a=0,l.b=0,l.c=-1640531527,l.d=1367130551,i===Math.floor(i)?(l.a=i/4294967296|0,l.b=i|0):u+=i;for(var c=0;c<u.length+20;c++)l.b^=u.charCodeAt(c)|0,l.next()}function o(i,l){return l.a=i.a,l.b=i.b,l.c=i.c,l.d=i.d,l}function a(i,l){var u=new r(i),c=l&&l.state,d=function(){return(u.next()>>>0)/4294967296};return d.double=function(){do var f=u.next()>>>11,h=(u.next()>>>0)/4294967296,p=(f+h)/(1<<21);while(p===0);return p},d.int32=u.next,d.quick=d,c&&(typeof c=="object"&&o(c,u),d.state=function(){return o(u,{})}),d}n&&n.exports?n.exports=a:s&&s.amd?s(function(){return a}):this.tychei=a})(wn,t,!1)})(YV);var ZV={exports:{}};const flt={},hlt=Object.freeze(Object.defineProperty({__proto__:null,default:flt},Symbol.toStringTag,{value:"Module"})),plt=Mg(hlt);(function(t){(function(e,n,s){var r=256,o=6,a=52,i="random",l=s.pow(r,o),u=s.pow(2,a),c=u*2,d=r-1,f;function h(_,$,x){var k=[];$=$==!0?{entropy:!0}:$||{};var C=y(g($.entropy?[_,b(n)]:_??w(),3),k),T=new p(k),N=function(){for(var M=T.g(o),R=l,D=0;M<u;)M=(M+D)*r,R*=r,D=T.g(1);for(;M>=c;)M/=2,R/=2,D>>>=1;return(M+D)/R};return N.int32=function(){return T.g(4)|0},N.quick=function(){return T.g(4)/4294967296},N.double=N,y(b(T.S),n),($.pass||x||function(M,R,D,z){return z&&(z.S&&m(z,T),M.state=function(){return m(T,{})}),D?(s[i]=M,R):M})(N,C,"global"in $?$.global:this==s,$.state)}function p(_){var $,x=_.length,k=this,C=0,T=k.i=k.j=0,N=k.S=[];for(x||(_=[x++]);C<r;)N[C]=C++;for(C=0;C<r;C++)N[C]=N[T=d&T+_[C%x]+($=N[C])],N[T]=$;(k.g=function(M){for(var R,D=0,z=k.i,B=k.j,V=k.S;M--;)R=V[z=d&z+1],D=D*r+V[d&(V[z]=V[B=d&B+R])+(V[B]=R)];return k.i=z,k.j=B,D})(r)}function m(_,$){return $.i=_.i,$.j=_.j,$.S=_.S.slice(),$}function g(_,$){var x=[],k=typeof _,C;if($&&k=="object")for(C in _)try{x.push(g(_[C],$-1))}catch{}return x.length?x:k=="string"?_:_+"\0"}function y(_,$){for(var x=_+"",k,C=0;C<x.length;)$[d&C]=d&(k^=$[d&C]*19)+x.charCodeAt(C++);return b($)}function w(){try{var _;return f&&(_=f.randomBytes)?_=_(r):(_=new Uint8Array(r),(e.crypto||e.msCrypto).getRandomValues(_)),b(_)}catch{var $=e.navigator,x=$&&$.plugins;return[+new Date,e,x,e.screen,b(n)]}}function b(_){return String.fromCharCode.apply(0,_)}if(y(s.random(),n),t.exports){t.exports=h;try{f=plt}catch{}}else s["seed"+i]=h})(typeof self<"u"?self:wn,[],Math)})(ZV);var mlt=GV.exports,glt=jV.exports,vlt=KV.exports,ylt=qV.exports,blt=XV.exports,wlt=YV.exports,lf=ZV.exports;lf.alea=mlt;lf.xor128=glt;lf.xorwow=vlt;lf.xorshift7=ylt;lf.xor4096=blt;lf.tychei=wlt;var Ji=lf;let rT=class{constructor(e,n,s,r,o){this.mean=e,this.stdDev=n,this.dtype=s,this.nextVal=NaN,this.truncated=r,this.truncated&&(this.upper=this.mean+this.stdDev*2,this.lower=this.mean-this.stdDev*2);const a=o||Math.random();this.random=Ji.alea(a.toString())}nextValue(){if(!isNaN(this.nextVal)){const r=this.nextVal;return this.nextVal=NaN,r}let e,n,s=!1;for(;!s;){let r,o,a;do r=2*this.random()-1,o=2*this.random()-1,a=r*r+o*o;while(a>=1||a===0);const i=Math.sqrt(-2*Math.log(a)/a);e=this.mean+this.stdDev*r*i,n=this.mean+this.stdDev*o*i,(!this.truncated||this.isValidTruncated(e))&&(s=!0)}return(!this.truncated||this.isValidTruncated(n))&&(this.nextVal=this.convertValue(n)),this.convertValue(e)}convertValue(e){return this.dtype==null||this.dtype==="float32"?e:Math.round(e)}isValidTruncated(e){return e<=this.upper&&e>=this.lower}},_lt=class{constructor(e,n,s,r){this.alpha=e,this.beta=1/n,this.dtype=s;const o=r||Math.random();this.randu=Ji.alea(o.toString()),this.randn=new rT(0,1,s,!1,this.randu()),e<1?this.d=e+2/3:this.d=e-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let e,n,s,r,o,a;for(;;){do r=this.randn.nextValue(),a=1+this.c*r;while(a<=0);if(a*=a*a,e=r*r,n=1-.331*e*e,s=.5*e+this.d*(1-a+Math.log(a)),o=this.randu(),o<n||Math.log(o)<s)break}return a=1/this.beta*this.d*a,this.alpha<1&&(a*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(a)}convertValue(e){return this.dtype==="float32"?e:Math.round(e)}},$lt=class{constructor(e=0,n=1,s,r){if(this.canReturnFloat=()=>this.dtype==null||this.dtype==="float32",this.min=e,this.range=n-e,this.dtype=s,r==null&&(r=Math.random()),typeof r=="number"&&(r=r.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${e} - ${n} <= 1 and dtype is not float`);this.random=Ji.alea(r)}convertValue(e){return this.canReturnFloat()?e:Math.round(e)}nextValue(){return this.convertValue(this.min+this.range*this.random())}};function xlt(t,e,n=1,s="float32",r){if(Io(t),n==null&&(n=1),s==null&&(s="float32"),s!=="float32"&&s!=="int32")throw new Error(`Unsupported data type ${s}`);const o=new _lt(e,n,s,r),a=tn(t,s);for(let i=0;i<a.values.length;i++)a.values[i]=o.nextValue();return a.toTensor()}const JV=be({randomGamma_:xlt});function Slt(t,e=0,n=1,s,r){if(Io(t),s!=null&&s==="bool")throw new Error(`Unsupported data type ${s}`);const o=new rT(e,n,s,!1,r),a=tn(t,s);for(let i=0;i<a.values.length;i++)a.values[i]=o.nextValue();return a.toTensor()}const Q_=be({randomNormal_:Slt});function Clt(t,e,n){if(e!=null&&e==="bool")throw new Error(`Unsupported data type ${e}`);return Q_(t,0,1,e,n)}const QV=be({randomStandardNormal_:Clt});function klt(t,e=0,n=1,s="float32",r){Io(t);const o=tn(t,s),a=new $lt(e,n,null,r);for(let i=0;i<o.values.length;i++)o.values[i]=a.nextValue();return o.toTensor()}const am=be({randomUniform_:klt});function Fd(t,e,n=1,s="float32"){if(n===0)throw new Error("Cannot have a step of zero");const r={start:t,stop:e,step:n,dtype:s};return ye.runKernel(p_,{},r)}function Tlt(t){const n={x:te(t,"x","reciprocal")};return ye.runKernel(Dp,n)}const oT=be({reciprocal_:Tlt});function Nlt(t){const n={x:te(t,"x","relu")};return ye.runKernel(Fp,n)}const li=be({relu_:Nlt});function Ilt(t){const n={x:te(t,"x","relu6")};return ye.runKernel(Mp,n)}const e3=be({relu6_:Ilt});function Elt(t,e){const s={x:te(t,"x","reverse")},r={dims:e};return ye.runKernel(O1,s,r)}const Xo=be({reverse_:Elt});function Alt(t){const e=te(t,"x","reverse");return q(e.rank===1,()=>`Error in reverse1D: x must be rank 1 but got rank ${e.rank}.`),Xo(e,0)}const eH=be({reverse1d_:Alt});function Olt(t,e){const n=te(t,"x","reverse");return q(n.rank===2,()=>`Error in reverse2D: x must be rank 2 but got rank ${n.rank}.`),Xo(n,e)}const tH=be({reverse2d_:Olt});function Rlt(t,e){const n=te(t,"x","reverse");return q(n.rank===3,()=>`Error in reverse3D: x must be rank 3 but got rank ${n.rank}.`),Xo(n,e)}const nH=be({reverse3d_:Rlt});function Dlt(t,e){const n=te(t,"x","reverse");return q(n.rank===4,()=>`Error in reverse4D: x must be rank 4 but got rank ${n.rank}.`),Xo(n,e)}const sH=be({reverse4d_:Dlt});function Flt(t){const n={x:te(t,"x","round")};return ye.runKernel(Pp,n)}const t3=be({round_:Flt});function Mlt(t){const n={x:te(t,"x","rsqrt","float32")};return ye.runKernel(Lp,n)}const n3=be({rsqrt_:Mlt});function Plt(t){const n={x:te(t,"x","selu")};return ye.runKernel(zp,n)}const s3=be({selu_:Plt});function Llt(t,e,n,s,r,o=[1,1],a="NHWC"){const i=te(t,"x","separableConv2d"),l=te(e,"depthwiseFilter","separableConv2d"),u=te(n,"pointwiseFilter","separableConv2d");let c=i,d=!1;if(i.rank===3&&(d=!0,c=Ne(i,[1,i.shape[0],i.shape[1],i.shape[2]])),a==="NCHW")throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");q(c.rank===4,()=>`Error in separableConv2d: input must be rank 4, but got rank ${c.rank}.`),q(l.rank===4,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${l.rank}.`),q(u.rank===4,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${l.rank}.`),q(u.shape[0]===1,()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${u.shape[0]}.`),q(u.shape[1]===1,()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${u.shape[1]}.`);const f=l.shape[2],h=l.shape[3];q(u.shape[2]===f*h,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${f*h}, but got ${u.shape[2]}.`);const p=em(c,l,s,r,a,o),g=Al(p,u,1,"valid",a);return d?Ne(g,[g.shape[1],g.shape[2],g.shape[3]]):g}const r3=be({separableConv2d_:Llt});async function zlt(t,e){const n=te(t,"x","setdiff1d"),s=te(e,"y","setdiff1d");q(n.dtype===s.dtype,()=>`x and y should have the same dtype, but got x (${n.dtype}) and y (${s.dtype}).`),q(n.rank===1,()=>`x should be 1D tensor, but got x (${n.shape}).`),q(s.rank===1,()=>`y should be 1D tensor, but got y (${s.shape}).`);const r=await n.data(),o=await s.data(),a=new Set(o);let i=0;for(let c=0;c<r.length;c++)a.has(r[c])||i++;const l=new Ds([i],n.dtype),u=new Ds([i],"int32");for(let c=0,d=0;c<r.length;c++)a.has(r[c])||(l.values[d]=r[c],u.values[d]=c,d++);return[l.toTensor(),u.toTensor()]}const rH=zlt;function Blt(t){const n={x:te(t,"x","sign")};return ye.runKernel(Hp,n)}const aT=be({sign_:Blt});function Vlt(t){const n={x:te(t,"x","sin","float32")};return ye.runKernel(Bp,n)}const o3=be({sin_:Vlt});function Hlt(t){const n={x:te(t,"x","sinh")};return ye.runKernel(Vp,n)}const a3=be({sinh_:Hlt});function Wlt(t,e,n){const s=te(t,"x","slice1d");return q(s.rank===1,()=>`slice1d expects a rank-1 tensor, but got a rank-${s.rank} tensor`),mn(s,[e],[n])}const n2=be({slice1d_:Wlt});function Ult(t,e,n){const s=te(t,"x","slice2d");return q(s.rank===2,()=>`slice2d expects a rank-2 tensor, but got a rank-${s.rank} tensor`),mn(s,e,n)}const i3=be({slice2d_:Ult});function Glt(t,e,n){const s=te(t,"x","slice3d");return q(s.rank===3,()=>`slice3d expects a rank-3 tensor, but got a rank-${s.rank} tensor`),mn(s,e,n)}const s2=be({slice3d_:Glt});function jlt(t,e,n){const s=te(t,"x","slice4d");return q(s.rank===4,()=>`slice4d expects a rank-4 tensor, but got a rank-${s.rank} tensor`),mn(s,e,n)}const Th=be({slice4d_:jlt});function Klt(t,e=-1){const n=te(t,"logits","softmax","float32");if(e===-1&&(e=n.rank-1),e!==n.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and dim was ${e}`);const s={logits:n},r={dim:e};return ye.runKernel(L1,s,r)}const r2=be({softmax_:Klt});function qlt(t){q(t.dtype==="complex64",()=>`The dtype for tf.spectral.fft() must be complex64 but got ${t.dtype}.`);const e={input:t};return ye.runKernel(Yw,e)}const o2=be({fft_:qlt});function Xlt(t){q(t.dtype==="complex64",()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${t.dtype}.`);const e={input:t};return ye.runKernel(e_,e)}const Nh=be({ifft_:Xlt});function Ylt(t){const e=t.shape[t.shape.length-1],n=t.size/e;let s;if(e<=2){const r=Ne(t,[n,e]);s=Nh(r)}else{const r=[n,2*(e-1)],o=Ne(Ch(t),[n,e]),a=Ne(U1(t),[n,e]),i=Xo(mn(o,[0,1],[n,e-2]),1),l=Te(Xo(mn(a,[0,1],[n,e-2]),1),Pt(-1)),u=vs([o,i],1),c=vs([a,l],1),d=Ne(El(u,c),[r[0],r[1]]);s=Nh(d)}if(s=Ch(s),t.rank===3&&t.shape[0]!==0){const r=s,o=t.shape[0];s=Ne(s,[o,s.shape[0]/o,s.shape[1]]),r.dispose()}return s}const l3=be({irfft_:Ylt});function Zlt(t,e,n=0){const r={x:te(t,"x","split")},o={numOrSizeSplits:e,axis:n};return ye.runKernel(P1,r,o)}const Kr=be({split_:Zlt});function Jlt(t,e){q(t.dtype==="float32",()=>`The dtype for rfft() must be real value but got ${t.dtype}`);let n=t.shape[t.shape.length-1];const s=t.size/n;let r;if(e!=null&&e<n){const p=t.shape.map(g=>0),m=t.shape.map(g=>g);m[t.shape.length-1]=e,r=mn(t,p,m),n=e}else if(e!=null&&e>n){const p=t.shape.map(m=>m);p[t.shape.length-1]=e-n,r=vs([t,xs(p)],t.shape.length-1),n=e}else r=t;const o=yn(r),a=Ne(El(r,o),[s,n]),i=o2(a),l=Math.floor(n/2)+1,u=Ch(i),c=U1(i),d=Kr(u,[l,n-l],u.shape.length-1),f=Kr(c,[l,n-l],c.shape.length-1),h=r.shape.slice();return h[r.shape.length-1]=l,Ne(El(d[0],f[0]),h)}const a2=be({rfft_:Jlt});function Qlt(t,e){let n=te(t,"a","squaredDifference"),s=te(e,"b","squaredDifference");[n,s]=ds(n,s),Zt(n.shape,s.shape);const r={a:n,b:s},o={};return ye.runKernel(jp,r,o)}const u3=be({squaredDifference_:Qlt});function eut(t,e){const n=te(t,"x","squeeze","string_or_numeric");return Ne(n,Kl(n.shape,e).newShape)}const gc=be({squeeze_:eut});function tut(t,e=0){const n=ng(t,"tensors","stack","string_or_numeric");q(n.length>=1,()=>"Pass at least one tensor to tf.stack"),n.length>0&&q(e<=n[0].rank,()=>"Axis must be <= rank of the tensor");const s=n,r={axis:e};return ye.runKernel(C1,s,r)}const Jr=be({stack_:tut});function nut(t,e=0){const s={x:te(t,"x","step")},r={alpha:e};return ye.runKernel(Zp,s,r)}const uf=be({step_:nut});function sut(t,e,n,s,r=0,o=0,a=0,i=0,l=0){const c={x:te(t,"x","stridedSlice","string_or_numeric")},d={begin:e,end:n,strides:s,beginMask:r,endMask:o,ellipsisMask:a,newAxisMask:i,shrinkAxisMask:l};return ye.runKernel(k_,c,d)}const iT=be({stridedSlice_:sut});function rut(t){const n={x:te(t,"x","tan","float32")};return ye.runKernel(qp,n)}const lT=be({tan_:rut});function vr(t,e){ef(t);const n=Vi(t,e);if(n.length!==1)throw new Error("tensor1d() requires values to be a flat/TypedArray");return fc(t,null,n,e)}function Mu(t,e,n){if(ef(t),e!=null&&e.length!==2)throw new Error("tensor2d() requires shape to have two numbers");const s=Vi(t,n);if(s.length!==2&&s.length!==1)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(s.length===1&&e==null)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return fc(t,e,s,n)}function oH(t,e,n){if(ef(t),e!=null&&e.length!==4)throw new Error("tensor4d() requires shape to have four numbers");const s=Vi(t,n);if(s.length!==4&&s.length!==1)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(s.length===1&&e==null)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return fc(t,e,s,n)}function aH(t,e,n){if(ef(t),e!=null&&e.length!==5)throw new Error("tensor5d() requires shape to have five numbers");const s=Vi(t,n);if(s.length!==5&&s.length!==1)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(s.length===1&&e==null)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return fc(t,e,s,n)}function iH(t,e,n){if(ef(t),e!=null&&e.length!==6)throw new Error("tensor6d() requires shape to have six numbers");const s=Vi(t,n);if(s.length!==6&&s.length!==1)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(s.length===1&&e==null)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return e=e||s,fc(t,e,s,n)}function out(t,e=1,n=!0){const s=te(t,"x","topk");if(s.rank===0)throw new Error("topk() expects the input to be of rank 1 or higher");const r=s.shape[s.shape.length-1];if(e<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${e}`);if(e>r)throw new Error(`'k' passed to topk() must be <= the last dimension (${r}) but got ${e}`);const o={x:s},a={k:e,sorted:n},[i,l]=ye.runKernel(E_,o,a);return{values:i,indices:l}}const uT=be({topk_:out});function aut(t,e=0,n=1,s,r){if(Io(t),s!=null&&s==="bool")throw new Error("Unsupported data type $ { dtype }");const o=new rT(e,n,s,!0,r),a=tn(t,s);for(let i=0;i<a.values.length;i++)a.values[i]=o.nextValue();return a.toTensor()}const c3=be({truncatedNormal_:aut});function iut(t,e=0){const n=te(t,"x","unique","string_or_numeric");q(n.rank>0,()=>"The input tensor must be at least 1D");const s={x:n},r={axis:e},[o,a]=ye.runKernel(O_,s,r);return{values:o,indices:a}}const cT=be({unique_:iut});function lut(t,e,n){const s=te(t,"x","unsortedSegmentSum"),r=te(e,"segmentIds","unsortedSegmentSum","int32");q(Nd(n),()=>"numSegments must be of dtype int");const o={x:s,segmentIds:r},a={numSegments:n};return ye.runKernel(B1,o,a)}const d3=be({unsortedSegmentSum_:lut});function uut(t,e=0){const n=te(t,"x","unstack","string_or_numeric");q(e>=-n.shape.length&&e<n.shape.length,()=>`Axis = ${e} is not in [-${n.shape.length}, ${n.shape.length})`);const s={value:n},r={axis:e};return ye.runKernel(z1,s,r)}const Yo=be({unstack_:uut});function lH(t,e){return J_(t,e,"right")}function dT(t,e=!0,n,s){return ye.makeVariable(t,e,n,s)}function f3(t,e){const n=[];for(let o=0;o<e.length;o++)e[o]&&n.push(o);const s=tn(t,"int32"),r=tn([n.length,t.length],"int32");for(let o=0;o<n.length;o++){const a=s.indexToLoc(n[o]),i=o*t.length;r.values.set(a,i)}return r.toTensor()}async function cut(t){const e=te(t,"condition","whereAsync","bool"),n=await e.data(),s=f3(e.shape,n);return t!==e&&e.dispose(),s}const fT=cut;async function dut(t,e,n){const s=te(t,"tensor","boolMask"),r=te(e,"mask","boolMask","bool"),o=n??0,a=r.rank,i=s.shape;q(a>0,()=>"mask cannot be scalar"),lr(i.slice(o,o+a),r.shape,"mask's shape must match the first K dimensions of tensor's shape,");let l=1;for(let m=o;m<o+a;m++)l*=i[m];const u=i.slice(0,o).concat([l],i.slice(o+a)),c=Ne(s,u),d=Ne(r,[-1]),f=await fT(d),h=gc(f,[1]),p=rm(c,h,o);return t!==s&&s.dispose(),e!==r&&r.dispose(),h.dispose(),c.dispose(),d.dispose(),f.dispose(),p}const uH=dut;function fut(t,e,n,s,r=!0){const o=te(t,"v","movingAverage"),a=te(e,"x","movingAverage"),i=te(n,"decay","movingAverage");BB(o,a),q(hn(o.shape,a.shape),()=>"Shape mismatch in v and x");const l=Pt(1),u=$t(l,i);let c=Te($t(a,o),u);if(r){q(s!=null,()=>"When using zeroDebias: true, step is required.");const d=te(s,"step","movingAverage");c=Et(c,$t(l,Ol(i,d)))}return st(o,c)}const cH=be({movingAverage_:fut});function hut(t,e,n){Io(n);const s=te(t,"indices","scatterND","int32"),r=te(e,"updates","scatterND");u8(r,s,n);const o={indices:s,updates:r},a={shape:n};return ye.runKernel(y_,o,a)}const dH=be({scatterND_:hut});function put(t,e,n,s){if(t.dtype!=="int32")throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);if(t.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${t.shape}.`);const r=t.rank>0?t.shape[0]:1,o=t.rank>1?t.shape[1]:1;if(n.length!==o)throw new Error(`outputShape has incorrect number of elements:, ${n.length}, should be: ${o}.`);const a=e.size;if(!(e.rank===0||e.rank===1&&a===r))throw new Error(`sparseValues has incorrect shape ${e.shape}, should be [] or [${r}]`);if(e.dtype!==s.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}function mut(t,e,n,s=0){Io(n);const r=te(t,"sparseIndices","sparseToDense","int32"),o=te(e,"sparseValues","sparseToDense","string_or_numeric"),a=te(s,"defaultValue","sparseToDense",o.dtype);put(r,o,n,a);const i={sparseIndices:r,sparseValues:o,defaultValue:a},l={outputShape:n};return ye.runKernel(S_,i,l)}const fH=be({sparseToDense_:mut});function gut(t,e){const n=te(e,"indices","gatherND","int32"),r={params:te(t,"x","gatherND","string_or_numeric"),indices:n};return ye.runKernel(Qw,r)}const hH=be({gatherND_:gut});function vut(t,e){if(e==null)return t.shape.slice();if(hn(t.shape,e))return e;if(t.shape.length===e.length){const n=[];for(let s=0;s<t.shape.length;s++)e[s]==null&&t.shape[s]!=null?n.push(t.shape[s]):n.push(e[s]);return n}return e}function yut(t,e,n,s){const r=te(t,"x","dropout");if(q(r.dtype==="float32",()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${r.dtype} tensor instead.`),q(e>=0&&e<1,()=>`rate must be a float in the range [0, 1), but got ${e}.`),e===0)return t instanceof $n?r.clone():r;const o=vut(r,n),a=1-e,i=Et(sm(st(am(o,0,1,"float32",s),a)),a);return Te(r,i)}const hT=be({dropout_:yut});function pT(t){return Math.floor(Math.pow(2,Math.ceil(Math.log(t)/Math.log(2))))}function h3(t,e,n){const s=1-t%2,r=new Float32Array(t);for(let o=0;o<t;++o){const a=2*Math.PI*o/(t+s-1);r[o]=e-n*Math.cos(a)}return vr(r,"float32")}async function but(t,e,n=1){const s=te(t,"predictions","inTopK"),r=te(e,"targets","inTopK");q(s.rank>1,()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${s.rank}`),q(s.rank-1===r.rank,()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${s.rank} and targets rank ${r.rank}`),lr(s.shape.slice(0,s.shape.length-1),r.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");const o=s.shape[s.shape.length-1];q(n>0&&n<=o,()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${o}), but got ${n}`);const a=await s.data(),i=await r.data(),[l,u]=[a.length/o,o],c=zs("bool",l);for(let d=0;d<l;d++){const f=d*u,h=a.subarray(f,f+u),p=[];for(let m=0;m<h.length;m++)p.push({value:h[m],index:m});p.sort((m,g)=>g.value-m.value),c[d]=0;for(let m=0;m<n;m++)if(p[m].index===i[d]){c[d]=1;break}}return t!==s&&s.dispose(),e!==r&&r.dispose(),yo(c,r.shape,"bool")}const pH=but;function wut(t,e,n,s,r,o="NHWC",a){let i=t;t.rank===3&&(i=Ne(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let l=e;l.rank===3&&(l=Ne(e,[1,e.shape[0],e.shape[1],e.shape[2]])),q(i.rank===4,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${i.shape}.`),q(l.rank===4,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${l.shape}.`),q(n.length===4,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${n}.`);const u=o==="NHWC"?i.shape[3]:i.shape[1],c=o==="NHWC"?l.shape[3]:l.shape[1];q(u===n[2],()=>`Error in conv2dDerFilter: depth of input ${u}) must match input depth in filter (${n[2]}.`),q(c===n[3],()=>`Error in conv2dDerFilter: depth of dy (${c}) must match output depth for filter (${n[3]}).`),Mr("conv2dDerFilter",r,a);const d={x:i,dy:l},f={strides:s,pad:r,dataFormat:o,dimRoundingMode:a,filterShape:n};return ye.runKernel(Lw,d,f)}const mT=be({conv2DBackpropFilter_:wut});function p3(t,e,n){if(n==null||n==="linear")return t;if(n==="relu")return Te(t,uf(e));throw new Error(`Cannot compute gradient for fused activation ${n}.`)}function m3(t,e){let n=e;const s=Ts(t.shape,e.shape);return s.length>0&&(n=kt(n,s)),Ne(n,t.shape)}function g3(t,e,n,s){if(e==="linear")return t;if(e==="relu")return li(t);if(e==="elu")return tm(t);if(e==="relu6")return e3(t);if(e==="prelu")return t2(t,n);if(e==="leakyrelu")return X1(t,s);if(e==="sigmoid")return qa(t);throw new Error(`Unknown fused activation ${e}.`)}const v3=(t,e)=>!(t>0)||e==="linear";function _ut({x:t,filter:e,strides:n,pad:s,dataFormat:r="NHWC",dilations:o=[1,1],dimRoundingMode:a,bias:i,activation:l="linear",preluActivationWeights:u,leakyreluAlpha:c}){if(l=l||"linear",v3(ye.state.gradientDepth,l)===!1){q(r==="NHWC",()=>`Error in fused conv2d: got dataFormat of ${r} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);let x=Al(t,e,n,s,r,o,a);return i!=null&&(x=st(x,i)),g3(x,l,u,c)}const d=te(t,"x","conv2d","float32"),f=te(e,"filter","conv2d","float32");let h=d,p=!1;d.rank===3&&(p=!0,h=Ne(d,[1,d.shape[0],d.shape[1],d.shape[2]])),q(h.rank===4,()=>`Error in fused conv2d: input must be rank 4, but got rank ${h.rank}.`),q(f.rank===4,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${f.rank}.`),Mr("fused conv2d",s,a);const m=r==="NHWC"?h.shape[3]:h.shape[1];q(f.shape[2]===m,()=>`Error in conv2d: depth of input (${m}) must match input depth for filter ${f.shape[2]}.`),q(ur(n,o),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${o}'`);const g=Gs(h.shape,f.shape,n,o,s,a);let y;i!=null&&(y=te(i,"bias","fused conv2d"),[y]=ds(y,d),r==="NHWC"?Zt(g.outShape,y.shape):(q(y.shape.length<=1,()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${y.shape.length}.`),q(y.shape.length===0||y.shape[0]===g.outChannels||y.shape[0]===1,()=>`Error in fused conv2d: bias shape (${y.shape}) is not compatible with the number of output channels (${g.outChannels})`)));let w;if(u!=null){const x=u.shape;if(q(x.length<=1||x.length===3,()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${x.length}.`),x.length===1)q(x[0]===1||x[0]===g.outChannels,()=>`Error in fused conv2d: PReLU activation weights (${x}) is not compatible with the number of output channels (${g.outChannels}).`);else if(x.length===3)try{Zt(x,g.outShape)}catch{const C=`Error in fused conv2d: PReLU activation weights (${x}) is not compatible with the output shape of the conv2d (${g.outShape}).`;throw Error(C)}w=te(u,"prelu weights","fused conv2d")}const b=(x,k)=>{q(r==="NHWC",()=>`Error in gradient of fused conv2D: got dataFormat of ${r} but only NHWC is currently supported.`);const[C,T,N,M]=k,R=p3(x,N,l);q(Zu(o),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${o}'`);const D=M8(T.shape,R,C,n,s),z=mT(T,R,C.shape,n,s),B=[D,z];if(M!=null){const V=m3(M,R);B.push(V)}return B},_={x:h,filter:f,bias:y,preluActivationWeights:w},$={strides:n,pad:s,dataFormat:r,dilations:o,dimRoundingMode:a,activation:l,leakyreluAlpha:c};return i==null?Hi((k,C,T)=>{let N=ye.runKernel(Z0,_,$);return T([C,k,N]),p&&(N=Ne(N,[N.shape[1],N.shape[2],N.shape[3]])),{value:N,gradFunc:b}})(h,f):Hi((k,C,T,N)=>{let M=ye.runKernel(Z0,_,$);return N([C,k,M,T]),p&&(M=Ne(M,[M.shape[1],M.shape[2],M.shape[3]])),{value:M,gradFunc:b}})(h,f,y)}const mH=be({fusedConv2d_:_ut});function $ut(t,e,n,s,r,o=[1,1],a){let i=t;t.rank===3&&(i=Ne(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let l=e;l.rank===3&&(l=Ne(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const u={x:i,dy:l},c={strides:s,pad:r,dimRoundingMode:a,dilations:o,filterShape:n};return ye.runKernel(Gw,u,c)}const gH=be({depthwiseConv2dNativeBackpropFilter_:$ut});function xut(t,e,n,s,r,o=[1,1],a){let i=e,l=!1;e.rank===3&&(l=!0,i=Ne(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const u={dy:i,filter:n},c={strides:s,pad:r,dimRoundingMode:a,dilations:o,inputShape:t},d=ye.runKernel(jw,u,c);return l?Ne(d,[d.shape[1],d.shape[2],d.shape[3]]):d}const vH=be({depthwiseConv2dNativeBackpropInput_:xut});function Sut({x:t,filter:e,strides:n,pad:s,dataFormat:r="NHWC",dilations:o=[1,1],dimRoundingMode:a,bias:i,activation:l="linear",preluActivationWeights:u,leakyreluAlpha:c}){if(v3(ye.state.gradientDepth,l)===!1){let $=em(t,e,n,s,r,o,a);return i!=null&&($=st($,i)),g3($,l,u,c)}const d=te(t,"x","depthwiseConv2d","float32"),f=te(e,"filter","depthwiseConv2d","float32");let h=d,p=!1;d.rank===3&&(p=!0,h=Ne(d,[1,d.shape[0],d.shape[1],d.shape[2]])),q(h.rank===4,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${h.rank}.`),q(f.rank===4,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${f.rank}.`),q(h.shape[3]===f.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${h.shape[3]}) must match the inChannels dimension in filter ${f.shape[2]}.`),o==null&&(o=[1,1]),q(ur(n,o),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${n} and dilations '${o}'`),Mr("fused depthwiseConv2d",s,a);const m=Gs(h.shape,f.shape,n,o,s,a,!0);let g;i!=null&&(g=te(i,"bias","fused conv2d"),[g]=ds(g,d),Zt(m.outShape,g.shape));let y;u!=null&&(y=te(u,"prelu weights","fused depthwiseConv2d"));const w=($,x)=>{q(Zu(o),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${o}'`);const[k,C,T,N]=x,M=p3($,T,l),R=vH(C.shape,M,k,n,s,o,a),D=gH(C,M,k.shape,n,s,o,a);if(N!=null){const z=m3(g,M);return[R,D,z]}return[R,D]},b={x:h,filter:f,bias:g,preluActivationWeights:y},_={strides:n,pad:s,dataFormat:r,dilations:o,dimRoundingMode:a,activation:l,leakyreluAlpha:c};return i==null?Hi((x,k,C)=>{let T=ye.runKernel(J0,b,_);return C([k,x,T]),p&&(T=Ne(T,[T.shape[1],T.shape[2],T.shape[3]])),{value:T,gradFunc:w}})(h,f):Hi((x,k,C,T)=>{let N=ye.runKernel(J0,b,_);return T([k,x,N,C]),p&&(N=Ne(N,[N.shape[1],N.shape[2],N.shape[3]])),{value:N,gradFunc:w}})(h,f,g)}const Cut=be({fusedDepthwiseConv2d_:Sut});function kut({a:t,b:e,transposeA:n=!1,transposeB:s=!1,bias:r,activation:o="linear",preluActivationWeights:a,leakyreluAlpha:i=.2}){if(v3(ye.state.gradientDepth,o)===!1){let M=ln(t,e,n,s);return r!=null&&(M=st(M,r)),g3(M,o,a,i)}let l=te(t,"a","fused matMul"),u=te(e,"b","fused matMul");[l,u]=ds(l,u);const c=n?l.shape[l.rank-2]:l.shape[l.rank-1],d=s?u.shape[u.rank-1]:u.shape[u.rank-2],f=n?l.shape[l.rank-1]:l.shape[l.rank-2],h=s?u.shape[u.rank-2]:u.shape[u.rank-1],p=l.shape.slice(0,-2),m=u.shape.slice(0,-2),g=Ge(p),y=Ge(m);q(c===d,()=>`Error in fused matMul: inner shapes (${c}) and (${d}) of Tensors with shapes ${l.shape} and ${u.shape} and transposeA=${n} and transposeB=${s} must match.`);const b=Zt(l.shape.slice(0,-2),u.shape.slice(0,-2)).concat([f,h]),_=n?Ne(l,[g,c,f]):Ne(l,[g,f,c]),$=s?Ne(u,[y,h,d]):Ne(u,[y,d,h]);let x;r!=null&&(x=te(r,"bias","fused matMul"),[x]=ds(x,l),Zt(b,x.shape));let k;a!=null&&(k=te(a,"prelu weights","fused matMul"));const C=(M,R)=>{const[D,z,B,V]=R,O=p3(Ne(M,B.shape),B,o);let F,L;if(!n&&!s?(F=ln(O,z,!1,!0),L=ln(D,O,!0,!1)):!n&&s?(F=ln(O,z,!1,!1),L=ln(O,D,!0,!1)):n&&!s?(F=ln(z,O,!1,!0),L=ln(D,O,!1,!1)):(F=ln(z,O,!0,!0),L=ln(O,D,!0,!0)),r!=null){const G=m3(V,O);return[F,L,G]}else return[F,L]},T={a:_,b:$,bias:x,preluActivationWeights:k},N={transposeA:n,transposeB:s,activation:o,leakyreluAlpha:i};return r==null?Hi((R,D,z)=>{const B=ye.runKernel(Y0,T,N);return z([R,D,B]),{value:Ne(B,b),gradFunc:C}})(_,$):Hi((R,D,z,B)=>{const V=ye.runKernel(Y0,T,N);return B([R,D,V,z]),{value:Ne(V,b),gradFunc:C}})(_,$,x)}const Tx=be({fusedMatMul_:kut});const yH=Object.freeze(Object.defineProperty({__proto__:null,conv2d:mH,depthwiseConv2d:Cut,matMul:Tx},Symbol.toStringTag,{value:"Module"}));function Tut(t){return h3(t,.54,.46)}const Nut=be({hammingWindow_:Tut});function Iut(t){return h3(t,.5,.5)}const bH=be({hannWindow_:Iut});function Eut(t,e,n,s=!1,r=0){let o=0;const a=[];for(;o+e<=t.size;)a.push(mn(t,o,e)),o+=n;if(s)for(;o<t.size;){const i=o+e-t.size,l=vs([mn(t,o,e-i),of([i],r)]);a.push(l),o+=n}return a.length===0?Mu([],[0,e]):Ne(vs(a),[a.length,e])}const wH=be({frame_:Eut});function Aut(t,e,n,s,r=bH){s==null&&(s=pT(e));const o=wH(t,e,n),a=Te(o,r(e));return a2(a,s)}const Out=be({stft_:Aut});function Rut(t,e,n,s,r="bilinear",o=0){const a=te(t,"image","cropAndResize"),i=te(e,"boxes","cropAndResize","float32"),l=te(n,"boxInd","cropAndResize","int32"),u=i.shape[0];q(a.rank===4,()=>`Error in cropAndResize: image must be rank 4,but got rank ${a.rank}.`),q(i.rank===2&&i.shape[1]===4,()=>`Error in cropAndResize: boxes must be have size [${u},4] but had shape ${i.shape}.`),q(l.rank===1&&l.shape[0]===u,()=>`Error in cropAndResize: boxInd must be have size [${u}] but had shape ${i.shape}.`),q(s.length===2,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${s.length}.`),q(s[0]>=1&&s[1]>=1,()=>`cropSize must be atleast [1,1], but was ${s}`),q(r==="bilinear"||r==="nearest",()=>`method must be bilinear or nearest, but was ${r}`);const c={image:a,boxes:i,boxInd:l},d={method:r,extrapolationValue:o,cropSize:s};return ye.runKernel(Hw,c,d)}const Dut=be({cropAndResize_:Rut});function Fut(t){const e=te(t,"image","flipLeftRight","float32");q(e.rank===4,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${e.rank}.`);const n={image:e};return ye.runKernel(Jw,n,{})}const Mut=be({flipLeftRight_:Fut});function Put(t){const e=te(t,"image","grayscaleToRGB"),n=e.rank-1,s=e.shape[n];q(e.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${e.rank}.`),q(s===1,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${s}.`);const r=new Array(e.rank);return r.fill(1,0,n),r[n]=3,Lo(e,r)}const Lut=be({grayscaleToRGB_:Put});function zut(t,e,n=0,s=.5){const r=te(t,"image","rotateWithOffset","float32");q(r.rank===4,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${r.rank}.`);const o={image:r},a={radians:e,fillValue:n,center:s};return ye.runKernel(R_,o,a)}const But=be({rotateWithOffset_:zut});function im(t,e,n,s,r,o){s==null&&(s=.5),r==null&&(r=Number.NEGATIVE_INFINITY),o==null&&(o=0);const a=t.shape[0];return n=Math.min(n,a),q(0<=s&&s<=1,()=>`iouThreshold must be in [0, 1], but was '${s}'`),q(t.rank===2,()=>`boxes must be a 2D tensor, but was of rank '${t.rank}'`),q(t.shape[1]===4,()=>`boxes must have 4 columns, but 2nd dimension was ${t.shape[1]}`),q(e.rank===1,()=>"scores must be a 1D tensor"),q(e.shape[0]===a,()=>`scores has incompatible shape with boxes. Expected ${a}, but was ${e.shape[0]}`),q(0<=o&&o<=1,()=>`softNmsSigma must be in [0, 1], but was '${o}'`),{maxOutputSize:n,iouThreshold:s,scoreThreshold:r,softNmsSigma:o}}function Vut(t,e,n,s=.5,r=Number.NEGATIVE_INFINITY){const o=te(t,"boxes","nonMaxSuppression","float32"),a=te(e,"scores","nonMaxSuppression","float32"),i=im(o,a,n,s,r);n=i.maxOutputSize,s=i.iouThreshold,r=i.scoreThreshold;const l={maxOutputSize:n,iouThreshold:s,scoreThreshold:r};return ye.runKernel(l_,{boxes:o,scores:a},l)}const Hut=be({nonMaxSuppression_:Vut});function Wut(t,e,n){const s=Uut(t,e,n),r=s<0?-(s+1):s;t.splice(r,0,e)}function Uut(t,e,n){return jut(t,e,n||Gut)}function Gut(t,e){return t>e?1:t<e?-1:0}function jut(t,e,n){let s=0,r=t.length,o=0,a=!1;for(;s<r;){o=s+(r-s>>>1);const i=n(e,t[o]);i>0?s=o+1:(r=o,a=!i)}return a?s:-s-1}function y3(t,e,n,s,r){return gT(t,e,n,s,r,0)}function b3(t,e,n,s,r,o){return gT(t,e,n,s,r,0,!1,o,!0)}function w3(t,e,n,s,r,o){return gT(t,e,n,s,r,o,!0)}function gT(t,e,n,s,r,o,a=!1,i=!1,l=!1){const u=[];for(let g=0;g<e.length;g++)e[g]>r&&u.push({score:e[g],boxIndex:g,suppressBeginIndex:0});u.sort(YR);const c=o>0?-.5/o:0,d=[],f=[];for(;d.length<n&&u.length>0;){const g=u.pop(),{score:y,boxIndex:w,suppressBeginIndex:b}=g;if(y<r)break;let _=!1;for(let $=d.length-1;$>=b;--$){const x=Kut(t,w,d[$]);if(x>=s){_=!0;break}if(g.score=g.score*qut(s,c,x),g.score<=r)break}g.suppressBeginIndex=d.length,_||(g.score===y?(d.push(w),f.push(g.score)):g.score>r&&Wut(u,g,YR))}const h=d.length,p=n-h;i&&p>0&&(d.push(...new Array(p).fill(0)),f.push(...new Array(p).fill(0)));const m={selectedIndices:d};return a&&(m.selectedScores=f),l&&(m.validOutputs=h),m}function Kut(t,e,n){const s=t.subarray(e*4,e*4+4),r=t.subarray(n*4,n*4+4),o=Math.min(s[0],s[2]),a=Math.min(s[1],s[3]),i=Math.max(s[0],s[2]),l=Math.max(s[1],s[3]),u=Math.min(r[0],r[2]),c=Math.min(r[1],r[3]),d=Math.max(r[0],r[2]),f=Math.max(r[1],r[3]),h=(i-o)*(l-a),p=(d-u)*(f-c);if(h<=0||p<=0)return 0;const m=Math.max(o,u),g=Math.max(a,c),y=Math.min(i,d),w=Math.min(l,f),b=Math.max(y-m,0)*Math.max(w-g,0);return b/(h+p-b)}function qut(t,e,n){const s=Math.exp(e*n*n);return n<=t?s:0}function YR(t,e){return t.score-e.score||t.score===e.score&&e.boxIndex-t.boxIndex}async function Xut(t,e,n,s=.5,r=Number.NEGATIVE_INFINITY){const o=te(t,"boxes","nonMaxSuppressionAsync"),a=te(e,"scores","nonMaxSuppressionAsync"),i=im(o,a,n,s,r);n=i.maxOutputSize,s=i.iouThreshold,r=i.scoreThreshold;const l=await Promise.all([o.data(),a.data()]),u=l[0],c=l[1],{selectedIndices:d}=y3(u,c,n,s,r);return o!==t&&o.dispose(),a!==e&&a.dispose(),vr(d,"int32")}const Yut=Xut;function Zut(t,e,n,s=.5,r=Number.NEGATIVE_INFINITY,o=0){const a=te(t,"boxes","nonMaxSuppression"),i=te(e,"scores","nonMaxSuppression"),l=im(a,i,n,s,r,o);n=l.maxOutputSize,s=l.iouThreshold,r=l.scoreThreshold,o=l.softNmsSigma;const u={boxes:a,scores:i},c={maxOutputSize:n,iouThreshold:s,scoreThreshold:r,softNmsSigma:o},d=ye.runKernel(c_,u,c);return{selectedIndices:d[0],selectedScores:d[1]}}const Jut=be({nonMaxSuppressionWithScore_:Zut});async function Qut(t,e,n,s=.5,r=Number.NEGATIVE_INFINITY,o=0){const a=te(t,"boxes","nonMaxSuppressionAsync"),i=te(e,"scores","nonMaxSuppressionAsync"),l=im(a,i,n,s,r,o);n=l.maxOutputSize,s=l.iouThreshold,r=l.scoreThreshold,o=l.softNmsSigma;const u=await Promise.all([a.data(),i.data()]),c=u[0],d=u[1],{selectedIndices:f,selectedScores:h}=w3(c,d,n,s,r,o);return a!==t&&a.dispose(),i!==e&&i.dispose(),{selectedIndices:vr(f,"int32"),selectedScores:vr(h)}}const ect=Qut;function tct(t,e,n,s=.5,r=Number.NEGATIVE_INFINITY,o=!1){const a=te(t,"boxes","nonMaxSuppression"),i=te(e,"scores","nonMaxSuppression"),l=im(a,i,n,s,r,null),u=l.maxOutputSize,c=l.iouThreshold,d=l.scoreThreshold,f={boxes:a,scores:i},h={maxOutputSize:u,iouThreshold:c,scoreThreshold:d,padToMaxOutputSize:o},p=ye.runKernel(u_,f,h);return{selectedIndices:p[0],validOutputs:p[1]}}const nct=be({nonMaxSuppressionPadded_:tct});async function sct(t,e,n,s=.5,r=Number.NEGATIVE_INFINITY,o=!1){const a=te(t,"boxes","nonMaxSuppressionAsync"),i=te(e,"scores","nonMaxSuppressionAsync"),l=im(a,i,n,s,r,null),u=l.maxOutputSize,c=l.iouThreshold,d=l.scoreThreshold,[f,h]=await Promise.all([a.data(),i.data()]),{selectedIndices:p,validOutputs:m}=b3(f,h,u,c,d,o);return a!==t&&a.dispose(),i!==e&&i.dispose(),{selectedIndices:vr(p,"int32"),validOutputs:Pt(m,"int32")}}const rct=sct;function oct(t,e,n=!1,s=!1){const r=te(t,"images","resizeBilinear");q(r.rank===3||r.rank===4,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${r.rank}.`),q(e.length===2,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${e}.`),q(s===!1||n===!1,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let o=r,a=!1;r.rank===3&&(a=!0,o=Ne(r,[1,r.shape[0],r.shape[1],r.shape[2]]));const i={images:o},l={alignCorners:n,halfPixelCenters:s,size:e},u=ye.runKernel(A1,i,l);return a?Ne(u,[u.shape[1],u.shape[2],u.shape[3]]):u}const _H=be({resizeBilinear_:oct});function act(t,e,n=!1,s=!1){const r=te(t,"images","resizeNearestNeighbor");q(r.rank===3||r.rank===4,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${r.rank}.`),q(e.length===2,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${e}.`),q(r.dtype==="float32"||r.dtype==="int32",()=>"`images` must have `int32` or `float32` as dtype"),q(s===!1||n===!1,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let o=r,a=!1;r.rank===3&&(a=!0,o=Ne(r,[1,r.shape[0],r.shape[1],r.shape[2]]));const i={images:o},l={alignCorners:n,halfPixelCenters:s,size:e},u=ye.runKernel(E1,i,l);return a?Ne(u,[u.shape[1],u.shape[2],u.shape[3]]):u}const $H=be({resizeNearestNeighbor_:act});function ict(t,e="binary",n=!1,s=.5){const r=te(t,"image","threshold"),o=.2989,a=.587,i=.114,l=r.shape[0]*r.shape[1];let u=Te(vr([s]),255),c,d,f,h;if(q(r.rank===3,()=>`Error in threshold: image must be rank 3,but got rank ${r.rank}.`),q(r.shape[2]===3||r.shape[2]===1,()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${r.shape[2]}.`),q(r.dtype==="int32"||r.dtype==="float32",()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${r.dtype}.`),q(e==="otsu"||e==="binary",()=>`Method must be binary or otsu, but was ${e}`),r.shape[2]===3){[c,d,f]=Kr(r,[1,1,1],-1);const g=Te(c,o),y=Te(d,a),w=Te(f,i);h=st(st(g,y),w)}else h=t;if(e==="otsu"){const g=E8(ht(t3(h),"int32"),yo([]),256);u=lct(g,l)}const p=n?mc(h,u):Pr(h,u);return ht(Te(p,255),"int32")}function lct(t,e){let n=vr([-1]),s=vr([0]),r=vr([0]),o,a,i,l,u,c;for(let d=0;d<t.size-1;d++){o=mn(t,0,d+1),a=mn(t,d+1),u=Et(kt(o),e),c=Et(kt(a),e);const f=kt(Te(o,Fd(0,o.size)));i=Et(f,kt(o));const h=of(a.shape,o.size),p=st(Fd(0,a.size),h),m=Te(a,p);l=Et(kt(m),kt(a));const g=$t(i,l),y=$t(i,l),w=Te(u,c);r=Te(Te(w,g),y);const b=Pr(r,s);s=wr(b,r,s),n=wr(b,vr([d]),n)}return n}const uct=be({threshold_:ict});function cct(t,e,n="nearest",s="constant",r=0,o){const a=te(t,"image","transform","float32"),i=te(e,"transforms","transform","float32");q(a.rank===4,()=>`Error in transform: image must be rank 4,but got rank ${a.rank}.`),q(i.rank===2&&(i.shape[0]===a.shape[0]||i.shape[0]===1)&&i.shape[1]===8,()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),q(o==null||o.length===2,()=>`Error in transform: outputShape must be [height, width] or null, but got ${o}.`);const l={image:a,transforms:i},u={interpolation:n,fillMode:s,fillValue:r,outputShape:o};return ye.runKernel(A_,l,u)}const dct=be({transform_:cct});function fct(t,e,n){q(e%1===0,()=>`bandPart(): numLower must be an integer, got ${e}.`),q(n%1===0,()=>`bandPart(): numUpper must be an integer, got ${n}.`);const s=te(t,"a","bandPart");q(s.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${s.rank}.`);const r=s.shape,[o,a]=s.shape.slice(-2);if(!(e<=o))throw new Error(`bandPart(): numLower (${e}) must not be greater than the number of rows (${o}).`);if(!(n<=a))throw new Error(`bandPart(): numUpper (${n}) must not be greater than the number of columns (${a}).`);e<0&&(e=o),n<0&&(n=a);const i=Ne(Fd(0,o,1,"int32"),[-1,1]),l=Fd(0,a,1,"int32"),u=$t(i,l),c=Ta(mc(u,Pt(+e,"int32")),Zl(u,Pt(-n,"int32"))),d=xs([o,a],s.dtype);return Ne(Jr(Yo(Ne(s,[-1,o,a])).map(f=>wr(c,f,d))),r)}const hct=be({bandPart_:fct});function pct(t){let e;if(Array.isArray(t)){e=!1,q(t!=null&&t.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");const r=t[0].shape[0];for(let o=1;o<t.length;++o)q(t[o].shape[0]===r,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${t[o].shape[0]} vs. ${r})`)}else e=!0,t=Kr(t,t.shape[0],0).map(r=>gc(r,[0]));q(t.length<=t[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${t.length}) exceeds number of dimensions (${t[0].shape[0]}).`);const n=[],s=t;for(let r=0;r<t.length;++r)n.push(ye.tidy(()=>{let o=s[r];if(r>0)for(let a=0;a<r;++a){const i=Te(kt(Te(n[a],o)),n[a]);o=$t(o,i)}return Et(o,nm(o,"euclidean"))}));return e?Jr(n,0):n}const mct=be({gramSchmidt_:pct});function gct(t,e=!1){if(q(t.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${t.rank}`),t.rank===2)return ZR(t,e);{const n=t.shape.slice(0,t.shape.length-2).reduce((l,u)=>l*u),s=Yo(Ne(t,[n,t.shape[t.shape.length-2],t.shape[t.shape.length-1]]),0),r=[],o=[];s.forEach(l=>{const[u,c]=ZR(l,e);r.push(u),o.push(c)});const a=Ne(Jr(r,0),t.shape),i=Ne(Jr(o,0),t.shape);return[a,i]}}function ZR(t,e=!1){return ye.tidy(()=>{q(t.shape.length===2,()=>`qr2d() requires a 2D Tensor, but got a ${t.shape.length}D Tensor.`);const n=t.shape[0],s=t.shape[1];let r=j_(n),o=Ri(t);const a=Mu([[1]],[1,1]);let i=Ri(a);const l=n>=s?s:n;for(let u=0;u<l;++u){const c=o,d=i,f=r;[i,o,r]=ye.tidy(()=>{const h=mn(o,[u,u],[n-u,1]),p=nm(h),m=mn(o,[u,u],[1,1]),g=wr(Pr(m,0),Mu([[-1]]),Mu([[1]])),y=$t(m,Te(g,p)),w=Et(h,y);w.shape[0]===1?i=Ri(a):i=vs([a,mn(w,[1,0],[w.shape[0]-1,w.shape[1]])],0);const b=Jn(Et(ln(g,y),p)),_=mn(o,[u,0],[n-u,s]),$=Te(b,i),x=dn(i);if(u===0)o=$t(_,ln($,ln(x,_)));else{const T=$t(_,ln($,ln(x,_)));o=vs([mn(o,[0,0],[u,s]),T],0)}const k=dn($),C=mn(r,[0,u],[n,r.shape[1]-u]);if(u===0)r=$t(C,ln(ln(C,i),k));else{const T=$t(C,ln(ln(C,i),k));r=vs([mn(r,[0,0],[n,u]),T],1)}return[i,o,r]}),Xt([c,d,f])}return!e&&n>s&&(r=mn(r,[0,0],[n,s]),o=mn(o,[0,0],[s,s])),[r,o]})}const vct=be({qr_:gct});var Tr;(function(t){t[t.NONE=0]="NONE",t[t.MEAN=1]="MEAN",t[t.SUM=2]="SUM",t[t.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"})(Tr||(Tr={}));function yct(t,e,n=Tr.SUM_BY_NONZERO_WEIGHTS){const s=te(t,"losses","computeWeightedLoss");let r=null;e!=null&&(r=te(e,"weights","computeWeightedLoss"));const o=r==null?s:Te(s,r);if(n===Tr.NONE)return o;if(n===Tr.SUM)return kt(o);if(n===Tr.MEAN){if(r==null)return us(o);{const a=s.size/r.size,i=Et(kt(o),kt(r));return a>1?Et(i,Pt(a)):i}}if(n===Tr.SUM_BY_NONZERO_WEIGHTS){if(r==null)return Et(kt(o),Pt(s.size));{const a=Te(r,po(s.shape)),i=ht(kt(Dd(a,Pt(0))),"float32");return Et(kt(o),i)}}throw Error(`Unknown reduction: ${n}`)}const Ql=be({computeWeightedLoss_:yct});function bct(t,e,n,s=Tr.SUM_BY_NONZERO_WEIGHTS){const r=te(t,"labels","absoluteDifference"),o=te(e,"predictions","absoluteDifference");let a=null;n!=null&&(a=te(n,"weights","absoluteDifference")),lr(r.shape,o.shape,"Error in absoluteDifference: ");const i=$s($t(r,o));return Ql(i,a,s)}const wct=be({absoluteDifference_:bct});function _ct(t,e,n,s,r=Tr.SUM_BY_NONZERO_WEIGHTS){const o=te(t,"labels","cosineDistance"),a=te(e,"predictions","cosineDistance");let i=null;s!=null&&(i=te(s,"weights","cosineDistance")),lr(o.shape,a.shape,"Error in cosineDistance: ");const l=Pt(1),u=$t(l,kt(Te(o,a),n,!0));return Ql(u,i,r)}const $ct=be({cosineDistance_:_ct});function xct(t,e,n,s=Tr.SUM_BY_NONZERO_WEIGHTS){let r=te(t,"labels","hingeLoss");const o=te(e,"predictions","hingeLoss");let a=null;n!=null&&(a=te(n,"weights","hingeLoss")),lr(r.shape,o.shape,"Error in hingeLoss: ");const i=Pt(1);r=$t(Te(Pt(2),r),i);const l=li($t(i,Te(r,o)));return Ql(l,a,s)}const Sct=be({hingeLoss_:xct});function Cct(t,e,n,s=1,r=Tr.SUM_BY_NONZERO_WEIGHTS){const o=te(t,"labels","huberLoss"),a=te(e,"predictions","huberLoss");let i=null;n!=null&&(i=te(n,"weights","huberLoss")),lr(o.shape,a.shape,"Error in huberLoss: ");const l=Pt(s),u=$s($t(a,o)),c=om(u,l),d=$t(u,c),f=st(Te(Pt(.5),Dn(c)),Te(l,d));return Ql(f,i,r)}const kct=be({huberLoss_:Cct});function Tct(t,e,n,s=1e-7,r=Tr.SUM_BY_NONZERO_WEIGHTS){const o=te(t,"labels","logLoss"),a=te(e,"predictions","logLoss");let i=null;n!=null&&(i=te(n,"weights","logLoss")),lr(o.shape,a.shape,"Error in logLoss: ");const l=Pt(1),u=Pt(s),c=Jn(Te(o,xo(st(a,u)))),d=Te($t(l,o),xo(st($t(l,a),u))),f=$t(c,d);return Ql(f,i,r)}const Nct=be({logLoss_:Tct});function Ict(t,e,n,s=Tr.SUM_BY_NONZERO_WEIGHTS){const r=te(t,"labels","meanSquaredError"),o=te(e,"predictions","meanSquaredError");let a=null;n!=null&&(a=te(n,"weights","meanSquaredError")),lr(r.shape,o.shape,"Error in meanSquaredError: ");const i=u3(r,o);return Ql(i,a,s)}const Ect=be({meanSquaredError_:Ict});function Act(t,e){const n=te(t,"labels","sigmoidCrossEntropyWithLogits"),s=te(e,"logits","sigmoidCrossEntropyWithLogits");lr(n.shape,s.shape,"Error in sigmoidCrossEntropyWithLogits: ");const r=li(s),o=Te(s,n),a=Y1($o(Jn($s(s))));return st($t(r,o),a)}function Oct(t,e,n,s=0,r=Tr.SUM_BY_NONZERO_WEIGHTS){let o=te(t,"multiClassLabels","sigmoidCrossEntropy");const a=te(e,"logits","sigmoidCrossEntropy");let i=null;if(n!=null&&(i=te(n,"weights","sigmoidCrossEntropy")),lr(o.shape,a.shape,"Error in sigmoidCrossEntropy: "),s>0){const u=Pt(s),c=Pt(1),d=Pt(.5);o=st(Te(o,$t(c,u)),Te(d,u))}const l=Act(o,a);return Ql(l,i,r)}const Rct=be({sigmoidCrossEntropy_:Oct});function Dct(t,e,n=-1){if(n===-1&&(n=e.rank-1),n!==e.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${e.rank} and dim was ${n}`);return Hi((r,o,a)=>{const l=Y_(o,[n],!0),u=$t(ht(o,"float32"),l);a([r,u]);const c=Jn(Te(u,r));return{value:kt(c,[n]),gradFunc:(h,p)=>{const[m,g]=p,y=ys(h.shape,[n]);return[Te(Ne(h,y),$t(ht(m,"float32"),$o(g))),Te(Ne(h,y),$t($o(g),ht(m,"float32")))]}}})(t,e)}function Fct(t,e,n,s=0,r=Tr.SUM_BY_NONZERO_WEIGHTS){let o=te(t,"onehotLabels","softmaxCrossEntropy");const a=te(e,"logits","softmaxCrossEntropy");let i=null;if(n!=null&&(i=te(n,"weights","softmaxCrossEntropy")),lr(o.shape,a.shape,"Error in softmaxCrossEntropy: "),s>0){const u=Pt(s),c=Pt(1),d=Pt(o.shape[1]);o=st(Te(o,$t(c,u)),Et(u,d))}const l=Dct(o,a);return Ql(l,i,r)}const Mct=be({softmaxCrossEntropy_:Fct});function Pct(t,e,n,s){const r=te(t,"indices","sparseFillEmptyRows","int32"),o=te(e,"values","sparseFillEmptyRows"),a=te(n,"denseShape","sparseFillEmptyRows","int32"),i=te(s,"defaultValue","sparseFillEmptyRows",o.dtype);if(r.rank!==2)throw new Error(`Indices should be Tensor2D but received shape
        ${r.shape}`);if(o.rank!==1)throw new Error(`Values should be Tensor1D but received shape ${o.shape}`);if(a.rank!==1)throw new Error(`Dense shape should be Tensor1D but received shape ${a.shape}`);if(i.rank!==0)throw new Error(`Default value should be a scalar but received shape ${i.shape}`);const l={indices:r,values:o,denseShape:a,defaultValue:i},u=ye.runKernel(w_,l);return{outputIndices:u[0],outputValues:u[1],emptyRowIndicator:u[2],reverseIndexMap:u[3]}}const Lct=be({sparseFillEmptyRows_:Pct});function zct(t,e,n){const s=te(t,"inputIndices","sparseReshape","int32"),r=te(e,"inputShape","sparseReshape","int32"),o=te(n,"newShape","sparseReshape","int32");if(s.rank!==2)throw new Error(`Input indices should be Tensor2D but received shape
        ${s.shape}`);if(r.rank!==1)throw new Error(`Input shape should be Tensor1D but received shape ${r.shape}`);if(o.rank!==1)throw new Error(`New shape should be Tensor1D but received shape ${o.shape}`);const a={inputIndices:s,inputShape:r,newShape:o},i=ye.runKernel(__,a);return{outputIndices:i[0],outputShape:i[1]}}const Bct=be({sparseReshape_:zct});function Vct(t,e,n){const s=te(t,"data","sparseSegmentMean"),r=te(e,"indices","sparseSegmentMean","int32"),o=te(n,"segmentIds","sparseSegmentMean","int32");if(s.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
          ${r.shape}`);if(o.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
          ${o.shape}`);const a={data:s,indices:r,segmentIds:o};return ye.runKernel($_,a)}const Hct=be({sparseSegmentMean_:Vct});function Wct(t,e,n){const s=te(t,"data","sparseSegmentSum"),r=te(e,"indices","sparseSegmentSum","int32"),o=te(n,"segmentIds","sparseSegmentSum","int32");if(s.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
         ${r.shape}`);if(o.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
         ${o.shape}`);const a={data:s,indices:r,segmentIds:o};return ye.runKernel(x_,a)}const Uct=be({sparseSegmentSum_:Wct});function Gct(t,e,n,s,r,o,a,i){const l=te(t,"data","stringNGrams","string");if(l.dtype!=="string")throw new Error("Data must be of datatype string");if(l.shape.length!==1)throw new Error(`Data must be a vector, saw: ${l.shape}`);const u=te(e,"dataSplits","stringNGrams");if(u.dtype!=="int32")throw new Error("Data splits must be of datatype int32");const c={separator:n,nGramWidths:s,leftPad:r,rightPad:o,padWidth:a,preserveShortSequences:i},d={data:l,dataSplits:u},f=ye.runKernel(T_,d,c);return{nGrams:f[0],nGramsSplits:f[1]}}const jct=be({stringNGrams_:Gct});function Kct(t,e,n=!0){const s=te(t,"input","stringSplit","string"),r=te(e,"delimiter","stringSplit","string");if(s.rank!==1)throw new Error(`Input should be Tensor1D but received shape ${s.shape}`);if(r.rank!==0)throw new Error(`Delimiter should be a scalar but received shape ${r.shape}`);const o={skipEmpty:n},a={input:s,delimiter:r},i=ye.runKernel(N_,a,o);return{indices:i[0],values:i[1],shape:i[2]}}const qct=be({stringSplit_:Kct});function Xct(t,e){const n=te(t,"input","stringToHashBucketFast","string"),s={numBuckets:e};if(e<=0)throw new Error("Number of buckets must be at least 1");const r={input:n};return ye.runKernel(I_,r,s)}const Yct=be({stringToHashBucketFast_:Xct});const xH={fft:o2,ifft:Nh,rfft:a2,irfft:l3},SH={hammingWindow:Nut,hannWindow:bH,frame:wH,stft:Out},Ti={flipLeftRight:Mut,grayscaleToRGB:Lut,resizeNearestNeighbor:$H,resizeBilinear:_H,rotateWithOffset:But,cropAndResize:Dut,nonMaxSuppression:Hut,nonMaxSuppressionAsync:Yut,nonMaxSuppressionWithScore:Jut,nonMaxSuppressionWithScoreAsync:ect,nonMaxSuppressionPadded:nct,nonMaxSuppressionPaddedAsync:rct,threshold:uct,transform:dct},vT={bandPart:hct,gramSchmidt:mct,qr:vct},CH={absoluteDifference:wct,computeWeightedLoss:Ql,cosineDistance:$ct,hingeLoss:Sct,huberLoss:kct,logLoss:Nct,meanSquaredError:Ect,sigmoidCrossEntropy:Rct,softmaxCrossEntropy:Mct},kH={sparseFillEmptyRows:Lct,sparseReshape:Bct,sparseSegmentMean:Hct,sparseSegmentSum:Uct},TH={stringNGrams:jct,stringSplit:qct,stringToHashBucketFast:Yct};let eu=class extends rf{minimize(e,n=!1,s){const{value:r,grads:o}=this.computeGradients(e,s);if(s!=null){const a=s.map(i=>({name:i.name,tensor:o[i.name]}));this.applyGradients(a)}else this.applyGradients(o);return Xt(o),n?r:(r.dispose(),null)}get iterations(){return this.iterations_==null&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(e,n){return EV(e,n)}dispose(){this.iterations_!=null&&Xt(this.iterations_)}async saveIterations(){return this.iterations_==null&&(this.iterations_=0),{name:"iter",tensor:Pt(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(e){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(e){return this.iterations_=(await e[0].tensor.data())[0],e.slice(1)}};Object.defineProperty(eu,Symbol.hasInstance,{value:t=>t.minimize!=null&&t.computeGradients!=null&&t.applyGradients!=null});let _3=class extends eu{constructor(e,n,s=null){super(),this.learningRate=e,this.rho=n,this.epsilon=s,this.accumulatedGrads=[],this.accumulatedUpdates=[],s==null&&(this.epsilon=ye.backend.epsilon())}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,r)=>{const o=ye.registeredVariables[s],a=!1;this.accumulatedGrads[r]==null&&(this.accumulatedGrads[r]={originalName:`${s}/accum_grad`,variable:Le(()=>yn(o).variable(a))}),this.accumulatedUpdates[r]==null&&(this.accumulatedUpdates[r]={originalName:`${s}/accum_var`,variable:Le(()=>yn(o).variable(a))});const i=Array.isArray(e)?e[r].tensor:e[s];if(i==null)return;const l=this.accumulatedGrads[r].variable,u=this.accumulatedUpdates[r].variable;Le(()=>{const c=st(Te(l,this.rho),Te(Dn(i),1-this.rho)),d=Te(Et(ar(st(u,this.epsilon)),ar(st(l,this.epsilon))),i),f=st(Te(u,this.rho),Te(Dn(d),1-this.rho));l.assign(c),u.assign(f);const h=st(Te(d,-this.learningRate),o);o.assign(h)})}),this.incrementIterations()}dispose(){this.accumulatedUpdates!=null&&(Xt(this.accumulatedGrads.map(e=>e.variable)),Xt(this.accumulatedUpdates.map(e=>e.variable)))}async getWeights(){const e=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(e.map(n=>({name:n.originalName,tensor:n.variable})))}async setWeights(e){e=await this.extractIterations(e);const n=e.length/2,s=!1;this.accumulatedGrads=e.slice(0,n).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})),this.accumulatedUpdates=e.slice(n,n*2).map(r=>({originalName:r.name,variable:r.tensor.variable(s)}))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(e,n){return new e(n.learningRate,n.rho,n.epsilon)}};_3.className="Adadelta";tt(_3);let $3=class extends eu{constructor(e,n=.1){super(),this.learningRate=e,this.initialAccumulatorValue=n,this.accumulatedGrads=[]}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,r)=>{const o=ye.registeredVariables[s];this.accumulatedGrads[r]==null&&(this.accumulatedGrads[r]={originalName:`${s}/accumulator`,variable:Le(()=>of(o.shape,this.initialAccumulatorValue).variable(!1))});const a=Array.isArray(e)?e[r].tensor:e[s];if(a==null)return;const i=this.accumulatedGrads[r].variable;Le(()=>{const l=st(i,Dn(a));i.assign(l);const u=st(Te(Et(a,ar(st(l,ye.backend.epsilon()))),-this.learningRate),o);o.assign(u)})}),this.incrementIterations()}dispose(){this.accumulatedGrads!=null&&Xt(this.accumulatedGrads.map(e=>e.variable))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);const n=!1;this.accumulatedGrads=e.map(s=>({originalName:s.name,variable:s.tensor.variable(n)}))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(e,n){return new e(n.learningRate,n.initialAccumulatorValue)}};$3.className="Adagrad";tt($3);let x3=class extends eu{constructor(e,n,s,r=null){super(),this.learningRate=e,this.beta1=n,this.beta2=s,this.epsilon=r,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],Le(()=>{this.accBeta1=Pt(n).variable(),this.accBeta2=Pt(s).variable()}),r==null&&(this.epsilon=ye.backend.epsilon())}applyGradients(e){const n=Array.isArray(e)?e.map(s=>s.name):Object.keys(e);Le(()=>{const s=$t(1,this.accBeta1),r=$t(1,this.accBeta2);n.forEach((o,a)=>{const i=ye.registeredVariables[o],l=!1;this.accumulatedFirstMoment[a]==null&&(this.accumulatedFirstMoment[a]={originalName:`${o}/m`,variable:Le(()=>yn(i).variable(l))}),this.accumulatedSecondMoment[a]==null&&(this.accumulatedSecondMoment[a]={originalName:`${o}/v`,variable:Le(()=>yn(i).variable(l))});const u=Array.isArray(e)?e[a].tensor:e[o];if(u==null)return;const c=this.accumulatedFirstMoment[a].variable,d=this.accumulatedSecondMoment[a].variable,f=st(Te(c,this.beta1),Te(u,1-this.beta1)),h=st(Te(d,this.beta2),Te(Dn(u),1-this.beta2)),p=Et(f,s),m=Et(h,r);c.assign(f),d.assign(h);const g=st(Te(Et(p,st(ar(m),this.epsilon)),-this.learningRate),i);i.assign(g)}),this.accBeta1.assign(Te(this.accBeta1,this.beta1)),this.accBeta2.assign(Te(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),this.accumulatedFirstMoment!=null&&Xt(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedSecondMoment!=null&&Xt(this.accumulatedSecondMoment.map(e=>e.variable))}async getWeights(){const e=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(e.map(n=>({name:n.originalName,tensor:n.variable})))}async setWeights(e){e=await this.extractIterations(e),Le(()=>{this.accBeta1.assign(Ol(this.beta1,this.iterations_+1)),this.accBeta2.assign(Ol(this.beta2,this.iterations_+1))});const n=e.length/2,s=!1;this.accumulatedFirstMoment=e.slice(0,n).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})),this.accumulatedSecondMoment=e.slice(n,n*2).map(r=>({originalName:r.name,variable:r.tensor.variable(s)}))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(e,n){return new e(n.learningRate,n.beta1,n.beta2,n.epsilon)}};x3.className="Adam";tt(x3);let S3=class extends eu{constructor(e,n,s,r=null,o=0){super(),this.learningRate=e,this.beta1=n,this.beta2=s,this.epsilon=r,this.decay=o,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],Le(()=>{this.iteration=Pt(0).variable(),this.accBeta1=Pt(n).variable()}),r==null&&(this.epsilon=ye.backend.epsilon())}applyGradients(e){const n=Array.isArray(e)?e.map(s=>s.name):Object.keys(e);Le(()=>{const s=$t(1,this.accBeta1),r=Et(-this.learningRate,st(Te(this.iteration,this.decay),1));n.forEach((o,a)=>{const i=ye.registeredVariables[o],l=!1;this.accumulatedFirstMoment[a]==null&&(this.accumulatedFirstMoment[a]={originalName:`${o}/m`,variable:yn(i).variable(l)}),this.accumulatedWeightedInfNorm[a]==null&&(this.accumulatedWeightedInfNorm[a]={originalName:`${o}/v`,variable:yn(i).variable(l)});const u=Array.isArray(e)?e[a].tensor:e[o];if(u==null)return;const c=this.accumulatedFirstMoment[a].variable,d=this.accumulatedWeightedInfNorm[a].variable,f=st(Te(c,this.beta1),Te(u,1-this.beta1)),h=Te(d,this.beta2),p=$s(u),m=Zi(h,p);c.assign(f),d.assign(m);const g=st(Te(Et(r,s),Et(f,st(m,this.epsilon))),i);i.assign(g)}),this.iteration.assign(st(this.iteration,1)),this.accBeta1.assign(Te(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),this.accumulatedFirstMoment!=null&&Xt(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedWeightedInfNorm!=null&&Xt(this.accumulatedWeightedInfNorm.map(e=>e.variable))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(e){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(e,n){return new e(n.learningRate,n.beta1,n.beta2,n.epsilon,n.decay)}};S3.className="Adamax";tt(S3);let i2=class extends eu{constructor(e){super(),this.learningRate=e,this.setLearningRate(e)}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,r)=>{const o=Array.isArray(e)?e[r].tensor:e[s];if(o==null)return;const a=ye.registeredVariables[s];Le(()=>{const i=st(Te(this.c,o),a);a.assign(i)})}),this.incrementIterations()}setLearningRate(e){this.learningRate=e,this.c!=null&&this.c.dispose(),this.c=As(Pt(-e))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(e){if(e=await this.extractIterations(e),e.length!==0)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(e,n){return new e(n.learningRate)}};i2.className="SGD";tt(i2);let C3=class extends i2{constructor(e,n,s=!1){super(e),this.learningRate=e,this.momentum=n,this.useNesterov=s,this.accumulations=[],this.m=Pt(this.momentum)}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,r)=>{const o=ye.registeredVariables[s];this.accumulations[r]==null&&(this.accumulations[r]={originalName:`${s}/momentum`,variable:Le(()=>yn(o).variable(!1))});const a=this.accumulations[r].variable,i=Array.isArray(e)?e[r].tensor:e[s];i!=null&&Le(()=>{let l;const u=st(Te(this.m,a),i);this.useNesterov?l=st(Te(this.c,st(i,Te(u,this.m))),o):l=st(Te(this.c,u),o),a.assign(u),o.assign(l)})}),this.incrementIterations()}dispose(){this.m.dispose(),this.accumulations!=null&&Xt(this.accumulations.map(e=>e.variable))}setMomentum(e){this.momentum=e}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);const n=!1;this.accumulations=e.map(s=>({originalName:s.name,variable:s.tensor.variable(n)}))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(e,n){return new e(n.learningRate,n.momentum,n.useNesterov)}};C3.className="Momentum";tt(C3);let k3=class extends eu{constructor(e,n=.9,s=0,r=null,o=!1){if(super(),this.learningRate=e,this.decay=n,this.momentum=s,this.epsilon=r,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=o,r==null&&(this.epsilon=ye.backend.epsilon()),e==null)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,r)=>{const o=ye.registeredVariables[s],a=!1;this.accumulatedMeanSquares[r]==null&&(this.accumulatedMeanSquares[r]={originalName:`${s}/rms`,variable:Le(()=>yn(o).variable(a))}),this.accumulatedMoments[r]==null&&(this.accumulatedMoments[r]={originalName:`${s}/momentum`,variable:Le(()=>yn(o).variable(a))}),this.accumulatedMeanGrads[r]==null&&this.centered&&(this.accumulatedMeanGrads[r]={originalName:`${s}/mg`,variable:Le(()=>yn(o).variable(a))});const i=Array.isArray(e)?e[r].tensor:e[s];if(i==null)return;const l=this.accumulatedMeanSquares[r].variable,u=this.accumulatedMoments[r].variable;Le(()=>{const c=st(Te(l,this.decay),Te(Dn(i),1-this.decay));if(this.centered){const d=this.accumulatedMeanGrads[r].variable,f=st(Te(d,this.decay),Te(i,1-this.decay)),h=Et(Te(i,this.learningRate),ar($t(c,st(Dn(f),this.epsilon)))),p=st(Te(u,this.momentum),h);l.assign(c),d.assign(f),u.assign(p);const m=$t(o,p);o.assign(m)}else{const d=st(Te(l,this.decay),Te(Dn(i),1-this.decay)),f=st(Te(u,this.momentum),Et(Te(i,this.learningRate),ar(st(d,this.epsilon))));l.assign(d),u.assign(f);const h=$t(o,f);o.assign(h)}})}),this.incrementIterations()}dispose(){this.accumulatedMeanSquares!=null&&Xt(this.accumulatedMeanSquares.map(e=>e.variable)),this.accumulatedMeanGrads!=null&&this.centered&&Xt(this.accumulatedMeanGrads.map(e=>e.variable)),this.accumulatedMoments!=null&&Xt(this.accumulatedMoments.map(e=>e.variable))}async getWeights(){const e=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&e.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(e.map(n=>({name:n.originalName,tensor:n.variable})))}async setWeights(e){e=await this.extractIterations(e);const n=this.centered?e.length/3:e.length/2,s=!1;this.accumulatedMeanSquares=e.slice(0,n).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})),this.accumulatedMoments=e.slice(n,n*2).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})),this.centered&&(this.accumulatedMeanGrads=e.slice(n*2,n*3).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(e,n){return new e(n.learningRate,n.decay,n.momentum,n.epsilon,n.centered)}};k3.className="RMSProp";tt(k3);let pu=class{static sgd(e){return new i2(e)}static momentum(e,n,s=!1){return new C3(e,n,s)}static rmsprop(e,n=.9,s=0,r=null,o=!1){return new k3(e,n,s,r,o)}static adam(e=.001,n=.9,s=.999,r=null){return new x3(e,n,s,r)}static adadelta(e=.001,n=.95,s=null){return new _3(e,n,s)}static adamax(e=.002,n=.9,s=.999,r=null,o=0){return new S3(e,n,s,r,o)}static adagrad(e,n=.1){return new $3(e,n)}};const Dc={sgd:pu.sgd,momentum:pu.momentum,adadelta:pu.adadelta,adagrad:pu.adagrad,rmsprop:pu.rmsprop,adamax:pu.adamax,adam:pu.adam};const Zct=(()=>typeof requestAnimationFrame<"u"?requestAnimationFrame:typeof setImmediate<"u"?setImmediate:t=>t())();function yT(){return new Promise(t=>Zct(()=>t()))}function bT(t,e){const n=t[0].length;t.forEach((r,o)=>{q(r.length===n,()=>`Error in concat${n}D: rank of tensors[${o}] must be the same as the rank of the rest (${n})`)}),q(e>=0&&e<n,()=>`Error in concat${n}D: axis must be between 0 and ${n-1}.`);const s=t[0];t.forEach((r,o)=>{for(let a=0;a<n;a++)q(a===e||r[a]===s[a],()=>`Error in concat${n}D: Shape of tensors[${o}] (${r}) does not match the shape of the rest (${s}) along the non-concatenated axis ${o}.`)})}function Di(t,e){const n=t[0].slice();for(let s=1;s<t.length;s++)n[e]+=t[s][e];return n}var za;(function(t){t[t.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",t[t.VALUE_ROWIDS=1]="VALUE_ROWIDS",t[t.ROW_LENGTHS=2]="ROW_LENGTHS",t[t.ROW_SPLITS=3]="ROW_SPLITS",t[t.ROW_LIMITS=4]="ROW_LIMITS",t[t.ROW_STARTS=5]="ROW_STARTS"})(za||(za={}));function NH(t,e,n){let s=new Array;if(n==null&&e==null)return s;if(e==null)for(;s.length<t+n.length;)s.push(-1);else s=e.slice();if(n==null)return s;if(t+n.length!==s.length)throw new Error(`rt input.shape and shape=${e} are incompatible: rt input.rank = ${t+n.length}, but shape.rank = ${s.length}`);for(let r=1;r<n.length;++r){const o=n[r],a=s[s.length-n.length+r],i=s[a];if(o>=0)if(i>=0){if(i!==o)throw new Error(`rt input.shape and shape=${e} are incompatible: rt input.shape[${r+t}] = ${o} but shape[${r+t}] = ${i}`)}else s[a]=o}return s}function IH(t){const e={FIRST_DIM_SIZE:za.FIRST_DIM_SIZE,VALUE_ROWIDS:za.VALUE_ROWIDS,ROW_LENGTHS:za.ROW_LENGTHS,ROW_SPLITS:za.ROW_SPLITS,ROW_LIMITS:za.ROW_LIMITS,ROW_STARTS:za.ROW_STARTS},n=[];for(const s of t)if(s in e)n.push(e[s]);else break;return n}function EH(t){return t.length===0?0:t[0]===za.FIRST_DIM_SIZE?t.length-1:t.length}function AH(t,e){if(t==null||e==null)return;const n=t.length,s=e.length;if(n>=s)throw new Error(`defaultValue.shape=${t} and ragged tensor flatValues.shape=${e}, are incompatible: defaultValue.rank = ${n} must be less than ragged tensor input flatValues.rank = ${s})`);for(let r=0;r<Math.min(n,s-1);++r){const o=t[r],a=e[r+1];if(o>=0&&a>=0&&o!==1&&o!==a)throw new Error(`defaultValue.shape=${t}, and ragged tensor input flatValues.shape=${e} are incompatible: defaultValue.shape[${r-t.length}] = ${o} but ragged tensor input.flatValues.shape[${r-t.length}] = ${a}`)}}const wT=30;function T3(t){return t<=wT?t:Ky(t,Math.floor(Math.sqrt(t)))}function _T(t,e,n){const s=n*(typeof t=="number"?t:t[0]),r=e*(typeof t=="number"?t:t[1]);return[s,r]}function l2(t,e,n,s=!0){let r=[];if(s)r=r.concat(e.slice(0)),r.push(t[0]/n),r=r.concat(t.slice(1));else{r=r.concat(t[0]);const o=e.length;for(let a=0;a<o;++a)r=r.concat([t[a+1]/e[a],e[a]]);r=r.concat(t.slice(o+1))}return r}function u2(t,e,n=!0){const s=[];if(n){s.push(e);for(let r=e+1;r<t;++r)r<=2*e?(s.push(r),s.push(r-(e+1))):s.push(r)}else{const r=[],o=[];for(let a=1;a<t;++a)a>=e*2+1||a%2===1?o.push(a):r.push(a);s.push(...r),s.push(0),s.push(...o)}return s}function c2(t,e,n,s=!0){const r=[];s?r.push(t[0]/n):r.push(t[0]*n);for(let o=1;o<t.length;++o)o<=e.length?s?r.push(e[o-1]*t[o]):r.push(t[o]/e[o-1]):r.push(t[o]);return r}function $T(t,e){const n=[0];for(let s=0;s<e;++s)n.push(t[s][0]);return n}function xT(t,e,n){const s=t.slice(0,1);for(let r=0;r<n;++r)s.push(t[r+1]-e[r][0]-e[r][1]);return s}const N3=1.7580993408473768,I3=1.0507009873554805;const ST=.3275911,CT=.254829592,kT=-.284496736,TT=1.421413741,NT=-1.453152027,IT=1.061405429;function Rl(t,e){if(t.length!==e.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${t.length}, imag: ${e.length}.`);const n=new Float32Array(t.length*2);for(let s=0;s<n.length;s+=2)n[s]=t[s/2],n[s+1]=e[s/2];return n}function OH(t){const e=new Float32Array(t.length/2),n=new Float32Array(t.length/2);for(let s=0;s<t.length;s+=2)e[s/2]=t[s],n[s/2]=t[s+1];return{real:e,imag:n}}function RH(t){const e=Math.ceil(t.length/4),n=new Float32Array(e),s=new Float32Array(e);for(let r=0;r<t.length;r+=4)n[Math.floor(r/4)]=t[r],s[Math.floor(r/4)]=t[r+1];return{real:n,imag:s}}function DH(t){const e=Math.floor(t.length/4),n=new Float32Array(e),s=new Float32Array(e);for(let r=2;r<t.length;r+=4)n[Math.floor(r/4)]=t[r],s[Math.floor(r/4)]=t[r+1];return{real:n,imag:s}}function ET(t,e){const n=t[e*2],s=t[e*2+1];return{real:n,imag:s}}function FH(t,e,n,s){t[s*2]=e,t[s*2+1]=n}function MH(t,e){const n=new Float32Array(t/2),s=new Float32Array(t/2);for(let r=0;r<Math.ceil(t/2);r++){const o=(e?2:-2)*Math.PI*(r/t);n[r]=Math.cos(o),s[r]=Math.sin(o)}return{real:n,imag:s}}function PH(t,e,n){const s=(n?2:-2)*Math.PI*(t/e),r=Math.cos(s),o=Math.sin(s);return{real:r,imag:o}}const y$="->",Jct=/->/g,JR=",",QR="...";function AT(t,e){t=t.replace(/\s/g,"");const n=(t.length-t.replace(Jct,"").length)/y$.length;if(n<1)throw new Error("Equations without an arrow are not supported.");if(n>1)throw new Error(`Equation must contain exactly one arrow ("${y$}").`);const[s,r]=t.split(y$);q(s.indexOf(QR)===-1,()=>`The ellipsis notation ("${QR}") is not supported yet.`);const o=s.split(JR),a=o.length;if(e!==a)throw new Error(`Expected ${a} input tensors, received ${e}`);if(a>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const i=[];for(let f=0;f<r.length;++f){const h=r[f];if(!o.some(p=>p.indexOf(h)!==-1))throw new Error(`Output subscripts contain the label ${h} not present in the input subscripts.`);i.indexOf(h)===-1&&i.push(h)}for(let f=0;f<s.length;++f){const h=s[f];i.indexOf(h)===-1&&h!==JR&&i.push(h)}const l=new Array(o.length);for(let f=0;f<a;++f){if(new Set(o[f].split("")).size!==o[f].length)throw new Error(`Found duplicate axes in input component ${o[f]}. Support for duplicate axes in input is not implemented yet.`);l[f]=[];for(let h=0;h<o[f].length;++h)l[f].push(i.indexOf(o[f][h]))}const u=i.length,c=r.length,d=[];for(let f=c;f<u;++f)d.push(f);return{allDims:i,summedDims:d,idDims:l}}function OT(t,e){let n=new Array(t);n.fill(-1);for(let r=0;r<e.length;++r)n[e[r]]=r;const s=[];for(let r=0;r<t;++r)n[r]===-1&&s.push(r);return n=n.filter(r=>r!==-1),{permutationIndices:n,expandDims:s}}function RT(t,e,n){const s=new Array(t);for(let r=0;r<n.length;++r){const o=n[r].shape;for(let a=0;a<e[r].length;++a)s[e[r][a]]===void 0?s[e[r][a]]=o[a]:q(s[e[r][a]]===o[a],()=>`Expected dimension ${s[e[r][a]]} at axis ${a} of input shaped ${JSON.stringify(o)}, but got dimension ${o[a]}`)}}function DT(t,e){const n=t,s=[];let r=0;t.length===0&&n.push(-1),r=t.length+1;for(let a=0;a<r;++a)s.push([]);const o=[];for(let a=0;a<n.length;++a){const i=n[a],l=Qct(e,i);for(const u of l)o.indexOf(u)===-1&&(s[a].push(u),o.push(u))}return{path:n,steps:s}}function FT(t){return t.every((e,n)=>e===n)}function Qct(t,e){const n=[];for(let s=0;s<t.length;++s)(t[s].length===0||t[s].indexOf(e)!==-1||e===-1)&&n.push(s);return n}function MT(t,e,n=0){let s=[];if(typeof e=="number")q(t.shape[n]%e===0,()=>"Number of splits must evenly divide the axis."),s=new Array(e).fill(t.shape[n]/e);else{const r=e.reduce((a,i)=>(i===-1&&(a+=1),a),0);q(r<=1,()=>"There should be only one negative value in split array.");const o=e.indexOf(-1);if(o!==-1){const a=e.reduce((i,l)=>l>0?i+l:i);e[o]=t.shape[n]-a}q(t.shape[n]===e.reduce((a,i)=>a+i),()=>"The sum of sizes must match the size of the axis dimension."),s=e}return s}function LH(t){return`Received SparseTensor with denseShape[0] = 0 but
  indices.shape[0] = ${t}`}function zH(t,e){return`indices(${t}, 0) is invalid: ${e} < 0`}function BH(t,e,n){return`indices(${t}, 0) is invalid: ${e} >= ${n}`}function VH(t,e){return`only one output dimension may be -1, not both ${t} and ${e}`}function HH(t,e){return`size ${t} must be non-negative, not ${e}`}function WH(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function UH(t,e){const n=Ge(t),s=Ge(e);return`Input to reshape is a SparseTensor with ${n}
  dense values, but the requested shape requires a multiple of ${s}. inputShape=${t} outputShape= ${e}`}function GH(t,e){const n=Ge(t),s=Ge(e);return`Input to reshape is a tensor with ${n} dense values, but the requested shape has ${s}. inputShape=${t} outputShape=${e}`}function Nx(){return"segment ids must be >= 0"}function jH(){return"segment ids are not increasing"}function KH(t,e){return`Segment id ${t} out of range [0, ${e}), possibly because segmentIds input is not sorted.`}function qH(t,e,n){return`Bad: indices[${t}] == ${e} out of range [0, ${n})`}function XH(t,e){let n=!1,s;for(t<=wT?(s=t,n=!0):s=Ky(t,Math.floor(Math.sqrt(t)));!n;)s>e||s===t?n=!0:s=Ky(t,s+1);return s}function YH(t,e,n){const s=[],r=t.length;for(let o=0;o<r;o++)o!==e?s.push(t[o]):s.push(n);return s}function PT(t,e,n,s){const r=e.shape.length,o=t.shape.length;if(s!==0&&(s<-r||s>r))throw new Error(`Expect batchDims in the range of [-${r}, ${r}], but got ${s}`);if(s<0&&(s+=r),s>o)throw new Error(`batchDims (${s}) must be less than rank(x) (
    ${o}).`);if(n<s)throw new Error(`batchDims (${s}) must be less than or equal to axis (${n}).`);for(let d=0;d<s;++d)if(t.shape[d]!==e.shape[d])throw new Error(`x.shape[${d}]: ${t.shape[d]} should be equal to indices.shape[${d}]: ${e.shape[d]}.`);const a=t.shape[n],i=[];let l=1,u=1,c=1;for(let d=0;d<s;++d)i.push(t.shape[d]),l*=t.shape[d];for(let d=s;d<n;d++)i.push(t.shape[d]),u*=t.shape[d];for(let d=s;d<r;d++)i.push(e.shape[d]);for(let d=n+1;d<o;d++)i.push(t.shape[d]),c*=t.shape[d];return{batchSize:l,sliceSize:c,outerSize:u,dimSize:a,outputShape:i}}const edt=Object.freeze(Object.defineProperty({__proto__:null,segOpComputeOptimalWindowSize:XH,computeOutShape:YH,collectGatherOpShapeInfo:PT},Symbol.toStringTag,{value:"Module"}));function Md(t){try{return t.map(e=>Nl(e))}catch(e){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${e}`)}}function ZH(t){return t.map(e=>Oi(e))}const JH=Object.freeze(Object.defineProperty({__proto__:null,slice_util:vV,segment_util:edt,fromUint8ToStringArray:Md,fromStringArrayToUint8:ZH,upcastType:Yr,axesAreInnerMostDims:U8,combineLocations:TV,computeOutAndReduceShapes:js,expandShapeToKeepDim:ys,assertAxesAreInnerMostDims:cr,getAxesPermutation:hs,getUndoAxesPermutation:pc,getInnerMostAxes:bs,getBroadcastDims:Ad,getReductionAxes:Ts,assertAndGetBroadcastShape:Zt,assertParamsConsistent:bT,computeOutShape:Di,computeDilation2DInfo:G1,computePool2DInfo:Na,computePool3DInfo:Xl,computeConv2DInfo:Gs,computeConv3DInfo:hc,computeDefaultPad:C8,tupleValuesAreOne:Zu,eitherStridesOrDilationsAreOne:ur,convertConv2DDataFormat:Yl,checkPadOnDimRoundingMode:Mr,getFusedDyActivation:p3,getFusedBiasGradient:m3,applyActivation:g3,shouldFuse:v3,get RowPartitionType(){return za},combineRaggedTensorToTensorShapes:NH,getRowPartitionTypesHelper:IH,getRaggedRank:EH,validateDefaultValueShape:AH,PARALLELIZE_THRESHOLD:wT,computeOptimalWindowSize:T3,getImageCenter:_T,getReshaped:l2,getPermuted:u2,getReshapedPermuted:c2,getSliceBeginCoords:$T,getSliceSize:xT,prepareAndValidate:L_,validateUpdateShape:l8,validateInput:u8,calculateShapes:Jp,SELU_SCALEALPHA:N3,SELU_SCALE:I3,ERF_P:ST,ERF_A1:CT,ERF_A2:kT,ERF_A3:TT,ERF_A4:NT,ERF_A5:IT,warn:Fo,log:Sst,mergeRealAndImagArrays:Rl,splitRealAndImagArrays:OH,complexWithEvenIndex:RH,complexWithOddIndex:DH,getComplexWithIndex:ET,assignToTypedArray:FH,exponents:MH,exponent:PH,decodeEinsumEquation:AT,getEinsumPermutation:OT,checkEinsumDimSizes:RT,getEinsumComputePath:DT,isIdentityPermutation:FT,prepareSplitSize:MT,getSparseFillEmptyRowsIndicesDenseShapeMismatch:LH,getSparseFillEmptyRowsNegativeIndexErrorMessage:zH,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:BH,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:VH,getSparseReshapeNegativeOutputDimErrorMessage:HH,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:WH,getSparseReshapeInputOutputMultipleErrorMessage:UH,getSparseReshapeInputOutputMismatchErrorMessage:GH,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:Nx,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:jH,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:KH,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:qH},Symbol.toStringTag,{value:"Module"}));const tdt=Object.freeze(Object.defineProperty({__proto__:null,nonMaxSuppressionV3Impl:y3,nonMaxSuppressionV4Impl:b3,nonMaxSuppressionV5Impl:w3,whereImpl:f3},Symbol.toStringTag,{value:"Module"}));const QH={kernelName:Vg,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Te(t,uf(ht(n,"float32"),-1))}}};const ndt={kernelName:sp,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>{const s=Dn(ht(n,"float32")),r=ar($t(Pt(1),s));return Jn(Et(t,r))}}}};const sdt={kernelName:rp,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>{const s=ar($t(Dn(ht(n,"float32")),1));return Et(t,s)}}}};const rdt={kernelName:nf,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,s]=e,r=Zt(n.shape,s.shape);return{a:()=>{let i=t;const l=Ts(n.shape,r);return l.length>0&&(i=kt(i,l)),Ne(i,n.shape)},b:()=>{let i=t;const l=Ts(s.shape,r);return l.length>0&&(i=kt(i,l)),Ne(i,s.shape)}}}};const odt={kernelName:Hg,saveAllInputs:!0,gradFunc:(t,e)=>{const n={};return e.forEach((s,r)=>{n[r]=()=>t.clone()}),n}};const adt={kernelName:Wg,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>yn(n)}}};const idt={kernelName:Ug,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>yn(n)}}};const ldt={kernelName:op,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Et(t,ar($t(Pt(1),Dn(ht(n,"float32")))))}}};const udt={kernelName:ap,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>{const s=ar(st(Pt(1),Dn(ht(n,"float32"))));return Et(t,s)}}}};const cdt={kernelName:up,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,s]=e,r=Zt(n.shape,s.shape);return{a:()=>{const i=st(Dn(n),Dn(s));let l=Te(t,Et(s,i));const u=Ts(n.shape,r);return u.length>0&&(l=kt(l,u)),Ne(l,n.shape)},b:()=>{const i=st(Dn(n),Dn(s));let l=Jn(Te(t,Et(n,i)));const u=Ts(s.shape,r);return u.length>0&&(l=kt(l,u)),Ne(l,s.shape)}}}};const ddt={kernelName:ip,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Et(t,st(Dn(ht(n,"float32")),1))}}};const fdt={kernelName:lp,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Et(t,$t(Pt(1),Dn(ht(n,"float32"))))}}};function hdt(t,e,n,s,r,o){const a=te(t,"dy","avgPool3dGrad"),i=te(e,"input","avgPool3dGrad");let l=a,u=i,c=!1;i.rank===4&&(c=!0,l=Ne(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]]),u=Ne(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),q(l.rank===5,()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${l.rank}.`),q(u.rank===5,()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${u.rank}.`),Mr("avgPool3dGrad",r,o);const d={dy:l,input:u},f={filterSize:n,strides:s,pad:r,dimRoundingMode:o},h=ye.runKernel(Dw,d,f);return c?Ne(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}const pdt=be({avgPool3dGrad_:hdt});const mdt={kernelName:jg,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[s]=e,{filterSize:r,strides:o,pad:a,dimRoundingMode:i}=n;return{x:()=>pdt(t,s,r,o,a,i)}}};function gdt(t,e,n,s,r){const o=te(t,"dy","avgPoolGrad"),a=te(e,"input","avgPoolGrad");q(a.rank===o.rank,()=>`Rank of input (${a.rank}) does not match rank of dy (${o.rank})`);let i=a,l=o,u=!1;a.rank===3&&(u=!0,i=Ne(a,[1,a.shape[0],a.shape[1],a.shape[2]]),l=Ne(o,[1,o.shape[0],o.shape[1],o.shape[2]])),q(l.rank===4,()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${l.rank}.`),q(i.rank===4,()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${i.rank}.`);const c={dy:l,input:i},d={filterSize:n,strides:s,pad:r},f=ye.runKernel(Rw,c,d);return u?Ne(f,[f.shape[1],f.shape[2],f.shape[3]]):f}const vdt=be({avgPoolGrad_:gdt});const ydt={kernelName:Gg,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[s]=e,{filterSize:r,strides:o,pad:a}=n;return{x:()=>vdt(t,s,r,o,a)}}};const bdt={kernelName:Kg,inputsToSave:["a","b"],gradFunc:(t,e,n)=>{const[s,r]=e,{transposeA:o,transposeB:a}=n;return!o&&!a?{a:()=>ln(t,r,!1,!0),b:()=>ln(s,t,!0,!1)}:!o&&a?{a:()=>ln(t,r,!1,!1),b:()=>ln(t,s,!0,!1)}:o&&!a?{a:()=>ln(r,t,!1,!0),b:()=>ln(s,t,!1,!1)}:{a:()=>ln(r,t,!0,!0),b:()=>ln(t,s,!0,!0)}}};const wdt={kernelName:qg,gradFunc:(t,e,n)=>{const{blockShape:s,crops:r}=n;return{x:()=>e2(t,s,r)}}};const _dt={kernelName:TB,gradFunc:(t,e,n)=>{const s=n,r=s.inputShape,o=s.shape,a=Array.from(o);for(let l=r.length-1;l>=0;l--)if(r[l]===o[l])a[l]=1;else if(r[l]!==1)throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${o}].`);const i=[];for(let l=0;l<a.length;l++)a[l]>1&&i.push(l);return{x:()=>kt(t,i,!0)}}};const $dt={kernelName:cp,gradFunc:t=>({x:()=>t.clone()})};const xdt={kernelName:dp,gradFunc:t=>({x:()=>yn(t)})};const Sdt={kernelName:fp,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[s]=e,{clipValueMin:r,clipValueMax:o}=n;return{x:()=>wr(Ta(Zl(s,r),mc(s,o)),t,yn(t))}}};const Cdt={kernelName:Xg,inputsToSave:["x"],gradFunc:QH.gradFunc};const kdt={kernelName:Yg,saveAllInputs:!0,gradFunc:(t,e,n)=>{const s=e.map(l=>l.shape),{axis:r}=n,o=un(r,e[0].shape)[0],a=s.map(l=>l[o]);return Kr(t,a,o).map(l=>()=>l)}};const Tdt={kernelName:Zg,inputsToSave:["x","filter"],gradFunc:(t,e,n)=>{const[s,r]=e,{dilations:o,strides:a,pad:i,dataFormat:l}=n;return q(Zu(o),()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${o}'`),{x:()=>M8(s.shape,t,r,a,i,l),filter:()=>mT(s,t,r.shape,a,i,l)}}};const Ndt={kernelName:Jg,inputsToSave:["dy","filter"],gradFunc:(t,e,n)=>{const[s,r]=e,{strides:o,pad:a,dataFormat:i,dimRoundingMode:l}=n;return{dy:()=>Al(t,r,o,a,i,1,l),filter:()=>mT(t,s,r.shape,o,a,i,l)}}};function Idt(t,e,n,s,r){let o=t;t.rank===4&&(o=Ne(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]));let a=e;a.rank===4&&(a=Ne(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]])),q(o.rank===5,()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${o.shape}.`),q(a.rank===5,()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${a.shape}.`),q(n.length===5,()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${n}.`),q(o.shape[4]===n[3],()=>`Error in conv3dDerFilter: depth of input ${o.shape[4]}) must match input depth in filter (${n[3]}.`),q(a.shape[4]===n[4],()=>`Error in conv3dDerFilter: depth of dy (${a.shape[4]}) must match output depth for filter (${n[4]}).`);const i={x:o,dy:a},l={strides:s,pad:r,filterShape:n};return ye.runKernel(zw,i,l)}const Edt=be({conv3DBackpropFilter_:Idt});const Adt={kernelName:Qg,inputsToSave:["x","filter"],gradFunc:(t,e,n)=>{const{dilations:s,strides:r,pad:o}=n;q(Zu(s),()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`);const[a,i]=e;return{x:()=>SV(a.shape,t,i,r,o),filter:()=>Edt(a,t,i.shape,r,o)}}};const Odt={kernelName:hp,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Te(Jn(o3(ht(n,"float32"))),t)}}};const Rdt={kernelName:pp,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Te(a3(ht(n,"float32")),t)}}};const Ddt={kernelName:e1,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[s]=e,{axis:r,exclusive:o,reverse:a}=n;return{x:()=>{const i=hs([r],s.rank);let l=G_(t,r,o,!a);return i!=null&&(l=dn(l,i)),l}}}};const Fdt={kernelName:t1,inputsToSave:["x","filter"],gradFunc:(t,e,n)=>{const{dilations:s,strides:r,pad:o,dimRoundingMode:a}=n,i=s??[1,1];q(Zu(i),()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${i}'`);const[l,u]=e;return q(l.rank===4,()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${l.rank}.`),q(u.rank===4,()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${u.rank}.`),q(l.shape[3]===u.shape[2],()=>`Error in gradient of depthwiseConv2d: number of input channels (${l.shape[3]}) must match the inChannels dimension in filter ${u.shape[2]}.`),q(ur(r,i),()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${r} and dilations '${i}'.`),Mr("depthwiseConv2d",o,a),{x:()=>vH(l.shape,t,u,r,o,i,a),filter:()=>gH(l,t,u.shape,r,o,i,a)}}};const Mdt={kernelName:n1,inputsToSave:["x","filter"],gradFunc:(t,e,n)=>{const[s,r]=e,o={x:s,filter:r,dy:t},a={x:s,filter:r,dy:t};return{x:()=>ye.runKernel(qy,o,n),filter:()=>ye.runKernel(Xy,a,n)}}};const Pdt={kernelName:gp,outputsToSave:[!0],gradFunc:(t,e)=>{const[n]=e,s={dy:t,y:n};return{x:()=>ye.runKernel(Xw,s)}}};const Ldt={kernelName:vp,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e,s=Te($o(Jn(Dn(n))),2/Math.sqrt(Math.PI));return{x:()=>Te(t,s)}}};const zdt={kernelName:yp,outputsToSave:[!0],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Te(t,n)}}};const Bdt={kernelName:r1,inputsToSave:["input"],gradFunc:(t,e)=>{const[n]=e;return{input:()=>Ne(t,n.shape)}}};const Vdt={kernelName:bp,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Te(t,$o(n))}}};const Hdt={kernelName:wp,gradFunc:t=>({x:()=>yn(t)})};const Wdt={kernelName:_p,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,s]=e,r=Zt(n.shape,s.shape);return{a:()=>{const i=Et(t,ht(s,"float32")),l=Ts(n.shape,r);return l.length>0?Ne(kt(i,l),n.shape):i},b:()=>{let i=Te(t,ht(n,"float32"));const l=Ts(s.shape,r);l.length>0&&(i=Ne(kt(i,l),s.shape));const u=Dn(s);return Jn(Et(i,ht(u,"float32")))}}}};const Udt={kernelName:o1,inputsToSave:["x","mean","variance","scale"],gradFunc:(t,e,n)=>{const{varianceEpsilon:s}=n,[r,o,a,i]=e,l=i??Pt(1),u=Ts(o.shape,r.shape),c=[];if(o.rank===1){for(let _=0;_<r.shape.length-1;++_)c.push(r.shape[_]);c.push(1)}const d=$t(r,o),f=Te(t,l),h=n3(st(a,Pt(s))),p=Te(Te(Te(h,h),h),Pt(-.5));return{x:()=>o.rank===1?Ne(Te(Te(t,Lo(Ne(h,[1,1,1,o.shape[0]]),c)),l),r.shape):Ne(Te(Te(t,h),l),r.shape),mean:()=>{let _=Te(Te(h,Pt(-1)),f);return o.rank===1&&(_=kt(_,u)),Ne(_,o.shape)},variance:()=>{let _=Te(Te(p,d),f);return o.rank===1&&(_=kt(_,u)),Ne(_,o.shape)},scale:()=>{const _=Te(d,h);let $=Te(t,_);return o.rank===1&&($=kt($,u)),Ne($,o.shape)},offset:()=>{let _=t;return o.rank===1&&(_=kt(_,u)),Ne(_,o.shape)}}}};const Gdt={kernelName:a1,inputsToSave:["x","indices"],gradFunc:(t,e,n)=>{const[s,r]=e,{axis:o}=n,a=un(o,s.shape)[0];return{x:()=>{const l=s.shape,u=r.size,c=l.slice(0,a),d=c.length,f=l.slice(o,l.length).slice(1),h=f.length,p=eD(0,d),m=eD(d+1,d+1+h),g=tD([c,[u],f]),y=Ne(t,g),w=Ne(r,[u]),b=tD([[d],p,m]),_=dn(y,b);let $=d3(_,w,s.shape[a]);const x=pc(b);return $=dn($,x),$},indices:()=>r}}};function eD(t,e){const n=[];for(let s=t;s<e;++s)n.push(s);return n}function tD(t){const e=[];for(let n=0;n<t.length;++n)for(let s=0;s<t[n].length;++s)e.push(t[n][s]);return e}const jdt={kernelName:$p,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,s]=e;return{a:()=>yn(n),b:()=>yn(s)}}};const Kdt={kernelName:xp,gradFunc:t=>({x:()=>ht(t,"float32")})};const qdt={kernelName:Sp,gradFunc:t=>({x:()=>yn(t)})};const Xdt={kernelName:Cp,gradFunc:t=>({x:()=>yn(t)})};const Ydt={kernelName:kp,gradFunc:t=>({x:()=>yn(t)})};const Zdt={kernelName:l1,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[s]=e,{alpha:r}=n,o=Pr(s,0);return{x:()=>wr(o,t,Te(t,r))}}};const Jdt={kernelName:Np,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Et(t,st(n,1))}}};const Qdt={kernelName:Tp,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Et(t,ht(n,"float32"))}}};const eft={kernelName:NB,inputsToSave:[],outputsToSave:[!0],gradFunc:(t,e,n)=>{const[s]=e,{axis:r}=n;return{logits:()=>{const a=$o(s);return $t(t,Te(kt(t,r,!0),a))}}}};function tft(t,e,n,s=5,r=1,o=1,a=.5){const i={x:t,y:e,dy:n},l={depthRadius:s,bias:r,alpha:o,beta:a};return ye.runKernel(s_,i,l)}const nft=be({localResponseNormalizationBackprop_:tft});const sft={kernelName:p1,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,e,n)=>{const[s,r]=e,{depthRadius:o,bias:a,alpha:i,beta:l}=n;return{x:()=>nft(s,r,t,o,a,i,l)}}};function eW(t,e,n,s){return e.rank<n.rank&&(e=Ne(e,ys(e.shape,s))),t.rank<n.rank&&(t=Ne(t,ys(t.shape,s))),{x:()=>Te(t,ht(_o(n,e),t.dtype))}}const nD={kernelName:m1,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,e,n)=>{const s=n,{reductionIndices:r}=s,o=e[0],a=e[1],i=un(r,o.shape),l=eW(t,a,o,i);return{x:()=>l.x()}}};const rft={kernelName:Ip,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,s]=e;return{a:()=>Te(t,ht(Zl(n,s),"float32")),b:()=>Te(t,ht(K_(n,s),"float32"))}}};function oft(t,e,n,s,r,o,a){const i=te(t,"dy","maxPool3dGrad"),l=te(e,"input","maxPool3dGrad"),u=te(n,"output","maxPool3dGrad");let c=i,d=l,f=u,h=!1;l.rank===4&&(h=!0,c=Ne(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]]),d=Ne(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]]),f=Ne(u,[1,u.shape[0],u.shape[1],u.shape[2],u.shape[3]])),q(c.rank===5,()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${c.rank}.`),q(d.rank===5,()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${d.rank}.`),q(f.rank===5,()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${f.rank}.`),Mr("maxPool3dGrad",o,a);const p={dy:c,input:d,output:f},m={filterSize:s,strides:r,pad:o,dimRoundingMode:a},g=ye.runKernel(o_,p,m);return h?Ne(g,[g.shape[1],g.shape[2],g.shape[3],g.shape[4]]):g}const aft=be({maxPool3dGrad_:oft});const ift={kernelName:v1,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,e,n)=>{const[s,r]=e,{filterSize:o,strides:a,pad:i,dimRoundingMode:l}=n;return{x:()=>aft(t,s,r,o,a,i,l)}}};function lft(t,e,n,s,r,o,a){const i=te(t,"dy","maxPoolGrad"),l=te(e,"input","maxPoolGrad"),u=te(n,"output","maxPoolGrad");q(l.rank===i.rank,()=>`Rank of input (${l.rank}) does not match rank of dy (${i.rank})`),q(i.rank===4,()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${i.rank}.`),q(l.rank===4,()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${l.rank}.`),Mr("maxPoolGrad",o,a);const c={dy:i,input:l,output:u},d={filterSize:s,strides:r,pad:o,dimRoundingMode:a};return ye.runKernel(r_,c,d)}const uft=be({maxPoolGrad_:lft});const cft={kernelName:g1,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,e,n)=>{const[s,r]=e,{filterSize:o,strides:a,pad:i}=n;return{x:()=>uft(t,s,r,o,a,i)}}};const dft={kernelName:y1,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[s]=e,{axis:r}=n,o=un(r,s.shape),i=js(s.shape,o)[1],l=Ge(i);return{x:()=>{const c=s.shape.slice();o.forEach(h=>{c[h]=1});const d=Ne(t,c);return Et(Te(d,po(s.shape,"float32")),l)}}}};const fft={kernelName:b1,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,e,n)=>{const s=n,{axis:r}=s,[o,a]=e,i=un(r,o.shape),l=eW(t,a,o,i);return{x:()=>l.x()}}};const hft={kernelName:Ep,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,s]=e;return{a:()=>Te(t,ht(mc(n,s),"float32")),b:()=>Te(t,ht(Pr(n,s),"float32"))}}};const pft={kernelName:w1,inputsToSave:["x"],gradFunc:(t,e,n)=>{const s=e[0],{paddings:r}=n,o=r.map(a=>a[0]);return{x:()=>mn(t,o,s.shape)}}};const mft={kernelName:Ap,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,s]=e,r=Zt(n.shape,s.shape);return{a:()=>{const i=Ts(n.shape,r);return i.length>0?Ne(kt(t,i),n.shape):t},b:()=>{const i=Te(t,Jn(sm(Et(n,s)))),l=Ts(s.shape,r);return l.length>0?Ne(kt(i,l),s.shape):i}}}};const gft={kernelName:Op,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,s]=e,r=Zt(n.shape,s.shape);return{a:()=>{const i=Te(t,ht(s,"float32")),l=Ts(n.shape,r);return l.length>0?Ne(kt(i,l),n.shape):i},b:()=>{const i=Te(t,ht(n,"float32")),l=Ts(s.shape,r);return l.length>0?Ne(kt(i,l),s.shape):i}}}};const vft={kernelName:_1,gradFunc:t=>({x:()=>Jn(t)})};const yft={kernelName:S1,inputsToSave:["indices"],gradFunc:(t,e)=>{const n=e[0];return{indices:()=>xs(n.shape,"float32")}}};const bft={kernelName:x1,gradFunc:t=>({x:()=>yn(t)})};const wft={kernelName:C1,saveAllInputs:!0,gradFunc:(t,e,n)=>{const{axis:s}=n;return Yo(t,s).map(o=>()=>o)}};const sD={kernelName:k1,inputsToSave:["x"],gradFunc:(t,e,n)=>{const s=e[0],{paddings:r}=n,o=r.map(a=>a[0]);return{x:()=>mn(t,o,s.shape)}}};const _ft={kernelName:Rp,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(t,e)=>{const[n,s,r]=e,o=n,a=s,i=Zt(o.shape,a.shape);return{a:()=>{const c=ht(a,"float32");let d=Te(t,Te(c,Ol(o,$t(c,Pt(1)))));const f=Ts(o.shape,i);return f.length>0&&(d=kt(d,f)),Ne(d,o.shape)},b:()=>{const c=Pr(o,0),d=wr(c,xo(o),yn(o));let f=Te(t,Te(r,d));const h=Ts(a.shape,i);return h.length>0&&(f=kt(f,h)),Ne(f,a.shape)}}}};const $ft={kernelName:T1,inputsToSave:["x","alpha"],gradFunc:(t,e)=>{const[n,s]=e,r=Pr(n,0);return{x:()=>wr(r,t,Te(t,s)),alpha:()=>{let o=wr(r,yn(t),Te(t,n));const a=Ts(s.shape,t.shape);return a.length>0&&(o=kt(o,a)),Ne(o,s.shape)}}}};function xft(t,e,n){const s=t.shape.slice();s[n]=1;const r=Ne(e,s),o=rg(t,n,!0,!1),a=rg(t,n,!0,!0),i=Te(o,a);return Te(r,i)}function Sft(t,e,n){const s=t.shape.length,r=s-n.length,o=hs(n,s);let a=t;o!=null&&(a=dn(t,o));const i=a.shape.slice(),u=i.splice(s-n.length,n.length).reduce((f,h)=>f*h,1);i.push(u);const c=a.reshape(i);let d=xft(c,e,r);if(d=d.reshape(a.shape),o!=null){const f=pc(o);d=dn(d,f)}return d}const Cft={kernelName:N1,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[s]=e,{axis:r}=n;let o=[];return r==null?o=s.shape.map((a,i)=>i):typeof r=="number"?o=[r]:o=r,{x:()=>Sft(s,t,o)}}};const kft={kernelName:mp,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,s]=e,r=Zt(n.shape,s.shape);return{a:()=>{const i=Et(t,ht(s,"float32")),l=Ts(n.shape,r);return l.length>0?Ne(kt(i,l),n.shape):i},b:()=>{let i=Te(t,ht(n,"float32"));const l=Ts(s.shape,r);l.length>0&&(i=Ne(kt(i,l),s.shape));const u=Dn(s);return Jn(Et(i,ht(u,"float32")))}}}};const Tft={kernelName:Dp,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Et(t,Jn(Dn(n)))}}};const Nft={kernelName:Mp,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e,s=Te(mc(n,6),uf(n));return{x:()=>Te(t,ht(s,"float32"))}}};const Ift={kernelName:Fp,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Te(t,ht(uf(n),"float32"))}}};const Eft={kernelName:I1,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Ne(t,n.shape)}}};const Aft={kernelName:A1,inputsToSave:["images"],gradFunc:(t,e,n)=>{const[s]=e,r={dy:t,images:s};return{images:()=>ye.runKernel(v_,r,n)}}};const Oft={kernelName:E1,inputsToSave:["images"],gradFunc:(t,e,n)=>{const[s]=e,r={dy:t,images:s};return{images:()=>ye.runKernel(g_,r,n)}}};const Rft={kernelName:O1,gradFunc:(t,e,n)=>{const{dims:s}=n,r=un(s,t.shape);return{x:()=>Xo(t,r)}}};const Dft={kernelName:Pp,gradFunc:t=>({x:()=>yn(t)})};const Fft={kernelName:Lp,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Jn(Et(t,Te(Ol(n,1.5),2)))}}};const Mft={kernelName:R1,inputsToSave:["condition"],gradFunc:(t,e)=>{const[n]=e;return{condition:()=>ht(yn(n),"float32"),t:()=>Te(t,ht(n,t.dtype)),e:()=>Te(t,ht(Z1(n),t.dtype))}}};const Pft={kernelName:zp,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>{const s=Pr(n,Pt(0)),r=Pt(N3),o=Pt(I3),a=Te(t,o),i=Te(Te(t,r),$o(ht(n,"float32")));return wr(s,a,i)}}}};const Lft={kernelName:Wp,outputsToSave:[!0],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Te(t,Te(n,$t(Pt(1),n)))}}};const zft={kernelName:Hp,gradFunc:t=>({x:()=>yn(t)})};const Bft={kernelName:Bp,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Te(q1(ht(n,"float32")),t)}}};const Vft={kernelName:Vp,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Te(U_(ht(n,"float32")),t)}}};const Hft={kernelName:D1,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[s]=e,{begin:r,size:o}=n,a=s.shape,[i,l]=z_(s,r,o),u=[];for(let c=0;c<t.rank;c++)u.push([i[c],a[c]-i[c]-l[c]]);return{x:()=>Jl(t,u)}}};const Wft={kernelName:L1,outputsToSave:[!0],gradFunc:(t,e,n)=>{const[s]=e,{dim:r}=n,o=!0,a=Te(t,s);return{logits:()=>$t(a,Te(kt(a,[r],o),s))}}};const Uft={kernelName:Up,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Te(t,qa(n))}}};const rD={kernelName:M1,gradFunc:(t,e,n)=>{const{blockShape:s,paddings:r}=n;return{x:()=>K1(t,s,r)}}};const oD={kernelName:P1,gradFunc:(t,e,n)=>{const{axis:s}=n;return{x:()=>vs(t,s)}}};const Gft={kernelName:Gp,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Et(t,Te(ar(ht(n,"float32")),2))}}};const jft={kernelName:C_,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Te(t,Te(ht(n,"float32"),2))}}};const Kft={kernelName:jp,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,s]=e,r=Pt(2);return{a:()=>Te(t,Te(r,$t(n,s))),b:()=>Te(t,Te(r,$t(s,n)))}}};const qft={kernelName:Zp,gradFunc:t=>({x:()=>yn(t)})};const Xft={kernelName:Kp,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,s]=e,r=Zt(n.shape,s.shape);return{a:()=>{let i=t;const l=Ts(n.shape,r);return l.length>0&&(i=kt(i,l)),Ne(i,n.shape)},b:()=>{let i=t;const l=Ts(s.shape,r);return l.length>0&&(i=kt(i,l)),Ne(Jn(i),s.shape)}}}};const Yft={kernelName:F1,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[s]=e,r=s.shape.slice(),{axis:o}=n;un(o,s.shape).forEach(u=>{r[u]=1});const i=Ne(t,r),l=Te(i,po(s.shape,"float32"));return{x:()=>l}}};const Zft={kernelName:qp,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Et(t,Dn(q1(n)))}}};const Jft={kernelName:Xp,outputsToSave:[!0],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Te($t(Pt(1),Dn(n)),t)}}};const Qft={kernelName:Yp,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[s]=e,{reps:r}=n;return{x:()=>{let a=yn(s);if(s.rank===1)for(let i=0;i<r[0];++i)a=st(a,mn(t,[i*s.shape[0]],[s.shape[0]]));else if(s.rank===2)for(let i=0;i<r[0];++i)for(let l=0;l<r[1];++l)a=st(a,mn(t,[i*s.shape[0],l*s.shape[1]],[s.shape[0],s.shape[1]]));else if(s.rank===3)for(let i=0;i<r[0];++i)for(let l=0;l<r[1];++l)for(let u=0;u<r[2];++u)a=st(a,mn(t,[i*s.shape[0],l*s.shape[1],u*s.shape[2]],[s.shape[0],s.shape[1],s.shape[2]]));else if(s.rank===4)for(let i=0;i<r[0];++i)for(let l=0;l<r[1];++l)for(let u=0;u<r[2];++u)for(let c=0;c<r[3];++c)a=st(a,mn(t,[i*s.shape[0],l*s.shape[1],u*s.shape[2],c*s.shape[3]],[s.shape[0],s.shape[1],s.shape[2],s.shape[3]]));else throw new Error(`Gradient for tile operation is not implemented for rank-${s.rank} tensors yet.`);return a}}}};const eht={kernelName:ld,gradFunc:(t,e,n)=>{const s=n,{perm:r}=s,o=pc(r);return{x:()=>dn(t,o)}}};const tht={kernelName:z1,gradFunc:(t,e,n)=>{const s=n,{axis:r}=s;return{value:()=>Jr(t,r)}}};const nht={kernelName:B1,inputsToSave:["segmentIds"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>sht(t,n)}}};function sht(t,e){const n=Zi(e,yn(e)),s=rm(t,n);let r=Zl(e,Pt(0,"int32"));const o=s.rank-r.rank;for(let i=0;i<o;++i)r=hr(r,i+1);r=Ta(r,po(s.shape,"bool"));const a=yn(s);return wr(r,s,a)}const rht={kernelName:V1,gradFunc:t=>({x:()=>yn(t)})};const oht=[QH,ndt,sdt,rdt,odt,adt,idt,ldt,udt,cdt,ddt,fdt,mdt,ydt,bdt,wdt,_dt,$dt,xdt,Sdt,Cdt,kdt,Ndt,Tdt,Adt,Odt,Rdt,Ddt,Fdt,Mdt,kft,Pdt,Ldt,zdt,Bdt,Vdt,Wdt,Hdt,Udt,Gdt,jdt,Kdt,qdt,Xdt,Ydt,Zdt,Jdt,Qdt,eft,sft,nD,nD,rft,ift,cft,dft,fft,hft,pft,mft,gft,vft,yft,bft,wft,sD,sD,_ft,$ft,Cft,Tft,Nft,Ift,Eft,Aft,Oft,Rft,Dft,Fft,Mft,Pft,Lft,zft,Bft,Vft,Hft,Wft,Uft,rD,rD,oD,oD,Gft,Kft,jft,qft,Xft,Yft,Zft,Jft,Qft,eht,tht,nht,rht];for(const t of oht)IB(t);Xe().prototype.abs=function(){return this.throwIfDisposed(),$s(this)};Xe().prototype.acos=function(){return this.throwIfDisposed(),v8(this)};Xe().prototype.acosh=function(){return this.throwIfDisposed(),y8(this)};Xe().prototype.add=function(t){return this.throwIfDisposed(),st(this,t)};Xe().prototype.all=function(t,e){return this.throwIfDisposed(),V_(this,t,e)};Xe().prototype.any=function(t,e){return this.throwIfDisposed(),sg(this,t,e)};Xe().prototype.argMax=function(t){return this.throwIfDisposed(),Od(this,t)};Xe().prototype.argMin=function(t){return this.throwIfDisposed(),b8(this,t)};Xe().prototype.asScalar=function(){return this.throwIfDisposed(),q(this.size===1,()=>"The array must have only 1 element."),Ne(this,[])};Xe().prototype.asType=function(t){return this.throwIfDisposed(),ht(this,t)};Xe().prototype.as1D=function(){return this.throwIfDisposed(),Ne(this,[this.size])};Xe().prototype.as2D=function(t,e){return this.throwIfDisposed(),Ne(this,[t,e])};Xe().prototype.as3D=function(t,e,n){return this.throwIfDisposed(),Ne(this,[t,e,n])};Xe().prototype.as4D=function(t,e,n,s){return this.throwIfDisposed(),Ne(this,[t,e,n,s])};Xe().prototype.as5D=function(t,e,n,s,r){return this.throwIfDisposed(),Ne(this,[t,e,n,s,r])};Xe().prototype.asin=function(){return this.throwIfDisposed(),w8(this)};Xe().prototype.asinh=function(){return this.throwIfDisposed(),_8(this)};Xe().prototype.atan=function(){return this.throwIfDisposed(),$8(this)};Xe().prototype.atan2=function(t){return this.throwIfDisposed(),x8(this,t)};Xe().prototype.atanh=function(){return this.throwIfDisposed(),S8(this)};Xe().prototype.avgPool=function(t,e,n,s){return this.throwIfDisposed(),j1(this,t,e,n,s)};Xe().prototype.batchToSpaceND=function(t,e){return this.throwIfDisposed(),K1(this,t,e)};Xe().prototype.batchNorm=function(t,e,n,s,r){return this.throwIfDisposed(),Qp(this,t,e,n,s,r)};Xe().prototype.broadcastTo=function(t){return this.throwIfDisposed(),cd(this,t)};Xe().prototype.cast=function(t){return this.throwIfDisposed(),ht(this,t)};Xe().prototype.ceil=function(){return this.throwIfDisposed(),A8(this)};Xe().prototype.clipByValue=function(t,e){return this.throwIfDisposed(),Zr(this,t,e)};Xe().prototype.concat=function(t,e){return this.throwIfDisposed(),t instanceof $n&&(t=[t]),vs([this,...t],e)};Xe().prototype.conv1d=function(t,e,n,s,r,o){return this.throwIfDisposed(),H_(this,t,e,n,s,r,o)};Xe().prototype.conv2dTranspose=function(t,e,n,s,r){return this.throwIfDisposed(),W_(this,t,e,n,s,r)};Xe().prototype.conv2d=function(t,e,n,s,r,o){return this.throwIfDisposed(),Al(this,t,e,n,s,r,o)};Xe().prototype.cos=function(){return this.throwIfDisposed(),q1(this)};Xe().prototype.cosh=function(){return this.throwIfDisposed(),U_(this)};Xe().prototype.cumprod=function(t,e,n){return this.throwIfDisposed(),rg(this,t,e,n)};Xe().prototype.cumsum=function(t,e,n){return this.throwIfDisposed(),G_(this,t,e,n)};Xe().prototype.depthToSpace=function(t,e){return this.throwIfDisposed(),z8(this,t,e)};Xe().prototype.depthwiseConv2d=function(t,e,n,s,r,o){return this.throwIfDisposed(),em(this,t,e,n,s,r,o)};Xe().prototype.dilation2d=function(t,e,n,s,r){return this.throwIfDisposed(),B8(this,t,e,n,s,r)};Xe().prototype.divNoNan=function(t){return this.throwIfDisposed(),V8(this,t)};Xe().prototype.div=function(t){return this.throwIfDisposed(),Et(this,t)};Xe().prototype.dot=function(t){return this.throwIfDisposed(),H8(this,t)};Xe().prototype.elu=function(){return this.throwIfDisposed(),tm(this)};Xe().prototype.equal=function(t){return this.throwIfDisposed(),_o(this,t)};Xe().prototype.erf=function(){return this.throwIfDisposed(),W8(this)};Xe().prototype.euclideanNorm=function(t,e){return this.throwIfDisposed(),G8(this,t,e)};Xe().prototype.exp=function(){return this.throwIfDisposed(),$o(this)};Xe().prototype.expandDims=function(t){return this.throwIfDisposed(),hr(this,t)};Xe().prototype.expm1=function(){return this.throwIfDisposed(),j8(this)};Xe().prototype.fft=function(){return this.throwIfDisposed(),o2(this)};Xe().prototype.flatten=function(){return this.throwIfDisposed(),Ne(this,[this.size])};Xe().prototype.floor=function(){return this.throwIfDisposed(),sm(this)};Xe().prototype.floorDiv=function(t){return this.throwIfDisposed(),B_(this,t)};Xe().prototype.gather=function(t,e){return this.throwIfDisposed(),rm(this,t,e)};Xe().prototype.greaterEqual=function(t){return this.throwIfDisposed(),Zl(this,t)};Xe().prototype.greater=function(t){return this.throwIfDisposed(),Pr(this,t)};Xe().prototype.ifft=function(){return this.throwIfDisposed(),Nh(this)};Xe().prototype.irfft=function(){return this.throwIfDisposed(),l3(this)};Xe().prototype.isFinite=function(){return this.throwIfDisposed(),K8(this)};Xe().prototype.isInf=function(){return this.throwIfDisposed(),q8(this)};Xe().prototype.isNaN=function(){return this.throwIfDisposed(),X8(this)};Xe().prototype.leakyRelu=function(t){return this.throwIfDisposed(),X1(this,t)};Xe().prototype.lessEqual=function(t){return this.throwIfDisposed(),mc(this,t)};Xe().prototype.less=function(t){return this.throwIfDisposed(),K_(this,t)};Xe().prototype.localResponseNormalization=function(t,e,n,s){return this.throwIfDisposed(),Y8(this,t,e,n,s)};Xe().prototype.logSigmoid=function(){return this.throwIfDisposed(),Z8(this)};Xe().prototype.logSoftmax=function(t){return this.throwIfDisposed(),X_(this,t)};Xe().prototype.logSumExp=function(t,e){return this.throwIfDisposed(),Y_(this,t,e)};Xe().prototype.log=function(){return this.throwIfDisposed(),xo(this)};Xe().prototype.log1p=function(){return this.throwIfDisposed(),Y1(this)};Xe().prototype.logicalAnd=function(t){return this.throwIfDisposed(),Ta(this,t)};Xe().prototype.logicalNot=function(){return this.throwIfDisposed(),Z1(this)};Xe().prototype.logicalOr=function(t){return this.throwIfDisposed(),Z_(this,t)};Xe().prototype.logicalXor=function(t){return this.throwIfDisposed(),J8(this,t)};Xe().prototype.matMul=function(t,e,n){return this.throwIfDisposed(),ln(this,t,e,n)};Xe().prototype.maxPool=function(t,e,n,s){return this.throwIfDisposed(),J1(this,t,e,n,s)};Xe().prototype.max=function(t,e){return this.throwIfDisposed(),Go(this,t,e)};Xe().prototype.maximum=function(t){return this.throwIfDisposed(),Zi(this,t)};Xe().prototype.mean=function(t,e){return this.throwIfDisposed(),us(this,t,e)};Xe().prototype.min=function(t,e){return this.throwIfDisposed(),kh(this,t,e)};Xe().prototype.minimum=function(t){return this.throwIfDisposed(),om(this,t)};Xe().prototype.mirrorPad=function(t,e){return this.throwIfDisposed(),eT(this,t,e)};Xe().prototype.mod=function(t){return this.throwIfDisposed(),tT(this,t)};Xe().prototype.mul=function(t){return this.throwIfDisposed(),Te(this,t)};Xe().prototype.neg=function(){return this.throwIfDisposed(),Jn(this)};Xe().prototype.norm=function(t,e,n){return this.throwIfDisposed(),nm(this,t,e,n)};Xe().prototype.notEqual=function(t){return this.throwIfDisposed(),Dd(this,t)};Xe().prototype.oneHot=function(t,e=1,n=0){return this.throwIfDisposed(),Sh(this,t,e,n)};Xe().prototype.onesLike=function(){return this.throwIfDisposed(),So(this)};Xe().prototype.pad=function(t,e){return this.throwIfDisposed(),Jl(this,t,e)};Xe().prototype.pool=function(t,e,n,s,r,o){return this.throwIfDisposed(),nT(this,t,e,n,s,r,o)};Xe().prototype.pow=function(t){return this.throwIfDisposed(),Ol(this,t)};Xe().prototype.prelu=function(t){return this.throwIfDisposed(),t2(this,t)};Xe().prototype.prod=function(t,e){return this.throwIfDisposed(),sT(this,t,e)};Xe().prototype.reciprocal=function(){return this.throwIfDisposed(),oT(this)};Xe().prototype.relu=function(){return this.throwIfDisposed(),li(this)};Xe().prototype.relu6=function(){return this.throwIfDisposed(),e3(this)};Xe().prototype.reshapeAs=function(t){return this.throwIfDisposed(),Ne(this,t.shape)};Xe().prototype.reshape=function(t){return this.throwIfDisposed(),Ne(this,t)};Xe().prototype.resizeBilinear=function(t,e,n){return this.throwIfDisposed(),_H(this,t,e,n)};Xe().prototype.resizeNearestNeighbor=function(t,e,n){return this.throwIfDisposed(),$H(this,t,e,n)};Xe().prototype.reverse=function(t){return this.throwIfDisposed(),Xo(this,t)};Xe().prototype.rfft=function(){return this.throwIfDisposed(),a2(this)};Xe().prototype.round=function(){return this.throwIfDisposed(),t3(this)};Xe().prototype.rsqrt=function(){return this.throwIfDisposed(),n3(this)};Xe().prototype.selu=function(){return this.throwIfDisposed(),s3(this)};Xe().prototype.separableConv2d=function(t,e,n,s,r,o){return this.throwIfDisposed(),r3(this,t,e,n,s,r,o)};Xe().prototype.sigmoid=function(){return this.throwIfDisposed(),qa(this)};Xe().prototype.sign=function(){return this.throwIfDisposed(),aT(this)};Xe().prototype.sin=function(){return this.throwIfDisposed(),o3(this)};Xe().prototype.sinh=function(){return this.throwIfDisposed(),a3(this)};Xe().prototype.slice=function(t,e){return this.throwIfDisposed(),mn(this,t,e)};Xe().prototype.softmax=function(t){return this.throwIfDisposed(),r2(this,t)};Xe().prototype.softplus=function(){return this.throwIfDisposed(),af(this)};Xe().prototype.spaceToBatchND=function(t,e){return this.throwIfDisposed(),e2(this,t,e)};Xe().prototype.split=function(t,e){return this.throwIfDisposed(),Kr(this,t,e)};Xe().prototype.sqrt=function(){return this.throwIfDisposed(),ar(this)};Xe().prototype.square=function(){return this.throwIfDisposed(),Dn(this)};Xe().prototype.squaredDifference=function(t){return this.throwIfDisposed(),u3(this,t)};Xe().prototype.squeeze=function(t){return this.throwIfDisposed(),gc(this,t)};Xe().prototype.stack=function(t,e){this.throwIfDisposed();const n=t instanceof $n?[this,t]:[this,...t];return Jr(n,e)};Xe().prototype.step=function(t){return this.throwIfDisposed(),uf(this,t)};Xe().prototype.stridedSlice=function(t,e,n,s,r,o,a,i){return this.throwIfDisposed(),iT(this,t,e,n,s,r,o,a,i)};Xe().prototype.sub=function(t){return this.throwIfDisposed(),$t(this,t)};Xe().prototype.sum=function(t,e){return this.throwIfDisposed(),kt(this,t,e)};Xe().prototype.tan=function(){return this.throwIfDisposed(),lT(this)};Xe().prototype.tanh=function(){return this.throwIfDisposed(),Rd(this)};Xe().prototype.tile=function(t){return this.throwIfDisposed(),Lo(this,t)};Xe().prototype.toBool=function(){return this.throwIfDisposed(),ht(this,"bool")};Xe().prototype.toFloat=function(){return this.throwIfDisposed(),ht(this,"float32")};Xe().prototype.toInt=function(){return this.throwIfDisposed(),ht(this,"int32")};Xe().prototype.topk=function(t,e){return this.throwIfDisposed(),uT(this,t,e)};Xe().prototype.transpose=function(t){return this.throwIfDisposed(),dn(this,t)};Xe().prototype.unique=function(t){return this.throwIfDisposed(),cT(this,t)};Xe().prototype.unsortedSegmentSum=function(t,e){return this.throwIfDisposed(),d3(this,t,e)};Xe().prototype.unstack=function(t){return this.throwIfDisposed(),Yo(this,t)};Xe().prototype.where=function(t,e){return this.throwIfDisposed(),wr(t,this,e)};Xe().prototype.zerosLike=function(){return this.throwIfDisposed(),yn(this)};class mi extends Error{constructor(e){super(e),Object.setPrototypeOf(this,mi.prototype)}}class pa extends Error{constructor(e){super(e),Object.setPrototypeOf(this,pa.prototype)}}class Ie extends Error{constructor(e){super(e),Object.setPrototypeOf(this,Ie.prototype)}}class Jt extends Error{constructor(e){super(e),Object.setPrototypeOf(this,Jt.prototype)}}class LT extends Error{constructor(e){super(e),Object.setPrototypeOf(this,LT.prototype)}}class tW{constructor(e){this.maxEntries=e||100,this.cache=new Map}get(e){let n;return this.cache.has(e)&&(n=this.cache.get(e),this.cache.delete(e),this.cache.set(e,n)),n}put(e,n){if(this.cache.has(e))this.cache.delete(e);else if(this.cache.size>=this.maxEntries){const s=this.cache.keys().next().value;this.cache.delete(s)}this.cache.set(e,n)}getMaxEntries(){return this.maxEntries}setMaxEntries(e){if(e<0)throw new Error(`The maxEntries of LRU caches must be at least 0, but got ${e}.`);if(this.maxEntries>e)for(let n=0;n<this.maxEntries-e;n++){const s=this.cache.keys().next().value;this.cache.delete(s)}this.maxEntries=e}}function Pd(t,e){if(Array.isArray(t)){let n=[];for(let s=0;s<e;s++)n=n.concat(t);return n}else{const n=new Array(e);return n.fill(t),n}}function gi(t,e){if(!t)throw new LT(e)}function aD(t,e){let n=0;for(const s of t)s===e&&n++;return n}function Ur(t){return t.length===1?t[0]:t}function qn(t){return Array.isArray(t)?t:[t]}function il(t){const n=t.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return n[0]!=="_"?n:"private"+n}function Hc(t){return t.length<=1||t.indexOf("_")===-1?t:t.replace(/[_]+(\w|$)/g,(e,n)=>n.toUpperCase())}let ea={};function zT(t){if(t==null)return null;const e={};return e.className=t.getClassName(),e.config=t.getConfig(),e}function Ix(t){if(!(t==null||typeof t!="object"))if(Array.isArray(t))t.forEach(e=>Ix(e));else{const e=Object.keys(t);for(const n of e){const s=t[n];s!=null&&typeof s=="object"&&(!Array.isArray(s)&&s.type==="ndarray"&&typeof s.value=="number"?t[n]=s.value:Ix(s))}}}function d2(t,e={},n={},s="object",r=!1){if(typeof t=="string"){const o=t;let a;if(o in n)a=n[o];else if(o in ea)a=ea[o];else if(a=e[o],a==null)throw new Ie(`Unknown ${s}: ${t}. This may be due to one of the following reasons:
1. The ${s} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${s} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return a}else{const o=t;if(o.className==null||o.config==null)throw new Ie(`${s}: Improper config format: ${JSON.stringify(o)}.
'className' and 'config' must set.`);const a=o.className;let i,l;if(a in n?[i,l]=n[a]:a in ea?[i,l]=ea.className:a in e&&([i,l]=e[a]),i==null)throw new Ie(`Unknown ${s}: ${a}. This may be due to one of the following reasons:
1. The ${s} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${s} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(l!=null){const u={};for(const h of Object.keys(ea))u[h]=ea[h];for(const h of Object.keys(n))u[h]=n[h];const c=o.config;c.customObjects=u;const d=Object.assign({},ea);for(const h of Object.keys(n))ea[h]=n[h];Ix(o.config);const f=l(i,o.config,n,r);return ea=Object.assign({},d),f}else{const u=Object.assign({},ea);for(const d of Object.keys(n))ea[d]=n[d];const c=new i(o.config);return ea=Object.assign({},u),c}}}function aht(t,e){return t<e?-1:t>e?1:0}function gv(t,e){return-1*aht(t,e)}function Pu(t){if(t==null)return t;const e=[];for(const n of t)e.indexOf(n)===-1&&e.push(n);return e}function iht(t){if(t==null)throw new Ie(`Invalid value in obj: ${JSON.stringify(t)}`);for(const e in t)if(t.hasOwnProperty(e))return!1;return!0}function cf(t,e,n){if(n!=null&&t.indexOf(n)<0)throw new Ie(`${n} is not a valid ${e}.  Valid values are ${t} or null/undefined.`)}function BT(t,e,n=0,s=1/0){return gi(n>=0),gi(s>=n),Array.isArray(t)&&t.length>=n&&t.length<=s&&t.every(r=>typeof r===e)}function Hs(t,e){Array.isArray(t)?(q(t.length>0,()=>`${e} is unexpectedly an empty array.`),t.forEach((n,s)=>Hs(n,`element ${s+1} of ${e}`))):q(Number.isInteger(t)&&t>0,()=>`Expected ${e} to be a positive integer, but got ${nW(t)}.`)}function nW(t){return t===null?"null":Array.isArray(t)?"["+t.map(e=>nW(e)).join(",")+"]":typeof t=="string"?`"${t}"`:`${t}`}function lht(t,e,n){let s=n!=null?n():Ys(),r;return(...a)=>{const i=n!=null?n():Ys();return i-s<e||(s=i,r=t(...a)),r}}function sW(t){return t==="relu"?"relu":t==="linear"?"linear":t==="elu"?"elu":null}let uht=0;function rW(){return uht++}const vv={};function E3(t=""){return t in vv||(vv[t]=0),vv[t]+=1,t+vv[t].toString()}const cht=["channelsFirst","channelsLast"],dht=["nearest","bilinear"],fht=["valid","same","causal"],hht=["max","avg"],pht=["sum","mul","concat","ave"];const xf=new Map;function ws(t){cf(cht,"DataFormat",t)}function mht(t){cf(dht,"InterpolationFormat",t)}function Jo(t){cf(fht,"PaddingMode",t)}function oW(t){cf(hht,"PoolMode",t)}const m0=[],iD="/";function dd(t,e){m0.push(t);try{const n=e();return m0.pop(),n}catch(n){throw m0.pop(),n}}function ght(){return m0.length===0?"":m0.join(iD)+iD}function aW(t){if(!lW(t))throw new Error("Not a valid tensor name: '"+t+"'");return ght()+t}function iW(t){if(!lW(t))throw new Error("Not a valid tensor name: '"+t+"'");xf.has(t)||xf.set(t,0);const e=xf.get(t);if(xf.set(t,xf.get(t)+1),e>0){const n=`${t}_${e}`;return xf.set(n,1),n}else return t}const vht=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function lW(t){return!!t.match(vht)}function yht(t){return t===parseInt(t.toString(),10)}function Lu(t,e,n){e==null&&(e=0),n==null&&(n=t.length);let s=1;for(let r=e;r<n;++r)s*=t[r];return s}function Ih(t){if(t.length===0)return Number.NaN;let e=Number.POSITIVE_INFINITY;for(let n=0;n<t.length;n++){const s=t[n];s<e&&(e=s)}return e}function Ju(t){if(t.length===0)return Number.NaN;let e=Number.NEGATIVE_INFINITY;for(let n=0;n<t.length;n++){const s=t[n];s>e&&(e=s)}return e}function ti(t,e){if(e<t)throw new Ie(`end (${e}) < begin (${t}) is forbidden.`);const n=[];for(let s=t;s<e;++s)n.push(s);return n}let b$;function Os(){return b$==null&&(b$=aV().epsilon()),b$}function ni(){return"channelsLast"}function Fi(t,e){return ht(t,e)}function f2(t,e=-1){const n=t.shape.slice();return e<0&&(e=n.length+e+1),n.splice(e,0,1),Ne(t,n)}function bht(t,e){return Le(()=>{if(t.shape.length!==2)throw new Ie(`repeat() expects a rank-2 tensor, but received a rank-${t.shape.length} tensor.`);const n=f2(t,1);return Ex(n,[1,e,1])})}function wht(t){const e=[Lu(t.shape)];return Ne(t,e)}function _ht(t){if(t.rank<=1)throw new Ie(`batchFlatten requires a minimum rank of 2. Got rank: ${t.rank}.`);const e=[t.shape[0],Lu(t.shape,1)];return Ne(t,e)}function fd(t,e,n){return Le(()=>{switch(t.rank){case 1:return n2(t,e,n);case 2:return i3(t,[e,0],[n,t.shape[1]]);case 3:return s2(t,[e,0,0],[n,t.shape[1],t.shape[2]]);case 4:return Th(t,[e,0,0,0],[n,t.shape[1],t.shape[2],t.shape[3]]);case 5:return mn(t,[e,0,0,0,0],[n,t.shape[1],t.shape[2],t.shape[3],t.shape[4]]);case 6:return mn(t,[e,0,0,0,0,0],[n,t.shape[1],t.shape[2],t.shape[3],t.shape[4],t.shape[5]]);default:throw new Ie(`sliceAlongFirstAxis() received an unsupported tensor rank: ${t.rank}`)}})}function w$(t,e,n){return Le(()=>{switch(t.rank){case 1:return n2(t,e,n);case 2:return i3(t,[0,e],[t.shape[0],n]);case 3:return s2(t,[0,0,e],[t.shape[0],t.shape[1],n]);case 4:return Th(t,[0,0,0,e],[t.shape[0],t.shape[1],t.shape[2],n]);default:throw new Ie(`sliceAlongLastAxis() received an unsupported tensor rank: ${t.rank}`)}})}function yv(t,e,n,s){return Le(()=>{switch(t.rank){case 1:return n2(t,e,n);case 2:switch(s){case 1:return fd(t,e,n);case 2:return w$(t,e,n);default:throw new Ie(`The axis is not within the rank of the tensor ${s}`)}case 3:switch(s){case 1:return fd(t,e,n);case 2:return s2(t,[0,e,0],[t.shape[0],n,t.shape[2]]);case 3:return w$(t,e,n);default:throw new Ie(`The axis is not within the rank of the tensor ${s}`)}case 4:switch(s){case 1:return fd(t,e,n);case 2:return Th(t,[0,e,0,0],[t.shape[0],n,t.shape[2],t.shape[3]]);case 3:return Th(t,[0,0,e,0],[t.shape[0],t.shape[1],n,t.shape[3]]);case 4:return w$(t,e,n);default:throw new Ie(`The axis is not within the rank of the tensor ${s}`)}default:throw new Ie(`sliceAlongLastAxis() received an unsupported tensor rank: ${t.rank}`)}})}function VT(t,e=-1){let n;return e<0&&(n=t[0].rank,n!==0?e=n:e=0),e===t[0].rank&&(e=-1),vs(t,e)}function lD(t,e){switch(t.rank){case 1:return O8([t,e]);case 2:return R8([t,e],0);case 3:return D8([t,e],0);case 4:return F8([t,e],0);default:throw new Ie(`concatAlongFirstAxis() received an unsupported tensor rank: ${t.rank}`)}}function Ex(t,e){if(Array.isArray(e)||(e=[e]),t.rank!==e.length)throw new Ie(`The length of input n (${e.length}) does not match the number of dimensions in input x (${t.rank})`);return Lo(t,e)}function A3(t,e=0,n=1,s,r){return Q_(t,e,n,s,r)}function Mi(t,e,n,s){if(t.rank<2||e.rank<2)throw new Jt(`dot requires both inputs to be rank >= 2 but got x shape = ${t.shape} and y shape = ${e.shape}`);if(e.rank>=3){const r=t.shape.slice(-1)[0],o=e.shape.slice(-2)[0];if(r!==o)throw new Jt(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${t.shape} and  y shape = ${e.shape}`)}if(t.rank===2&&e.rank===2)return Tx({a:t,b:e,transposeA:!1,transposeB:!1,bias:s?Ax(t.rank,s,ni()):null,activation:n});{const r=t.shape.slice(),o=r.pop();t=Ne(t,[-1,o]);const a=e.shape.slice(),i=a.pop(),l=a.pop(),u=[...a,i],c=Array.from({length:e.rank},(p,m)=>m===0?e.rank-2:m<=e.rank-2?m-1:m);e=Ne(dn(e,c),[l,-1]);const d=[...r,...u];return Ne(Tx({a:t,b:e,transposeA:!1,transposeB:!1,bias:s?Ax(t.rank,s,ni()):null,activation:n}),d)}}function uW(t,e,n){return Le(()=>(Array.isArray(e)?e=vr(e,"int32"):e=ht(e,"int32"),rm(t,e,n)))}function h2(t){return Te(t,t)}function Ax(t,e,n){const s=e.shape;if(e.rank!==1&&e.rank!==t)throw new Ie(`Unexpected bias dimensions: ${e.rank}; expected it to be 1 or ${t}`);if(t===5){if(n==="channelsFirst")return s.length===1?Ne(e,[1,s[0],1,1,1]):Ne(e,[1,s[3],s[0],s[1],s[2]]);if(n==="channelsLast")return s.length===1?Ne(e,[1,1,1,1,s[0]]):Ne(e,[1].concat(s))}else if(t===4){if(n==="channelsFirst")return s.length===1?Ne(e,[1,s[0],1,1]):Ne(e,[1,s[2],s[0],s[1]]);if(n==="channelsLast")return s.length===1?Ne(e,[1,1,1,s[0]]):Ne(e,[1].concat(s))}else if(t===3){if(n==="channelsFirst")return s.length===1?Ne(e,[1,s[0],1]):Ne(e,[1,s[1],s[0]]);if(n==="channelsLast")return s.length===1?Ne(e,[1,1,s[0]]):Ne(e,[1].concat(s))}else if(t<3)return e;throw new Ie(`Unsupported input rank by biasAdd: ${e.rank}`)}function ui(t,e,n){return Le(()=>(n==null&&(n=ni()),ws(n),st(t,Ax(t.rank,e,n))))}function $ht(t,e=1){if(e!==1)throw new Jt(`Support for alpha values other than 1 (${e}) is not implemented yet.`);return tm(t)}function xht(t){return Le(()=>Et(t,st($s(t),1)))}function cW(t,e,n,s){return Le(()=>hT(t,e,n,s))}function Sht(t){return Le(()=>{const e=st(.5,Te(.2,t));return Zr(e,0,1)})}function p2(t,e,n=!1){return n?t():e()}const Cht=["fanIn","fanOut","fanAvg"],kht=["normal","uniform","truncatedNormal"];function Tht(t){cf(Cht,"FanMode",t)}function Nht(t){cf(kht,"Distribution",t)}class Ia extends rf{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}}class HT extends Ia{apply(e,n){return xs(e,n)}}HT.className="Zeros";tt(HT);class O3 extends Ia{apply(e,n){return po(e,n)}}O3.className="Ones";tt(O3);class WT extends Ia{constructor(e){if(super(),typeof e!="object")throw new Ie(`Expected argument of type ConstantConfig but got ${e}`);if(e.value===void 0)throw new Ie(`config must have value set but got ${e}`);this.value=e.value}apply(e,n){return Le(()=>Te(Pt(this.value),po(e,n)))}getConfig(){return{value:this.value}}}WT.className="Constant";tt(WT);class UT extends Ia{constructor(e){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=e.minval||this.DEFAULT_MINVAL,this.maxval=e.maxval||this.DEFAULT_MAXVAL,this.seed=e.seed}apply(e,n){return am(e,this.minval,this.maxval,n)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}}UT.className="RandomUniform";tt(UT);class GT extends Ia{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,n){if(n=n||"float32",n!=="float32"&&n!=="int32")throw new Jt(`randomNormal does not support dType ${n}.`);return A3(e,this.mean,this.stddev,n,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}GT.className="RandomNormal";tt(GT);class jT extends Ia{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,n){if(n=n||"float32",n!=="float32"&&n!=="int32")throw new Jt(`truncatedNormal does not support dType ${n}.`);return c3(e,this.mean,this.stddev,n,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}jT.className="TruncatedNormal";tt(jT);let KT=class extends Ia{constructor(e){super(),this.gain=e.gain!=null?e.gain:1}apply(e,n){return Le(()=>{if(e.length!==2||e[0]!==e[1])throw new Ie("Identity matrix initializer can only be used for 2D square matrices.");return Te(this.gain,j_(e[0]))})}getConfig(){return{gain:this.gain}}};KT.className="Identity";tt(KT);function Iht(t,e="channelsLast"){let n,s;if(ws(e),t.length===2)n=t[0],s=t[1];else if([3,4,5].indexOf(t.length)!==-1){if(e==="channelsFirst"){const r=Lu(t,2);n=t[1]*r,s=t[0]*r}else if(e==="channelsLast"){const r=Lu(t,0,t.length-2);n=t[t.length-2]*r,s=t[t.length-1]*r}}else{const r=Lu(t);n=Math.sqrt(r),s=Math.sqrt(r)}return[n,s]}class Qr extends Ia{constructor(e){if(super(),e.scale<0)throw new Ie(`scale must be a positive float. Got: ${e.scale}`);this.scale=e.scale==null?1:e.scale,this.mode=e.mode==null?"fanIn":e.mode,Tht(this.mode),this.distribution=e.distribution==null?"normal":e.distribution,Nht(this.distribution),this.seed=e.seed}apply(e,n){const s=Iht(e),r=s[0],o=s[1];let a=this.scale;if(this.mode==="fanIn"?a/=Math.max(1,r):this.mode==="fanOut"?a/=Math.max(1,o):a/=Math.max(1,(r+o)/2),this.distribution==="normal"){const i=Math.sqrt(a);if(n=n||"float32",n!=="float32"&&n!=="int32")throw new Jt(`${this.getClassName()} does not support dType ${n}.`);return c3(e,0,i,n,this.seed)}else{const i=Math.sqrt(3*a);return am(e,-i,i,n)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}}Qr.className="VarianceScaling";tt(Qr);class R3 extends Qr{constructor(e){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return Qr.className}}R3.className="GlorotUniform";tt(R3);class D3 extends Qr{constructor(e){super({scale:1,mode:"fanAvg",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return Qr.className}}D3.className="GlorotNormal";tt(D3);class F3 extends Qr{constructor(e){super({scale:2,mode:"fanIn",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return Qr.className}}F3.className="HeNormal";tt(F3);class M3 extends Qr{constructor(e){super({scale:2,mode:"fanIn",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return Qr.className}}M3.className="HeUniform";tt(M3);class P3 extends Qr{constructor(e){super({scale:1,mode:"fanIn",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return Qr.className}}P3.className="LeCunNormal";tt(P3);class L3 extends Qr{constructor(e){super({scale:1,mode:"fanIn",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return Qr.className}}L3.className="LeCunNormal";tt(L3);class qT extends Ia{constructor(e){if(super(),this.DEFAULT_GAIN=1,this.gain=e.gain==null?this.DEFAULT_GAIN:e.gain,this.seed=e.seed,this.seed!=null)throw new Jt("Random seed is not implemented for Orthogonal Initializer yet.")}apply(e,n){return Le(()=>{if(e.length<2)throw new Jt("Shape must be at least 2D.");e[0]*e[1]>2e3&&console.warn(`Orthogonal initializer is being called on a matrix with more than 2000 (${e[0]*e[1]}) elements: Slowness may result.`);const s=e[0]>e[1]?[e[1],e[0]]:e,r=A3(s,0,1,"float32");let o=vT.gramSchmidt(r);return e[0]>e[1]&&(o=dn(o)),Te(this.gain,o)})}getConfig(){return{gain:this.gain,seed:this.seed}}}qT.className="Orthogonal";tt(qT);const uD={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function cD(t,e={}){return d2(t,ua.getMap().classNameMap,e,"initializer")}function cs(t){return zT(t)}function as(t){if(typeof t=="string"){const e=t in uD?uD[t]:t;if(e==="GlorotNormal")return new D3;if(e==="GlorotUniform")return new R3;if(e==="HeNormal")return new F3;if(e==="HeUniform")return new M3;if(e==="LeCunNormal")return new P3;if(e==="LeCunUniform")return new L3;{const n={};return n.className=e,n.config={},cD(n)}}else return t instanceof Ia?t:cD(t)}function Ox(t){return Array.isArray(t)&&Array.isArray(t[0])}function ab(t){return t.length===0?[]:Array.isArray(t[0])?t:[t]}function jt(t){let e;if(Array.isArray(t)){if(t.length!==1)throw new Ie(`Expected Tensor length to be 1; got ${t.length}`);e=t[0]}else e=t;return e}function Cn(t){if(Array.isArray(t)&&Array.isArray(t[0])){if(t.length===1)return t=t,t[0];throw new Ie(`Expected exactly 1 Shape; got ${t.length}`)}else return t}function ib(t){let e=0;for(const n of t)n.shape.length===0?e+=1:e+=n.shape.reduce((s,r)=>s*r);return e}const dD="Variable";class dW{constructor(e,n="float32",s=dD,r=!0,o=null){this.dtype=n??"float32",this.shape=e.shape,this.id=rW(),s=s??dD,this.originalName=aW(s),this.name=iW(this.originalName),this.trainable_=r,this.constraint=o,this.val=dT(e,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(e){return this.assertNotDisposed(),Eht(this.val,e),this.val.id!==e.id&&(this.val.assign(e),this.constraint!=null&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(e){this.trainable_=e,this.val.trainable=e}}function Eht(t,e){if(t.shape.toString()!==e.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(t.shape)+" vs. "+JSON.stringify(e.shape))}function Rx(t){return t.map(e=>e.read())}function XT(t){t.forEach(e=>{e[0].write(e[1])})}class Ss{constructor(e){this.dtype=e.dtype,this.shape=e.shape,e.shape!=null?this.ndim=e.shape.length:this.ndim=e.ndim,this.maxNDim=e.maxNDim,this.minNDim=e.minNDim,this.axes=e.axes||{}}}class Ga{constructor(e,n,s,r,o,a,i){this.dtype=e,this.shape=n,this.sourceLayer=s,this.inputs=r,this.callArgs=o,this.outputTensorIndex=i,this.id=rW(),a!=null&&(this.originalName=aW(a),this.name=iW(this.originalName)),this.rank=n.length}}let Aht=0;class z3{constructor(e,n){this.callArgs=n,this.id=Aht++,this.outboundLayer=e.outboundLayer,this.inboundLayers=e.inboundLayers,this.nodeIndices=e.nodeIndices,this.tensorIndices=e.tensorIndices,this.inputTensors=e.inputTensors,this.outputTensors=e.outputTensors,this.inputMasks=e.inputMasks,this.outputMasks=e.outputMasks,this.inputShapes=e.inputShapes,this.outputShapes=e.outputShapes;for(const s of e.inboundLayers)s!=null&&s.outboundNodes.push(this);e.outboundLayer.inboundNodes.push(this)}getConfig(){const e=[];for(const n of this.inboundLayers)n!=null?e.push(n.name):e.push(null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:e,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}}let Oht=0;class cn extends rf{constructor(e={}){super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=Oht++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let n=e.name;if(!n){const s=this.getClassName();n=il(s)+"_"+E3(s)}if(this.name=n,this.trainable_=e.trainable==null?!0:e.trainable,e.inputShape!=null||e.batchInputShape!=null){let s;if(e.batchInputShape!=null)s=e.batchInputShape;else if(e.inputShape!=null){let o=null;e.batchSize!=null&&(o=e.batchSize),s=[o].concat(e.inputShape)}this.batchInputShape=s;let r=e.dtype;r==null&&(r=e.inputDType),r==null&&(r="float32"),this.dtype=r}e.weights!=null?this.initialWeights=e.weights:this.initialWeights=null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(e,n){return e.name+"_ib-"+n.toString()}getNodeAtIndex(e,n){if(this.inboundNodes.length===0)throw new pa(`The layer has never been called and thus has no defined ${n}.`);if(this.inboundNodes.length<=e)throw new Ie(`Asked to get ${n} at node ${e}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[e]}getInputAt(e){return Ur(this.getNodeAtIndex(e,"input").inputTensors)}getOutputAt(e){return Ur(this.getNodeAtIndex(e,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new mi(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(this.inboundNodes.length===0)throw new mi(`Layer ${this.name} is not connected, no input to return.`);return Ur(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(this.inboundNodes.length===0)throw new mi(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new mi(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return Ur(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map(e=>e())}get updates(){return this._updates}get built(){return this._built}set built(e){this._built=e}get trainable(){return this.trainable_}set trainable(e){this._trainableWeights.forEach(n=>n.trainable=e),this.trainable_=e}get trainableWeights(){return this.trainable_?this._trainableWeights.filter(e=>e.trainable):[]}set trainableWeights(e){this._trainableWeights=e}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter(e=>!e.trainable).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(e){this._nonTrainableWeights=e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(e){if(e=qn(e),this.inputSpec==null||this.inputSpec.length===0)return;const n=qn(this.inputSpec);if(e.length!==n.length)throw new Ie(`Layer ${this.name} expects ${n.length} inputs, but it received ${e.length} input tensors. Input received: ${e}`);for(let s=0;s<e.length;s++){const r=e[s],o=n[s];if(o==null)continue;const a=r.rank;if(o.ndim!=null&&a!==o.ndim)throw new Ie(`Input ${s} is incompatible with layer ${this.name}: expected ndim=${o.ndim}, found ndim=${a}`);if(o.maxNDim!=null&&a>o.maxNDim)throw new Ie(`Input ${s} is incompatible with layer ${this.name}: expected max_ndim=${o.maxNDim}, found ndim=${a}`);if(o.minNDim!=null&&a<o.minNDim)throw new Ie(`Input ${s} is incompatible with layer ${this.name}: expected min_ndim=${o.minNDim}, found ndim=${a}.`);if(o.dtype!=null&&r.dtype!==o.dtype)throw new Ie(`Input ${s} is incompatible with layer ${this.name} : expected dtype=${o.dtype}, found dtype=${r.dtype}.`);if(o.axes){const i=r.shape;for(const l in o.axes){const u=Number(l),c=o.axes[l],d=u>=0?i[u]:i[i.length+u];if(c!=null&&[c,null].indexOf(d)===-1)throw new Ie(`Input ${s} is incompatible with layer ${this.name}: expected axis ${u} of input shape to have value ${c} but got shape ${i}.`)}}if(o.shape!=null)for(let i=0;i<o.shape.length;++i){const l=o.shape[i],u=r.shape[i];if(l!=null&&u!=null&&l!==u)throw new Ie(`Input ${s} is incompatible with layer ${this.name}: expected shape=${o.shape}, found shape=${r.shape}.`)}}}call(e,n){return e}invokeCallHook(e,n){this._callHook!=null&&this._callHook(e,n)}setCallHook(e){this._callHook=e}clearCallHook(){this._callHook=null}apply(e,n){n=n||{},this.assertNotDisposed();const s=qn(e);let r=!0;for(const a of s)if(!(a instanceof Ga)){r=!1;break}let o=!0;for(const a of s)if(a instanceof Ga){o=!1;break}if(r===o)throw new Ie("Arguments to apply() must be all SymbolicTensors or all Tensors");return dd(this.name,()=>{if(!this.built){this.assertInputCompatibility(e);const a=[];for(const i of qn(e))a.push(i.shape);this.build(Ur(a)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),this._refCount===null&&o&&(this._refCount=1)}if(this.assertInputCompatibility(e),o){let a=this.call(e,n);const i=qn(a),l=[];for(let u of i)s.indexOf(u)!==-1&&(u=u.clone()),l.push(u);if(a=Ur(l),this.activityRegularizer!=null)throw new Jt("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return a}else{const a=Rht(e),i=this.computeOutputShape(a);let l;const u=Dht(e);if(this.warnOnIncompatibleInputShape(Array.isArray(e)?a[0]:a),i!=null&&i.length>0&&Array.isArray(i[0])?l=i.map((c,d)=>new Ga(u,c,this,qn(e),n,this.name,d)):l=new Ga(u,i,this,qn(e),n,this.name),this.addInboundNode(e,l,null,null,a,i,n),this._refCount++,this.activityRegularizer!=null)throw new Jt("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return l}})}warnOnIncompatibleInputShape(e){if(this.batchInputShape!=null)if(e.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(e)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let n=!1;this.batchInputShape.forEach((s,r)=>{s!=null&&e[r]!=null&&e[r]!==s&&(n=!0)}),n&&console.warn(`The shape of the input tensor (${JSON.stringify(e)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(this.inboundNodes==null||this.inboundNodes.length===0)throw new mi(`The layer ${this.name} has never been called and thus has no defined output shape.`);const e=[];for(const n of this.inboundNodes){const s=JSON.stringify(n.outputShapes);e.indexOf(s)===-1&&e.push(s)}if(e.length===1){const n=this.inboundNodes[0].outputShapes;return Array.isArray(n)&&Array.isArray(n[0])&&n.length===1?n[0]:n}else throw new mi(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new pa(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return ib(this.weights)}build(e){this.built=!0}getWeights(e=!1){return Rx(e?this.trainableWeights:this.weights)}setWeights(e){Le(()=>{const n=this.weights;if(n.length!==e.length)throw new Ie(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${e.length}, but the layer was expecting ${n.length} weights. Provided weights: ${e}...`);if(n.length===0)return;const s=[],r=Rx(n);for(let o=0;o<r.length;++o){const a=r[o],i=n[o],l=e[o];if(!hn(a.shape,l.shape))throw new Ie(`Layer weight shape ${a.shape} not compatible with provided weight shape ${l.shape}`);s.push([i,l])}XT(s)})}addWeight(e,n,s,r,o,a,i,l){if(this._addedWeightNames.indexOf(e)!==-1)throw new Ie(`Duplicate weight name ${e} for layer ${this.name}`);this._addedWeightNames.push(e),s==null&&(s="float32"),this.fastWeightInitDuringBuild&&(r=l!=null?l():as("zeros"));const u=r.apply(n,s),c=new dW(u,s,e,a,i);return u.dispose(),o!=null&&this.addLoss(()=>o.apply(c.read())),a==null&&(a=!0),a?this._trainableWeights.push(c):this._nonTrainableWeights.push(c),c}setFastWeightInitDuringBuild(e){this.fastWeightInitDuringBuild=e}addLoss(e){e==null||Array.isArray(e)&&e.length===0||(e=qn(e),this._losses!==void 0&&this._losses!==null&&this.losses.push(...e))}computeOutputShape(e){return e}computeMask(e,n){if(!this.supportsMasking){if(n!=null)if(Array.isArray(n))n.forEach(s=>{if(s!=null)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)});else throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);return null}return n}addInboundNode(e,n,s,r,o,a,i=null){const l=qn(e);n=qn(n),s=qn(s),r=qn(r),o=ab(o),a=ab(a);const u=[],c=[],d=[];for(const f of l)u.push(f.sourceLayer),c.push(f.nodeIndex),d.push(f.tensorIndex);new z3({outboundLayer:this,inboundLayers:u,nodeIndices:c,tensorIndices:d,inputTensors:l,outputTensors:n,inputMasks:s,outputMasks:r,inputShapes:o,outputShapes:a},i);for(let f=0;f<n.length;f++)n[f].sourceLayer=this,n[f].nodeIndex=this.inboundNodes.length-1,n[f].tensorIndex=f}getConfig(){const e={name:this.name,trainable:this.trainable};return this.batchInputShape!=null&&(e.batchInputShape=this.batchInputShape),this.dtype!=null&&(e.dtype=this.dtype),e}disposeWeights(){return this.weights.forEach(e=>e.dispose()),this.weights.length}assertNotDisposed(){if(this._refCount===0)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(this._refCount===null)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let e=0;return--this._refCount===0&&(e=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:e}}}function Rht(t){t=qn(t);const e=[];for(const n of t)e.push(n.shape);return Ur(e)}function Dht(t){return"float32"}function fW(t,e,n){if((e==null||n!=null&&n>0)&&(e=t.sourceLayer,n=t.nodeIndex),e.inboundNodes.length===0)return[t];{const s=e.inboundNodes[n];if(s.inboundLayers.length===0)return s.inputTensors;{const r=[];for(let o=0;o<s.inboundLayers.length;o++){const a=s.inputTensors[o],i=s.inboundLayers[o],l=s.nodeIndices[o],u=fW(a,i,l);for(const c of u)r.indexOf(c)===-1&&r.push(c)}return r}}}class lm extends cn{constructor(e){if(super({dtype:e.dtype,name:e.name!=null?e.name:E3("input").toString()}),e.batchSize==null&&(e.batchSize=null),e.sparse==null&&(e.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=e.sparse,e.inputShape!=null&&e.batchInputShape!=null)throw new Ie("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let n=e.batchInputShape;if(n==null){if(e.inputShape==null)throw new Ie("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");n=[e.batchSize].concat(e.inputShape)}else if(e.batchSize!=null)throw new Ie("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");const s=e.dtype||"float32";this.batchInputShape=n,this.dtype=s,this.inputSpec=[{shape:n}];const r=new Ga(this.dtype,this.batchInputShape,this,[],{},this.name);r.nodeIndex=0,r.tensorIndex=0,new z3({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[r],outputTensors:[r],inputMasks:[null],outputMasks:[null],inputShapes:[n],outputShapes:[n]})}apply(e,n){throw new Ie(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}}lm.className="InputLayer";tt(lm);function hW(t){if(t.batchShape==null&&t.shape==null)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(t.batchShape!=null&&t.shape!=null)throw new Ie("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let e=t.batchShape;t.shape!=null&&e==null&&(e=[null].concat(t.shape));let n=t.dtype;return n==null&&(n="float32"),new lm({batchInputShape:e,name:t.name,dtype:n,sparse:t.sparse}).inboundNodes[0].outputTensors[0]}function Fht(t,e){if(t.dtype==null||t.dtype===e.dtype)return e;try{return ht(e,t.dtype)}catch{throw new Ie(`The dtype of the feed (${e.dtype}) can not be cast to the dtype of the key '${t.name}' (${t.dtype}).`)}}class ku{constructor(e){if(this.id2Value={},this.id2Mask={},this.name2Id={},e instanceof ku)for(const n in e.id2Value)this.id2Value[n]=e.id2Value[n],n in e.id2Mask&&(this.id2Mask[n]=e.id2Mask[n]);else{if(e==null)return;for(const n of e)this.add(n.key,n.value)}}add(e,n,s){if(this.id2Value[e.id]==null)this.id2Value[e.id]=Fht(e,n),this.name2Id[e.name]=e.id,s!=null&&(this.id2Mask[e.id]=s);else throw new Ie(`Duplicate key: name=${e.name}, id=${e.id}`);return this}addFeed(e){this.add(e.key,e.value)}hasKey(e){return this.id2Value[e.id]!=null}names(){return Object.keys(this.name2Id)}getValue(e){if(e instanceof Ga){if(this.id2Value[e.id]==null)throw new Ie(`Nonexistent key: ${e.name}`);return this.id2Value[e.id]}else{const n=this.name2Id[e];if(n==null)throw new Ie(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Value[n]}}getMask(e){if(e instanceof Ga){if(this.id2Value[e.id]==null)throw new Ie(`Nonexistent key: ${e.name}`);return this.id2Mask[e.id]}else{const n=this.name2Id[e];if(n==null)throw new Ie(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Mask[n]}}disposeMasks(){this.id2Mask!=null&&Xt(this.id2Mask)}}const lb=new tW,ub=new tW;function Mht(t){lb!=null&&lb.setMaxEntries(t),ub!=null&&ub.setMaxEntries(t)}function Km(t,e,n,s){const r=n==null?!1:n.training,o=Array.isArray(t),a=o?t:[t],i=a.map(p=>p.name),l=[],u=e.names();for(const p of i)u.indexOf(p)!==-1?l.push(e.getValue(p)):l.push(null);s!=null&&(s.maxNumTensors=-1/0,s.minNumTensors=1/0);const c=i.join(",")+"|"+e.names().sort().join(",");let d=lb.get(c),f;if(d==null){const p=Pht(a,e);d=p.sorted,f=p.recipientCounts,lb.put(c,d),ub.put(c,f)}f={},r||Object.assign(f,ub.get(c));const h=new ku(e);for(let p=0;p<d.length;++p){if(s!=null){const T=sb().numTensors;T>s.maxNumTensors&&(s.maxNumTensors=T),T<s.minNumTensors&&(s.minNumTensors=T)}const m=d[p],g=m.sourceLayer;if(g instanceof lm)continue;const y=[],w=[],b=[];let _=!1;for(const T of m.inputs){const N=h.getValue(T),M=h.getMask(T);y.push(N),w.push(M),M!=null&&(_=!0),r||(f[T.name]--,f[T.name]===0&&!e.hasKey(T)&&i.indexOf(T.name)===-1&&!N.isDisposed&&T.sourceLayer.stateful!==!0&&b.push(N))}_&&(n=n||{},n.mask=w[0]);const $=qn(g.apply(y,n));let x=null;g.supportsMasking&&(x=g.computeMask(y,w));const k=zht(m),C=Array.isArray(k)?k:[k];for(let T=0;T<C.length;++T){h.hasKey(C[T])||h.add(C[T],$[T],Array.isArray(x)?x[0]:x);const N=i.indexOf(C[T].name);N!==-1&&(l[N]=$[T])}r||Xt(b)}return h.disposeMasks(),o?l:l[0]}function Pht(t,e){q(t!=null&&t.length>0,()=>"Expected at least one fetch, got none");let n=[],s={};if(t.length===1){const r=fD(t[0],e);n=r.sorted,s=r.recipientMap}else{const r=new Set;for(const o of t){const{sorted:a,recipientMap:i}=fD(o,e);for(const l of a)r.has(l.name)||(n.push(l),r.add(l.name));for(const l in i)s[l]==null&&(s[l]=new Set),i[l].forEach(u=>s[l].add(u))}}return{sorted:n,recipientCounts:Lht(s)}}function Lht(t){const e={};for(const n in t)e[n]=t[n].size;return e}function fD(t,e){const n=new Set,s=[],r={};for(const i of e.names())n.add(i);const o=[],a=[];for(o.push(t);o.length>0;){const i=o[o.length-1];if(n.has(i.name)){o.pop();continue}const l=a[a.length-1]===o.length-1;if(i.inputs.length===0||l)o.pop(),s.push(i),n.add(i.name),l&&a.pop();else{a.push(o.length-1);for(const u of i.inputs)r[u.name]==null&&(r[u.name]=new Set),r[u.name].add(i.name),!n.has(u.name)&&o.push(u)}}return{sorted:s,recipientMap:r}}function zht(t){let e;if(t.sourceLayer.inboundNodes.length===1)e=t.sourceLayer.output;else{let n=null;for(let s=0;s<t.sourceLayer.inboundNodes.length;++s)for(const r of t.sourceLayer.inboundNodes[s].outputTensors)if(r.id===t.id){n=s;break}e=t.sourceLayer.getOutputAt(n)}return e}const Bht=Be();Bht.registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",()=>100,Mht);function YT(t,e){return Le(()=>ar(kt(Te(t,t),e,!0)))}class m2 extends rf{getConfig(){return{}}}class ZT extends m2{constructor(e){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=e.maxValue!=null?e.maxValue:this.defaultMaxValue,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return Le(()=>{const n=YT(e,this.axis),s=Zr(n,0,this.maxValue);return Te(e,Et(s,st(Os(),n)))})}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}}ZT.className="MaxNorm";tt(ZT);class JT extends m2{constructor(e){super(),this.defaultAxis=0,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return Le(()=>Et(e,st(Os(),YT(e,this.axis))))}getConfig(){return{axis:this.axis}}}JT.className="UnitNorm";tt(JT);class QT extends m2{apply(e){return li(e)}}QT.className="NonNeg";tt(QT);class eN extends m2{constructor(e){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=e.minValue!=null?e.minValue:this.defaultMinValue,this.maxValue=e.maxValue!=null?e.maxValue:this.defaultMaxValue,this.rate=e.rate!=null?e.rate:this.defaultRate,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return Le(()=>{const n=YT(e,this.axis),s=st(Te(this.rate,Zr(n,this.minValue,this.maxValue)),Te(1-this.rate,n));return Te(e,Et(s,st(Os(),n)))})}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}}eN.className="MinMaxNorm";tt(eN);const hD={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function Fs(t){return zT(t)}function pD(t,e={}){return d2(t,ua.getMap().classNameMap,e,"constraint")}function Ms(t){if(t==null)return null;if(typeof t=="string"){const n={className:t in hD?hD[t]:t,config:{}};return pD(n)}else return t instanceof m2?t:pD(t)}function Vht(t){return new ZT(t)}function Hht(t){return new JT(t)}function Wht(){return new QT}function Uht(t){return new eN(t)}const Ght=Object.freeze(Object.defineProperty({__proto__:null,maxNorm:Vht,unitNorm:Hht,nonNeg:Wht,minMaxNorm:Uht},Symbol.toStringTag,{value:"Module"}));function jht(){return new HT}function Kht(){return new O3}function qht(t){return new WT(t)}function Xht(t){return new UT(t)}function Yht(t){return new GT(t)}function Zht(t){return new jT(t)}function Jht(t){return new KT(t)}function Qht(t){return new Qr(t)}function ept(t){return new R3(t)}function tpt(t){return new D3(t)}function npt(t){return new F3(t)}function spt(t){return new M3(t)}function rpt(t){return new P3(t)}function opt(t){return new L3(t)}function apt(t){return new qT(t)}const ipt=Object.freeze(Object.defineProperty({__proto__:null,zeros:jht,ones:Kht,constant:qht,randomUniform:Xht,randomNormal:Yht,truncatedNormal:Zht,identity:Jht,varianceScaling:Qht,glorotUniform:ept,glorotNormal:tpt,heNormal:npt,heUniform:spt,leCunNormal:rpt,leCunUniform:opt,orthogonal:apt},Symbol.toStringTag,{value:"Module"}));async function mu(t){if(t==null)return;const e=[],n=[],s=[];for(const r in t){const o=t[r];if(typeof o!="number"){const a=o;e.push(a.data()),n.push(r),s.push(a)}}if(e.length>0){const r=await Promise.all(e);for(let o=0;o<r.length;++o)t[n[o]]=r[o][0];Xt(s)}}function pW(t){if(t!=null)for(const e in t){const n=t[e];typeof n!="number"&&n.dispose()}}var mD;(function(t){t[t.SILENT=0]="SILENT",t[t.VERBOSE=1]="VERBOSE"})(mD||(mD={}));const lpt=125;class Eh{constructor(){this.validationData=null}setParams(e){this.params=e}async onEpochBegin(e,n){}async onEpochEnd(e,n){}async onBatchBegin(e,n){}async onBatchEnd(e,n){}async onTrainBegin(e){}async onTrainEnd(e){}setModel(e){}}class mW{constructor(e,n=10){e==null&&(e=[]),this.callbacks=e,this.queueLength=n}append(e){this.callbacks.push(e)}setParams(e){for(const n of this.callbacks)n.setParams(e)}setModel(e){for(const n of this.callbacks)n.setModel(e)}async onEpochBegin(e,n){n==null&&(n={});for(const s of this.callbacks)await s.onEpochBegin(e,n)}async onEpochEnd(e,n){n==null&&(n={});for(const s of this.callbacks)await s.onEpochEnd(e,n)}async onBatchBegin(e,n){n==null&&(n={});for(const s of this.callbacks)await s.onBatchBegin(e,n)}async onBatchEnd(e,n){n==null&&(n={});for(const s of this.callbacks)await s.onBatchEnd(e,n)}async onTrainBegin(e){e==null&&(e={});for(const n of this.callbacks)await n.onTrainBegin(e)}async onTrainEnd(e){e==null&&(e={});for(const n of this.callbacks)await n.onTrainEnd(e)}}class upt extends Eh{constructor(){super()}async onEpochBegin(e){this.seen=0,this.totals={}}async onBatchEnd(e,n){n==null&&(n={});const s=n.size==null?0:n.size;this.seen+=s;for(const r in n){const o=n[r];if(typeof o=="number")this.totals.hasOwnProperty(r)||(this.totals[r]=0),this.totals[r]=this.totals[r]+o*s;else{let a;r in this.totals?a=this.totals[r]:this.totals[r]=0;const i=Le(()=>st(this.totals[r],Te(o,s)));this.totals[r]=i,a!=null&&a.dispose()}}}async onEpochEnd(e,n){if(n!=null)for(const s of this.params.metrics)this.totals[s]!=null&&(typeof this.totals[s]=="number"?n[s]=this.totals[s]/this.seen:Le(()=>{const r=Te(Et(1,this.seen),this.totals[s]);n[s]=r,this.totals[s].dispose(),As(n[s])}))}}class gW extends Eh{async onTrainBegin(e){this.epoch=[],this.history={}}async onEpochEnd(e,n){n==null&&(n={}),this.epoch.push(e);for(const s in n)this.history[s]==null&&(this.history[s]=[]),this.history[s].push(n[s])}async syncData(){const e=[],n=[],s=[];for(const o in this.history){const a=this.history[o];for(let i=0;i<a.length;++i)if(typeof a[i]!="number"){const l=a[i];e.push(l.data()),n.push(o),s.push(i)}}const r=await Promise.all(e);for(let o=0;o<r.length;++o)this.history[n[o]][s[o]].dispose(),this.history[n[o]][s[o]]=r[o][0]}}class vW extends Eh{constructor(e,n){if(super(),this.currentEpoch=0,this.nowFunc=e.nowFunc,this.nextFrameFunc=e.nextFrameFunc||yT,this.yieldEvery=n||"auto",this.yieldEvery==="auto"&&(this.yieldEvery=lpt),this.yieldEvery==="never"&&e.onYield!=null)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");jy(this.yieldEvery)&&(this.maybeWait=lht(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=e.onTrainBegin,this.trainEnd=e.onTrainEnd,this.epochBegin=e.onEpochBegin,this.epochEnd=e.onEpochEnd,this.batchBegin=e.onBatchBegin,this.batchEnd=e.onBatchEnd,this.yield=e.onYield}async maybeWait(e,n,s){const r=[];this.yield!=null&&(await mu(s),r.push(this.yield(e,n,s))),r.push(this.nextFrameFunc()),await Promise.all(r)}async onEpochBegin(e,n){this.currentEpoch=e,this.epochBegin!=null&&(await mu(n),await this.epochBegin(e,n))}async onEpochEnd(e,n){const s=[];this.epochEnd!=null&&(await mu(n),s.push(this.epochEnd(e,n))),this.yieldEvery==="epoch"&&s.push(this.nextFrameFunc()),await Promise.all(s)}async onBatchBegin(e,n){this.batchBegin!=null&&(await mu(n),await this.batchBegin(e,n))}async onBatchEnd(e,n){const s=[];this.batchEnd!=null&&(await mu(n),s.push(this.batchEnd(e,n))),this.yieldEvery==="batch"?s.push(this.nextFrameFunc()):jy(this.yieldEvery)&&s.push(this.maybeWait(this.currentEpoch,e,n)),await Promise.all(s)}async onTrainBegin(e){this.trainBegin!=null&&(await mu(e),await this.trainBegin(e))}async onTrainEnd(e){this.trainEnd!=null&&(await mu(e),await this.trainEnd(e))}}function yW(t,e){return t==null&&(t={}),t instanceof Eh?[t]:Array.isArray(t)&&t[0]instanceof Eh?t:qn(t).map(s=>new vW(s,e))}class Do{constructor(){}static registerCallbackConstructor(e,n){q(e>=0&&Number.isInteger(e),()=>`Verbosity level is expected to be an integer >= 0, but got ${e}`),Do.checkForDuplicate(n),Do.constructors[e]==null&&(Do.constructors[e]=[]),Do.constructors[e].push(n)}static checkForDuplicate(e){for(const n in Do.constructors)Do.constructors[+n].forEach(r=>{if(r===e)throw new Ie("Duplicate callback constructor.")})}static clear(){Do.constructors={}}static createCallbacks(e){const n=[];for(const s in Do.constructors){const r=+s;e>=r&&n.push(...Do.constructors[r])}return n.map(s=>new s)}}Do.constructors={};function bW(t,e,n,s,r,o,a,i,l){const u=new gW,c=[new upt,...Do.createCallbacks(e)];t!=null&&c.push(...t),c.push(u);const d=new mW(c);return d.setParams({epochs:n,initialEpoch:s,samples:r,steps:o,batchSize:a,verbose:e,doValidation:i,metrics:l}),{callbackList:d,history:u}}function Xa(t,e={},n=!1){return d2(t,ua.getMap().classNameMap,e,"layer",n)}function cb(t,e){return Le(()=>{t.dtype!=="float32"&&(t=ht(t,"float32"));const n=kt(h2(t),e,!0),s=of(n.shape,Os()),r=ar(Zi(n,s));return Et(t,r)})}function df(t,e){return Le(()=>us(h2($t(e,t)),-1))}function B3(t,e){return Le(()=>us($s($t(e,t)),-1))}function um(t,e){return Le(()=>{const n=$t(t,e),s=Zr($s(t),Os(),Number.MAX_VALUE),r=$s(Et(n,s));return Te(100,us(r,-1))})}function cpt(t,e){return Le(()=>{const n=Zr(e,Os(),Number.MAX_VALUE),s=xo(st(1,n)),r=Zr(t,Os(),Number.MAX_VALUE),o=xo(st(1,r));return us(h2($t(s,o)),-1)})}function dpt(t,e){return Le(()=>{const n=Zi(0,$t(1,Te(t,e)));return us(h2(n),-1)})}function fpt(t,e){return Le(()=>{const n=Zi(0,$t(1,Te(t,e)));return us(n,-1)})}function hpt(t,e){return Le(()=>{const n=kt(Te(t,e),-1),s=Go(Te($t(1,t),e),-1);return Zi(0,st(1,$t(s,n)))})}function ppt(t,e){return Le(()=>{const n=Math.log(2),s=$t(e,t),r=$t(st(s,af(Te(-2,s))),n);return us(r,-1)})}function og(t,e,n=!1){return Le(()=>{if(n)e=r2(e);else{const s=kt(e,e.shape.length-1,!0);e=Et(e,s)}return e=Zr(e,Os(),1-Os()),Jn(kt(Te(ht(t,"float32"),xo(e)),e.shape.length-1))})}function db(t,e,n=!1){return Le(()=>{const s=ht(sm(wht(t)),"int32");e=Zr(e,Os(),1-Os());const r=e.shape,o=Ne(Sh(s,r[r.length-1]),r);return og(o,e,n)})}function mpt(t,e){if(!hn(t.shape,e.shape))throw new Ie(`logits and labels must have the same shape, but got shapes ${JSON.stringify(t.shape)} and ${JSON.stringify(e.shape)}`);return Le(()=>{const n=li(e),s=Jn($s(e));return st($t(n,Te(e,t)),Y1($o(s)))})}function V3(t,e){return Le(()=>{let n;return n=Zr(e,Os(),1-Os()),n=xo(Et(n,$t(1,n))),us(mpt(t,n),-1)})}function gpt(t,e){return Le(()=>{const n=Zr(t,Os(),1),s=Zr(e,Os(),1);return kt(Te(t,xo(Et(n,s))),-1)})}function vpt(t,e){return Le(()=>{const n=xo(st(Os(),e));return us($t(e,Te(t,n)),-1)})}function tN(t,e){return Le(()=>{const n=cb(t,-1),s=cb(e,-1),r=Te(n,s);return Jn(kt(r,-1))})}const fb={meanSquaredError:df,meanAbsoluteError:B3,meanAbsolutePercentageError:um,meanSquaredLogarithmicError:cpt,squaredHinge:dpt,hinge:fpt,categoricalHinge:hpt,logcosh:ppt,categoricalCrossentropy:og,sparseCategoricalCrossentropy:db,binaryCrossentropy:V3,kullbackLeiblerDivergence:gpt,poisson:vpt,cosineProximity:tN};function _$(t){if(typeof t=="string"){if(t in fb)return fb[t];let e=`Unknown loss ${t}`;throw t.toLowerCase().includes("softmaxcrossentropy")&&(e=`Unknown loss ${t}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new Ie(e)}else return t}function nN(t,e){return Le(()=>{const n=Te(.5,So(e)),s=Fi(Pr(e,n),t.dtype);return us(_o(t,s),-1)})}function sN(t,e){return Le(()=>Fi(_o(Od(t,-1),Od(e,-1)),"float32"))}function wW(t,e){return Le(()=>ht(kt(Ta(_o(t,1),_o(e,1))),"float32"))}function ypt(t,e){return Le(()=>ht(kt(Ta(_o(t,1),_o(e,0))),"float32"))}function bpt(t,e){return Le(()=>ht(kt(Ta(_o(t,0),_o(e,1))),"float32"))}function _W(t,e){return Le(()=>{const n=wW(t,e),s=bpt(t,e),r=st(n,s);return ht(wr(Pr(r,0),Et(n,r),0),"float32")})}function wpt(t,e){return Le(()=>{const n=wW(t,e),s=ypt(t,e),r=st(n,s);return ht(wr(Pr(r,0),Et(n,r),0),"float32")})}function $W(t,e){return V3(t,e)}function xW(t,e){return t.rank===e.rank&&(t=gc(t,[t.rank-1])),e=Od(e,-1),e.dtype!==t.dtype&&(e=ht(e,t.dtype)),ht(_o(t,e),"float32")}const _pt=df,$pt=df,xpt=B3,Spt=B3,Cpt=um,kpt=um,rN=og,Tpt=tN,SW=db,hb={binaryAccuracy:nN,categoricalAccuracy:sN,precision:_W,categoricalCrossentropy:rN,sparseCategoricalCrossentropy:SW,mse:_pt,MSE:$pt,mae:xpt,MAE:Spt,mape:Cpt,MAPE:kpt,cosine:Tpt};function Npt(t){if(typeof t=="string"&&t in hb)return hb[t];if(typeof t!="string"&&t!=null)return t;throw new Ie(`Unknown metric ${t}`)}function bv(t){if(gi(t!==null,`Unknown LossOrMetricFn ${t}`),typeof t=="string")return t;{let e;for(const n of Object.keys(fb))if(fb[n]===t){e=n;break}if(e!==void 0)return e;for(const n of Object.keys(hb))if(hb[n]===t){e=n;break}return e!==void 0?e:t.name}}function Ipt(t){const e={Adagrad:()=>Dc.adagrad(.01),Adadelta:()=>Dc.adadelta(1,.95,Os()),Adam:()=>Dc.adam(.001,.9,.999,Os()),Adamax:()=>Dc.adamax(.002,.9,.999,Os(),0),RMSProp:()=>Dc.rmsprop(.001,.9,0,Os()),SGD:()=>Dc.sgd(.01)};if(e.adagrad=e.Adagrad,e.adadelta=e.Adadelta,e.adam=e.Adam,e.adamax=e.Adamax,e.rmsprop=e.RMSProp,e.sgd=e.SGD,t in e)return e[t]();throw new Ie(`Unknown Optimizer ${t}`)}const gD=1*1024*1024;function vD(t,e,n=!1){if(t==null||typeof t!="object"||Object.getPrototypeOf(t)!==Object.prototype||!Dx(t))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(n){const s=JSON.stringify(t);s.length>gD&&console.warn(`User-defined metadata of model "${e}" is too large in size (length=${s.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= ${gD}.`)}}function Dx(t){if(t===null)return!0;if(typeof t=="object")if(Object.getPrototypeOf(t)===Object.prototype){const e=Object.keys(t);for(const n of e)if(typeof n!="string"||!Dx(t[n]))return!1;return!0}else if(Array.isArray(t)){for(const e of t)if(!Dx(e))return!1;return!0}else return!1;else{const e=typeof t;return e==="string"||e==="number"||e==="boolean"}}function Ept(t,e,n,s=console.log){const r=Opt(t),o=["Layer (type)","Input Shape","Output shape","Param #"];r?(e=e||90,n=n||[.32,.61,.89,1]):(e=e||115,n=n||[.24,.48,.7,.8,1]),n[n.length-1]<=1&&(n=n.map(c=>Math.floor(e*c)));let a;if(!r){o.push("Receives inputs"),a=[];for(const c in t.nodesByDepth)a.push(...t.nodesByDepth[c])}s("_".repeat(e)),pb(o,n,s),s("=".repeat(e));const i=t.layers;for(let c=0;c<i.length;++c)r?Rpt(i[c],n,s):Dpt(i[c],n,a,s),s((c===i.length-1?"=":"_").repeat(e));t.checkTrainableWeightsConsistency();const l=Apt(t),u=ib(t.nonTrainableWeights);s(`Total params: ${l+u}`),s(`Trainable params: ${l}`),s(`Non-trainable params: ${u}`),s("_".repeat(e))}function Apt(t){let e;return t.collectedTrainableWeights!=null?e=ib(t.collectedTrainableWeights):e=ib(t.trainableWeights),e}function Opt(t){let e=!0;const n=[],s=[];for(const r in t.nodesByDepth)n.push(t.nodesByDepth[r]);for(const r of n){if(r.length>1||r.length===1&&r[0].inboundLayers.length>1){e=!1;break}s.push(...r)}if(e)for(const r of t.layers){let o=!1;for(const a of r.inboundNodes)if(s.indexOf(a)!==-1)if(o){e=!1;break}else o=!0;if(!e)break}return e}function pb(t,e,n=console.log){let s="";for(let r=0;r<t.length;++r)r>0&&(s=s.slice(0,s.length-1)+" "),s+=t[r],s=s.slice(0,e[r]),s+=" ".repeat(e[r]-s.length);n(s)}function Rpt(t,e,n){let s,r;try{r=t.inboundNodes.map(l=>JSON.stringify(l.inputShapes)).join(",")}catch{r="multiple"}try{s=JSON.stringify(t.outputShape)}catch{s="multiple"}const o=t.name,a=t.getClassName(),i=[`${o} (${a})`,r,s,t.countParams().toString()];pb(i,e,n)}function Dpt(t,e,n,s){let r,o;try{o=t.inboundNodes.map(d=>JSON.stringify(d.inputShapes)).join(",")}catch{o="multiple"}try{r=JSON.stringify(t.outputShape)}catch{r="multiple"}const a=[];for(const d of t.inboundNodes)if(!(n!=null&&n.length>0&&n.indexOf(d)===-1))for(let f=0;f<d.inboundLayers.length;++f){const h=d.inboundLayers[f].name,p=d.nodeIndices[f],m=d.tensorIndices[f];a.push(`${h}[${p}][${m}]`)}const i=t.name,l=t.getClassName(),u=a.length===0?"":a[0],c=[`${i} (${l})`,o,r,t.countParams().toString(),u];pb(c,e,s);for(let d=1;d<a.length;++d)pb(["","","","",a[d]],e,s)}function CW(t,e,n){return(t==="inboundNodes"||t==="outputLayers"||t==="inputLayers")&&e===0&&typeof n=="string"}function ag(t,e){if(t===null)return null;if(typeof t=="string")return Hc(t);if(typeof t=="number"||typeof t=="boolean")return t;if(t instanceof Array){const n=[],s=t.length;for(let r=0;r<s;++r){const o=t[r];CW(e,r,o)?n.push(o):n.push(ag(o,e))}return n}else{const n={};for(const s of Object.keys(t)){const r=t[s];if(s==="name"&&typeof r=="string")n[s]=r;else{const o=Hc(s);n[o]=ag(r,o)}}return n}}function Fx(t,e){if(t==null)return null;if(typeof t=="string")return il(t);if(typeof t=="number"||typeof t=="boolean")return t;if(t instanceof Array){const n=[],s=t.length;for(let r=0;r<s;++r){const o=t[r];CW(e,r,o)?n.push(o):n.push(Fx(o,e))}return n}else{const n={};for(const s of Object.keys(t)){const r=t[s],o=il(s);(s==="name"||s==="className")&&typeof r=="string"?n[o]=r:n[o]=Fx(r,s)}return n}}const H3="4.1.0";class Fa extends cn{constructor(e){if(super({}),this.containerNodes=new Set,this.name=e.name,this.name==null){const w=this.getClassName().toLowerCase();this.name=E3(w)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(e.inputs)?this.inputs=e.inputs.slice():this.inputs=[e.inputs],Array.isArray(e.outputs)?this.outputs=e.outputs.slice():this.outputs=[e.outputs],Pu(this.inputs).length!==this.inputs.length)throw new Ie(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map(w=>w.name)}`);Pu(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map(w=>w.name)}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(const w of this.outputs){const b=w.sourceLayer,_=w.nodeIndex,$=w.tensorIndex;this.outputLayers.push(b),this.outputLayersNodeIndices.push(_),this.outputLayersTensorIndices.push($)}for(const w of this.inputs){const b=w.sourceLayer,_=w.nodeIndex,$=w.tensorIndex;gi(_===0,"input layer has >1 nodes"),gi($===0,"input layer has >1 tensors"),this.inputLayers.push(b),this.inputLayersNodeIndices.push(_),this.inputLayersTensorIndices.push($)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let w=0;w<this.inputLayers.length;w++){const b=this.inputLayers[w];if(!(b instanceof lm))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${e.inputs}. Input ${w} (0-based) originates from layer type ${b.getClassName()}.`);this.inputNames.push(b.name),this.feedInputShapes.push(b.batchInputShape),this.feedInputNames.push(b.name)}for(const w of this.outputLayers)this.outputNames.push(w.name);this.internalInputShapes=this.inputs.map(w=>w.shape),this.internalOutputShapes=this.outputs.map(w=>w.shape);const n={},s={},r={},o={},a={},i=[],l=(w,b,_,$,x,k)=>{($==null||x==null||k==null)&&($=w.sourceLayer,x=w.nodeIndex,k=w.tensorIndex);const C=$.inboundNodes[x];if(_.indexOf(C)!==-1)throw new pa(`The tensor ${w.name} at layer "${$.name}" is part of a cycle.`);if(b.indexOf(C)!==-1)return;this.containerNodes.add(Fa.nodeKey($,x)),$.id in a||(a[$.id]=Object.keys(a).length),_.indexOf(C)===-1&&_.push(C);const T=C.inboundLayers.length;for(let N=0;N<T;N++){const M=C.inputTensors[N],R=C.inboundLayers[N],D=C.nodeIndices[N],z=C.tensorIndices[N];l(M,b,_,R,D,z)}for(b.push(C);_.indexOf(C)>=0;)_.splice(_.indexOf(C),1);i.push(C)},u=[],c=[];for(const w of this.outputs)l(w,u,c);const d=i.slice().reverse();for(const w of d){s[w.id]=w,w.id in n||(n[w.id]=0);let b=n[w.id];const _=r[w.outboundLayer.id]==null?0:r[w.outboundLayer.id];b=Math.max(b,_),r[w.outboundLayer.id]=b,o[w.outboundLayer.id]=w.outboundLayer,n[w.id]=b;for(let $=0;$<w.inboundLayers.length;$++){const x=w.inboundLayers[$],k=w.nodeIndices[$],C=x.inboundNodes[k],T=n[C.id]==null?0:n[C.id];n[C.id]=Math.max(b+1,T),s[C.id]=C}}const f={};for(const w in n){const b=n[w];b in f||(f[b]=[]),f[b].push(s[w])}const h={};for(const w in r){const b=r[w];b in h||(h[b]=[]),h[b].push(o[w])}let p=Object.keys(h).map(w=>parseInt(w,10)).sort(gv);this.layers=[];for(const w of p){const b=h[w];b.sort((_,$)=>{const x=a[_.id],k=a[$.id];return x<k?-1:x>k?1:0});for(const _ of b)_ instanceof Fa&&this.internalContainerRefs.push(_),this.layers.push(_)}this.layersByDepth=h,p=Object.keys(f).map(w=>parseInt(w,10)).sort(gv);const m=this.inputs.slice(),g=[];for(const w of p)for(const b of f[w]){const _=b.outboundLayer;if(_!=null){for(const $ of b.inputTensors)if(m.indexOf($)===-1)throw new pa(`Graph disconnected: cannot obtain value for tensor ${$} at layer "${_.name}". The following previous layers were accessed without issue: ${g}`);for(const $ of b.outputTensors)m.push($);g.push(_.name)}}this.nodesByDepth=f;const y=this.layers.map(w=>w.name);for(const w of y){const b=y.filter(_=>_===w).length;if(b!==1)throw new pa(`The name "${w}" is used ${b} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(y))}this.outboundNodes=[],this.inboundNodes=[],new z3({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map(w=>null),outputMasks:this.outputs.map(w=>null),inputShapes:this.inputs.map(w=>w.shape),outputShapes:this.outputs.map(w=>w.shape)}),this.built=!0,this._refCount=1}assertNotDisposed(){if(this._refCount===0)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();const e={refCountAfterDispose:null,numDisposedVariables:0};if(--this._refCount===0){for(const n of this.layers)e.numDisposedVariables+=n.dispose().numDisposedVariables;for(const n of this.internalContainerRefs)e.numDisposedVariables+=n.dispose().numDisposedVariables}return e.refCountAfterDispose=this._refCount,e}get trainable(){return this.trainable_}set trainable(e){this.layers.forEach(n=>{n._trainableWeights.forEach(s=>s.trainable=e)}),this.trainable_=e}get trainableWeights(){if(this._trainableWeights.length>0)throw new Ie("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let e=[];for(const n of this.layers)e=e.concat(n.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const n of this.layers)e.push(...n.nonTrainableWeights);if(!this.trainable){const n=[];for(const s of this.layers)n.push(...s.trainableWeights);return n.concat(e)}return e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(e,n=!0){const s={};let r=0;for(const a of this.layers)for(const i of a.weights){if(s[i.originalName]!=null)throw new Ie(`Duplicate weight name: ${i.originalName}`);s[i.originalName]=i,r++}const o=[];for(const a in e){let i=a;if(s[a]==null){const l=a.split("/");i=l.slice(0,-2).concat([l[l.length-1]]).join("/")}if(s[i]!=null)o.push([s[i],e[a]]);else if(n)throw new Ie(`Provided weight data has no target variable: ${a}`);delete s[i]}if(n){const a=[];for(const i in s)a.push(i);if(a.length>0)throw new Ie(`${a.length} of ${r} weights are not set: ${a}`)}XT(o)}updatedConfig(){const e=this.getConfig(),n={};return n.className=this.getClassName(),n.config=e,n.kerasVersion=`tfjs-layers ${H3}`,n.backend="TensorFlow.js",n}toJSON(e,n=!0){const s=Fx(this.updatedConfig());return n?JSON.stringify(s):s}call(e,n){return Le(()=>{e=qn(e);const s=new ku;for(let r=0;r<this.inputs.length;++r)s.add(this.inputs[r],e[r]);return Km(this.outputs,s,n)})}computeMask(e,n){return Le(()=>{e=qn(e);let s;return n==null?s=Pd(null,e.length):s=qn(n),this.runInternalGraph(e,s)[1]})}computeOutputShape(e){const n=ab(e);if(n.length!==this.inputLayers.length)throw new Ie(`Invalid inputShape argument ${e}: model has ${this.inputLayers.length} tensor inputs.`);const s={};for(let i=0;i<n.length;i++){const l=this.inputLayers[i],u=n[i],c=l.name+"_0_0";s[c]=u}const r=Object.keys(this.nodesByDepth).map(i=>parseInt(i,10)).sort(gv);if(r.length>1)for(const i of r){const l=this.nodesByDepth[i];for(const u of l){const c=u.outboundLayer;if(this.inputLayers.map(m=>m.id).indexOf(c.id)!==-1)continue;const d=[];for(let m=0;m<u.inboundLayers.length;m++){const g=u.inboundLayers[m],y=u.nodeIndices[m],w=u.tensorIndices[m],b=`${g.name}_${y}_${w}`,_=s[b];d.push(_)}const f=c.computeOutputShape(Ur(d)),h=ab(f),p=c.inboundNodes.indexOf(u);for(let m=0;m<h.length;m++){const g=`${c.name}_${p}_${m}`;s[g]=h[m]}}}const o=[],a=[];for(let i=0;i<this.outputLayers.length;i++){const l=this.outputLayers[i],u=this.outputLayersNodeIndices[i],c=this.outputLayersTensorIndices[i],d=`${l.name}_${u}_${c}`;a.push(d)}for(let i=0;i<a.length;i++){const l=a[i];gi(l in s),o.push(s[l])}return Ur(o)}runInternalGraph(e,n){n==null&&(n=Pd(null,e.length));const s={};for(let l=0;l<this.inputs.length;++l){const u=this.inputs[l],c=e[l],d=n[l];s[u.id]=[c,d]}const r=Object.keys(this.nodesByDepth).map(l=>parseInt(l,10)).sort(gv);for(const l of r){const u=this.nodesByDepth[l];for(const c of u){const d=c.outboundLayer,f=c.inputTensors,h=c.outputTensors,p=new Array;for(const m of f)m.id in s&&p.push(s[m.id]);if(p.length===f.length){let m={},g,y,w,b;if(c.callArgs!=null&&(m=c.callArgs),p.length===1){const[_,$]=p[0];m.mask==null&&(m.mask=$),w=qn(d.call(_,m)),b=qn(d.computeMask(_,$)),g=[_],y=[$]}else g=p.map(_=>_[0]),y=p.map(_=>_[1]),m.mask==null&&(m.mask=y),w=qn(d.call(g,m)),b=qn(d.computeMask(g,y));if(d.activityRegularizer)throw new Jt("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let _=0;_<h.length;++_){const $=h[_],x=w[_],k=b[_];s[$.id]=[x,k]}}}}const o=[],a=[],i=[];for(const l of this.outputs){gi(l.id in s,`Could not compute output ${l.name} : ${l.id}`);const[u,c]=s[l.id];i.push(u.shape),o.push(u),a.push(c)}return[o,a,i]}buildNodeConversionMap(e){const n={};let s;for(const r of this.layers){s=r instanceof Fa?1:0;for(let o=0;o<r.inboundNodes.length;o++){const a=Fa.nodeKey(r,o);this.containerNodes.has(a)&&(n[a]=s,s+=1)}}return n}getLayer(e,n){if(n!=null){if(this.layers.length<=n)throw new Ie(`Was asked to retrieve layer at index ${n}, but model only has ${this.layers.length} layer(s).`);return this.layers[n]}else if(e==null)throw new Ie("Provide either a layer name or layer index");for(const s of this.layers)if(s.name===e)return s;throw new Ie(`No such layer: ${e}`)}calculateLosses(){return Le(()=>{const e=[];for(const n of this.layers)for(let s=0;s<n.inboundNodes.length;++s){const r=Fa.nodeKey(n,s);this.containerNodes.has(r)&&e.push(...n.calculateLosses())}return e})}getConfig(){const e={name:this.name},n=this.buildNodeConversionMap(this.layers),s=[];for(const a of this.layers){const i=a.getClassName(),l=a.getConfig(),u=[];for(let d=0;d<a.inboundNodes.length;d++){const f=a.inboundNodes[d],h=Fa.nodeKey(a,d);let p={};if(this.containerNodes.has(h)){if(f.callArgs)try{JSON.stringify(f.callArgs),p=f.callArgs}catch{console.warn(`Layer ${a.name} was passed non-serializable keyword arguments: ${f.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),p={}}if(f.inboundLayers.length>0){const m=[];for(let g=0;g<f.inboundLayers.length;g++){const y=f.inboundLayers[g],w=f.nodeIndices[g],b=f.tensorIndices[g],_=Fa.nodeKey(y,w);let $=n[_];$==null&&($=0),m.push([y.name,$,b,p])}u.push(m)}}}const c={};c.name=a.name,c.className=i,c.config=l,c.inboundNodes=u,s.push(c)}e.layers=s;const r=[];for(let a=0;a<this.inputLayers.length;a++){const i=this.inputLayers[a],l=this.inputLayersNodeIndices[a],u=Fa.nodeKey(i,l);if(!this.containerNodes.has(u))continue;let c=n[u];c==null&&(c=0);const d=this.inputLayersTensorIndices[a];r.push([i.name,c,d])}e.inputLayers=r;const o=[];for(let a=0;a<this.outputLayers.length;a++){const i=this.outputLayers[a],l=this.outputLayersNodeIndices[a],u=Fa.nodeKey(i,l);if(!this.containerNodes.has(u))continue;let c=n[u];c==null&&(c=0);const d=this.outputLayersTensorIndices[a];o.push([i.name,c,d])}return e.outputLayers=o,e}static fromConfig(e,n,s={},r=!1){const o={},a={};function i(g,y){g.name in a?a[g.name].push(y):a[g.name]=[y]}function l(g,y){const w=[];let b;for(const _ of y){const $=_[0],x=_[1],k=_[2];if(b=_[3]==null?{}:_[3],!($ in o)){i(g,y);return}const C=o[$];if(C.inboundNodes.length<=x){i(g,y);return}const T=C.inboundNodes[x];w.push(T.outputTensors[k])}w.length>0&&g.apply(Ur(w),b)}function u(g){const y=g.name,w=Xa(g,n.customObjects!=null?n.customObjects:{});w.setFastWeightInitDuringBuild(r),o[y]=w,g.inboundNodes.forEach(_=>{if(!(_ instanceof Array))throw new Ie(`Corrupted configuration, expected array for nodeData: ${_}`);i(w,_)})}const c=n.name,d=n.layers;for(const g of d)u(g);for(;!iht(a);)for(const g of d){const y=o[g.name];if(y.name in a){const w=a[y.name];delete a[y.name];for(const b of w)l(y,b)}}const f=[],h=[],p=n.inputLayers;for(const g of p){const y=g[0],w=g[1],b=g[2];gi(y in o);const $=o[y].inboundNodes[w].outputTensors;f.push($[b])}const m=n.outputLayers;for(const g of m){const y=g[0],w=g[1],b=g[2];gi(y in o);const $=o[y].inboundNodes[w].outputTensors;h.push($[b])}return new e({inputs:f,outputs:h,name:c})}get stateful(){if(this._stateful)throw new Ie("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(const e of this.layers)if(e.stateful)return!0;return!1}resetStates(){Le(()=>{this.layers.forEach(e=>{e.stateful&&e.resetStates()})})}}function Fpt(t,e,n){const s=e.length;if(t==null||Array.isArray(t)&&t.length===0)return e.map(r=>null);if(s===1)return Array.isArray(t)&&t.length===1?t:typeof t=="object"&&e[0]in t?[t[e[0]]]:[t];if(Array.isArray(t)){if(t.length!==s)throw new Error(`Provided ${n} is an array of ${t.length} element(s), but the model has ${s} outputs. Make sure a set of weights is provided for each model output.`);return t}else if(typeof t=="object"&&Object.keys(t).length>0&&typeof t[Object.keys(t)[0]]=="object"){const r=[];return e.forEach(o=>{o in t?r.push(t[o]):r.push(null)}),r}else throw new Error(`The model has multiple (${s}) outputs, so ${n} must be either an array with ${s} elements or an object with ${e} keys. Provided ${n} not understood: ${JSON.stringify(t)}`)}function kW(t,e){return Fpt(t,e,"classWeight")}async function TW(t,e,n,s){if(e!=null||s!=null)throw new Error("Support sampleWeight is not implemented yet");if(n!=null){const r=Le(()=>{if(t.shape.length===1)return Ri(t);if(t.shape.length===2){if(t.shape[1]>1)return Od(t,1);if(t.shape[1]===1)return Ne(t,[t.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${t.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}else throw new Error(`Unexpected rank of target (y) tensor (${t.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)}),o=Array.from(await r.data());Xt(r);const a=[];return o.forEach(i=>{if(n[i]==null)throw new Error(`classWeight must contain all classes in the training data. The class ${i} exists in the data but not in classWeight`);a.push(n[i])}),vr(a,"float32")}else return null}function Mpt(t,e){return Te(t,e)}const Ppt=32;function NW(t,e){let n,s;const r=e;n=r.xs,s=r.ys,q(n!=null&&s!=null,()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${e}`);const o=yD("input",t.inputNames,n),a=yD("output",t.outputNames,s),i=o[0].shape[0];q(o.length===t.inputs.length,()=>`LayersModel has ${t.inputs.length} inputs, but the dataset provides ${o.length} inputs.  (Expected input keys: ${JSON.stringify(t.inputNames)})`),q(a.length===t.outputs.length,()=>`LayersModel has ${t.outputs.length} outputs, but the dataset provides ${a.length} outputs.  (Expected output keys: ${JSON.stringify(t.outputNames)})`);for(let l=0;l<o.length;l++)q(o[l].shape[0]===i,()=>`Batch size mismatch: input ${t.inputNames[l]} has ${o[l].shape[0]}; expected  ${i} based on input ${t.inputNames[0]}.`);for(let l=0;l<a.length;l++)q(a[l].shape[0]===i,()=>`Batch size mismatch: output ${t.outputNames[l]} has ${a[l].shape[0]}; expected  ${i} based on input ${t.inputNames[0]}.`);return{xs:o,ys:a}}function yD(t,e,n){if(n instanceof $n)return[n];if(Array.isArray(n))return q(n.length===e.length,()=>`Received an array of ${n.length} Tensors, but expected ${e.length} to match the ${t} keys ${e}.`),n;{const s=[];for(const r of e){if(n[r]==null)throw new Ie(`The feature data generated by the dataset lacks the required ${t} key '${r}'.`);s.push(n[r])}return s}}function Lpt(t){if(t.length===3)throw new Jt("Validation with sample weights is not implemented yet.");return{xs:t[0],ys:t[1]}}async function zpt(t,e,n){const s=n.batchesPerEpoch!=null;if(q(t.optimizer!=null,()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."),q(n!=null,()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."),q(n.epochs!=null&&n.epochs>0&&Number.isInteger(n.epochs),()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${n.epochs}`),q(!s||n.batchesPerEpoch>0&&Number.isInteger(n.batchesPerEpoch),()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${n.batchesPerEpoch}`),q(n.validationSplit==null,()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead."),t.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");t.isTraining=!0;try{const r=n.validationData!=null;let o,a;if(r)if(bD(n.validationData))q(n.validationBatches==null||n.validationBatches>0&&Number.isInteger(n.validationBatches),()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${n.validationBatches}`);else{const g=Lpt(n.validationData);o=g.xs,a=g.ys}const i=t.makeTrainFunction(),l=t.getDedupedMetricsNames();let u;r?u=l.slice().concat(l.map(g=>"val_"+g)):u=l.slice();const c=yW(n.callbacks,n.yieldEvery),d=n.verbose==null?1:n.verbose,{callbackList:f,history:h}=bW(c,d,n.epochs,null,null,Bpt(e,n),null,r,u);f.setModel(t),t.history=h,await f.onTrainBegin(),t.stopTraining_=!1;let p=n.initialEpoch==null?0:n.initialEpoch,m=await e.iterator();for(;p<n.epochs;){const g={};await f.onEpochBegin(p);let y=0,w=0;for(s||(m=await e.iterator());!s||y<n.batchesPerEpoch;){const b=await m.next();if(s&&b.done){console.warn(`You provided \`batchesPerEpoch\` as ${n.batchesPerEpoch}, but your dataset iterator ran out of data after ${y} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, ${n.batchesPerEpoch*n.epochs} batches). You may need to use the repeat() function when building your dataset.`);break}if(b.value!=null){const{xs:_,ys:$}=NW(t,b.value),x={};x.batch=w,x.size=_[0].shape[0],await f.onBatchBegin(w,x);const k=[];if(n.classWeight!=null){const N=kW(n.classWeight,t.outputNames);for(let M=0;M<N.length;++M)k.push(await TW($[M],null,N[M]))}const C=_.concat($).concat(k),T=i(C);Xt(C);for(let N=0;N<l.length;++N){const M=l[N],R=T[N];x[M]=R,As(R)}await f.onBatchEnd(w,x),pW(x),w++,y++}if(s?y>=n.batchesPerEpoch:b.done){if(r){let _;bD(n.validationData)?_=qn(await t.evaluateDataset(n.validationData,{batches:n.validationBatches})):_=qn(t.evaluate(o,a,{batchSize:n.validationBatchSize==null?Ppt:n.validationBatchSize,verbose:0}));for(let $=0;$<t.metricsNames.length;++$)g[`val_${t.metricsNames[$]}`]=_[$]}break}if(t.stopTraining_)break}if(await f.onEpochEnd(p,g),p++,t.stopTraining_)break}return await f.onTrainEnd(),await t.history.syncData(),t.history}finally{t.isTraining=!1}}function Bpt(t,e){let n=null;return e.batchesPerEpoch!=null?n=e.batchesPerEpoch:Number.isFinite(t.size)&&(n=t.size),n}function bD(t){return typeof t.iterator=="function"}function Vpt(t){return typeof t.next=="function"}async function Hpt(t,e,n){n=n||{};const s=n.batches!=null,r=t.testFunction;let o=[];if(n.verbose>0)throw new Jt("Verbose mode is not implemented yet.");q(!s||n.batches>0&&Number.isInteger(n.batches),()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(n.batches)}`);const a=Vpt(e)?e:await e.iterator();let i=0,l=0;for(;!s||l<n.batches;){const u=await a.next();if(o=Le(()=>{if(u.value){const{xs:c,ys:d}=NW(t,u.value),f=c.concat(d),h=Le(()=>r(f));if(Xt(f),l===0)for(let m=0;m<h.length;++m)o.push(Pt(0));const p=f[0].shape[0];for(let m=0;m<h.length;++m){const g=h[m],y=o[m];o[m]=Le(()=>st(o[m],Te(p,g))),l>0&&Xt(y)}Xt(h),i+=p,++l}return o}),u.done){s&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${n.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let u=0;u<o.length;++u){const c=o[u];o[u]=Et(o[u],i),Xt(c)}return Ur(o)}function $$(t){q(t>0&&Number.isInteger(t),()=>`batchSize is required to be a positive integer, but got ${t}`)}function Fm(t,e,n){return t==null?[null]:Array.isArray(t)?t.map(s=>fd(s,e,n-e)):fd(t,e,n-e)}function Mx(t,e){return Le(()=>t==null?null:Array.isArray(t)?t.map(n=>Mx(n,e)):uW(t,e.dtype==="int32"?e:ht(e,"int32")))}function x$(t,e){const n=[];let s=0,r=null;for(;s<t;)r=s+e,r>=t&&(r=t),n.push([s,r]),s=r;return n}function IW(t){const e=[];t instanceof $n&&(t=[t]);for(let n=0;n<t.length;++n){const s=t[n];if(s.rank===1)e.push(f2(s,1));else{if(s.rank===0)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");e.push(s)}}return e}function Ra(t,e){if(t==null)return;const n=[];if(e instanceof $n)n.push(e.id);else if(Array.isArray(e))e.forEach(r=>n.push(r.id));else if(e!=null)for(const r in e){const o=e[r];n.push(o.id)}const s=[];if(t instanceof $n)n.indexOf(t.id)===-1&&s.push(t);else if(Array.isArray(t))t.forEach(r=>{n.indexOf(r.id)===-1&&s.push(r)});else if(t!=null)for(const r in t){const o=t[r];n.indexOf(o.id)===-1&&s.push(o)}s.forEach(r=>{r.isDisposed||r.dispose()})}function Wpt(t){return t instanceof $n}function Px(t){return Array.isArray(t)}function wD(t){return!Wpt(t)&&!Px(t)}function _D(t,e,n,s=!0,r=""){if(e==null||e.length===0){if(t!=null){let a=!1;if(Px(t)&&t.length>0)a=!0;else if(wD(t)){for(const i in t)if(t.hasOwnProperty(i)){a=!0;break}}else a=!0;if(a)throw new Ie(`Error when checking model ${r} expected no data, but got ${t}`)}return[]}if(t==null)return e.map(a=>null);let o;if(wD(t)){t=t,o=[];for(const a of e){if(t[a]==null)throw new Ie(`No data provided for "${a}". Need data for each key in: ${e}`);o.push(t[a])}}else if(Px(t)){if(t=t,t.length!==e.length)throw new Ie(`Error when checking model ${r}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${e.length} Tensor(s), but instead got the following list of Tensor(s): ${t}`);o=t}else{if(t=t,e.length>1)throw new Ie(`The model ${r} expects ${e.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${t.shape}`);o=[t]}if(o=IW(o),n!=null)for(let a=0;a<e.length;++a){if(n[a]==null)continue;const i=o[a];if(i.shape.length!==n[a].length)throw new Ie(`Error when checking ${r}: expected ${e[a]} to have ${n[a].length} dimension(s). but got array with shape ${i.shape}`);for(let l=0;l<n[a].length;++l){if(l===0&&!s)continue;const u=i.shape[l],c=n[a][l];if(c!=null&&c>=0&&u!==c)throw new Ie(`${r} expected a batch of elements where each example has shape [${n[a].slice(1,n[a].length)}] (i.e.,tensor shape [*,${n[a].slice(1,n[a].length)}]) but the ${r} received an input with ${i.shape[0]} examples, each with shape [${i.shape.slice(1,i.shape.length)}] (tensor shape [${i.shape}])`)}}return o}function Upt(t,e,n){const s=Pu(t.map(o=>o.shape[0]));s.sort();const r=Pu(e.map(o=>o.shape[0]));if(r.sort(),s.length>1)throw new Ie(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(t.map(o=>o.shape))}`);if(r.length>1)throw new Ie(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(e.map(o=>o.shape))}`);if(s.length>0&&r.length>0&&!hn(s,r))throw new Ie(`Input Tensors should have the same number of samples as target Tensors. Found ${s[0]} input sample(s) and ${r[0]} target sample(s).`)}function Gpt(t,e,n){const s=[df,V3,og];for(let r=0;r<t.length;++r){const o=t[r],a=e[r],i=n[r];if(a!=null){if(a===og&&o.shape[o.shape.length-1]===1)throw new Ie(`You are passing a target array of shape ${o.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(s.indexOf(a)!==-1){const l=o.shape.slice(1),u=i.slice(1);for(let c=0;c<l.length;++c){const d=l[c],f=u[c];if(f!=null&&d!==f)throw new Ie(`A target Tensor with shape ${o.shape} was passed for an output of shape ${i}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}function $D(t,e,n,s=!0,r=""){let o;if(Array.isArray(t)){if(t.length!==e.length)throw new Ie(`Error when checking model ${r}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${e.length} Tensor(s), but instead got ${t.length} Tensors(s).`);o=t}else{if(e.length>1)throw new Ie(`The model expects ${e.length} ${r} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(t.shape)}.`);o=[t]}if(n!=null)for(let a=0;a<e.length;++a){if(n[a]==null)continue;const i=o[a];if(i.shape.length!==n[a].length)throw new Ie(`Error when checking ${r}: expected ${e[a]} to have ${n[a].length} dimension(s), but got array with shape ${JSON.stringify(i.shape)}`);for(let l=0;l<n[a].length;++l){if(l===0&&!s)continue;const u=i.shape[l],c=n[a][l];if(c!=null&&c!==u)throw new Ie(`Error when checking ${r}: expected ${e[a]} to have shape ${JSON.stringify(n[a])} but got array with shape ${JSON.stringify(i.shape)}.`)}}}function jpt(t,e){if(t==null||Array.isArray(t)&&t.length===0)return e.map(s=>[]);let n;if(typeof t=="string"||typeof t=="function")n=[t];else if(Array.isArray(t)||typeof t=="object")n=t;else throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${t}`);if(Array.isArray(n))return e.map(s=>n);{const s=[];for(const r of e){let o=n.hasOwnProperty(r)?n[r]:[];Array.isArray(o)||(o=[o]),s.push(o)}return s}}const Kpt="layers-model";class yl extends Fa{constructor(e){super(e),this.isTraining=!1}summary(e,n,s=console.log){if(!this.built)throw new Ie("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");Ept(this,e,n,s)}compile(e){if(e.loss==null&&(e.loss=[]),this.loss=e.loss,typeof e.optimizer=="string")this.optimizer_=Ipt(e.optimizer),this.isOptimizerOwned=!0;else{if(!(e.optimizer instanceof eu))throw new Ie("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=e.optimizer,this.isOptimizerOwned=!1}let n=[];if(!Array.isArray(e.loss)&&typeof e.loss!="string"&&typeof e.loss!="function"){e.loss=e.loss;for(const a in e.loss)if(this.outputNames.indexOf(a)===-1)throw new Ie(`Unknown entry in loss dictionary: "${a}". Only expected the following keys: ${this.outputNames}`);for(const a of this.outputNames)e.loss[a]==null&&console.warn(`Output "${a}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${a} during training`),n.push(_$(e.loss[a]))}else if(Array.isArray(e.loss)){if(e.loss.length!==this.outputs.length)throw new Ie(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${e.loss}.`);n=e.loss.map(i=>_$(i))}else{const a=_$(e.loss);this.outputs.forEach(i=>{n.push(a)})}this.lossFunctions=n,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let a=0;a<this.outputs.length;++a){const i=this.internalOutputShapes[a],l=this.outputNames[a];this.feedOutputNames.push(l),this.feedOutputShapes.push(i),this.feedLossFns.push(this.lossFunctions[a])}const s=[];this.metrics=e.metrics,this.metricsNames=["loss"],this.metricsTensors=[],dd("loss",()=>{for(let a=0;a<this.outputs.length;++a){if(s.indexOf(a)!==-1)continue;const i=this.lossFunctions[a];this.outputs.length>1&&(this.metricsTensors.push([i,a]),this.metricsNames.push(this.outputNames[a]+"_loss"))}});const r=jpt(e.metrics,this.outputNames),o=(a,i,l)=>{this.outputNames.length>1&&(i=this.outputNames[a]+"_"+i),this.metricsNames.push(i),this.metricsTensors.push([l,a])};dd("metric",()=>{for(let a=0;a<this.outputs.length;++a){if(s.indexOf(a)!==-1)continue;const i=r[a];(u=>{const c="";let d,f,h;for(const p of u){if(typeof p=="string"&&["accuracy","acc","crossentropy","ce"].indexOf(p)!==-1){const g=this.internalOutputShapes[a];g[g.length-1]===1||this.lossFunctions[a]===V3?["accuracy","acc"].indexOf(p)!==-1?f=nN:["crossentropy","ce"].indexOf(p)!==-1&&(f=$W):this.lossFunctions[a]===db?["accuracy","acc"].indexOf(p)!==-1?f=xW:["crossentropy","ce"].indexOf(p)!==-1&&(f=SW):["accuracy","acc"].indexOf(p)!==-1?f=sN:["crossentropy","ce"].indexOf(p)!==-1&&(f=rN);let y;["accuracy","acc"].indexOf(p)!==-1?y="acc":["crossentropy","ce"].indexOf(p)!==-1&&(y="ce"),h=f,d=c+y}else h=Npt(p),d=c+bv(p);let m;dd(d,()=>{m=h}),o(a,d,m)}})(i)}}),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){this.collectedTrainableWeights!=null&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(e,n,s={}){const r=s.batchSize==null?32:s.batchSize;$$(r);const o=!0,a=this.standardizeUserDataXY(e,n,o,r);try{const i=a[0].concat(a[1]);this.makeTestFunction();const l=this.testFunction,u=this.testLoop(l,i,r,s.verbose,s.steps);return Ur(u)}finally{Ra(a[0],e),Ra(a[1],n)}}async evaluateDataset(e,n){return this.makeTestFunction(),Hpt(this,e,n)}checkNumSamples(e,n,s,r="steps"){let o;if(s!=null){if(o=null,n!=null)throw new Ie(`If ${r} is set, batchSize must be null or undefined.Got batchSize = ${n}`)}else if(e!=null)Array.isArray(e)?o=e[0].shape[0]:o=e.shape[0];else throw new Ie(`Either the input data should have a defined shape, or ${r} shoud be specified.`);return o}execute(e,n){if(Array.isArray(n)&&n.length===0)throw new Ie("`outputs` is an empty Array, which is not allowed.");const s=Array.isArray(n),r=s?n:[n],o=this.retrieveSymbolicTensors(r),a=new ku;if(e instanceof $n&&(e=[e]),Array.isArray(e)){if(e.length!==this.inputs.length)throw new Ie(`The number of inputs provided (${e.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let l=0;l<this.inputs.length;++l)a.add(this.inputs[l],e[l])}else for(const l of this.inputs){const u=e[l.name];if(u==null)throw new Ie(`No value is provided for the model's input ${l.name}`);a.add(l,u)}const i=Km(o,a);return s?i:i[0]}retrieveSymbolicTensors(e){const n=Pd(null,e.length);let s=e.length;for(const r of this.layers){const o=Array.isArray(r.output)?r.output:[r.output],a=o.map(i=>i.name);for(let i=0;i<e.length;++i){const l=a.indexOf(e[i]);if(l!==-1&&(n[i]=o[l],s--),s===0)break}if(s===0)break}if(s>0){const r=[];throw n.forEach((o,a)=>{o==null&&r.push(e[a])}),new Ie(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(r)}`)}return n}predictLoop(e,n=32,s=!1){return Le(()=>{const r=this.checkNumSamples(e);if(s)throw new Jt("Verbose predictLoop() is not implemented yet.");const o=x$(r,n),a=this.outputs.map(i=>[]);for(let i=0;i<o.length;++i)Le(()=>{const u=o[i][0],c=o[i][1],d=Fm(e,u,c),f=[];if(Array.isArray(d))for(let p=0;p<d.length;++p)f.push({key:this.inputs[p],value:d[p]});else f.push({key:this.inputs[0],value:d});const h=new ku(f);return Km(this.outputs,h)}).forEach((u,c)=>a[c].push(u));return Ur(a.map(i=>vs(i,0)))})}predict(e,n={}){const s=IW(e);$D(s,this.inputNames,this.feedInputShapes,!1);try{const r=n.batchSize==null?32:n.batchSize;return $$(r),this.predictLoop(s,r)}finally{Ra(s,e)}}predictOnBatch(e){$D(e,this.inputNames,this.feedInputShapes,!0);const n=(Array.isArray(e)?e[0]:e).shape[0];return this.predictLoop(e,n)}standardizeUserDataXY(e,n,s=!0,r){if(this.optimizer_==null)throw new pa("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");const o=[];for(let a=0;a<this.feedOutputShapes.length;++a){const i=this.feedOutputShapes[a];this.feedLossFns[a]===db?o.push(i.slice(0,i.length-1).concat([1])):o.push(i)}if(e=_D(e,this.feedInputNames,this.feedInputShapes,!1,"input"),n=_D(n,this.feedOutputNames,o,!1,"target"),Upt(e,n),Gpt(n,this.feedLossFns,this.feedOutputShapes),this.stateful&&r!=null&&r>0&&e[0].shape[0]%r!==0)throw new Ie(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${r}. Found: ${e[0].shape[0]} sample(s).`);return[e,n]}async standardizeUserData(e,n,s,r,o=!0,a){const[i,l]=this.standardizeUserDataXY(e,n,o,a);if(s!=null)throw new Error("sample weight is not supported yet.");let u=null;if(r!=null){const c=kW(r,this.outputNames);u=[];for(let d=0;d<c.length;++d)u.push(await TW(l[d],null,c[d]))}return[i,l,u]}testLoop(e,n,s,r=0,o){return Le(()=>{const a=this.checkNumSamples(n,s,o,"steps"),i=[];if(r>0)throw new Jt("Verbose mode is not implemented yet.");if(o!=null)throw new Jt("steps mode in testLoop() is not implemented yet");{const l=x$(a,s),u=vr(ti(0,a));for(let c=0;c<l.length;++c){const d=l[c][0],f=l[c][1],h=fd(u,d,f-d),p=Mx(n,h),m=e(p);if(c===0)for(let g=0;g<m.length;++g)i.push(Pt(0));for(let g=0;g<m.length;++g){const y=m[g];i[g]=st(i[g],Te(f-d,y))}}for(let c=0;c<i.length;++c)i[c]=Et(i[c],a)}return i})}getDedupedMetricsNames(){const e=this.metricsNames,n=[];for(let s=0;s<e.length;++s){const r=e[s];let o=r;if(aD(e,r)>1){const a=aD(e.slice(0,s),r);o+=`_${a}`}n.push(o)}return n}makeTrainFunction(){return e=>{const n=[],s=e.slice(0,this.inputs.length),r=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),o=e.slice(this.inputs.length+this.outputs.length,this.inputs.length+this.outputs.length*2),a=[],i=()=>{const d=[];for(let m=0;m<this.inputs.length;++m)d.push({key:this.inputs[m],value:s[m]});const f=new ku(d),h=Km(this.outputs,f,{training:!0});let p;for(let m=0;m<this.lossFunctions.length;++m){const g=this.lossFunctions[m];let y=g(r[m],h[m]);o[m]!=null&&(y=Mpt(y,o[m]));const w=us(y);n.push(w),m===0?p=y:p=st(p,y)}for(let m=0;m<this.metricsTensors.length;++m){let g;if(this.outputs.length>1&&m<this.outputs.length)g=n[m];else{const y=this.metricsTensors[m][0],w=this.metricsTensors[m][1];g=us(y(r[w],h[w]))}As(g),a.push(g)}return p=us(p),this.calculateLosses().forEach(m=>{p=st(p,m)}),p},l=this.collectedTrainableWeights.map(d=>d.read()),u=!0;return[this.optimizer_.minimize(i,u,l)].concat(a)}}makeTestFunction(){this.testFunction=e=>Le(()=>{const n=[];let s;const r=e.slice(0,this.inputs.length),o=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),a=[];for(let u=0;u<this.inputs.length;++u)a.push({key:this.inputs[u],value:r[u]});const i=new ku(a),l=Km(this.outputs,i);for(let u=0;u<this.lossFunctions.length;++u){const c=this.lossFunctions[u],d=us(c(o[u],l[u]));u===0?s=d:s=st(s,d),n.push(s)}for(let u=0;u<this.metricsTensors.length;++u){const c=this.metricsTensors[u][0],d=this.metricsTensors[u][1],f=us(c(o[d],l[d]));n.push(f)}return n})}async fit(e,n,s={}){if(this.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");this.isTraining=!0;let r,o,a,i,l,u,c,d,f;try{const h=s.batchSize==null?32:s.batchSize;$$(h);const p=!1,m=await this.standardizeUserData(e,n,s.sampleWeight,s.classWeight,p,h);r=m[0],o=m[1],f=m[2];let g=!1,y;if(s.validationData!=null&&s.validationData.length>0){if(g=!0,s.validationData.length===2)l=s.validationData[0],u=s.validationData[1];else throw s.validationData.length===3?new Jt("validationData including sample weights is not supported yet."):new Ie(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${s.validationData} is invalid.`);const T=!0,N=await this.standardizeUserData(l,u,null,null,T,h);c=N[0],d=N[1],y=c.concat(d)}else if(s.validationSplit!=null&&s.validationSplit>0&&s.validationSplit<1){g=!0;const T=Math.floor(r[0].shape[0]*(1-s.validationSplit)),N=r[0].shape[0];c=Fm(r,T,N),a=r,r=Fm(r,0,T),d=Fm(o,T,N),i=o,o=Fm(o,0,T),y=c.concat(d)}else s.validationSteps!=null&&(g=!0);const w=r.concat(o).concat(f);this.checkTrainableWeightsConsistency();const b=this.makeTrainFunction(),_=this.getDedupedMetricsNames();let $,x;g?(this.makeTestFunction(),$=this.testFunction,x=_.slice().concat(_.map(T=>"val_"+T))):($=null,y=[],x=_.slice());const k=yW(s.callbacks,s.yieldEvery);return await this.fitLoop(b,w,_,h,s.epochs,s.verbose,k,$,y,s.shuffle,x,s.initialEpoch,null,null)}finally{this.isTraining=!1,Ra(r,e),Ra(o,n),Ra(a,e),Ra(i,n),Ra(c,l),Ra(d,u),f!=null&&Xt(f)}}async fitLoop(e,n,s,r,o,a,i,l,u,c,d,f,h,p){r==null&&(r=32),o==null&&(o=1),c==null&&(c=!0),f==null&&(f=0);let m=!1;if(l!=null&&u!=null&&(m=!0),p!=null&&(m=!0,h==null))throw new Ie("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");const g=this.checkNumSamples(n,r,h,"steps_per_epoch");let y;g!=null&&(y=ti(0,g)),a==null&&(a=1);const{callbackList:w,history:b}=bW(i,a,o,f,g,h,r,m,d);w.setModel(this),this.history=b,await w.onTrainBegin(),this.stopTraining_=!1;for(let _=f;_<o;++_){await w.onEpochBegin(_);const $={};if(h!=null)throw new Jt("stepsPerEpoch mode is not implemented yet.");{if(c==="batch")throw new Jt("batch shuffling is not implemneted yet");c&&Bk(y);const x=vr(y),k=x$(g,r);for(let C=0;C<k.length;++C){const T={};if(await w.onBatchBegin(C,T),Le(()=>{const N=k[C][0],M=k[C][1],R=fd(x,N,M-N);T.batch=C,T.size=M-N;const D=Mx(n,R),z=e(D);for(let B=0;B<s.length;++B){const V=s[B],O=z[B];T[V]=O,As(O)}if(C===k.length-1&&m){const B=this.testLoop(l,u,r);for(let V=0;V<s.length;++V){const O=s[V],F=B[V];As(F),$["val_"+O]=F}}}),await w.onBatchEnd(C,T),pW(T),this.stopTraining_)break}x.dispose()}if(await w.onEpochEnd(_,$),this.stopTraining_)break}return await w.onTrainEnd(),await this.history.syncData(),this.history}async fitDataset(e,n){return zpt(this,e,n)}async trainOnBatch(e,n){const s=await this.standardizeUserData(e,n),r=s[0],o=s[1],i=this.makeTrainFunction()(r.concat(o)),l=[];for(const u of i){const c=await u.data();l.push(c[0])}return Xt(i),Ra(s[0],e),Ra(s[1],n),Ur(l)}getNamedWeights(e){const n=[],s=e!=null&&e.trainableOnly,r=s?this.trainableWeights:this.weights,o=this.getWeights(s);for(let a=0;a<r.length;++a)s&&!r[a].trainable||n.push({name:r[a].originalName,tensor:o[a]});return n}set stopTraining(e){this.stopTraining_=e}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(e){this.optimizer_!==e&&(this.optimizer_=e,this.isOptimizerOwned=!1)}dispose(){const e=super.dispose();if(e.refCountAfterDispose===0&&this.optimizer!=null&&this.isOptimizerOwned){const n=sb().numTensors;this.optimizer_.dispose(),e.numDisposedVariables+=n-sb().numTensors}return e}getLossIdentifiers(){let e;if(typeof this.loss=="string")e=il(this.loss);else if(Array.isArray(this.loss)){for(const n of this.loss)if(typeof n!="string")throw new Error("Serialization of non-string loss is not supported.");e=this.loss.map(n=>il(n))}else{const n=Object.keys(this.loss);e={};const s=this.loss;for(const r of n)if(typeof s[r]=="string")e[r]=il(s[r]);else throw new Error("Serialization of non-string loss is not supported.")}return e}getMetricIdentifiers(){if(typeof this.metrics=="string"||typeof this.metrics=="function")return[il(bv(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map(e=>il(bv(e)));{const e={};for(const n in this.metrics)e[n]=il(bv(this.metrics[n]));return e}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(e){if(e.weighted_metrics!=null)throw new Error("Loading weight_metrics is not supported yet.");if(e.loss_weights!=null)throw new Error("Loading loss_weights is not supported yet.");if(e.sample_weight_mode!=null)throw new Error("Loading sample_weight_mode is not supported yet.");const n=ag(e.optimizer_config),s=Xa(n);let r;if(typeof e.loss=="string")r=Hc(e.loss);else if(Array.isArray(e.loss))r=e.loss.map(a=>Hc(a));else if(e.loss!=null){r={};for(const a in e.loss)r[a]=Hc(e.loss[a])}let o;if(Array.isArray(e.metrics))o=e.metrics.map(a=>Hc(a));else if(e.metrics!=null){o={};for(const a in e.metrics)o[a]=Hc(e.metrics[a])}this.compile({loss:r,metrics:o,optimizer:s})}async save(e,n){if(typeof e=="string"){const u=GB(e);if(u.length===0)throw new Ie(`Cannot find any save handlers for URL '${e}'`);if(u.length>1)throw new Ie(`Found more than one (${u.length}) save handlers for URL '${e}'`);e=u[0]}if(e.save==null)throw new Ie("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");const s=await bx(this.getNamedWeights(n)),r=!1,o=null,i={modelTopology:this.toJSON(o,r),format:Kpt,generatedBy:`TensorFlow.js tfjs-layers v${H3}`,convertedBy:null};if((n==null?!1:n.includeOptimizer)&&this.optimizer!=null){i.trainingConfig=this.getTrainingConfig();const u="optimizer",{data:c,specs:d}=await bx(await this.optimizer.getWeights(),u);s.specs.push(...d),s.data=P_([s.data,c])}return this.userDefinedMetadata!=null&&(vD(this.userDefinedMetadata,this.name,!0),i.userDefinedMetadata=this.userDefinedMetadata),i.weightData=s.data,i.weightSpecs=s.specs,e.save(i)}setUserDefinedMetadata(e){vD(e,this.name),this.userDefinedMetadata=e}getUserDefinedMetadata(){return this.userDefinedMetadata}}yl.className="Model";tt(yl);class EW extends yl{}EW.className="Functional";tt(EW);async function qpt(t,e){"modelTopology"in t||(t={modelTopology:t}),t=t;let n=t.modelTopology;n.model_config!=null&&(n=n.model_config);const s=ag(n),r=Xa(s,e);if(t.weightsManifest!=null){const o=await tV(t.weightsManifest,t.pathPrefix,r.weights.map(i=>i.originalName)),a={};for(const i of r.weights)a[i.originalName]=o[i.originalName];r.loadWeights(a),Xt(o)}return r}async function Xpt(t,e){if(e==null&&(e={}),typeof t=="string"){const n=jB(t,e);if(n.length===0)n.push(rV(t,e));else if(n.length>1)throw new Ie(`Found more than one (${n.length}) load handlers for URL '${t}'`);t=n[0]}return Ypt(t,void 0,e)}async function Ypt(t,e,n){if(n==null&&(n={}),t.load==null)throw new Ie("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const s=await t.load();let r=s.modelTopology;r.model_config!=null&&(r=r.model_config);const o=n.strict==null?!0:n.strict,a=s.weightData!=null&&s.weightSpecs!=null&&o,i=Xa(ag(r),e,a),l=s.trainingConfig;if(l!=null&&i.loadTrainingConfig(l),s.userDefinedMetadata!=null&&i.setUserDefinedMetadata(s.userDefinedMetadata),s.weightData!=null){if(s.weightSpecs==null)throw new Ie("LayersModel artifacts contains weight data, but not weight specs. Therefore loading of weights cannot proceed.");const{modelWeights:u,optimizerWeights:c}=Zpt(s.weightData,s.weightSpecs);i.loadWeights(u,o),i.optimizer!=null&&c.length>0&&await i.optimizer.setWeights(c),Xt(u),Xt(c.map(d=>d.tensor))}return i}function Zpt(t,e){const n=Zk(t,e),s={},r=[];return e.forEach(o=>{o.group==="optimizer"?r.push({name:o.name,tensor:n[o.name]}):s[o.name]=n[o.name]}),{modelWeights:s,optimizerWeights:r}}class Ld extends yl{constructor(e){if(super({inputs:[],outputs:[]}),e=e||{},this.trainable=!0,this.built=!1,this.name=e.name!=null?e.name:E3("sequential_"),e.layers!=null)for(const n of e.layers)this.add(n)}checkShape(e){if(e.inboundNodes[0].outputTensors[0].shape.some(s=>s<0))throw new Ie(`Negative dimension size caused by adding layer ${e.name} with input shape [${e.inboundNodes[0].inputTensors[0].shape}]`)}add(e){const n=e instanceof Ld||e instanceof yl;let s;if(n){if(s=e,s.outputs.length!==1)throw new Ie("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(s.inputs.length!==1)throw new Ie("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(this.outputs.length===0){if(e.inboundNodes.length===0){if(e.batchInputShape==null)throw new Ie("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");const r=hW({batchShape:e.batchInputShape,dtype:e.dtype,name:e.name+"_input"});e.apply(r)}if(n)this.outputs=s.outputs,this.inputs=s.inputs;else{if(e.inboundNodes.length!==1)throw new Ie(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${e.name} which has ${e.inboundNodes.length} pre-existing inbound connections.`);if(e.inboundNodes[0].outputTensors.length!==1)throw new Ie("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[e.inboundNodes[0].outputTensors[0]],this.inputs=fW(this.outputs[0])}this.inboundNodes=[],new z3({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:Pd(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map(r=>r.shape),outputShapes:this.outputs[0].shape})}else{const r=e.apply(this.outputs[0]);if(Array.isArray(r))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[r],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(e),this.built=!1}pop(){if(this.layers.length===0)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),this.layers.length===0)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{const e=this.layers.length-1;this.layers[e].outboundNodes=[],this.outputs=[this.layers[e].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(e,n){return this.model==null&&this.build(),this.model.call(e,n)}build(e){if(Cn(e),this.inputs.length===0||this.outputs.length===0)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new yl({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(e,n,s=console.log){this.built||this.build(),super.summary(e,n,s)}setWeights(e){this.model==null&&this.build(),this.model.setWeights(e)}evaluate(e,n,s={}){if(!this.built)throw new pa("The model needs to be compiled before being used.");return this.model.evaluate(e,n,s)}async evaluateDataset(e,n){if(!this.built)throw new pa("The model needs to be compiled before being used.");return this.model.evaluateDataset(e,n)}predict(e,n={}){return this.model==null&&this.build(),this.model.predict(e,n)}predictOnBatch(e){return this.model==null&&this.build(),this.model.predictOnBatch(e)}compile(e){this.build(),this.model.compile(e),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return this.model==null?void 0:this.model.optimizer}set optimizer(e){this.model.optimizer=e}async fit(e,n,s={}){if(!this.built)throw new pa("The model needs to be compiled before being used.");return this.model.fit(e,n,s)}async fitDataset(e,n){if(!this.built)throw new pa("The model needs to be compiled before being used.");return this.model.fitDataset(e,n)}async trainOnBatch(e,n){return this.model.trainOnBatch(e,n)}static fromConfig(e,n,s={},r=!1){let o,a={};if(n instanceof Array){if(n[0].className==null||n[0].className==="Merge")throw new Ie("Legacy serialization format not supported yet.");o=n}else q(n.layers!=null,()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."),o=n.layers,delete n.layers,a=n;const i=new e(a);if(!(i instanceof Ld))throw new Jt(`Sequential.fromConfig called on non-Sequential input: ${i}`);for(const l of o){const c=Xa(l,void 0,r);r&&c.setFastWeightInitDuringBuild(!0),i.add(c)}return i}set stopTraining(e){if(this.model==null)throw new Ie("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=e}get stopTraining(){if(this.model==null)throw new Ie("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){const e=[];for(const n of this.layers){const s={};s.className=n.getClassName(),s.config=n.getConfig(),e.push(s)}return{name:this.name,layers:e}}}Ld.className="Sequential";tt(Ld);function Jpt(t){return new yl(t)}function Qpt(t){return new Ld(t)}function AW(t){return hW(t)}function emt(t,e){Do.registerCallbackConstructor(t,e)}let no=class extends rf{getConfig(){return{}}},OW=class extends no{apply(e,n=1){return $ht(e,n)}};OW.className="elu";tt(OW);let RW=class extends no{apply(e){return s3(e)}};RW.className="selu";tt(RW);let DW=class extends no{apply(e){return li(e)}};DW.className="relu";tt(DW);let FW=class extends no{apply(e){return Le(()=>om(6,li(e)))}};FW.className="relu6";tt(FW);class MW extends no{apply(e){return e}}MW.className="linear";tt(MW);let PW=class extends no{apply(e){return qa(e)}};PW.className="sigmoid";tt(PW);class LW extends no{apply(e){return Sht(e)}}LW.className="hardSigmoid";tt(LW);let zW=class extends no{apply(e){return af(e)}};zW.className="softplus";tt(zW);class BW extends no{apply(e){return xht(e)}}BW.className="softsign";tt(BW);let VW=class extends no{apply(e){return Rd(e)}};VW.className="tanh";tt(VW);let oN=class extends no{apply(e,n=-1){return r2(e,n)}};oN.className="softmax";tt(oN);let HW=class extends no{apply(e,n=-1){return X_(e,n)}};HW.className="logSoftmax";tt(HW);class WW extends no{apply(e,n=1){return Le(()=>Te(qa(Te(e,n)),e))}}WW.className="swish";tt(WW);class UW extends no{apply(e){return Le(()=>Te(e,Rd(af(e))))}}UW.className="mish";tt(UW);function Qu(t){return t.getClassName()}function S$(t,e={}){return d2(t,ua.getMap().classNameMap,e,"activation")}function ec(t){if(t==null){const e={};return e.className="linear",e.config={},S$(e)}if(typeof t=="string"){const e={};return e.className=t,e.config={},S$(e)}else return t instanceof no?t:S$(t)}function aN(t){if(t!=null&&typeof t!="object")throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${t}`)}class GW extends rf{}class g2 extends GW{constructor(e){super(),aN(e),this.l1=e==null||e.l1==null?.01:e.l1,this.l2=e==null||e.l2==null?.01:e.l2,this.hasL1=this.l1!==0,this.hasL2=this.l2!==0}apply(e){return Le(()=>{let n=xs([1]);return this.hasL1&&(n=st(n,kt(Te(this.l1,$s(e))))),this.hasL2&&(n=st(n,kt(Te(this.l2,h2(e))))),Ne(n,[])})}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(e,n){return new e({l1:n.l1,l2:n.l2})}}g2.className="L1L2";tt(g2);function tmt(t){return aN(t),new g2({l1:t!=null?t.l1:null,l2:0})}function nmt(t){return aN(t),new g2({l2:t!=null?t.l2:null,l1:0})}const xD={l1l2:"L1L2"};function zn(t){return zT(t)}function SD(t,e={}){return d2(t,ua.getMap().classNameMap,e,"regularizer")}function is(t){if(t==null)return null;if(typeof t=="string"){const n={className:t in xD?xD[t]:t,config:{}};return SD(n)}else return t instanceof GW?t:SD(t)}class iN extends cn{constructor(e){super(e??{}),this.supportsMasking=!0,e!=null&&(this.maxValue=e.maxValue)}call(e,n){e=jt(e);let s=li(e);return this.maxValue!=null&&(s=Zr(s,0,this.maxValue)),s}computeOutputShape(e){return e}getConfig(){const e={maxValue:this.maxValue},n=super.getConfig();return Object.assign(e,n),e}}iN.className="ReLU";tt(iN);class lN extends cn{constructor(e){super(e??{}),this.DEFAULT_ALPHA=.3,e==null&&(e={}),this.alpha=e.alpha==null?this.DEFAULT_ALPHA:e.alpha}call(e,n){const s=jt(e);return X1(s,this.alpha)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},n=super.getConfig();return Object.assign(e,n),e}}lN.className="LeakyReLU";tt(lN);class uN extends cn{constructor(e){if(super(e??{}),this.DEFAULT_ALPHA_INITIALIZER="zeros",e==null&&(e={}),this.supportsMasking=!0,this.alphaInitializer=as(e.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=is(e.alphaRegularizer),this.alphaConstraint=Ms(e.alphaConstraint),e.sharedAxes==null)this.sharedAxes=null;else if(Array.isArray(e.sharedAxes))this.sharedAxes=e.sharedAxes;else if(typeof e.sharedAxes=="number")this.sharedAxes=[e.sharedAxes];else throw new Ie(`Expected sharedAxes to be a number or an array of numbers, but got ${e.sharedAxes}`)}build(e){e=Cn(e);const n=e.slice(1);if(this.sharedAxes!=null)for(const r of this.sharedAxes)n[r-1]=1;this.alpha=this.addWeight("alpha",n,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);const s={};if(this.sharedAxes!=null)for(let r=1;r<e.length;++r)s[r]=e[r];this.inputSpec=[new Ss({ndim:e.length,axes:s})],this.built=!0}call(e,n){return e=jt(e),t2(e,this.alpha.read())}getConfig(){const e={alphaInitializer:cs(this.alphaInitializer),alphaRegularizer:zn(this.alphaRegularizer),alphaConstraint:Fs(this.alphaConstraint),sharedAxes:this.sharedAxes},n=super.getConfig();return Object.assign(e,n),e}}uN.className="PReLU";tt(uN);let cN=class extends cn{constructor(e){if(super(e??{}),this.DEFAULT_ALPHA=1,e==null&&(e={}),e.alpha!=null&&e.alpha!==this.DEFAULT_ALPHA)throw new Jt(`Non-default alpha value (${e.alpha}) is not supported by the ELU layer yet.`);this.alpha=e.alpha==null?this.DEFAULT_ALPHA:e.alpha}call(e,n){const s=jt(e);return tm(s)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},n=super.getConfig();return Object.assign(e,n),e}};cN.className="ELU";tt(cN);class dN extends cn{constructor(e){super(e??{}),this.DEFAULT_THETA=1,e==null&&(e={}),this.theta=e.theta==null?this.DEFAULT_THETA:e.theta}call(e,n){const s=jt(e);return Te(s,ht(Pr(s,this.theta),"float32"))}computeOutputShape(e){return e}getConfig(){const e={theta:this.theta},n=super.getConfig();return Object.assign(e,n),e}}dN.className="ThresholdedReLU";tt(dN);let fN=class extends cn{constructor(e){super(e??{}),this.DEFAULT_AXIS=1,e==null&&(e={}),this.softmax=new oN().apply,this.axis=e.axis==null?this.DEFAULT_AXIS:e.axis}call(e,n){const s=jt(e);return this.softmax(s,this.axis)}computeOutputShape(e){return e}getConfig(){const e={axis:this.axis},n=super.getConfig();return Object.assign(e,n),e}};fN.className="Softmax";tt(fN);function Jf(t,e,n){if(typeof t=="number")return Pd(t,e);if(t.length!==e)throw new Ie(`The ${n} argument must be an integer or tuple of ${e} integers. Received: ${t.length} elements.`);for(let s=0;s<e;++s){const r=t[s];if(!yht(r))throw new Ie(`The ${n} argument must be an integer or tuple of ${e} integers. Received: ${JSON.stringify(t)} including a non-integer number ${r}`)}return t}function Ya(t,e,n,s,r=1){if(t==null)return t;const o=e+(e-1)*(r-1);let a;return n==="same"?a=t:a=t-o+1,Math.floor((a+s-1)/s)}function vi(t,e,n,s){if(t==null)return null;if(s==="valid")t=t*e+Ju([n-e,0]);else if(s==="same")t=t*e;else throw new Ie(`Unsupport padding mode: ${s}.`);return t}function hN(t,e){return Le(()=>(ws(e),e==="channelsFirst"?dn(t,[0,2,3,1]):t))}function jW(t,e){return Le(()=>(ws(e),e==="channelsFirst"?dn(t,[0,2,3,4,1]):t))}function smt(t,e,n,s=1,r="valid",o,a=1){return Le(()=>{if(o==null&&(o=ni()),ws(o),t.shape.length!==3)throw new Ie(`The input of a conv1dWithBias operation should be 3, but is ${t.shape.length} instead.`);if(e.shape.length!==3)throw new Ie(`The kernel for a conv1dWithBias operation should be 3, but is ${e.shape.length} instead`);if(n!=null&&n.shape.length!==1)throw new Ie(`The bias for a conv1dWithBias operation should be 1, but is ${e.shape.length} instead`);if(o==="channelsFirst"&&(t=dn(t,[0,2,1])),r==="causal")throw new Jt("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let i=H_(t,e,s,r==="same"?"same":"valid","NWC",a);return n!=null&&(i=ui(i,n)),i})}function CD(t,e,n,s=[1,1],r="valid",o,a,i=null){return Le(()=>{if(o==null&&(o=ni()),ws(o),t.rank!==3&&t.rank!==4)throw new Ie(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${t.rank}.`);if(e.rank!==3&&e.rank!==4)throw new Ie(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${t.rank}.`);let l=hN(t,o);if(r==="causal")throw new Jt("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return l=mH({x:l,filter:e,strides:s,pad:r==="same"?"same":"valid",dilations:a,dataFormat:"NHWC",bias:n,activation:i}),o==="channelsFirst"&&(l=dn(l,[0,3,1,2])),l})}function rmt(t,e,n,s=[1,1,1],r="valid",o,a){return Le(()=>{if(o==null&&(o=ni()),ws(o),t.rank!==4&&t.rank!==5)throw new Ie(`conv3dWithBias expects input to be of rank 4 or 5, but received ${t.rank}.`);if(e.rank!==4&&e.rank!==5)throw new Ie(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${t.rank}.`);let i=jW(t,o);if(r==="causal")throw new Jt("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return i=P8(i,e,s,r==="same"?"same":"valid","NDHWC",a),n!=null&&(i=ui(i,n)),o==="channelsFirst"&&(i=dn(i,[0,4,1,2,3])),i})}class W3 extends cn{constructor(e,n){if(super(n),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",W3.verifyArgs(n),this.rank=e,Hs(this.rank,"rank"),this.rank!==1&&this.rank!==2&&this.rank!==3)throw new Jt(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=Jf(n.kernelSize,e,"kernelSize"),this.strides=Jf(n.strides==null?1:n.strides,e,"strides"),this.padding=n.padding==null?"valid":n.padding,Jo(this.padding),this.dataFormat=n.dataFormat==null?"channelsLast":n.dataFormat,ws(this.dataFormat),this.activation=ec(n.activation),this.useBias=n.useBias==null?!0:n.useBias,this.biasInitializer=as(n.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=Ms(n.biasConstraint),this.biasRegularizer=is(n.biasRegularizer),this.activityRegularizer=is(n.activityRegularizer),this.dilationRate=Jf(n.dilationRate==null?1:n.dilationRate,e,"dilationRate"),this.rank===1&&Array.isArray(this.dilationRate)&&this.dilationRate.length!==1)throw new Ie(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(this.rank===2){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==2)throw new Ie(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(this.rank===3){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==3)throw new Ie(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}}static verifyArgs(e){if(gi("kernelSize"in e,"required key 'kernelSize' not in config"),typeof e.kernelSize!="number"&&!BT(e.kernelSize,"number",1,3))throw new Ie(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(e.kernelSize)}.`)}getConfig(){const e={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:Qu(this.activation),useBias:this.useBias,biasInitializer:cs(this.biasInitializer),biasRegularizer:zn(this.biasRegularizer),activityRegularizer:zn(this.activityRegularizer),biasConstraint:Fs(this.biasConstraint)},n=super.getConfig();return Object.assign(e,n),e}}class cm extends W3{constructor(e,n){super(e,n),this.kernel=null,cm.verifyArgs(n),this.filters=n.filters,Hs(this.filters,"filters"),this.kernelInitializer=as(n.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=Ms(n.kernelConstraint),this.kernelRegularizer=is(n.kernelRegularizer)}build(e){e=Cn(e);const n=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[n]==null)throw new Ie(`The channel dimension of the input should be defined. Found ${e[n]}`);const s=e[n],r=this.kernelSize.concat([s,this.filters]);this.kernel=this.addWeight("kernel",r,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[n]:s}}],this.built=!0}call(e,n){return Le(()=>{e=jt(e);let s;const r=this.bias==null?null:this.bias.read(),o=sW(this.activation.getClassName());if(o!=null&&this.rank===2)s=CD(e,this.kernel.read(),r,this.strides,this.padding,this.dataFormat,this.dilationRate,o);else{if(this.rank===1)s=smt(e,this.kernel.read(),r,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(this.rank===2)s=CD(e,this.kernel.read(),r,this.strides,this.padding,this.dataFormat,this.dilationRate);else if(this.rank===3)s=rmt(e,this.kernel.read(),r,this.strides,this.padding,this.dataFormat,this.dilationRate);else throw new Jt("convolutions greater than 3D are not implemented yet.");this.activation!=null&&(s=this.activation.apply(s))}return s})}computeOutputShape(e){e=Cn(e);const n=[],s=this.dataFormat==="channelsLast"?e.slice(1,e.length-1):e.slice(2);for(let o=0;o<s.length;++o){const a=Ya(s[o],this.kernelSize[o],this.padding,this.strides[o],typeof this.dilationRate=="number"?this.dilationRate:this.dilationRate[o]);n.push(a)}let r=[e[0]];return this.dataFormat==="channelsLast"?(r=r.concat(n),r.push(this.filters)):(r.push(this.filters),r=r.concat(n)),r}getConfig(){const e={filters:this.filters,kernelInitializer:cs(this.kernelInitializer),kernelRegularizer:zn(this.kernelRegularizer),kernelConstraint:Fs(this.kernelConstraint)},n=super.getConfig();return Object.assign(e,n),e}static verifyArgs(e){if(!("filters"in e)||typeof e.filters!="number"||e.filters<1)throw new Ie(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(e.filters)}`)}}let v2=class extends cm{constructor(e){super(2,e),v2.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!BT(e.kernelSize,"number",1,2))throw new Ie(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(e.kernelSize)}.`)}};v2.className="Conv2D";tt(v2);let y2=class extends cm{constructor(e){super(3,e),y2.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!(Array.isArray(e.kernelSize)&&(e.kernelSize.length===1||e.kernelSize.length===3)))throw new Ie(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(e.kernelSize)}.`)}};y2.className="Conv3D";tt(y2);class pN extends v2{constructor(e){if(super(e),this.inputSpec=[new Ss({ndim:4})],this.padding!=="same"&&this.padding!=="valid")throw new Ie(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(e=Cn(e),e.length!==4)throw new Ie("Input should have rank 4; Received input shape: "+JSON.stringify(e));const n=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[n]==null)throw new Ie("The channel dimension of the inputs should be defined. Found `None`.");const s=e[n],r=this.kernelSize.concat([this.filters,s]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new Ss({ndim:4,axes:{[n]:s}})],this.built=!0}call(e,n){return Le(()=>{let s=jt(e);if(s.shape.length!==4)throw new Ie(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${s.shape.length}`);const r=s.shape,o=r[0];let a,i;this.dataFormat==="channelsFirst"?(a=2,i=3):(a=1,i=2);const l=r[a],u=r[i],c=this.kernelSize[0],d=this.kernelSize[1],f=this.strides[0],h=this.strides[1],p=vi(l,f,c,this.padding),m=vi(u,h,d,this.padding),g=[o,p,m,this.filters];this.dataFormat!=="channelsLast"&&(s=dn(s,[0,2,3,1]));let y=W_(s,this.kernel.read(),g,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(y=dn(y,[0,3,1,2])),this.bias!=null&&(y=ui(y,this.bias.read(),this.dataFormat)),this.activation!=null&&(y=this.activation.apply(y)),y})}computeOutputShape(e){e=Cn(e);const n=e.slice();let s,r,o;this.dataFormat==="channelsFirst"?(s=1,r=2,o=3):(s=3,r=1,o=2);const a=this.kernelSize[0],i=this.kernelSize[1],l=this.strides[0],u=this.strides[1];return n[s]=this.filters,n[r]=vi(n[r],l,a,this.padding),n[o]=vi(n[o],u,i,this.padding),n}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}pN.className="Conv2DTranspose";tt(pN);class mN extends y2{constructor(e){if(super(e),this.inputSpec=[new Ss({ndim:5})],this.padding!=="same"&&this.padding!=="valid")throw new Ie(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(e=Cn(e),e.length!==5)throw new Ie("Input should have rank 5; Received input shape: "+JSON.stringify(e));const n=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[n]==null)throw new Ie("The channel dimension of the inputs should be defined. Found `None`.");const s=e[n],r=this.kernelSize.concat([this.filters,s]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new Ss({ndim:5,axes:{[n]:s}})],this.built=!0}call(e,n){return Le(()=>{let s=jt(e);if(s.shape.length!==5)throw new Ie(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${s.shape.length}`);const r=s.shape,o=r[0];let a,i,l;this.dataFormat==="channelsFirst"?(l=2,a=3,i=4):(l=1,a=2,i=3);const u=r[l],c=r[a],d=r[i],f=this.kernelSize[0],h=this.kernelSize[1],p=this.kernelSize[2],m=this.strides[0],g=this.strides[1],y=this.strides[2],w=vi(u,m,f,this.padding),b=vi(c,g,h,this.padding),_=vi(d,y,p,this.padding),$=[o,w,b,_,this.filters];this.dataFormat!=="channelsLast"&&(s=dn(s,[0,2,3,4,1]));let x=L8(s,this.kernel.read(),$,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(x=dn(x,[0,4,1,2,3])),this.bias!==null&&(x=ui(x,this.bias.read(),this.dataFormat)),this.activation!==null&&(x=this.activation.apply(x)),x})}computeOutputShape(e){e=Cn(e);const n=e.slice();let s,r,o,a;this.dataFormat==="channelsFirst"?(s=1,r=2,o=3,a=4):(s=4,r=1,o=2,a=3);const i=this.kernelSize[0],l=this.kernelSize[1],u=this.kernelSize[2],c=this.strides[0],d=this.strides[1],f=this.strides[2];return n[s]=this.filters,n[r]=vi(n[r],c,i,this.padding),n[o]=vi(n[o],d,l,this.padding),n[a]=vi(n[a],f,u,this.padding),n}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}mN.className="Conv3DTranspose";tt(mN);class KW extends cm{constructor(e,n){if(super(e,n),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,n.filters==null)throw new Ie("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(n.kernelInitializer!=null||n.kernelRegularizer!=null||n.kernelConstraint!=null)throw new Ie("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(n.padding!=null&&n.padding!=="same"&&n.padding!=="valid")throw new Ie(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(n.padding)}`);this.depthMultiplier=n.depthMultiplier==null?1:n.depthMultiplier,this.depthwiseInitializer=as(n.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=is(n.depthwiseRegularizer),this.depthwiseConstraint=Ms(n.depthwiseConstraint),this.pointwiseInitializer=as(n.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=is(n.pointwiseRegularizer),this.pointwiseConstraint=Ms(n.pointwiseConstraint)}build(e){if(e=Cn(e),e.length<this.rank+2)throw new Ie(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(e)}`);const n=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[n]==null||e[n]<0)throw new Ie(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(e[n])}`);const s=e[n],r=this.kernelSize.concat([s,this.depthMultiplier]),o=[];for(let i=0;i<this.rank;++i)o.push(1);o.push(s*this.depthMultiplier,this.filters);const a=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",r,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,a,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",o,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,a,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,a,this.biasConstraint):this.bias=null,this.inputSpec=[new Ss({ndim:this.rank+2,axes:{[n]:s}})],this.built=!0}call(e,n){return Le(()=>{e=jt(e);let s;if(this.rank===1)throw new Jt("1D separable convolution is not implemented yet.");return this.rank===2&&(this.dataFormat==="channelsFirst"&&(e=dn(e,[0,2,3,1])),s=r3(e,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(s=ui(s,this.bias.read(),this.dataFormat)),this.activation!=null&&(s=this.activation.apply(s)),this.dataFormat==="channelsFirst"&&(s=dn(s,[0,3,1,2])),s})}getConfig(){const e=super.getConfig();return delete e.rank,delete e.kernelInitializer,delete e.kernelRegularizer,delete e.kernelConstraint,e.depthwiseInitializer=cs(this.depthwiseInitializer),e.pointwiseInitializer=cs(this.pointwiseInitializer),e.depthwiseRegularizer=zn(this.depthwiseRegularizer),e.pointwiseRegularizer=zn(this.pointwiseRegularizer),e.depthwiseConstraint=Fs(this.depthwiseConstraint),e.pointwiseConstraint=Fs(this.pointwiseConstraint),e}}KW.className="SeparableConv";class gN extends KW{constructor(e){super(2,e)}}gN.className="SeparableConv2D";tt(gN);class b2 extends cm{constructor(e){super(1,e),b2.verifyArgs(e),this.inputSpec=[{ndim:3}]}getConfig(){const e=super.getConfig();return delete e.rank,delete e.dataFormat,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!BT(e.kernelSize,"number",1,1))throw new Ie(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(e.kernelSize)}.`)}}b2.className="Conv1D";tt(b2);class vN extends cn{constructor(e){super(e),typeof e.cropping=="number"?this.cropping=[[e.cropping,e.cropping],[e.cropping,e.cropping]]:typeof e.cropping[0]=="number"?this.cropping=[[e.cropping[0],e.cropping[0]],[e.cropping[1],e.cropping[1]]]:this.cropping=e.cropping,this.dataFormat=e.dataFormat===void 0?"channelsLast":e.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(e){return this.dataFormat==="channelsFirst"?[e[0],e[1],e[2]-this.cropping[0][0]-this.cropping[0][1],e[3]-this.cropping[1][0]-this.cropping[1][1]]:[e[0],e[1]-this.cropping[0][0]-this.cropping[0][1],e[2]-this.cropping[1][0]-this.cropping[1][1],e[3]]}call(e,n){return Le(()=>{if(e=jt(e),this.dataFormat==="channelsLast"){const s=yv(e,this.cropping[0][0],e.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return yv(s,this.cropping[1][0],e.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}else{const s=yv(e,this.cropping[0][0],e.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return yv(s,this.cropping[1][0],e.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}})}getConfig(){const e={cropping:this.cropping,dataFormat:this.dataFormat},n=super.getConfig();return Object.assign(e,n),e}}vN.className="Cropping2D";tt(vN);class yN extends cn{constructor(e){super(e),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=e.size==null?this.DEFAULT_SIZE:e.size,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,ws(this.dataFormat),this.interpolation=e.interpolation==null?"nearest":e.interpolation,mht(this.interpolation)}computeOutputShape(e){if(this.dataFormat==="channelsFirst"){const n=e[2]==null?null:this.size[0]*e[2],s=e[3]==null?null:this.size[1]*e[3];return[e[0],e[1],n,s]}else{const n=e[1]==null?null:this.size[0]*e[1],s=e[2]==null?null:this.size[1]*e[2];return[e[0],n,s,e[3]]}}call(e,n){return Le(()=>{let s=jt(e);const r=s.shape;if(this.dataFormat==="channelsFirst"){s=dn(s,[0,2,3,1]);const o=this.size[0]*r[2],a=this.size[1]*r[3],i=this.interpolation==="nearest"?Ti.resizeNearestNeighbor(s,[o,a]):Ti.resizeBilinear(s,[o,a]);return dn(i,[0,3,1,2])}else{const o=this.size[0]*r[1],a=this.size[1]*r[2];return this.interpolation==="nearest"?Ti.resizeNearestNeighbor(s,[o,a]):Ti.resizeBilinear(s,[o,a])}})}getConfig(){const e={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation},n=super.getConfig();return Object.assign(e,n),e}}yN.className="UpSampling2D";tt(yN);function omt(t,e,n=[1,1],s="valid",r,o){return Le(()=>{r==null&&(r=ni()),ws(r);let a=hN(t,r);if(t.rank!==4)throw new Ie(`Input for depthwiseConv2d is required to be 4-D, but is instead ${t.rank}-D`);if(e.rank!==4)throw new Ie(`depthwiseKernel is required to be 4-D, but is instead ${e.rank}-D`);return a=em(a,e,n,s==="same"?"same":"valid","NHWC",o),r==="channelsFirst"&&(a=dn(a,[0,3,1,2])),a})}class bN extends W3{constructor(e){super(2,e),this.depthwiseKernel=null,this.depthMultiplier=e.depthMultiplier==null?1:e.depthMultiplier,this.depthwiseInitializer=as(e.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=Ms(e.depthwiseConstraint),this.depthwiseRegularizer=is(e.depthwiseRegularizer)}build(e){if(e=Cn(e),e.length<4)throw new Ie(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(e)}.`);const n=this.dataFormat==="channelsFirst"?1:3;if(e[n]==null||e[n]<0)throw new Ie(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${e[n]}).`);const s=e[n],r=[this.kernelSize[0],this.kernelSize[1],s,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",r,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[s*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,n){return Le(()=>{e=jt(e);let s=omt(e,this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(s=ui(s,this.bias.read(),this.dataFormat)),this.activation!=null&&(s=this.activation.apply(s)),s})}computeOutputShape(e){e=Cn(e);const n=this.dataFormat==="channelsFirst"?e[2]:e[1],s=this.dataFormat==="channelsFirst"?e[3]:e[2],r=this.dataFormat==="channelsFirst"?e[1]*this.depthMultiplier:e[3]*this.depthMultiplier,o=Ya(n,this.kernelSize[0],this.padding,this.strides[0]),a=Ya(s,this.kernelSize[1],this.padding,this.strides[1]);return this.dataFormat==="channelsFirst"?[e[0],r,o,a]:[e[0],o,a,r]}getConfig(){const e=super.getConfig();return e.depthMultiplier=this.depthMultiplier,e.depthwiseInitializer=cs(this.depthwiseInitializer),e.depthwiseRegularizer=zn(this.depthwiseRegularizer),e.depthwiseConstraint=Fs(this.depthwiseRegularizer),e}}bN.className="DepthwiseConv2D";tt(bN);function qW(t,e,n,s){if(Array.isArray(t)){if(e!=null||n!=null)throw new Ie("When inputs is an array, neither initialState or constants should be provided");s!=null&&(n=t.slice(t.length-s,t.length),t=t.slice(0,t.length-s)),t.length>1&&(e=t.slice(1,t.length)),t=t[0]}function r(o){return o==null||Array.isArray(o)?o:[o]}return e=r(e),n=r(n),{inputs:t,initialState:e,constants:n}}function XW(t,e,n,s=!1,r,o,a=!1,i=!1){return Le(()=>{const l=e.shape.length;if(l<3)throw new Ie(`Input should be at least 3D, but is ${l}D.`);const u=[1,0].concat(ti(2,l));if(e=dn(e,u),o!=null)throw new Jt("The rnn() functoin of the deeplearn.js backend does not support constants yet.");a&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),r!=null&&(r=ht(ht(r,"bool"),"float32"),r.rank===l-1&&(r=hr(r,-1)),r=dn(r,u)),s&&(e=Xo(e,0),r!=null&&(r=Xo(r,0)));const c=[];let d,f=n;const h=e.shape[0],p=Yo(e);let m;r!=null&&(m=Yo(r));for(let y=0;y<h;++y){const w=p[y],b=Le(()=>t(w,f));if(r==null)d=b[0],f=b[1];else{const _=Le(()=>{const $=m[y],x=$t(So($),$),k=st(Te(b[0],$),Te(f[0],x)),C=f.map((T,N)=>st(Te(b[1][N],$),Te(T,x)));return{output:k,newStates:C}});d=_.output,f=_.newStates}i&&c.push(d)}let g;return i&&(g=Jr(c,1)),[d,g,f]})}class ci extends cn{constructor(e){super(e);let n;if(e.cell==null)throw new Ie("cell property is missing for the constructor of RNN.");if(Array.isArray(e.cell)?n=new j3({cells:e.cell}):n=e.cell,n.stateSize==null)throw new Ie("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=n,this.returnSequences=e.returnSequences==null?!1:e.returnSequences,this.returnState=e.returnState==null?!1:e.returnState,this.goBackwards=e.goBackwards==null?!1:e.goBackwards,this._stateful=e.stateful==null?!1:e.stateful,this.unroll=e.unroll==null?!1:e.unroll,this.supportsMasking=!0,this.inputSpec=[new Ss({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){if(this.states_==null){const e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;return ti(0,e).map(n=>null)}else return this.states_}setStates(e){this.states_=e}computeOutputShape(e){Ox(e)&&(e=e[0]),e=e;let n=this.cell.stateSize;Array.isArray(n)||(n=[n]);const s=n[0];let r;if(this.returnSequences?r=[e[0],e[1],s]:r=[e[0],s],this.returnState){const o=[];for(const a of n)o.push([e[0],a]);return[r].concat(o)}else return r}computeMask(e,n){return Le(()=>{Array.isArray(n)&&(n=n[0]);const s=this.returnSequences?n:null;if(this.returnState){const r=this.states.map(o=>null);return[s].concat(r)}else return s})}get states(){if(this.states_==null){const e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,n=[];for(let s=0;s<e;++s)n.push(null);return n}else return this.states_}set states(e){this.states_=e}build(e){if(this.numConstants!=null)throw new Jt("Constants support is not implemented in RNN yet.");Ox(e)&&(e=e[0]),e=e;const n=this.stateful?e[0]:null,s=e.slice(2);this.inputSpec[0]=new Ss({shape:[n,null,...s]});const r=[e[0]].concat(e.slice(2));this.cell.build(r);let o;if(Array.isArray(this.cell.stateSize)?o=this.cell.stateSize:o=[this.cell.stateSize],this.stateSpec!=null){if(!hn(this.stateSpec.map(a=>a.shape[a.shape.length-1]),o))throw new Ie(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=o.map(a=>new Ss({shape:[null,a]}));this.stateful&&this.resetStates()}resetStates(e,n=!1){Le(()=>{if(!this.stateful)throw new mi("Cannot call resetStates() on an RNN Layer that is not stateful.");const s=this.inputSpec[0].shape[0];if(s==null)throw new Ie("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.states_==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(r=>xs([s,r])):this.states_=[xs([s,this.cell.stateSize])];else if(e==null)Xt(this.states_),this.keptStates!=null&&(Xt(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(r=>xs([s,r])):this.states_[0]=xs([s,this.cell.stateSize]);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new Ie(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);n===!0?this.keptStates.push(this.states_.slice()):Xt(this.states_);for(let r=0;r<this.states_.length;++r){const o=e[r],a=Array.isArray(this.cell.stateSize)?this.cell.stateSize[r]:this.cell.stateSize,i=[s,a];if(!hn(o.shape,i))throw new Ie(`State ${r} is incompatible with layer ${this.name}: expected shape=${i}, received shape=${o.shape}`);this.states_[r]=o}}this.states_=this.states_.map(r=>As(r.clone()))})}apply(e,n){let s=n==null?null:n.initialState,r=n==null?null:n.constants;n==null&&(n={});const o=qW(e,s,r,this.numConstants);e=o.inputs,s=o.initialState,r=o.constants;let a=[],i=[];if(s!=null){n.initialState=s,a=a.concat(s),this.stateSpec=[];for(const u of s)this.stateSpec.push(new Ss({shape:u.shape}));i=i.concat(this.stateSpec)}if(r!=null&&(n.constants=r,a=a.concat(r),this.numConstants=r.length),a[0]instanceof Ga){const u=[e].concat(a),c=this.inputSpec.concat(i),d=this.inputSpec;this.inputSpec=c;const f=super.apply(u,n);return this.inputSpec=d,f}else return super.apply(e,n)}call(e,n){return Le(()=>{const s=n==null?null:n.mask,r=n==null?null:n.training;let o=n==null?null:n.initialState;e=jt(e),o==null&&(this.stateful?o=this.states_:o=this.getInitialState(e));const a=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(o.length!==a)throw new Ie(`RNN Layer has ${a} state(s) but was passed ${o.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");const i={training:r},u=XW((p,m)=>{const g=this.cell.call([p].concat(m),i);return[g[0],g.slice(1)]},e,o,this.goBackwards,s,null,this.unroll,this.returnSequences),c=u[0],d=u[1],f=u[2];this.stateful&&this.resetStates(f,r);const h=this.returnSequences?d:c;return this.returnState?[h].concat(f):h})}getInitialState(e){return Le(()=>{let n=xs(e.shape);return n=kt(n,[1,2]),n=f2(n),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(s=>s>1?Ex(n,[1,s]):n):this.cell.stateSize>1?[Ex(n,[1,this.cell.stateSize])]:[n]})}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.cell!=null&&this.cell.setFastWeightInitDuringBuild(e)}getConfig(){const e=super.getConfig(),n={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};this.numConstants!=null&&(n.numConstants=this.numConstants);const s=this.cell.getConfig();return this.getClassName()===ci.className&&(n.cell={className:this.cell.getClassName(),config:s}),Object.assign(Object.assign(Object.assign({},s),e),n)}static fromConfig(e,n,s={}){const r=n.cell,o=Xa(r,s);return new e(Object.assign(n,{cell:o}))}}ci.className="RNN";tt(ci);class w2 extends cn{}class U3 extends w2{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,Hs(this.units,"units"),this.activation=ec(e.activation==null?this.DEFAULT_ACTIVATION:e.activation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=as(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=as(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=as(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=is(e.kernelRegularizer),this.recurrentRegularizer=is(e.recurrentRegularizer),this.biasRegularizer=is(e.biasRegularizer),this.kernelConstraint=Ms(e.kernelConstraint),this.recurrentConstraint=Ms(e.recurrentConstraint),this.biasConstraint=Ms(e.biasConstraint),this.dropout=Ih([1,Ju([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=Ih([1,Ju([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=Cn(e),this.kernel=this.addWeight("kernel",[e[e.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,n){return Le(()=>{if(e=e,e.length!==2)throw new Ie(`SimpleRNNCell expects 2 input Tensors, got ${e.length}.`);let s=e[1];e=e[0];const r=n.training==null?!1:n.training;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=tc({ones:()=>So(e),rate:this.dropout,training:r,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=tc({ones:()=>So(s),rate:this.recurrentDropout,training:r,dropoutFunc:this.dropoutFunc}));let o;const a=this.dropoutMask,i=this.recurrentDropoutMask;a!=null?o=Mi(Te(e,a),this.kernel.read()):o=Mi(e,this.kernel.read()),this.bias!=null&&(o=ui(o,this.bias.read())),i!=null&&(s=Te(s,i));let l=st(o,Mi(s,this.recurrentKernel.read()));return this.activation!=null&&(l=this.activation.apply(l)),[l,l]})}getConfig(){const e=super.getConfig(),n={units:this.units,activation:Qu(this.activation),useBias:this.useBias,kernelInitializer:cs(this.kernelInitializer),recurrentInitializer:cs(this.recurrentInitializer),biasInitializer:cs(this.biasInitializer),kernelRegularizer:zn(this.kernelRegularizer),recurrentRegularizer:zn(this.recurrentRegularizer),biasRegularizer:zn(this.biasRegularizer),activityRegularizer:zn(this.activityRegularizer),kernelConstraint:Fs(this.kernelConstraint),recurrentConstraint:Fs(this.recurrentConstraint),biasConstraint:Fs(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign(Object.assign({},e),n)}}U3.className="SimpleRNNCell";tt(U3);class wN extends ci{constructor(e){e.cell=new U3(e),super(e)}call(e,n){return Le(()=>{this.cell.dropoutMask!=null&&(Xt(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Xt(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const s=n==null?null:n.mask,r=n==null?null:n.training,o=n==null?null:n.initialState;return super.call(e,{mask:s,training:r,initialState:o})})}static fromConfig(e,n){return new e(n)}}wN.className="SimpleRNN";tt(wN);class G3 extends w2{constructor(e){if(super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.resetAfter)throw new Ie("GRUCell does not support reset_after parameter set to true.");this.units=e.units,Hs(this.units,"units"),this.activation=ec(e.activation===void 0?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=ec(e.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=as(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=as(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=as(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=is(e.kernelRegularizer),this.recurrentRegularizer=is(e.recurrentRegularizer),this.biasRegularizer=is(e.biasRegularizer),this.kernelConstraint=Ms(e.kernelConstraint),this.recurrentConstraint=Ms(e.recurrentConstraint),this.biasConstraint=Ms(e.biasConstraint),this.dropout=Ih([1,Ju([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=Ih([1,Ju([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=Cn(e);const n=e[e.length-1];this.kernel=this.addWeight("kernel",[n,this.units*3],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*3],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units*3],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,n){return Le(()=>{if(e=e,e.length!==2)throw new Ie(`GRUCell expects 2 input Tensors (inputs, h, c), got ${e.length}.`);const s=n.training==null?!1:n.training;let r=e[1];e=e[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=tc({ones:()=>So(e),rate:this.dropout,training:s,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=tc({ones:()=>So(r),rate:this.recurrentDropout,training:s,count:3,dropoutFunc:this.dropoutFunc}));const o=this.dropoutMask,a=this.recurrentDropoutMask;let i,l,u;0<this.dropout&&this.dropout<1&&(e=Te(e,o[0]));let c=Mi(e,this.kernel.read());this.useBias&&(c=ui(c,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(r=Te(r,a[0]));const d=this.recurrentKernel.read(),[f,h]=Kr(d,[2*this.units,this.units],d.rank-1),p=Mi(r,f),[m,g,y]=Kr(c,3,c.rank-1),[w,b]=Kr(p,2,p.rank-1);i=this.recurrentActivation.apply(st(m,w)),l=this.recurrentActivation.apply(st(g,b));const _=Mi(Te(l,r),h);u=this.activation.apply(st(y,_));const $=st(Te(i,r),Te(st(1,Jn(i)),u));return[$,$]})}getConfig(){const e=super.getConfig(),n={units:this.units,activation:Qu(this.activation),recurrentActivation:Qu(this.recurrentActivation),useBias:this.useBias,kernelInitializer:cs(this.kernelInitializer),recurrentInitializer:cs(this.recurrentInitializer),biasInitializer:cs(this.biasInitializer),kernelRegularizer:zn(this.kernelRegularizer),recurrentRegularizer:zn(this.recurrentRegularizer),biasRegularizer:zn(this.biasRegularizer),activityRegularizer:zn(this.activityRegularizer),kernelConstraint:Fs(this.kernelConstraint),recurrentConstraint:Fs(this.recurrentConstraint),biasConstraint:Fs(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign(Object.assign({},e),n)}}G3.className="GRUCell";tt(G3);class _N extends ci{constructor(e){e.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new G3(e),super(e)}call(e,n){return Le(()=>{this.cell.dropoutMask!=null&&(Xt(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Xt(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const s=n==null?null:n.mask,r=n==null?null:n.training,o=n==null?null:n.initialState;return super.call(e,{mask:s,training:r,initialState:o})})}static fromConfig(e,n){return n.implmentation===0&&(n.implementation=1),new e(n)}}_N.className="GRU";tt(_N);class _2 extends w2{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,Hs(this.units,"units"),this.activation=ec(e.activation===void 0?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=ec(e.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=as(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=as(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=as(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=e.unitForgetBias,this.kernelRegularizer=is(e.kernelRegularizer),this.recurrentRegularizer=is(e.recurrentRegularizer),this.biasRegularizer=is(e.biasRegularizer),this.kernelConstraint=Ms(e.kernelConstraint),this.recurrentConstraint=Ms(e.recurrentConstraint),this.biasConstraint=Ms(e.biasConstraint),this.dropout=Ih([1,Ju([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=Ih([1,Ju([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){var n;e=Cn(e);const s=e[e.length-1];this.kernel=this.addWeight("kernel",[s,this.units*4],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*4],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint);let r;if(this.useBias){if(this.unitForgetBias){const o=this.biasInitializer,a=this.units;r=new(n=class extends Ia{apply(l,u){const c=o.apply([a]),d=new O3().apply([a]),f=o.apply([a*2]);return lD(lD(c,d),f)}},n.className="CustomInit",n)}else r=this.biasInitializer;this.bias=this.addWeight("bias",[this.units*4],null,r,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(e,n){return Le(()=>{const s=n.training==null?!1:n.training;if(e=e,e.length!==3)throw new Ie(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let r=e[1];const o=e[2];e=e[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=tc({ones:()=>So(e),rate:this.dropout,training:s,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=tc({ones:()=>So(r),rate:this.recurrentDropout,training:s,count:4,dropoutFunc:this.dropoutFunc}));const a=this.dropoutMask,i=this.recurrentDropoutMask;let l,u,c,d;0<this.dropout&&this.dropout<1&&(e=Te(e,a[0]));let f=Mi(e,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(r=Te(r,i[0])),f=st(f,Mi(r,this.recurrentKernel.read())),this.useBias&&(f=ui(f,this.bias.read()));const[h,p,m,g]=Kr(f,4,f.rank-1);l=this.recurrentActivation.apply(h),u=this.recurrentActivation.apply(p),c=st(Te(u,o),Te(l,this.activation.apply(m))),d=this.recurrentActivation.apply(g);const y=Te(d,this.activation.apply(c));return[y,y,c]})}getConfig(){const e=super.getConfig(),n={units:this.units,activation:Qu(this.activation),recurrentActivation:Qu(this.recurrentActivation),useBias:this.useBias,kernelInitializer:cs(this.kernelInitializer),recurrentInitializer:cs(this.recurrentInitializer),biasInitializer:cs(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:zn(this.kernelRegularizer),recurrentRegularizer:zn(this.recurrentRegularizer),biasRegularizer:zn(this.biasRegularizer),activityRegularizer:zn(this.activityRegularizer),kernelConstraint:Fs(this.kernelConstraint),recurrentConstraint:Fs(this.recurrentConstraint),biasConstraint:Fs(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign(Object.assign({},e),n)}}_2.className="LSTMCell";tt(_2);class $N extends ci{constructor(e){e.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new _2(e),super(e)}call(e,n){return Le(()=>{this.cell.dropoutMask!=null&&(Xt(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Xt(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const s=n==null?null:n.mask,r=n==null?null:n.training,o=n==null?null:n.initialState;return super.call(e,{mask:s,training:r,initialState:o})})}static fromConfig(e,n){return n.implmentation===0&&(n.implementation=1),new e(n)}}$N.className="LSTM";tt($N);class j3 extends w2{constructor(e){super(e),this.cells=e.cells}get stateSize(){const e=[];for(const n of this.cells.slice().reverse())Array.isArray(n.stateSize)?e.push(...n.stateSize):e.push(n.stateSize);return e}call(e,n){return Le(()=>{e=e;let s=e.slice(1);const r=[];for(const i of this.cells.slice().reverse())Array.isArray(i.stateSize)?r.push(s.splice(0,i.stateSize.length)):r.push(s.splice(0,1));r.reverse();const o=[];let a;for(let i=0;i<this.cells.length;++i){const l=this.cells[i];s=r[i],i===0?a=[e[0]].concat(s):a=[a[0]].concat(s),a=l.call(a,n),o.push(a.slice(1))}s=[];for(const i of o.slice().reverse())s.push(...i);return[a[0]].concat(s)})}build(e){Ox(e)&&(e=e[0]),e=e;let n;this.cells.forEach((s,r)=>{dd(`RNNCell_${r}`,()=>{s.build(e),Array.isArray(s.stateSize)?n=s.stateSize[0]:n=s.stateSize,e=[e[0],n]})}),this.built=!0}getConfig(){const e=super.getConfig(),n=o=>({className:o.getClassName(),config:o.getConfig()}),r={cells:this.cells.map(n)};return Object.assign(Object.assign({},e),r)}static fromConfig(e,n,s={}){const r=[];for(const o of n.cells)r.push(Xa(o,s));return new e({cells:r})}get trainableWeights(){if(!this.trainable)return[];const e=[];for(const n of this.cells)e.push(...n.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const n of this.cells)e.push(...n.nonTrainableWeights);if(!this.trainable){const n=[];for(const s of this.cells)n.push(...s.trainableWeights);return n.concat(e)}return e}getWeights(){const e=[];for(const n of this.cells)e.push(...n.weights);return Rx(e)}setWeights(e){const n=[];for(const s of this.cells){const r=s.weights.length,o=e.splice(r);for(let a=0;a<s.weights.length;++a)n.push([s.weights[a],o[a]])}XT(n)}}j3.className="StackedRNNCells";tt(j3);function tc(t){const{ones:e,rate:n,training:s=!1,count:r=1,dropoutFunc:o}=t,a=()=>o!=null?o(e(),n):cW(e(),n),i=()=>p2(a,e,s);return!r||r<=1?As(i().clone()):Array(r).fill(void 0).map(i).map(u=>As(u.clone()))}var amt=globalThis&&globalThis.__rest||function(t,e){var n={};for(var s in t)Object.prototype.hasOwnProperty.call(t,s)&&e.indexOf(s)<0&&(n[s]=t[s]);if(t!=null&&typeof Object.getOwnPropertySymbols=="function")for(var r=0,s=Object.getOwnPropertySymbols(t);r<s.length;r++)e.indexOf(s[r])<0&&Object.prototype.propertyIsEnumerable.call(t,s[r])&&(n[s[r]]=t[s[r]]);return n};class YW extends ci{constructor(e){if(e.unroll)throw new Jt("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(e.cell))throw new Jt("It is not possible at the moment to stack convolutional cells.");super(e),this.inputSpec=[new Ss({ndim:5})]}call(e,n){return Le(()=>{if(this.cell.dropoutMask!=null&&(Xt(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Xt(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),n&&n.constants)throw new Ie("ConvRNN2D cell does not support constants");const s=n==null?null:n.mask,r=n==null?null:n.training,o=n==null?null:n.initialState;return super.call(e,{mask:s,training:r,initialState:o})})}computeOutputShape(e){let n=this.computeSingleOutputShape(e);return this.returnSequences||(n=[n[0],...n.slice(2)]),this.returnState&&(n=[n,...Array(2).fill([e[0],...n.slice(-3)])]),n}getInitialState(e){return Le(()=>{const{stateSize:n}=this.cell,s=e.shape,r=this.computeSingleOutputShape(s),o=[r[0],...r.slice(2)],a=xs(o);return Array.isArray(n)?Array(n.length).fill(a):[a]})}resetStates(e,n=!1){Le(()=>{if(!this.stateful)throw new mi("Cannot call resetStates() on an RNN Layer that is not stateful.");const s=this.inputSpec[0].shape,r=this.computeSingleOutputShape(s),o=[r[0],...r.slice(2)];if(s[0]==null)throw new Ie("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.getStates()==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>xs(o)):this.states_=[xs(o)];else if(e==null)Xt(this.states_),this.keptStates!=null&&(Xt(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>xs(o)):this.states_[0]=xs(o);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new Ie(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);n?this.keptStates.push(this.states_.slice()):Xt(this.states_);for(let i=0;i<this.states_.length;++i){const l=e[i],u=o;if(!hn(l.shape,u))throw new Ie(`State ${i} is incompatible with layer ${this.name}: expected shape=${u}, received shape=${l.shape}`);this.states_[i]=l}}this.states_=this.states_.map(i=>As(i.clone()))})}computeSingleOutputShape(e){const{dataFormat:n,filters:s,kernelSize:r,padding:o,strides:a,dilationRate:i}=this.cell,l=n==="channelsFirst",u=e[l?3:2],c=e[l?4:3],d=Ya(u,r[0],o,a[0],i[0]),f=Ya(c,r[1],o,a[1],i[1]);return[...e.slice(0,2),...l?[s,d,f]:[d,f,s]]}}YW.className="ConvRNN2D";class K3 extends _2{constructor(e){const{filters:n,kernelSize:s,strides:r,padding:o,dataFormat:a,dilationRate:i}=e;super(Object.assign(Object.assign({},e),{units:n})),this.filters=n,Hs(this.filters,"filters"),this.kernelSize=Jf(s,2,"kernelSize"),this.kernelSize.forEach(l=>Hs(l,"kernelSize")),this.strides=Jf(r||1,2,"strides"),this.strides.forEach(l=>Hs(l,"strides")),this.padding=o||"valid",Jo(this.padding),this.dataFormat=a||"channelsLast",ws(this.dataFormat),this.dilationRate=Jf(i||1,2,"dilationRate"),this.dilationRate.forEach(l=>Hs(l,"dilationRate"))}build(e){var n;e=Cn(e);const s=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[s]==null)throw new Ie(`The channel dimension of the input should be defined. Found ${e[s]}`);const r=e[s],o=4,a=this.kernelSize.concat([r,this.filters*o]);this.kernel=this.addWeight("kernel",a,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);const i=this.kernelSize.concat([this.filters,this.filters*o]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",i,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let l;if(this.unitForgetBias){const u=this.biasInitializer,c=this.filters;l=new(n=class extends Ia{apply(f,h){const p=u.apply([c]),m=po([c]),g=u.apply([c*2]);return VT([p,m,g])}},n.className="CustomInit",n)}else l=this.biasInitializer;this.bias=this.addWeight("bias",[this.filters*o],null,l,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(e,n){return Le(()=>{if(e.length!==3)throw new Ie(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);const s=n.training||!1,r=e[0],o=e[1],a=e[2],i=4;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=tc({ones:()=>So(r),rate:this.dropout,training:s,count:i,dropoutFunc:this.dropoutFunc}));const l=this.dropoutMask,u=(G,Z,j)=>!Z||!Z[j]?G:Te(Z[j],G);let c=u(r,l,0),d=u(r,l,1),f=u(r,l,2),h=u(r,l,3);0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=tc({ones:()=>So(o),rate:this.recurrentDropout,training:s,count:i,dropoutFunc:this.dropoutFunc}));const p=this.recurrentDropoutMask;let m=u(o,p,0),g=u(o,p,1),y=u(o,p,2),w=u(o,p,3);const b=3,[_,$,x,k]=Kr(this.kernel.read(),i,b),[C,T,N,M]=this.useBias?Kr(this.bias.read(),i):[null,null,null,null];c=this.inputConv(c,_,C,this.padding),d=this.inputConv(d,$,T,this.padding),f=this.inputConv(f,x,N,this.padding),h=this.inputConv(h,k,M,this.padding);const[R,D,z,B]=Kr(this.recurrentKernel.read(),i,b);m=this.recurrentConv(m,R),g=this.recurrentConv(g,D),y=this.recurrentConv(y,z),w=this.recurrentConv(w,B);const V=this.recurrentActivation.apply(st(c,m)),O=this.recurrentActivation.apply(st(d,g)),F=st(Te(O,a),Te(V,this.activation.apply(st(f,y)))),L=Te(this.recurrentActivation.apply(st(h,w)),this.activation.apply(F));return[L,L,F]})}getConfig(){const e=super.getConfig(),n=amt(e,["units"]),s={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign(Object.assign({},n),s)}inputConv(e,n,s,r){const o=Al(e,n,this.strides,r||"valid",this.dataFormat==="channelsFirst"?"NCHW":"NHWC",this.dilationRate);return s?ui(o,s,this.dataFormat):o}recurrentConv(e,n){return Al(e,n,1,"same",this.dataFormat==="channelsFirst"?"NCHW":"NHWC")}}K3.className="ConvLSTM2DCell";tt(K3);class xN extends YW{constructor(e){const n=new K3(e);super(Object.assign(Object.assign({},e),{cell:n}))}static fromConfig(e,n){return new e(n)}}xN.className="ConvLSTM2D";tt(xN);class q3 extends cn{constructor(e){super(e),this.rate=Math.max(Math.min(e.rate,1),0),this.noiseShape=e.noiseShape,this.seed=e.seed,this.supportsMasking=!0}getNoiseShape(e){if(this.noiseShape==null)return this.noiseShape;const n=e.shape,s=[];for(let r=0;r<this.noiseShape.length;++r)s.push(this.noiseShape[r]==null?n[r]:this.noiseShape[r]);return s}call(e,n){return Le(()=>{this.invokeCallHook(e,n);const s=jt(e);if(0<this.rate&&this.rate<1){const r=n.training==null?!1:n.training,o=this.getNoiseShape(s);return p2(()=>cW(s,this.rate,o,this.seed),()=>s,r)}return e})}getConfig(){const e={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},n=super.getConfig();return Object.assign(e,n),e}dispose(){return super.dispose()}}q3.className="Dropout";tt(q3);class SN extends q3{constructor(e){super(e),this.inputSpec=[{ndim:3}]}getNoiseShape(e){const n=e.shape;return[n[0],1,n[2]]}}SN.className="SpatialDropout1D";tt(SN);class CN extends cn{constructor(e){if(super(e),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.batchInputShape==null&&e.inputShape==null&&e.inputDim!=null){let n=null;e.batchSize!=null&&(n=e.batchSize),this.batchInputShape=[n,e.inputDim]}this.units=e.units,Hs(this.units,"units"),this.activation=ec(e.activation),e.useBias!=null&&(this.useBias=e.useBias),this.kernelInitializer=as(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=as(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=Ms(e.kernelConstraint),this.biasConstraint=Ms(e.biasConstraint),this.kernelRegularizer=is(e.kernelRegularizer),this.biasRegularizer=is(e.biasRegularizer),this.activityRegularizer=is(e.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(e){e=Cn(e);const n=e[e.length-1];this.kernel==null&&(this.kernel=this.addWeight("kernel",[n,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:n}}],this.built=!0}computeOutputShape(e){e=Cn(e);const n=e.slice();return n[n.length-1]=this.units,n}call(e,n){return Le(()=>{this.invokeCallHook(e,n);const s=jt(e),r=sW(this.activation.getClassName());let o;return r!=null?o=Mi(s,this.kernel.read(),r,this.bias?this.bias.read():null):(o=Mi(s,this.kernel.read()),this.bias!=null&&(o=ui(o,this.bias.read())),this.activation!=null&&(o=this.activation.apply(o))),o})}getConfig(){const e={units:this.units,activation:Qu(this.activation),useBias:this.useBias,kernelInitializer:cs(this.kernelInitializer),biasInitializer:cs(this.biasInitializer),kernelRegularizer:zn(this.kernelRegularizer),biasRegularizer:zn(this.biasRegularizer),activityRegularizer:zn(this.activityRegularizer),kernelConstraint:Fs(this.kernelConstraint),biasConstraint:Fs(this.biasConstraint)},n=super.getConfig();return Object.assign(e,n),e}}CN.className="Dense";tt(CN);class kN extends cn{constructor(e){e=e||{},super(e),this.inputSpec=[{minNDim:3}],this.dataFormat=e.dataFormat}computeOutputShape(e){e=Cn(e);for(const n of e.slice(1))if(n==null)throw new Ie(`The shape of the input to "Flatten" is not fully defined (got ${e.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[e[0],Lu(e,1)]}call(e,n){return Le(()=>{this.invokeCallHook(e,n);let s=jt(e);if(this.dataFormat==="channelsFirst"&&s.rank>1){const r=[0];for(let o=2;o<s.rank;++o)r.push(o);r.push(1),s=dn(s,r)}return _ht(s)})}getConfig(){const e={};this.dataFormat!=null&&(e.dataFormat=this.dataFormat);const n=super.getConfig();return Object.assign(e,n),e}}kN.className="Flatten";tt(kN);class TN extends cn{constructor(e){super(e),this.supportsMasking=!0,this.activation=ec(e.activation)}call(e,n){return Le(()=>{this.invokeCallHook(e,n);const s=jt(e);return this.activation.apply(s)})}getConfig(){const e={activation:Qu(this.activation)},n=super.getConfig();return Object.assign(e,n),e}}TN.className="Activation";tt(TN);class NN extends cn{constructor(e){super(e),this.n=e.n,this.inputSpec=[{ndim:2}]}computeOutputShape(e){return[e[0],this.n,e[1]]}call(e,n){return Le(()=>(e=jt(e),bht(e,this.n)))}getConfig(){const e={n:this.n},n=super.getConfig();return Object.assign(e,n),e}}NN.className="RepeatVector";tt(NN);let IN=class extends cn{constructor(e){super(e),this.targetShape=e.targetShape;for(let n=0;n<this.targetShape.length;++n)this.isUnknown(this.targetShape[n])&&(this.targetShape[n]=null)}isUnknown(e){return e<0||e==null}fixUnknownDimension(e,n){const s="Total size of new array must be unchanged.",r=n.slice();let o=1,a=null;for(let l=0;l<r.length;++l){const u=r[l];if(this.isUnknown(u))if(a===null)a=l;else throw new Ie("Can only specifiy one unknown dimension.");else o*=u}const i=Lu(e);if(a!==null){if(o===0||i%o!==0)throw new Ie(s);r[a]=i/o}else if(i!==o)throw new Ie(s);return r}computeOutputShape(e){let n=!1;for(let s=0;s<e.length;++s)if(this.isUnknown(e[s])){n=!0;break}return n?e.slice(0,1).concat(this.targetShape):e.slice(0,1).concat(this.fixUnknownDimension(e.slice(1),this.targetShape))}call(e,n){return Le(()=>{this.invokeCallHook(e,n);const s=jt(e),r=s.shape,o=r.slice(0,1).concat(this.fixUnknownDimension(r.slice(1),this.targetShape));return Ne(s,o)})}getConfig(){const e={targetShape:this.targetShape},n=super.getConfig();return Object.assign(e,n),e}};IN.className="Reshape";tt(IN);class EN extends cn{constructor(e){if(super(e),e.dims==null)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(e.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${e.dims} instead.`);const n=ti(1,e.dims.length+1);if(!hn(e.dims.slice().sort(),n))throw new Error("Invalid permutation `dims`: "+JSON.stringify(e.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=e.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new Ss({ndim:this.dims.length+1})]}computeOutputShape(e){e=Cn(e);const n=e.slice();return this.dims.forEach((s,r)=>{n[r+1]=e[s]}),n}call(e,n){return dn(jt(e),this.dimsIncludingBatch)}getConfig(){const e={dims:this.dims},n=super.getConfig();return Object.assign(e,n),e}}EN.className="Permute";tt(EN);class AN extends cn{constructor(e){super(e??{}),this.supportsMasking=!0,e!=null?this.maskValue=e.maskValue==null?0:e.maskValue:this.maskValue=0}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),n={maskValue:this.maskValue};return Object.assign(n,e),n}computeMask(e,n){const s=jt(e),r=-1;return sg(Dd(s,this.maskValue),r)}call(e,n){return Le(()=>{this.invokeCallHook(e,n);const s=jt(e),r=-1,o=!0,a=sg(Dd(s,this.maskValue),r,o);return Te(s,ht(a,s.dtype))})}}AN.className="Masking";tt(AN);class ON extends cn{constructor(e){if(super(e),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",e.batchInputShape==null&&e.inputShape==null){let n=null;e.batchSize!=null&&(n=e.batchSize),e.inputLength==null?this.batchInputShape=[n,null]:this.batchInputShape=[n].concat(qn(e.inputLength))}this.inputDim=e.inputDim,Hs(this.inputDim,"inputDim"),this.outputDim=e.outputDim,Hs(this.outputDim,"outputDim"),this.embeddingsInitializer=as(e.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=is(e.embeddingsRegularizer),this.activityRegularizer=is(e.activityRegularizer),this.embeddingsConstraint=Ms(e.embeddingsConstraint),this.maskZero=e.maskZero,this.supportsMasking=e.maskZero,this.inputLength=e.inputLength}build(e){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(e){}computeMask(e,n){return Le(()=>this.maskZero?(e=jt(e),Dd(e,yn(e))):null)}computeOutputShape(e){if(e=Cn(e),this.inputLength==null)return[...e,this.outputDim];const n=qn(this.inputLength);if(n.length!==e.length-1)throw new Ie(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);{let s=0;for(let r=0;r<n.length;++r){const o=n[r],a=e[r+1];if(o!=null&&a!=null&&o!==a)throw new Ie(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);o==null&&(n[s]=a),s++}}return[e[0],...n,this.outputDim]}call(e,n){return Le(()=>{this.invokeCallHook(e,n);let s=jt(e);s.dtype!=="int32"&&(s=Fi(s,"int32"));const r=uW(this.embeddings.read(),Ne(s,[s.size]));return Ne(r,Cn(this.computeOutputShape(s.shape)))})}getConfig(){const e={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:cs(this.embeddingsInitializer),embeddingsRegularizer:zn(this.embeddingsRegularizer),activityRegularizer:zn(this.activityRegularizer),embeddingsConstraint:Fs(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},n=super.getConfig();return Object.assign(e,n),e}}ON.className="Embedding";tt(ON);class ff extends cn{constructor(e){super(e||{}),this.supportsMasking=!0}mergeFunction(e){throw new Jt}computeElementwiseOpOutputShape(e,n){if(e==null||n==null)return null;if(e.length<n.length)return this.computeElementwiseOpOutputShape(n,e);if(n.length===0)return e;const s=e.slice(0,e.length-n.length);for(let r=0;r<n.length;++r){const o=e[e.length-n.length+r],a=n[r];if(o==null||a==null||o<0||a<0)s.push(null);else if(o===1)s.push(a);else if(a===1)s.push(o);else{if(o!==a)throw new Ie("Operands could not be broadcast together with shapes "+JSON.stringify(e)+" "+JSON.stringify(n));s.push(o)}}return s}build(e){if(Array.isArray(e)&&!Array.isArray(e[0])&&(e=[Cn(e)]),e=e,e.length<2)throw new Ie(`A merge layer should be called on an Array of at least 2 inputs. Got ${e.length} input(s).`);let n=[];for(const o of e)o!=null&&o[0]!==null&&n.push(o[0]);if(n=Pu(n),n.length>1)throw new Ie(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(e)}.`);let s=e[0]==null?null:e[0].slice(1);for(let o=1;o<e.length;++o){const a=e[o]==null?null:e[o].slice(1);s=this.computeElementwiseOpOutputShape(s,a)}const r=e.map(o=>o.length);e.indexOf(null)===-1&&Pu(r).length===1?this.reshapeRequired=!1:this.reshapeRequired=!0}call(e,n){return Le(()=>{if(e=e,this.reshapeRequired){const s=[],r=e.map(o=>o.rank);if(r.indexOf(null)===-1){const o=Ju(r);for(let a of e){const i=a.rank;for(let l=0;l<o-i;++l)a=f2(a,1);s.push(a)}return this.mergeFunction(s)}else{let o=!1;for(const l of e){const u=l.rank;if(u==null){const c=l.shape,d=c[0],f=c.slice(1).concat([d]);let h=Ne(l,[d].concat(Lu(c.slice(1))));h=dn(h,[1,0]),h=Ne(h,f),s.push(h),o=!0}else if(u>1){const c=ti(1,u).concat([0]);s.push(dn(l,c)),o=!0}else s.push(l)}let a=this.mergeFunction(s);const i=a.rank;if(o){if(i==null){const l=a.shape,u=l.length,c=l[u-1],d=[c].concat(l.slice(0,l.length-1));a=Ne(dn(Ne(a,[-1,c]),[1,0]),d)}else if(i>1){const l=[i-1].concat(ti(0,i-1));a=dn(a,l)}}return a}}else return this.mergeFunction(e)})}computeOutputShape(e){e=e;let n;e[0]==null?n=null:n=e[0].slice(1);for(let r=1;r<e.length;++r){const o=e[r]==null?null:e[r].slice(1);n=this.computeElementwiseOpOutputShape(n,o)}let s=[];for(const r of e)r!=null&&r[0]!==null&&s.push(r[0]);return s=Pu(s),s.length===1?n=s.concat(n):n=[null].concat(n),n}computeMask(e,n){return Le(()=>{if(n==null)return null;if(!Array.isArray(n))throw new Ie("`mask` should be an Array");if(!Array.isArray(e))throw new Ie("`inputs` should be an Array");if(n.length!==e.length)throw new Ie(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${e.length} vs ${n.length})`);if(n.every(r=>r==null))return null;n=n.map(r=>r==null?r:hr(r,0));let s=n[0];for(let r=1;r<n.length-1;++r)s=Ta(s,n[r]);return s})}}let RN=class extends ff{constructor(e){super(e)}mergeFunction(e){return Le(()=>{let n=e[0].clone();for(let s=1;s<e.length;++s)n=st(n,e[s]);return n})}};RN.className="Add";tt(RN);let DN=class extends ff{constructor(e){super(e)}mergeFunction(e){return Le(()=>{let n=e[0].clone();for(let s=1;s<e.length;++s)n=Te(n,e[s]);return n})}};DN.className="Multiply";tt(DN);class FN extends ff{constructor(e){super(e)}mergeFunction(e){return Le(()=>{let n=e[0].clone();for(let s=1;s<e.length;++s)n=st(n,e[s]);return Te(1/e.length,n)})}}FN.className="Average";tt(FN);let MN=class extends ff{constructor(e){super(e)}mergeFunction(e){return Le(()=>{let n=e[0];for(let s=1;s<e.length;++s)n=Zi(n,e[s]);return n})}};MN.className="Maximum";tt(MN);let PN=class extends ff{constructor(e){super(e)}mergeFunction(e){return Le(()=>{let n=e[0];for(let s=1;s<e.length;++s)n=om(n,e[s]);return n})}};PN.className="Minimum";tt(PN);class LN extends ff{constructor(e){super(e),this.DEFAULT_AXIS=-1,e==null&&(e={}),this.axis=e.axis==null?this.DEFAULT_AXIS:e.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){if(!(Array.isArray(e)&&Array.isArray(e[0]))||e.length===1)throw new Ie("A `Concatenate` layer should be called on a list of at least 2 inputs");e=e;let n=!0;for(const r of e)if(r!=null){n=!1;break}if(n)return;const s=[];for(let r=0;r<e.length;++r){const o=e[r].slice();o.splice(this.axis,1);let a=!1;for(const i of s)if(hn(i,o)){a=!0;break}a||s.push(o)}if(s.length>1)throw new Ie("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(e))}mergeFunction(e){return Le(()=>VT(e,this.axis))}computeOutputShape(e){if(!(Array.isArray(e)&&Array.isArray(e[0])))throw new Ie("A `Concatenate` layer should be called on a list of inputs.");const n=e,s=n[0].slice(),r=this.axis<0?s.length+this.axis:this.axis;for(const o of n.slice(1)){if(s[r]==null||o[r]==null){s[r]=null;break}s[r]+=o[r]}return s}computeMask(e,n){if(n==null)return null;if(!Array.isArray(n))throw new Ie("`mask` should be an array for Concatenate");if(!Array.isArray(e))throw new Ie("`inputs` should be an array for Concatenate");if(n.length!==e.length)throw new Ie(`Mismatch in the length of mask (${n.length}) and the legnth of inputs (${e.length})`);return Le(()=>{let s=!0;if(n.forEach(a=>{if(a!=null){s=!1;return}}),s)return null;const r=[];for(let a=0;a<e.length;++a)n[a]==null?r.push(ht(So(e[a]),"bool")):n[a].rank<e[a].rank?r.push(hr(n[a],-1)):r.push(n[a]);const o=vs(r,this.axis);return V_(o,-1,!1)})}getConfig(){const e={axis:this.axis},n=super.getConfig();return Object.assign(e,n),e}}LN.className="Concatenate";tt(LN);function Mm(t,e){for(;t<0;)t+=e;return t}function imt(t,e,n){if(t.shape.length>3||e.shape.length>3)throw new Jt("batchDot is not implemented for tensors of 4D or higher rank yet");if(q(t.shape.length>=2,()=>`batchDot requires the rank of x to be >= 2, but got ${t.shape.length}`),q(t.shape.length>=2,()=>`batchDot requires the rank of y to be >= 2, but got ${e.shape.length}`),typeof n=="number"&&(n=[n,n]),t.dtype==="complex64"||e.dtype==="complex64")throw new Jt("batchDot is not implemented for complex64-type Tensors yet.");const s=t.shape.length,r=e.shape.length;n==null&&(n=[s-1,r-2]);const o=n;return Le(()=>{let a;if(s>r){a=s-r;const l=[];for(let u=0;u<a;++u)l.push(1);e=Ne(e,e.shape.concat(l))}else if(r>s){a=r-s;const l=[];for(let u=0;u<a;++u)l.push(1);t=Ne(t,t.shape.concat(l))}else a=0;let i;if(t.shape.length===2&&e.shape.length===2)o[0]===o[1]?i=kt(Te(t,e),o[0]):i=kt(Te(dn(t,[1,0]),e),o[1]);else{const l=o[0]!==t.shape.length-1,u=o[1]===e.shape.length-1;i=ln(t,e,l,u)}if(a>0){let l;s>r?l=s+r-3:l=s-1;const u=[];for(let c=l;c<l+a;++c)u.push(c);i=gc(i,u)}return i.shape.length===1&&(i=hr(i,1)),i})}class zN extends ff{constructor(e){super(e),this.axes=e.axes,this.normalize=e.normalize==null?!1:e.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){q(Array.isArray(e)&&e.length===2&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const n=e[0],s=e[1];if(n.length>3||s.length>3)throw new Jt("Dot layer does not support tensors of 4D or higher rank yet.");const r=this.interpretAxes(n,s);if(n[r[0]]!==s[r[1]])throw new Ie(`Dimension incompatibility: ${n[r[0]]} !== ${s[r[1]]}`)}mergeFunction(e){if(e.length!==2)throw new Ie(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${e.length} input(s).`);let n=e[0],s=e[1],r;return Array.isArray(this.axes)?r=this.axes.map((o,a)=>Mm(o,e[a].shape.length)):r=[Mm(this.axes,n.shape.length),Mm(this.axes,s.shape.length)],this.normalize&&(n=cb(n,r[0]),s=cb(s,r[1])),imt(n,s,r)}interpretAxes(e,n){let s;return Array.isArray(this.axes)?s=this.axes:s=[Mm(this.axes,e.length),Mm(this.axes,n.length)],s}computeOutputShape(e){q(Array.isArray(e)&&e.length===2&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const n=e[0].slice(),s=e[1].slice();if(n.length>3||s.length>3)throw new Jt("Dot layer does not support tensors of 4D or higher rank yet.");const r=this.interpretAxes(n,s);n.splice(r[0],1),s.splice(r[1],1),s.splice(0,1);const o=n.concat(s);return o.length===1&&o.push(1),o}computeMask(e,n){return null}getConfig(){const e={axes:this.axes,normalize:this.normalize},n=super.getConfig();return Object.assign(e,n),e}}zN.className="Dot";tt(zN);class BN extends cn{constructor(e){super(e),this.supportsMasking=!0,this.stddev=e.stddev}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),n={stddev:this.stddev};return Object.assign(n,e),n}call(e,n){return Le(()=>{this.invokeCallHook(e,n);const s=jt(e);return p2(()=>st(A3(s.shape,0,this.stddev),s),()=>s,n.training||!1)})}}BN.className="GaussianNoise";tt(BN);class VN extends cn{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),n={rate:this.rate};return Object.assign(n,e),n}call(e,n){return Le(()=>{this.invokeCallHook(e,n);const s=jt(e);return this.rate>0&&this.rate<1?p2(()=>{const o=Math.sqrt(this.rate/(1-this.rate));return Te(s,A3(s.shape,1,o))},()=>s,n.training||!1):s})}}VN.className="GaussianDropout";tt(VN);class HN extends cn{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate,this.noiseShape=e.noiseShape}_getNoiseShape(e){return this.noiseShape||jt(e).shape}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),n={rate:this.rate};return Object.assign(n,e),n}call(e,n){return Le(()=>{if(this.rate<1&&this.rate>0){const s=this._getNoiseShape(e);return p2(()=>{const o=jt(e),a=1.6732632423543772,i=1.0507009873554805,l=-a*i;let u=Zl(am(s),this.rate);u=Fi(u,"float32");const c=((1-this.rate)*(1+this.rate*l**2))**-.5,d=-c*l*this.rate,f=st(Te(o,u),Te(st(u,-1),l));return st(Te(f,c),d)},()=>jt(e),n.training||!1)}return e})}}HN.className="AlphaDropout";tt(HN);function ig(t,e,n,s,r,o=.001){let a;if(t.rank===2)a=T8(t,e,n,s,r,o);else if(t.rank===3)a=N8(t,e,n,s,r,o);else if(t.rank===4)a=I8(t,e,n,s,r,o);else throw new Jt(`batchNormalization is not implemented for array of rank ${t.rank} yet`);return a}function lmt(t,e,n,s,r=.001){return Le(()=>{const o=Q1(t,s),a=o.mean,i=o.variance;return[ig(t,a,i,n,e,r),a,i]})}function umt(t,e,n,s,r=.001){return Le(()=>{const o=Q1(t,s),a=o.mean,i=o.variance,l=[];for(const p of ti(0,t.rank))s.indexOf(p)!==-1?l.push(1):l.push(t.shape[p]);const u=Ne(a,l),c=Ne(i,l),d=e==null?null:Ne(e,l),f=n==null?null:Ne(n,l);return[ig(t,u,c,f,d,r),a,i]})}function cmt(t,e,n,s,r=.001){return hn(s.slice().sort(),ti(0,t.rank-1))?lmt(t,e,n,s,r):umt(t,e,n,s,r)}class WN extends cn{constructor(e){e==null&&(e={}),super(e),this.supportsMasking=!0,this.axis=e.axis==null?-1:e.axis,this.momentum=e.momentum==null?.99:e.momentum,this.epsilon=e.epsilon==null?.001:e.epsilon,this.center=e.center==null?!0:e.center,this.scale=e.scale==null?!0:e.scale,this.betaInitializer=as(e.betaInitializer||"zeros"),this.gammaInitializer=as(e.gammaInitializer||"ones"),this.movingMeanInitializer=as(e.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=as(e.movingVarianceInitializer||"ones"),this.betaConstraint=Ms(e.betaConstraint),this.gammaConstraint=Ms(e.gammaConstraint),this.betaRegularizer=is(e.betaRegularizer),this.gammaRegularizer=is(e.gammaRegularizer)}build(e){e=Cn(e);const n=this.axis>=0?this.axis:this.axis+e.length,s=e[n];if(s==null)throw new Ie(`Axis ${n} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(e)}.`);this.inputSpec=[new Ss({ndim:e.length,axes:{[n]:s}})];const r=[s];this.scale&&(this.gamma=this.addWeight("gamma",r,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",r,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",r,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",r,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(e,n){return Le(()=>{const s=n.training==null?!1:n.training,r=jt(e),o=r.shape,a=o.length,i=ti(0,a),l=this.axis>=0?this.axis:this.axis+a;i.splice(l,1);const u=Pd(1,a);u[l]=o[l];const c=i.slice();c.sort();const d=!hn(c,ti(0,a).slice(0,a-1)),f=()=>{if(d){const w=Ne(this.movingMean.read(),u),b=Ne(this.movingVariance.read(),u),_=this.center?Ne(this.beta.read(),u):null,$=this.scale?Ne(this.gamma.read(),u):null;return ig(r,w,b,_,$,this.epsilon)}else return ig(r,this.movingMean.read(),this.movingVariance.read(),this.beta==null?null:this.beta.read(),this.gamma==null?null:this.gamma.read(),this.epsilon)};if(!s)return f();const[h,p,m]=cmt(r,this.gamma.read(),this.beta.read(),i,this.epsilon),g=(w,b,_)=>{Le(()=>{const $=1-_,x=w.read(),k=Te($t(x,b),$);w.write($t(x,k))})};return(()=>{g(this.movingMean,p,this.momentum),g(this.movingVariance,m,this.momentum)})(),h})}getConfig(){const e={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:cs(this.betaInitializer),gammaInitializer:cs(this.gammaInitializer),movingMeanInitializer:cs(this.movingMeanInitializer),movingVarianceInitializer:cs(this.movingVarianceInitializer),betaRegularizer:zn(this.betaRegularizer),gammaRegularizer:zn(this.gammaRegularizer),betaConstraint:Fs(this.betaConstraint),gammaConstraint:Fs(this.gammaConstraint)},n=super.getConfig();return Object.assign(e,n),e}}WN.className="BatchNormalization";tt(WN);class UN extends cn{constructor(e){if(e==null&&(e={}),super(e),this.axis=e.axis==null?-1:e.axis,typeof this.axis=="number"){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else if(Array.isArray(this.axis)){for(const n of this.axis)if(!Number.isInteger(n))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}else throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);this.epsilon=e.epsilon==null?.001:e.epsilon,this.center=e.center==null?!0:e.center,this.scale=e.scale==null?!0:e.scale,this.betaInitializer=as(e.betaInitializer||"zeros"),this.gammaInitializer=as(e.gammaInitializer||"ones"),this.betaRegularizer=is(e.betaRegularizer),this.gammaRegularizer=is(e.gammaRegularizer),this.supportsMasking=!0}build(e){e=Cn(e);const n=e.length;typeof this.axis=="number"&&(this.axis=[this.axis]);for(let o=0;o<this.axis.length;++o)this.axis[o]<0&&(this.axis[o]+=n);for(const o of this.axis)if(o<0||o>=n)throw new Error(`Invalid axis: ${o}`);if(this.axis.length!==Pu(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);const s=this.axis.map(o=>e[o]),r=!0;this.scale?this.gamma=this.addWeight("gamma",s,"float32",this.gammaInitializer,this.gammaRegularizer,r):this.gamma=null,this.center?this.beta=this.addWeight("beta",s,"float32",this.betaInitializer,this.betaRegularizer,r):this.beta=null,this.built=!0}call(e,n){const s=jt(e),r=s.shape,o=r.length;return Le(()=>{let{mean:i,variance:l}=Q1(s,this.axis,!0);const u=Pd(1,o);for(const m of this.axis)u[m]=r[m];const c=m=>m!=null&&m.shape.length!==o?Ne(m,u):m;let d=this.scale?c(this.gamma.read()):null,f=this.center?c(this.beta.read()):null;const h=[],p=[];for(let m=0;m<o;++m)this.axis.indexOf(m)!==-1?(h.push(r[m]),p.push(1)):(h.push(1),p.push(r[m]));return i=Lo(i,h),l=Lo(l,h),d!=null&&(d=Lo(d,p)),f!=null&&(f=Lo(f,p)),ig(s,i,l,f,d,this.epsilon)})}getConfig(){const e={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:cs(this.betaInitializer),gammaInitializer:cs(this.gammaInitializer),betaRegularizer:zn(this.betaRegularizer),gammaRegularizer:zn(this.gammaRegularizer)},n=super.getConfig();return Object.assign(e,n),e}}UN.className="LayerNormalization";tt(UN);function dmt(t,e,n){return Le(()=>{if(t.rank!==4)throw new Ie(`temporalPadding expects input tensor to be 4-D, but received a ${t.rank}-D tensor.`);if(e==null&&(e=[[1,1],[1,1]]),e.length!==2||e[0].length!==2||e[1].length!==2)throw new Ie("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(n==null&&(n=ni()),n!=="channelsLast"&&n!=="channelsFirst")throw new Ie(`Unknown data format: ${n}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let s;return n==="channelsFirst"?s=[[0,0],[0,0],e[0],e[1]]:s=[[0,0],e[0],e[1],[0,0]],Jl(t,s)})}class GN extends cn{constructor(e){if(e==null&&(e={}),super(e),this.dataFormat=e.dataFormat==null?ni():e.dataFormat,e.padding==null)this.padding=[[1,1],[1,1]];else if(typeof e.padding=="number")this.padding=[[e.padding,e.padding],[e.padding,e.padding]];else{if(e.padding=e.padding,e.padding.length!==2)throw new Ie(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${e.padding.length} array.`);let n,s;if(typeof e.padding[0]=="number")n=[e.padding[0],e.padding[0]],s=[e.padding[1],e.padding[1]];else{if(e.padding=e.padding,e.padding[0].length!==2)throw new Ie(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${e.padding[0].length} array.`);if(n=e.padding[0],e.padding[1].length!==2)throw new Ie(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${e.padding[1].length} array.`);s=e.padding[1]}this.padding=[n,s]}this.inputSpec=[new Ss({ndim:4})]}computeOutputShape(e){e=Cn(e);let n,s;return this.dataFormat==="channelsFirst"?(e[2]!=null&&e[2]>=0?n=e[2]+this.padding[0][0]+this.padding[0][1]:n=null,e[3]!=null&&e[3]>=0?s=e[3]+this.padding[1][0]+this.padding[1][1]:s=null,[e[0],e[1],n,s]):(e[1]!=null&&e[1]>=0?n=e[1]+this.padding[0][0]+this.padding[0][1]:n=null,e[2]!=null&&e[2]>=0?s=e[2]+this.padding[1][0]+this.padding[1][1]:s=null,[e[0],n,s,e[3]])}call(e,n){return Le(()=>dmt(jt(e),this.padding,this.dataFormat))}getConfig(){const e={padding:this.padding,dataFormat:this.dataFormat},n=super.getConfig();return Object.assign(e,n),e}}GN.className="ZeroPadding2D";tt(GN);function X3(t,e,n,s,r,o){return Le(()=>{ws(r),oW(o),Jo(s),n==null&&(n=[1,1]),s==null&&(s="valid"),r==null&&(r=ni()),o==null&&(o="max"),t=hN(t,r);let a;const i=s==="same"?"same":"valid";return o==="max"?a=J1(t,e,n,i):a=j1(t,e,n,i),r==="channelsFirst"&&(a=dn(a,[0,3,1,2])),a})}function ZW(t,e,n,s,r,o){return Le(()=>{ws(r),oW(o),Jo(s),n==null&&(n=[1,1,1]),s==null&&(s="valid"),r==null&&(r=ni()),o==null&&(o="max"),t=jW(t,r);let a;const i=s==="same"?"same":"valid";return o==="max"?a=Q8(t,e,n,i):a=k8(t,e,n,i),r==="channelsFirst"&&(a=dn(a,[0,4,1,2,3])),a})}class JW extends cn{constructor(e){if(e.poolSize==null&&(e.poolSize=2),super(e),typeof e.poolSize=="number")this.poolSize=[e.poolSize];else if(Array.isArray(e.poolSize)&&e.poolSize.length===1&&typeof e.poolSize[0]=="number")this.poolSize=e.poolSize;else throw new Ie(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.poolSize)}`);if(Hs(this.poolSize,"poolSize"),e.strides==null)this.strides=this.poolSize;else if(typeof e.strides=="number")this.strides=[e.strides];else if(Array.isArray(e.strides)&&e.strides.length===1&&typeof e.strides[0]=="number")this.strides=e.strides;else throw new Ie(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.strides)}`);Hs(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,Jo(this.padding),this.inputSpec=[new Ss({ndim:3})]}computeOutputShape(e){e=Cn(e);const n=Ya(e[1],this.poolSize[0],this.padding,this.strides[0]);return[e[0],n,e[2]]}call(e,n){return Le(()=>{this.invokeCallHook(e,n),e=f2(jt(e),2);const s=this.poolingFunction(jt(e),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return gc(s,[2])})}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides},n=super.getConfig();return Object.assign(e,n),e}}class jN extends JW{constructor(e){super(e)}poolingFunction(e,n,s,r,o){return ws(o),Jo(r),X3(e,n,s,r,o,"max")}}jN.className="MaxPooling1D";tt(jN);class KN extends JW{constructor(e){super(e)}poolingFunction(e,n,s,r,o){return ws(o),Jo(r),X3(e,n,s,r,o,"avg")}}KN.className="AveragePooling1D";tt(KN);class QW extends cn{constructor(e){if(e.poolSize==null&&(e.poolSize=[2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize],e.strides==null)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(e.strides.length!==2)throw new Ie(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides];Hs(this.poolSize,"poolSize"),Hs(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,ws(this.dataFormat),Jo(this.padding),this.inputSpec=[new Ss({ndim:4})]}computeOutputShape(e){e=Cn(e);let n=this.dataFormat==="channelsFirst"?e[2]:e[1],s=this.dataFormat==="channelsFirst"?e[3]:e[2];return n=Ya(n,this.poolSize[0],this.padding,this.strides[0]),s=Ya(s,this.poolSize[1],this.padding,this.strides[1]),this.dataFormat==="channelsFirst"?[e[0],e[1],n,s]:[e[0],n,s,e[3]]}call(e,n){return Le(()=>(this.invokeCallHook(e,n),this.poolingFunction(jt(e),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},n=super.getConfig();return Object.assign(e,n),e}}class qN extends QW{constructor(e){super(e)}poolingFunction(e,n,s,r,o){return ws(o),Jo(r),X3(e,n,s,r,o,"max")}}qN.className="MaxPooling2D";tt(qN);class XN extends QW{constructor(e){super(e)}poolingFunction(e,n,s,r,o){return ws(o),Jo(r),X3(e,n,s,r,o,"avg")}}XN.className="AveragePooling2D";tt(XN);class eU extends cn{constructor(e){if(e.poolSize==null&&(e.poolSize=[2,2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize,e.poolSize],e.strides==null)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(e.strides.length!==3)throw new Ie(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides,e.strides];Hs(this.poolSize,"poolSize"),Hs(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,ws(this.dataFormat),Jo(this.padding),this.inputSpec=[new Ss({ndim:5})]}computeOutputShape(e){e=Cn(e);let n=this.dataFormat==="channelsFirst"?e[2]:e[1],s=this.dataFormat==="channelsFirst"?e[3]:e[2],r=this.dataFormat==="channelsFirst"?e[4]:e[3];return n=Ya(n,this.poolSize[0],this.padding,this.strides[0]),s=Ya(s,this.poolSize[1],this.padding,this.strides[1]),r=Ya(r,this.poolSize[2],this.padding,this.strides[2]),this.dataFormat==="channelsFirst"?[e[0],e[1],n,s,r]:[e[0],n,s,r,e[4]]}call(e,n){return Le(()=>(this.invokeCallHook(e,n),this.poolingFunction(jt(e),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},n=super.getConfig();return Object.assign(e,n),e}}class YN extends eU{constructor(e){super(e)}poolingFunction(e,n,s,r,o){return ws(o),Jo(r),ZW(e,n,s,r,o,"max")}}YN.className="MaxPooling3D";tt(YN);class ZN extends eU{constructor(e){super(e)}poolingFunction(e,n,s,r,o){return ws(o),Jo(r),ZW(e,n,s,r,o,"avg")}}ZN.className="AveragePooling3D";tt(ZN);class tU extends cn{constructor(e){super(e),this.inputSpec=[new Ss({ndim:3})]}computeOutputShape(e){return[e[0],e[2]]}call(e,n){throw new Jt}}class JN extends tU{constructor(e){super(e||{})}call(e,n){return Le(()=>{const s=jt(e);return us(s,1)})}}JN.className="GlobalAveragePooling1D";tt(JN);class QN extends tU{constructor(e){super(e||{})}call(e,n){return Le(()=>{const s=jt(e);return Go(s,1)})}}QN.className="GlobalMaxPooling1D";tt(QN);class nU extends cn{constructor(e){super(e),this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,ws(this.dataFormat),this.inputSpec=[new Ss({ndim:4})]}computeOutputShape(e){return e=e,this.dataFormat==="channelsLast"?[e[0],e[3]]:[e[0],e[1]]}call(e,n){throw new Jt}getConfig(){const e={dataFormat:this.dataFormat},n=super.getConfig();return Object.assign(e,n),e}}class eI extends nU{call(e,n){return Le(()=>{const s=jt(e);return this.dataFormat==="channelsLast"?us(s,[1,2]):us(s,[2,3])})}}eI.className="GlobalAveragePooling2D";tt(eI);class tI extends nU{call(e,n){return Le(()=>{const s=jt(e);return this.dataFormat==="channelsLast"?Go(s,[1,2]):Go(s,[2,3])})}}tI.className="GlobalMaxPooling2D";tt(tI);class sU extends cn{constructor(e){super(e),this.layer=e.layer}build(e){this.built=!0}get trainable(){return this.layer!=null?this.layer.trainable:!1}set trainable(e){this.layer!=null&&(this.layer.trainable=e)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(e){this.layer.setWeights(e)}getConfig(){const e={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},n=super.getConfig();return Object.assign(e,n),e}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.layer!=null&&this.layer.setFastWeightInitDuringBuild(e)}static fromConfig(e,n,s={}){const r=n.layer,o=Xa(r,s);delete n.layer;const a={layer:o};return Object.assign(a,n),new e(a)}}class nI extends sU{constructor(e){super(e),this.supportsMasking=!0}build(e){if(e=Cn(e),e.length<3)throw new Ie(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(e)}`);this.inputSpec=[{shape:e}];const n=[e[0]].concat(e.slice(2));this.layer.built||(this.layer.build(n),this.layer.built=!0),super.build(e)}computeOutputShape(e){e=Cn(e);const n=[e[0]].concat(e.slice(2)),s=this.layer.computeOutputShape(n),r=e[1];return[s[0],r].concat(s.slice(1))}call(e,n){return Le(()=>(e=jt(e),XW((a,i)=>[jt(this.layer.call(a,n)),[]],e,[],!1,null,null,!1,!0)[1]))}}nI.className="TimeDistributed";tt(nI);function fmt(t){cf(pht,"BidirectionalMergeMode",t)}const hmt="concat";class sI extends sU{constructor(e){super(e);const n=e.layer.getConfig(),s={};s.className=e.layer.getClassName(),s.config=n,this.forwardLayer=Xa(s),n.goBackwards=n.goBackwards!==!0;const r={};if(r.className=e.layer.getClassName(),r.config=n,this.backwardLayer=Xa(r),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=e.mergeMode===void 0?hmt:e.mergeMode,fmt(this.mergeMode),e.weights)throw new Jt("weights support is not implemented for Bidirectional layer yet.");this._stateful=e.layer.stateful,this.returnSequences=e.layer.returnSequences,this.returnState=e.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=e.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(e){this._trainable=e,this.forwardLayer!=null&&(this.forwardLayer.trainable=e),this.backwardLayer!=null&&(this.backwardLayer.trainable=e)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(e){const n=e.length,s=Math.floor(n/2);this.forwardLayer.setWeights(e.slice(0,s)),this.backwardLayer.setWeights(e.slice(s))}computeOutputShape(e){let n=this.forwardLayer.computeOutputShape(e);Array.isArray(n)&&Array.isArray(n[0])||(n=[n]),n=n;let s,r,o;return this.returnState&&(o=n.slice(1)),s=n[0],s=s,this.mergeMode==="concat"?(s[s.length-1]*=2,r=[s]):this.mergeMode==null?r=[s,s.slice()]:r=[s],this.returnState?this.mergeMode==null?r.concat(o).concat(o.slice()):[s].concat(o).concat(o.slice()):Ur(r)}apply(e,n){let s=n==null?null:n.initialState,r=n==null?null:n.constants;n==null&&(n={});const o=qW(e,s,r,this.numConstants);if(e=o.inputs,s=o.initialState,r=o.constants,Array.isArray(e)&&(s=e.slice(1),e=e[0]),(s==null||s.length===0)&&r==null)return super.apply(e,n);const a=[],i=[];if(s!=null){const u=s.length;if(u%2>0)throw new Ie("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");n.initialState=s,a.push(...s);const c=s.map(d=>new Ss({shape:d.shape}));this.forwardLayer.stateSpec=c.slice(0,u/2),this.backwardLayer.stateSpec=c.slice(u/2),i.push(...c)}if(r!=null)throw new Jt("Support for constants in Bidirectional layers is not implemented yet.");const l=a[0]instanceof Ga;for(const u of a)if(u instanceof Ga!==l)throw new Ie("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(l){const u=[e].concat(a),c=this.inputSpec.concat(i),d=this.inputSpec;this.inputSpec=c;const f=super.apply(u,n);return this.inputSpec=d,f}else return super.apply(e,n)}call(e,n){return Le(()=>{const s=n.initialState;let r,o;if(s==null)r=this.forwardLayer.call(e,n),o=this.backwardLayer.call(e,n);else{const l=s.slice(0,s.length/2),u=s.slice(s.length/2);r=this.forwardLayer.call(e,Object.assign(n,{initialState:l})),o=this.backwardLayer.call(e,Object.assign(n,{initialState:u}))}let a;this.returnState&&(Array.isArray(r)&&(a=r.slice(1).concat(o.slice(1))),r=r[0],o=o[0]),this.returnSequences&&(o=Xo(o,1));let i;return this.mergeMode==="concat"?i=VT([r,o]):this.mergeMode==="sum"?i=st(r,o):this.mergeMode==="ave"?i=Te(.5,st(r,o)):this.mergeMode==="mul"?i=Te(r,o):this.mergeMode==null&&(i=[r,o]),this.returnState?this.mergeMode==null?i.concat(a):[i].concat(a):i})}resetStates(e){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(e){dd(this.forwardLayer.name,()=>{this.forwardLayer.build(e)}),dd(this.backwardLayer.name,()=>{this.backwardLayer.build(e)}),this.built=!0}computeMask(e,n){Array.isArray(n)&&(n=n[0]);let s;if(this.returnSequences?this.mergeMode==null?s=[n,n]:s=n:this.mergeMode==null?s=[null,null]:s=null,this.returnState){const o=this.forwardLayer.states.map(a=>null);return Array.isArray(s)?s.concat(o).concat(o):[s].concat(o).concat(o)}else return s}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.forwardLayer!=null&&this.forwardLayer.setFastWeightInitDuringBuild(e),this.backwardLayer!=null&&this.backwardLayer.setFastWeightInitDuringBuild(e)}getConfig(){const e={mergeMode:this.mergeMode},n=super.getConfig();return Object.assign(e,n),e}static fromConfig(e,n){const s=Xa(n.layer);if(delete n.layer,n.numConstants!=null)throw new Jt("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");const r=n;return r.layer=s,new e(r)}}sI.className="Bidirectional";tt(sI);class rI extends cn{constructor(e){super(e),this.scale=e.scale,e.offset?this.offset=e.offset:this.offset=0}getConfig(){const e={scale:this.scale,offset:this.offset},n=super.getConfig();return Object.assign(e,n),e}call(e,n){return Le(()=>(e=jt(e),e.dtype!=="float32"&&(e=Fi(e,"float32")),st(Te(e,this.scale),this.offset)))}}rI.className="Rescaling";tt(rI);const{resizeBilinear:pmt,cropAndResize:mmt}=Ti;class oI extends cn{constructor(e){super(e),this.height=e.height,this.width=e.width}centerCrop(e,n,s,r,o,a,i,l){return Le(()=>{let u,c=!1;const d=n/a,f=s/i,h=(r+n)/a,p=(o+s)/i,m=[d,f,h,p],g=[];e.rank===3?(c=!0,u=Jr([e])):u=e;for(let $=0;$<u.shape[0];$++)g.push(m);const y=yo(g,[g.length,4]),w=Fd(0,g.length,1,"int32"),_=mmt(u,y,w,[r,o],"nearest");return Fi(c?jt(Yo(_)):_,l)})}upsize(e,n,s,r){return Le(()=>{const o=pmt(e,[n,s]);return Fi(o,r)})}call(e,n){return Le(()=>{const s=jt(e),r=s.dtype,o=s.shape,a=o[o.length-3],i=o[o.length-2];let l=0;a!==this.height&&(l=Math.floor((a-this.height)/2));let u=0;return i!==this.width&&(u=Math.floor((i-this.width)/2),u===0&&(u=1)),l>=0&&u>=0?this.centerCrop(s,l,u,this.height,this.width,a,i,r):this.upsize(e,this.height,this.width,r)})}getConfig(){const e={height:this.height,width:this.width},n=super.getConfig();return Object.assign(e,n),e}computeOutputShape(e){e=Cn(e);const n=e.length-3,s=e.length-2;return e[n]=this.height,e[s]=this.width,e}}oI.className="CenterCrop";tt(oI);function gmt(t,e,n,s){let r=jt(t);if(r.dtype!=="int32"&&(r=Fi(r,"int32")),e==="int")return r;const o=r.shape;if(r.rank===0&&(r=hr(r,-1)),e==="oneHot"&&r.shape[r.shape.length-1]!==1&&(r=hr(r,-1)),r.rank>2)throw new Ie(`When outputMode is not int, maximum output rank is 2 Received outputMode ${e} and input shape ${o} which would result in output rank ${r.rank}.`);const a=["multiHot","oneHot"].includes(e),i=r;let l;if(typeof s<"u"&&e==="count"?l=ob(i,s,n,a):l=ob(i,[],n,a),e!=="tfIdf")return l;if(s)return Te(l,s);throw new Ie("When outputMode is 'tfIdf', weights must be provided.")}class aI extends cn{constructor(e){super(e),this.numTokens=e.numTokens,e.outputMode?this.outputMode=e.outputMode:this.outputMode="multiHot"}getConfig(){const e={numTokens:this.numTokens,outputMode:this.outputMode},n=super.getConfig();return Object.assign(e,n),e}computeOutputShape(e){return e=Cn(e),e==null?[this.numTokens]:this.outputMode==="oneHot"&&e[e.length-1]!==1?(e.push(this.numTokens),e):(e[e.length-1]=this.numTokens,e)}call(e,n){return Le(()=>{e=jt(e),e.dtype!=="int32"&&(e=Fi(e,"int32"));let s;if(typeof n.countWeights<"u"){if(this.outputMode!=="count")throw new Ie(`countWeights is not used when outputMode !== count.
              Received countWeights=${n.countWeights}`);s=jt(n.countWeights)}const r=Go(e),o=kh(e),a=Pr(this.numTokens,r).bufferSync().get(0),i=Zl(o,0).bufferSync().get(0);if(!(a&&i))throw new Ie(`Input values must be between 0 < values <= numTokens with numTokens=${this.numTokens}`);return gmt(e,this.outputMode,this.numTokens,s)})}}aI.className="CategoryEncoding";tt(aI);const vmt=["bilinear","nearest"],kD=new Set(vmt);class iI extends cn{constructor(e){if(super(e),this.height=e.height,this.width=e.width,e.interpolation)if(kD.has(e.interpolation))this.interpolation=e.interpolation;else throw new Ie(`Invalid interpolation parameter: ${e.interpolation} is not implemented`);else this.interpolation="bilinear";this.cropToAspectRatio=Boolean(e.cropToAspectRatio)}computeOutputShape(e){e=Cn(e);const n=e[2];return[this.height,this.width,n]}getConfig(){const e={height:this.height,width:this.width,interpolation:this.interpolation,cropToAspectRatio:this.cropToAspectRatio},n=super.getConfig();return Object.assign(e,n),e}call(e,n){return Le(()=>{const s=[this.height,this.width];if(this.interpolation==="bilinear")return Ti.resizeBilinear(e,s,!this.cropToAspectRatio);if(this.interpolation==="nearest")return Ti.resizeNearestNeighbor(e,s,!this.cropToAspectRatio);throw new Error(`Interpolation is ${this.interpolation} but only ${[...kD]} are supported`)})}}iI.className="Resizing";tt(iI);function ymt(t){return new lm(t)}function bmt(t){return new cN(t)}function wmt(t){return new iN(t)}function _mt(t){return new lN(t)}function $mt(t){return new uN(t)}function xmt(t){return new fN(t)}function Smt(t){return new dN(t)}function Cmt(t){return new b2(t)}function kmt(t){return new v2(t)}function Tmt(t){return new pN(t)}function Nmt(t){return new y2(t)}function Imt(t){return new mN(t)}function Emt(t){return new gN(t)}function Amt(t){return new vN(t)}function Omt(t){return new yN(t)}function Rmt(t){return new bN(t)}function Dmt(t){return new TN(t)}function Fmt(t){return new CN(t)}function Mmt(t){return new q3(t)}function Pmt(t){return new SN(t)}function Lmt(t){return new kN(t)}function zmt(t){return new NN(t)}function Bmt(t){return new IN(t)}function Vmt(t){return new EN(t)}function Hmt(t){return new ON(t)}function Wmt(t){return new RN(t)}function Umt(t){return new FN(t)}function Gmt(t){return new LN(t)}function jmt(t){return new MN(t)}function Kmt(t){return new PN(t)}function qmt(t){return new DN(t)}function Xmt(t){return new zN(t)}function Ymt(t){return new WN(t)}function Zmt(t){return new UN(t)}function Jmt(t){return new GN(t)}function lI(t){return new KN(t)}function Qmt(t){return lI(t)}function e0t(t){return lI(t)}function uI(t){return new XN(t)}function t0t(t){return uI(t)}function n0t(t){return uI(t)}function cI(t){return new ZN(t)}function s0t(t){return cI(t)}function r0t(t){return cI(t)}function o0t(t){return new JN(t)}function a0t(t){return new eI(t)}function rU(t){return new QN(t)}function oU(t){return new tI(t)}function aU(t){return new jN(t)}function iU(t){return new qN(t)}function i0t(t){return new YN(t)}function l0t(t){return new _N(t)}function u0t(t){return new G3(t)}function c0t(t){return new $N(t)}function d0t(t){return new _2(t)}function f0t(t){return new wN(t)}function h0t(t){return new U3(t)}function p0t(t){return new xN(t)}function m0t(t){return new K3(t)}function g0t(t){return new ci(t)}function v0t(t){return new j3(t)}function y0t(t){return new sI(t)}function b0t(t){return new nI(t)}const w0t=rU,_0t=oU,$0t=aU,x0t=iU;function S0t(t){return new BN(t)}function C0t(t){return new VN(t)}function k0t(t){return new HN(t)}function T0t(t){return new AN(t)}function N0t(t){return new rI(t)}function I0t(t){return new oI(t)}function E0t(t){return new iI(t)}function A0t(t){return new aI(t)}const O0t=Object.freeze(Object.defineProperty({__proto__:null,inputLayer:ymt,elu:bmt,reLU:wmt,leakyReLU:_mt,prelu:$mt,softmax:xmt,thresholdedReLU:Smt,conv1d:Cmt,conv2d:kmt,conv2dTranspose:Tmt,conv3d:Nmt,conv3dTranspose:Imt,separableConv2d:Emt,cropping2D:Amt,upSampling2d:Omt,depthwiseConv2d:Rmt,activation:Dmt,dense:Fmt,dropout:Mmt,spatialDropout1d:Pmt,flatten:Lmt,repeatVector:zmt,reshape:Bmt,permute:Vmt,embedding:Hmt,add:Wmt,average:Umt,concatenate:Gmt,maximum:jmt,minimum:Kmt,multiply:qmt,dot:Xmt,batchNormalization:Ymt,layerNormalization:Zmt,zeroPadding2d:Jmt,averagePooling1d:lI,avgPool1d:Qmt,avgPooling1d:e0t,averagePooling2d:uI,avgPool2d:t0t,avgPooling2d:n0t,averagePooling3d:cI,avgPool3d:s0t,avgPooling3d:r0t,globalAveragePooling1d:o0t,globalAveragePooling2d:a0t,globalMaxPooling1d:rU,globalMaxPooling2d:oU,maxPooling1d:aU,maxPooling2d:iU,maxPooling3d:i0t,gru:l0t,gruCell:u0t,lstm:c0t,lstmCell:d0t,simpleRNN:f0t,simpleRNNCell:h0t,convLstm2d:p0t,convLstm2dCell:m0t,rnn:g0t,stackedRNNCells:v0t,bidirectional:y0t,timeDistributed:b0t,globalMaxPool1d:w0t,globalMaxPool2d:_0t,maxPool1d:$0t,maxPool2d:x0t,Layer:cn,RNN:ci,RNNCell:w2,input:AW,gaussianNoise:S0t,gaussianDropout:C0t,alphaDropout:k0t,masking:T0t,rescaling:N0t,centerCrop:I0t,resizing:E0t,categoryEncoding:A0t},Symbol.toStringTag,{value:"Module"}));function R0t(t,e){return nN(t,e)}function D0t(t,e){return $W(t,e)}function F0t(t,e){return xW(t,e)}function M0t(t,e){return sN(t,e)}function P0t(t,e){return rN(t,e)}function L0t(t,e){return _W(t,e)}function z0t(t,e){return wpt(t,e)}function B0t(t,e){return tN(t,e)}function V0t(t,e){return B3(t,e)}function H0t(t,e){return um(t,e)}function W0t(t,e){return um(t,e)}function U0t(t,e){return um(t,e)}function G0t(t,e){return df(t,e)}function j0t(t,e){return df(t,e)}function K0t(t,e){return df(t,e)}const q0t=Object.freeze(Object.defineProperty({__proto__:null,binaryAccuracy:R0t,binaryCrossentropy:D0t,sparseCategoricalAccuracy:F0t,categoricalAccuracy:M0t,categoricalCrossentropy:P0t,precision:L0t,recall:z0t,cosineProximity:B0t,meanAbsoluteError:V0t,meanAbsolutePercentageError:H0t,MAPE:W0t,mape:U0t,meanSquaredError:G0t,MSE:j0t,mse:K0t},Symbol.toStringTag,{value:"Module"}));const X0t=Object.freeze(Object.defineProperty({__proto__:null,modelFromJSON:qpt},Symbol.toStringTag,{value:"Module"}));function Y0t(t){return new g2(t)}function Z0t(t){return tmt(t)}function J0t(t){return nmt(t)}const Q0t=Object.freeze(Object.defineProperty({__proto__:null,l1l2:Y0t,l1:Z0t,l2:J0t},Symbol.toStringTag,{value:"Module"}));class lU extends Eh{constructor(){super(...arguments),this.model=null}setModel(e){if(!(e instanceof yl))throw new Error("model must be a LayersModel, not some other Container");this.model=e}}function wv(t,e){return t<e}function TD(t,e){return t>e}class uU extends lU{constructor(e){if(super(),e==null&&(e={}),e.restoreBestWeights)throw new Jt("restoreBestWeights = True is not implemented in EarlyStopping yet.");this.monitor=e.monitor||"val_loss",this.minDelta=Math.abs(e.minDelta||0),this.patience=e.patience||0,this.verbose=e.verbose||0,this.mode=e.mode||"auto",this.baseline=e.baseline,["auto","min","max"].indexOf(this.mode)===-1&&(console.warn(`EarlyStopping mode '${this.mode}' is invalid. Falling back to mode 'auto'.`),this.mode="auto"),this.mode==="min"?this.monitorFunc=wv:this.mode==="max"?this.monitorFunc=TD:this.monitor.indexOf("acc")!==-1?this.monitorFunc=TD:this.monitorFunc=wv,this.monitorFunc===wv&&(this.minDelta*=-1)}async onTrainBegin(e){this.wait=0,this.stoppedEpoch=0,this.baseline!=null?this.best=this.baseline:this.best=this.monitorFunc===wv?1/0:-1/0}async onEpochEnd(e,n){await mu(n);const s=this.getMonitorValue(n);s!=null&&(this.monitorFunc(s-this.minDelta,this.best)?(this.best=s,this.wait=0):(this.wait++,this.wait>=this.patience&&(this.stoppedEpoch=e,this.model.stopTraining=!0)))}async onTrainEnd(e){this.stoppedEpoch>0&&this.verbose&&console.log(`Epoch ${this.stoppedEpoch}: early stopping.`)}getMonitorValue(e){e==null&&(e={});const n=e[this.monitor];return n==null&&console.warn(`Metric for EarlyStopping ${this.monitor} is not available. Available metrics are: ${Object.keys(e)}`),n}}function egt(t){return new uU(t)}const tgt={earlyStopping:egt};const ngt=Be();ngt.registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,t=>{t&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")});var na;(function(t){t[t.DT_INVALID=0]="DT_INVALID",t[t.DT_FLOAT=1]="DT_FLOAT",t[t.DT_DOUBLE=2]="DT_DOUBLE",t[t.DT_INT32=3]="DT_INT32",t[t.DT_UINT8=4]="DT_UINT8",t[t.DT_INT16=5]="DT_INT16",t[t.DT_INT8=6]="DT_INT8",t[t.DT_STRING=7]="DT_STRING",t[t.DT_COMPLEX64=8]="DT_COMPLEX64",t[t.DT_INT64=9]="DT_INT64",t[t.DT_BOOL=10]="DT_BOOL",t[t.DT_QINT8=11]="DT_QINT8",t[t.DT_QUINT8=12]="DT_QUINT8",t[t.DT_QINT32=13]="DT_QINT32",t[t.DT_BFLOAT16=14]="DT_BFLOAT16",t[t.DT_QINT16=15]="DT_QINT16",t[t.DT_QUINT16=16]="DT_QUINT16",t[t.DT_UINT16=17]="DT_UINT16",t[t.DT_COMPLEX128=18]="DT_COMPLEX128",t[t.DT_HALF=19]="DT_HALF",t[t.DT_RESOURCE=20]="DT_RESOURCE",t[t.DT_VARIANT=21]="DT_VARIANT",t[t.DT_UINT32=22]="DT_UINT32",t[t.DT_UINT64=23]="DT_UINT64",t[t.DT_FLOAT_REF=101]="DT_FLOAT_REF",t[t.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",t[t.DT_INT32_REF=103]="DT_INT32_REF",t[t.DT_UINT8_REF=104]="DT_UINT8_REF",t[t.DT_INT16_REF=105]="DT_INT16_REF",t[t.DT_INT8_REF=106]="DT_INT8_REF",t[t.DT_STRING_REF=107]="DT_STRING_REF",t[t.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",t[t.DT_INT64_REF=109]="DT_INT64_REF",t[t.DT_BOOL_REF=110]="DT_BOOL_REF",t[t.DT_QINT8_REF=111]="DT_QINT8_REF",t[t.DT_QUINT8_REF=112]="DT_QUINT8_REF",t[t.DT_QINT32_REF=113]="DT_QINT32_REF",t[t.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",t[t.DT_QINT16_REF=115]="DT_QINT16_REF",t[t.DT_QUINT16_REF=116]="DT_QUINT16_REF",t[t.DT_UINT16_REF=117]="DT_UINT16_REF",t[t.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",t[t.DT_HALF_REF=119]="DT_HALF_REF",t[t.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",t[t.DT_VARIANT_REF=121]="DT_VARIANT_REF",t[t.DT_UINT32_REF=122]="DT_UINT32_REF",t[t.DT_UINT64_REF=123]="DT_UINT64_REF"})(na||(na={}));var ND;(function(t){(function(e){e[e.LEGACY=0]="LEGACY",e[e.V1=1]="V1",e[e.V2=2]="V2"})(t.CheckpointFormatVersion||(t.CheckpointFormatVersion={}))})(ND||(ND={}));const dI={};function sgt(t,e){const n={tfOpName:t,category:"custom",inputs:[],attrs:[],customExecutor:e};dI[t]=n}function cU(t){return dI[t]}function rgt(t){delete dI[t]}function H(t,e,n,s,r){const o=e.inputParams[t];if(o&&o.inputIndexStart!==void 0){const i=o.inputIndexStart,l=o.inputIndexEnd===0?void 0:o.inputIndexEnd===void 0?i+1:o.inputIndexEnd;if(o.type==="tensor")return Nr(e.inputNames[o.inputIndexStart],n,s,r);if(o.type==="tensors")return e.inputNames.slice(i,l).map(f=>Nr(f,n,s,r));const u=Nr(e.inputNames.slice(i)[0],n,s,r),c=u.dataSync();return o.type==="number"?c[0]:Uo(u.shape,c)}const a=e.attrParams[t];return a&&a.value}function Nr(t,e,n,s){const[r,o]=lo(t);if(s!=null){const i=s.getHashTableHandleByName(r);if(i!=null)return i}const a=n.currentContextIds.find(i=>!!e[mb(r,i)]);return a!==void 0?e[mb(r,a)][o]:void 0}function ogt(t,e,n){return e[mb(t,n.currentContextId)]}function ll(t,e){const[n,s,r]=lo(t);return[mb(n,e&&e.currentContextId),s,r]}function mb(t,e){return e?`${t}-${e}`:t}function lo(t){const e=t.split(":");if(e.length===1)return[t,0,void 0];const n=e[0],s=e.length===3?e[1]:void 0,r=Number(e[e.length-1]);return[n,r,s]}function hy(t,e,n){let s=H("pad",t,e,n);if(s==="explicit"){s=H("explicitPaddings",t,e,n);const r=[[0,0],[0,0],[0,0],[0,0]];for(let o=0;o<4;o++)r[o][0]=s[o*2],r[o][1]=s[o*2+1];return r}return s}function ul(t){return t.kept?t:Ri(t)}const agt=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],igt=Object.freeze(Object.defineProperty({__proto__:null,json:agt},Symbol.toStringTag,{value:"Module"}));const lgt=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Prod",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axes",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],ugt=Object.freeze(Object.defineProperty({__proto__:null,json:lgt},Symbol.toStringTag,{value:"Module"}));const cgt=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}],dgt=Object.freeze(Object.defineProperty({__proto__:null,json:cgt},Symbol.toStringTag,{value:"Module"}));const fgt=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}],hgt=Object.freeze(Object.defineProperty({__proto__:null,json:fgt},Symbol.toStringTag,{value:"Module"}));const pgt=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomStandardNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}],mgt=Object.freeze(Object.defineProperty({__proto__:null,json:pgt},Symbol.toStringTag,{value:"Module"}));const ggt=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],vgt=Object.freeze(Object.defineProperty({__proto__:null,json:ggt},Symbol.toStringTag,{value:"Module"}));const ygt=[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}],bgt=Object.freeze(Object.defineProperty({__proto__:null,json:ygt},Symbol.toStringTag,{value:"Module"}));const wgt=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],_gt=Object.freeze(Object.defineProperty({__proto__:null,json:wgt},Symbol.toStringTag,{value:"Module"}));const $gt=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"InitializeTable",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]},{tfOpName:"InitializeTableV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],xgt=Object.freeze(Object.defineProperty({__proto__:null,json:$gt},Symbol.toStringTag,{value:"Module"}));const Sgt=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}],Cgt=Object.freeze(Object.defineProperty({__proto__:null,json:Sgt},Symbol.toStringTag,{value:"Module"}));const kgt=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],Tgt=Object.freeze(Object.defineProperty({__proto__:null,json:kgt},Symbol.toStringTag,{value:"Module"}));const Ngt=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]}],Igt=Object.freeze(Object.defineProperty({__proto__:null,json:Ngt},Symbol.toStringTag,{value:"Module"}));const Egt=[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"SparseToDense",category:"normalization",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!0,notSupported:!0}]}],Agt=Object.freeze(Object.defineProperty({__proto__:null,json:Egt},Symbol.toStringTag,{value:"Module"}));const Ogt=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}],Rgt=Object.freeze(Object.defineProperty({__proto__:null,json:Ogt},Symbol.toStringTag,{value:"Module"}));const Dgt=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]}],Fgt=Object.freeze(Object.defineProperty({__proto__:null,json:Dgt},Symbol.toStringTag,{value:"Module"}));const Mgt=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}],Pgt=Object.freeze(Object.defineProperty({__proto__:null,json:Mgt},Symbol.toStringTag,{value:"Module"}));const Lgt=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],zgt=Object.freeze(Object.defineProperty({__proto__:null,json:Lgt},Symbol.toStringTag,{value:"Module"}));const Bgt=[{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}],Vgt=Object.freeze(Object.defineProperty({__proto__:null,json:Bgt},Symbol.toStringTag,{value:"Module"}));const Hgt=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}],Wgt=Object.freeze(Object.defineProperty({__proto__:null,json:Hgt},Symbol.toStringTag,{value:"Module"}));let ID=class{constructor(){const e=[igt,ugt,dgt,hgt,mgt,vgt,bgt,_gt,xgt,Cgt,Tgt,Igt,Agt,Rgt,Fgt,Pgt,zgt,Vgt,Wgt],n=[].concat(...e.map(s=>s.json));this.opMappers=n.reduce((s,r)=>(s[r.tfOpName]=r,s),{})}static get Instance(){return this._instance||(this._instance=new this)}transformGraph(e,n={}){const s=e.node,r=[],o=[],a=[],i=s.reduce((m,g)=>(m[g.name]=this.mapNode(g),g.op.startsWith("Placeholder")?r.push(m[g.name]):g.op==="Const"?o.push(m[g.name]):(g.input==null||g.input.length===0)&&a.push(m[g.name]),m),{});let l=[];const u=[];let c={},d={};n!=null&&(c=this.mapSignatureEntries(n.inputs),d=this.mapSignatureEntries(n.outputs));const f=Object.keys(i);f.forEach(m=>{const g=i[m];g.inputNames.forEach((y,w)=>{const[b,,_]=ll(y),$=i[b];if($.outputs!=null){const x=$.outputs.indexOf(_);if(x!==-1){const k=`${b}:${x}`;g.inputNames[w]=k}}g.inputs.push($),$.children.push(g)})}),Object.keys(d).length===0?f.forEach(m=>{const g=i[m];g.children.length===0&&u.push(g)}):Object.keys(d).forEach(m=>{const[g]=ll(m),y=i[g];y!=null&&(y.signatureKey=d[m],u.push(y))}),Object.keys(c).length>0?Object.keys(c).forEach(m=>{const[g]=ll(m),y=i[g];y&&(y.signatureKey=c[m],l.push(y))}):l=r;let h={};e.library!=null&&e.library.function!=null&&(h=e.library.function.reduce((m,g)=>(m[g.signature.name]=this.mapFunction(g),m),{}));const p={nodes:i,inputs:l,outputs:u,weights:o,placeholders:r,signature:n,functions:h};return a.length>0&&(p.initNodes=a),p}mapSignatureEntries(e){return Object.keys(e||{}).reduce((n,s)=>(n[e[s].name]=s,n),{})}mapNode(e){const n=cU(e.op)||this.opMappers[e.op]||{};e.attr==null&&(e.attr={});const s={name:e.name,op:e.op,category:n.category,inputNames:(e.input||[]).map(r=>r.startsWith("^")?r.slice(1):r),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:e.attr,outputs:n.outputs};return n.inputs!=null&&(s.inputParams=n.inputs.reduce((r,o)=>(r[o.name]={type:o.type,inputIndexStart:o.start,inputIndexEnd:o.end},r),{})),n.attrs!=null&&(s.attrParams=n.attrs.reduce((r,o)=>{const a=o.type;let i;switch(o.type){case"string":i=Lx(e.attr,o.tfName,o.defaultValue),i===void 0&&!!o.tfDeprecatedName&&(i=Lx(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"string[]":i=Gx(e.attr,o.tfName,o.defaultValue),i===void 0&&!!o.tfDeprecatedName&&(i=Gx(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"number":i=Bx(e.attr,o.tfName,o.defaultValue||0),i===void 0&&!!o.tfDeprecatedName&&(i=Bx(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"number[]":i=Ux(e.attr,o.tfName,o.defaultValue),i===void 0&&!!o.tfDeprecatedName&&(i=Ux(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"bool":i=zx(e.attr,o.tfName,o.defaultValue),i===void 0&&!!o.tfDeprecatedName&&(i=zx(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"bool[]":i=Kx(e.attr,o.tfName,o.defaultValue),i===void 0&&!!o.tfDeprecatedName&&(i=Kx(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"shape":i=Wx(e.attr,o.tfName,o.defaultValue),i===void 0&&!!o.tfDeprecatedName&&(i=Wx(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"shape[]":i=jx(e.attr,o.tfName,o.defaultValue),i===void 0&&!!o.tfDeprecatedName&&(i=jx(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"dtype":i=Vx(e.attr,o.tfName,o.defaultValue),i===void 0&&!!o.tfDeprecatedName&&(i=Vx(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"dtype[]":i=Hx(e.attr,o.tfName,o.defaultValue),i===void 0&&!!o.tfDeprecatedName&&(i=Hx(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"func":i=ED(e.attr,o.tfName,o.defaultValue),i===void 0&&!!o.tfDeprecatedName&&(i=ED(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${o.type} for op: ${e.op}`)}return r[o.name]={value:i,type:a},r},{})),s}mapFunction(e){const n=e.nodeDef,s=[],r=[];let o={};n!=null&&(o=n.reduce((d,f)=>(d[f.name]=this.mapNode(f),f.op==="Const"&&r.push(d[f.name]),d),{}));const a=[],i=[];e.signature.inputArg.forEach(d=>{const[f]=ll(d.name),h={name:f,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:fI(d.type),type:"dtype"}},children:[]};h.signatureKey=d.name,a.push(h),o[f]=h}),Object.keys(o).forEach(d=>{const f=o[d];f.inputNames.forEach((h,p)=>{const[m,,g]=ll(h),y=o[m];if(y.outputs!=null){const w=y.outputs.indexOf(g);if(w!==-1){const b=`${m}:${w}`;f.inputNames[p]=b}}f.inputs.push(y),y.children.push(f)})});const u=e.ret;e.signature.outputArg.forEach(d=>{const[f,h]=ll(u[d.name]),p=o[f];p!=null&&(p.defaultOutput=h,i.push(p))});const c=this.mapArgsToSignature(e);return{nodes:o,inputs:a,outputs:i,weights:r,placeholders:s,signature:c}}mapArgsToSignature(e){return{methodName:e.signature.name,inputs:e.signature.inputArg.reduce((n,s)=>(n[s.name]=this.mapArgToTensorInfo(s),n),{}),outputs:e.signature.outputArg.reduce((n,s)=>(n[s.name]=this.mapArgToTensorInfo(s,e.ret),n),{})}}mapArgToTensorInfo(e,n){let s=e.name;return n!=null&&(s=n[s]),{name:s,dtype:e.type}}};function Ugt(t){const e=Be().global;if(typeof e.atob<"u")return e.atob(t);if(typeof Buffer<"u")return new Buffer(t,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}function dU(t,e){const n=Array.isArray(t)?String.fromCharCode.apply(null,t):Ugt(t);return e?n:n.toLowerCase()}function Lx(t,e,n,s=!1){const r=t[e];return r!=null?dU(r.s,s):n}function zx(t,e,n){const s=t[e];return s?s.b:n}function Bx(t,e,n){const s=t[e]||{},r=s.i!=null?s.i:s.f!=null?s.f:n;return typeof r=="number"?r:parseInt(r,10)}function fI(t){switch(typeof t=="string"&&(t=na[t]),t){case na.DT_FLOAT:case na.DT_HALF:return"float32";case na.DT_INT32:case na.DT_INT64:case na.DT_INT8:case na.DT_UINT8:return"int32";case na.DT_BOOL:return"bool";case na.DT_DOUBLE:return"float32";case na.DT_STRING:return"string";default:return null}}function ED(t,e,n){const s=t[e];return s&&s.func?s.func.name:n}function Vx(t,e,n){const s=t[e];return s&&s.type?fI(s.type):n}function Hx(t,e,n){const s=t[e];return s&&s.list&&s.list.type?s.list.type.map(r=>fI(r)):n}function fU(t){if(!t.unknownRank)return t.dim!=null?t.dim.map(e=>typeof e.size=="number"?e.size:parseInt(e.size,10)):[]}function Wx(t,e,n){const s=t[e];return s&&s.shape?fU(s.shape):n}function Ux(t,e,n){const s=t[e];return s?((s.list.f&&s.list.f.length?s.list.f:s.list.i)||[]).map(r=>typeof r=="number"?r:parseInt(r,10)):n}function Gx(t,e,n,s=!1){const r=t[e];return r&&r.list&&r.list.s?r.list.s.map(o=>dU(o,s)):n}function jx(t,e,n){const s=t[e];return s&&s.list&&s.list.shape?s.list.shape.map(r=>fU(r)):n}function Kx(t,e,n){const s=t[e];return s&&s.list&&s.list.b?s.list.b:n}let Ggt=class{constructor(e,n,s){this.node=e,this.tensorMap=n,this.context=s,this.inputs=[],this.attrs={},this.inputs=e.inputNames.map(r=>this.getInput(r)),e.rawAttrs!=null&&(this.attrs=Object.keys(e.rawAttrs).reduce((r,o)=>(r[o]=this.getAttr(o),r),{}))}getInput(e){return Nr(e,this.tensorMap,this.context)}getAttr(e,n){const s=this.node.rawAttrs[e];if(s.tensor!=null)return Nr(e,this.tensorMap,this.context);if(s.i!=null||s.f!=null)return Bx(this.node.rawAttrs,e,n);if(s.s!=null)return Lx(this.node.rawAttrs,e,n);if(s.b!=null)return zx(this.node.rawAttrs,e,n);if(s.shape!=null)return Wx(this.node.rawAttrs,e,n);if(s.type!=null)return Vx(this.node.rawAttrs,e,n);if(s.list!=null){if(s.list.i!=null||s.list.f!=null)return Ux(this.node.rawAttrs,e,n);if(s.list.s!=null)return Gx(this.node.rawAttrs,e,n);if(s.list.shape!=null)return jx(this.node.rawAttrs,e,n);if(s.list.b!=null)return Kx(this.node.rawAttrs,e,n);if(s.list.type!=null)return Hx(this.node.rawAttrs,e,n)}return n}};const dr=Object.freeze(Object.defineProperty({__proto__:null,abs:$s,acos:v8,acosh:y8,add:st,addN:_V,all:V_,any:sg,argMax:Od,argMin:b8,asin:w8,asinh:_8,atan:$8,atan2:x8,atanh:S8,avgPool:j1,avgPool3d:k8,basicLSTMCell:$V,batchToSpaceND:K1,batchNorm:Qp,batchNorm2d:T8,batchNorm3d:N8,batchNorm4d:I8,bincount:E8,broadcastArgs:xV,broadcastTo:cd,buffer:tn,cast:ht,ceil:A8,clipByValue:Zr,clone:Ri,complex:El,concat:vs,concat1d:O8,concat2d:R8,concat3d:D8,concat4d:F8,conv1d:H_,conv2d:Al,conv2dTranspose:W_,conv3d:P8,conv3dTranspose:L8,cos:q1,cosh:U_,cumprod:rg,cumsum:G_,denseBincount:ob,depthToSpace:z8,depthwiseConv2d:em,diag:CV,dilation2d:B8,div:Et,divNoNan:V8,dot:H8,einsum:kV,elu:tm,equal:_o,erf:W8,euclideanNorm:G8,exp:$o,expandDims:hr,expm1:j8,eye:j_,fill:of,floor:sm,floorDiv:B_,gather:rm,greater:Pr,greaterEqual:Zl,imag:U1,isFinite:K8,isInf:q8,isNaN:X8,leakyRelu:X1,less:K_,lessEqual:mc,linspace:IV,localResponseNormalization:Y8,log:xo,log1p:Y1,logSigmoid:Z8,logSoftmax:X_,logSumExp:Y_,logicalAnd:Ta,logicalNot:Z1,logicalOr:Z_,logicalXor:J8,lowerBound:AV,matMul:ln,max:Go,maxPool:J1,maxPool3d:Q8,maxPoolWithArgmax:OV,maximum:Zi,mean:us,meshgrid:RV,min:kh,minimum:om,mirrorPad:eT,mod:tT,moments:Q1,mul:Te,multiRNNCell:DV,multinomial:FV,neg:Jn,notEqual:Dd,oneHot:Sh,ones:po,onesLike:So,outerProduct:MV,pad:Jl,pad1d:PV,pad2d:LV,pad3d:zV,pad4d:BV,pool:nT,pow:Ol,prelu:t2,print:n8,prod:sT,raggedGather:VV,raggedRange:HV,raggedTensorToTensor:WV,rand:UV,randomGamma:JV,randomNormal:Q_,randomStandardNormal:QV,randomUniform:am,range:Fd,real:Ch,reciprocal:oT,relu:li,relu6:e3,reshape:Ne,reverse:Xo,reverse1d:eH,reverse2d:tH,reverse3d:nH,reverse4d:sH,round:t3,rsqrt:n3,scalar:Pt,selu:s3,separableConv2d:r3,setdiff1dAsync:rH,sigmoid:qa,sign:aT,sin:o3,sinh:a3,slice:mn,slice1d:n2,slice2d:i3,slice3d:s2,slice4d:Th,softmax:r2,softplus:af,spaceToBatchND:e2,fft:o2,ifft:Nh,irfft:l3,rfft:a2,split:Kr,sqrt:ar,square:Dn,squaredDifference:u3,squeeze:gc,stack:Jr,step:uf,stridedSlice:iT,sub:$t,sum:kt,tan:lT,tanh:Rd,tensor:yo,tensor1d:vr,tensor2d:Mu,tensor3d:i8,tensor4d:oH,tensor5d:aH,tensor6d:iH,tile:Lo,topk:uT,truncatedNormal:c3,unique:cT,unsortedSegmentSum:d3,unstack:Yo,upperBound:lH,variable:dT,where:wr,whereAsync:fT,zeros:xs,zerosLike:yn,op:be,OP_SCOPE_SUFFIX:Yk,booleanMaskAsync:uH,transpose:dn,norm:nm,movingAverage:cH,scatterND:dH,searchSorted:J_,sparseToDense:fH,gatherND:hH,dropout:hT,enclosingPowerOfTwo:pT,cosineWindow:h3,inTopKAsync:pH,image:Ti,linalg:vT,losses:CH,spectral:xH,fused:yH,signal:SH,sparse:kH,string:TH},Symbol.toStringTag,{value:"Module"}));const jgt=(t,e,n,s=dr)=>{switch(t.op){case"BiasAdd":case"AddV2":case"Add":return[s.add(H("a",t,e,n),H("b",t,e,n))];case"AddN":return[s.addN(H("tensors",t,e,n))];case"FloorMod":case"Mod":return[s.mod(H("a",t,e,n),H("b",t,e,n))];case"Mul":return[s.mul(H("a",t,e,n),H("b",t,e,n))];case"RealDiv":case"Div":return[s.div(H("a",t,e,n),H("b",t,e,n))];case"DivNoNan":return[s.divNoNan(H("a",t,e,n),H("b",t,e,n))];case"FloorDiv":return[s.floorDiv(H("a",t,e,n),H("b",t,e,n))];case"Sub":return[s.sub(H("a",t,e,n),H("b",t,e,n))];case"Minimum":return[s.minimum(H("a",t,e,n),H("b",t,e,n))];case"Maximum":return[s.maximum(H("a",t,e,n),H("b",t,e,n))];case"Pow":return[s.pow(H("a",t,e,n),H("b",t,e,n))];case"SquaredDifference":return[s.squaredDifference(H("a",t,e,n),H("b",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};const Kgt=(t,e,n,s=dr)=>{switch(t.op){case"Abs":case"ComplexAbs":return[s.abs(H("x",t,e,n))];case"Acos":return[s.acos(H("x",t,e,n))];case"Acosh":return[s.acosh(H("x",t,e,n))];case"Asin":return[s.asin(H("x",t,e,n))];case"Asinh":return[s.asinh(H("x",t,e,n))];case"Atan":return[s.atan(H("x",t,e,n))];case"Atan2":return[s.atan2(H("x",t,e,n),H("y",t,e,n))];case"Atanh":return[s.atanh(H("x",t,e,n))];case"Ceil":return[s.ceil(H("x",t,e,n))];case"Complex":return[s.complex(H("real",t,e,n),H("imag",t,e,n))];case"Cos":return[s.cos(H("x",t,e,n))];case"Cosh":return[s.cosh(H("x",t,e,n))];case"Elu":return[s.elu(H("x",t,e,n))];case"Erf":return[s.erf(H("x",t,e,n))];case"Exp":return[s.exp(H("x",t,e,n))];case"Expm1":return[s.expm1(H("x",t,e,n))];case"Floor":return[s.floor(H("x",t,e,n))];case"Log":return[s.log(H("x",t,e,n))];case"Log1p":return[s.log1p(H("x",t,e,n))];case"Imag":return[s.imag(H("x",t,e,n))];case"Neg":return[s.neg(H("x",t,e,n))];case"Reciprocal":return[s.reciprocal(H("x",t,e,n))];case"Real":return[s.real(H("x",t,e,n))];case"Relu":return[s.relu(H("x",t,e,n))];case"Round":return[s.round(H("x",t,e,n))];case"Selu":return[s.selu(H("x",t,e,n))];case"Sigmoid":return[s.sigmoid(H("x",t,e,n))];case"Sin":return[s.sin(H("x",t,e,n))];case"Sign":return[s.sign(H("x",t,e,n))];case"Sinh":return[s.sinh(H("x",t,e,n))];case"Softplus":return[s.softplus(H("x",t,e,n))];case"Sqrt":return[s.sqrt(H("x",t,e,n))];case"Square":return[s.square(H("x",t,e,n))];case"Tanh":return[s.tanh(H("x",t,e,n))];case"Tan":return[s.tan(H("x",t,e,n))];case"ClipByValue":return[s.clipByValue(H("x",t,e,n),H("clipValueMin",t,e,n),H("clipValueMax",t,e,n))];case"Relu6":return[s.relu6(H("x",t,e,n))];case"Rsqrt":return[s.rsqrt(Nr(t.inputNames[0],e,n))];case"Prod":return[s.prod(H("x",t,e,n),H("axes",t,e,n))];case"LeakyRelu":return[s.leakyRelu(H("x",t,e,n),H("alpha",t,e,n))];case"Prelu":return[s.prelu(H("x",t,e,n),H("alpha",t,e,n))];case"IsNan":return[s.isNaN(Nr(t.inputNames[0],e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};function oa(t,e,n=""){if(!(typeof t=="number"||typeof e=="number")){q(t.length===e.length,()=>n+` Shapes ${t} and ${e} must match`);for(let s=0;s<t.length;s++){const r=t[s],o=e[s];q(r<0||o<0||r===o,()=>n+` Shapes ${t} and ${e} must match`)}}}function AD(t){return!(typeof t=="number"||t.some(e=>e<0))}function Pm(t,e,n){let s=qx(t,n);const r=!AD(s);if(r&&e.length===0)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${s}`);if(r&&e.forEach(o=>{s=qx(o.shape,s)}),!AD(s))throw new Error(`Non-fully-defined elementShape: ${s}`);return s}function qx(t,e){if(typeof t=="number")return e;if(typeof e=="number")return t;if(t.length!==e.length)throw new Error(`Incompatible ranks during merge: ${t} vs. ${e}`);const n=[];for(let s=0;s<t.length;++s){const r=t[s],o=e[s];if(r>=0&&o>=0&&r!==o)throw new Error(`Incompatible shape during merge: ${t} vs. ${e}`);n[s]=r>=0?r:o}return n}let qgt=class{constructor(e,n,s,r,o,a,i){this.name=e,this.dtype=n,this.maxSize=s,this.elementShape=r,this.identicalElementShapes=o,this.dynamicSize=a,this.clearAfterRead=i,this.tensors=[],this.closed_=!1,this.idTensor=Pt(0),As(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(e){this.tensors.forEach(n=>{(e==null||!e.has(n.tensor.id))&&n.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||e>=this.size())throw new Error(`Tried to read from index ${e}, but array size is: ${this.size()}`);const n=this.tensors[e];if(n.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${e} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(n.cleared=!0),n.read=!0,n.tensor}readMany(e){return e.map(n=>this.read(n))}write(e,n){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||!this.dynamicSize&&e>=this.maxSize)throw new Error(`Tried to write to index ${e}, but array is not resizeable and size is: ${this.maxSize}`);const s=this.tensors[e]||{};if(n.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e},
          because the value dtype is ${n.dtype}, but TensorArray dtype is ${this.dtype}.`);if(this.size()===0&&(this.elementShape==null||this.elementShape.length===0)&&(this.elementShape=n.shape),oa(this.elementShape,n.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${e}.`),s.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been read.`);if(s.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been written.`);s.tensor=n,As(n),s.written=!0,this.tensors[e]=s}writeMany(e,n){if(e.length!==n.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${e.length} is not the same as tensors size: ${n.length}.`);e.forEach((s,r)=>this.write(s,n[r]))}gather(e,n){if(!!n&&n!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${n}`);if(e)e=e.slice(0,this.size());else{e=[];for(let r=0;r<this.size();r++)e.push(r)}if(e.length===0)return yo([],[0].concat(this.elementShape));const s=this.readMany(e);return oa(this.elementShape,s[0].shape,"TensorArray shape mismatch: "),Jr(s,0)}concat(e){if(!!e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${e}`);if(this.size()===0)return yo([],[0].concat(this.elementShape));const n=[];for(let r=0;r<this.size();r++)n.push(r);const s=this.readMany(n);return oa(this.elementShape,s[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${s[0].shape})`),vs(s,0)}scatter(e,n){if(n.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${n.dtype}`);if(e.length!==n.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${n.shape[0]}`);const s=Math.max(...e);if(!this.dynamicSize&&s>=this.maxSize)throw new Error(`Max index must be < array size (${s}  vs. ${this.maxSize})`);this.writeMany(e,Yo(n,0))}split(e,n){if(n.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${n.dtype}`);let s=0;const r=e.map(l=>(s+=l,s));if(s!==n.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${s}, and tensor's shape is: ${n.shape}`);if(!this.dynamicSize&&e.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${e.length}), and the TensorArray is not marked as dynamically resizeable`);const o=s===0?0:n.size/s,a=[];Le(()=>{n=Ne(n,[1,s,o]);for(let l=0;l<e.length;++l){const c=[0,l===0?0:r[l-1],0],d=[1,e[l],o];a[l]=Ne(mn(n,c,d),this.elementShape)}return a});const i=[];for(let l=0;l<e.length;l++)i[l]=l;this.writeMany(i,a)}};let Ah=class{constructor(e,n,s,r=-1){this.tensors=e,this.elementShape=n,this.elementDtype=s,e!=null&&e.forEach(o=>{if(s!==o.dtype)throw new Error(`Invalid data types; op elements ${s}, but list elements ${o.dtype}`);oa(n,o.shape,"TensorList shape mismatch: "),As(o)}),this.idTensor=Pt(0),this.maxNumElements=r,As(this.idTensor)}get id(){return this.idTensor.id}copy(){return new Ah([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(e){this.tensors.forEach(n=>{(e==null||!e.has(n.id))&&n.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(e,n,s=-1){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);if(s!==-1&&this.tensors.length!==s)throw new Error(`Operation expected a list with ${s} elements but got a list with ${this.tensors.length} elements.`);oa(e,this.elementShape,"TensorList shape mismatch: ");const r=Pm(this.elementShape,this.tensors,e);return Le(()=>{const o=this.tensors.map(a=>Ne(a,r));return Jr(o,0)})}popBack(e,n){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);if(this.size()===0)throw new Error("Trying to pop from an empty list.");const s=Pm(this.elementShape,this.tensors,e),r=this.tensors.pop();return r.kept=!1,oa(r.shape,e,"TensorList shape mismatch: "),Ne(r,s)}pushBack(e){if(e.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if(oa(e.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");As(e),this.tensors.push(e)}resize(e){if(e<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${e}`);if(this.maxNumElements!==-1&&e>this.maxNumElements)throw new Error(`TensorListResize input size ${e} is greater maxNumElement ${this.maxNumElements}.`);const n=new Ah([],this.elementShape,this.elementDtype,this.maxNumElements);n.tensors.length=e;for(let s=0;s<Math.min(this.tensors.length,e);++s)n.tensors[s]=this.tensors[s];return n}getItem(e,n,s){if(s!==this.elementDtype)throw new Error(`Invalid data types; op elements ${s}, but list elements ${this.elementDtype}`);if(e<0||e>this.tensors.length)throw new Error(`Trying to access element ${e} in a list with ${this.tensors.length} elements.`);if(this.tensors[e]==null)throw new Error(`element at index ${e} is null.`);oa(this.tensors[e].shape,n,"TensorList shape mismatch: ");const r=Pm(this.elementShape,this.tensors,n);return Ne(this.tensors[e],r)}setItem(e,n){if(n.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n.dtype}, but list elements ${this.elementDtype}`);if(e<0||this.maxNumElements!==-1&&e>=this.maxNumElements)throw new Error(`Trying to set element ${e} in a list with max ${this.maxNumElements} elements.`);oa(this.elementShape,n.shape,"TensorList shape mismatch: "),As(n),this.tensors[e]!=null&&(this.tensors[e].kept=!1),this.tensors[e]=n}gather(e,n,s){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);oa(this.elementShape,s,"TensorList shape mismatch: "),e=e.slice(0,this.size());const r=Pm(this.elementShape,this.tensors,s);return e.length===0?yo([],[0].concat(r)):Le(()=>{const o=e.map(a=>Ne(this.tensors[a],r));return Jr(o,0)})}concat(e,n){if(!!e&&e!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${e}`);oa(this.elementShape,n,"TensorList shape mismatch: ");const s=Pm(this.elementShape,this.tensors,n);return this.size()===0?yo([],[0].concat(s)):Le(()=>{const r=this.tensors.map(o=>Ne(o,s));return vs(r,0)})}};function Xgt(t,e,n){const s=t.dtype;if(t.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${t.shape}`);if(t.dtype!==n)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${n}`);const r=t.shape.slice(1);oa(r,e,"TensorList shape mismatch: ");const o=Yo(t);return new Ah(o,e,s)}function Ygt(t,e,n,s){return new Ah([],t,e,s)}function Zgt(t,e,n,s){if(e.length!==t.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${t.shape[0]}`);const r=Math.max(...e);if(s!=null&&s!==-1&&r>=s)throw new Error(`Max index must be < array size (${r}  vs. ${s})`);const o=new Ah([],n,t.dtype,s),a=Yo(t,0);return e.forEach((i,l)=>{o.setItem(i,a[l])}),o}function Jgt(t,e,n){let s=0;const r=e.map(c=>(s+=c,s));if(s!==t.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${s}, and tensor's shape is: ${t.shape}`);const o=t.shape.slice(1),a=qx(o,n),i=s===0?0:t.size/s,l=Le(()=>{const c=[];t=Ne(t,[1,s,i]);for(let d=0;d<e.length;++d){const h=[0,d===0?0:r[d-1],0],p=[1,e[d],i];c[d]=Ne(mn(t,h,p),a)}return t.dispose(),c}),u=new Ah([],n,t.dtype,e.length);for(let c=0;c<l.length;c++)u.setItem(c,l[c]);return u}const Qgt=async(t,e,n)=>{switch(t.op){case"If":case"StatelessIf":{const s=H("thenBranch",t,e,n),r=H("elseBranch",t,e,n),o=H("cond",t,e,n),a=H("args",t,e,n);return(await o.data())[0]?n.functionMap[s].executeFunctionAsync(a,n.tensorArrayMap,n.tensorListMap):n.functionMap[r].executeFunctionAsync(a,n.tensorArrayMap,n.tensorListMap)}case"While":case"StatelessWhile":{const s=H("body",t,e,n),r=H("cond",t,e,n),o=H("args",t,e,n),a=await n.functionMap[r].executeFunctionAsync(o,n.tensorArrayMap,n.tensorListMap),i=o.map(c=>c.id);let l=await a[0].data();a.forEach(c=>{!c.kept&&i.indexOf(c.id)===-1&&c.dispose()});let u=o;for(;l[0];){const c=u;u=await n.functionMap[s].executeFunctionAsync(u,n.tensorArrayMap,n.tensorListMap);const d=u.map(h=>h.id);c.forEach(h=>{!h.kept&&i.indexOf(h.id)===-1&&d.indexOf(h.id)===-1&&h.dispose()});const f=await n.functionMap[r].executeFunctionAsync(u,n.tensorArrayMap,n.tensorListMap);l=await f[0].data(),f.forEach(h=>{!h.kept&&i.indexOf(h.id)===-1&&d.indexOf(h.id)===-1&&h.dispose()})}return u}case"LoopCond":{const s=H("pred",t,e,n);return[ul(s)]}case"Switch":{const s=H("pred",t,e,n);let r=H("data",t,e,n);return r.kept||(r=ul(r)),(await s.data())[0]?[void 0,r]:[r,void 0]}case"Merge":{const s=t.inputNames.find(r=>Nr(r,e,n)!==void 0);if(s){const r=Nr(s,e,n);return[ul(r)]}return}case"Enter":{const s=H("frameName",t,e,n),r=H("tensor",t,e,n);return n.enterFrame(s),[ul(r)]}case"Exit":{const s=H("tensor",t,e,n);return n.exitFrame(),[ul(s)]}case"NextIteration":{const s=H("tensor",t,e,n);return n.nextIteration(),[ul(s)]}case"TensorArrayV3":{const s=H("size",t,e,n),r=H("dtype",t,e,n),o=H("elementShape",t,e,n),a=H("dynamicSize",t,e,n),i=H("clearAfterRead",t,e,n),l=H("identicalElementShapes",t,e,n),u=H("name",t,e,n),c=new qgt(u,r,s,o,l,a,i);return n.addTensorArray(c),[c.idTensor,Pt(1)]}case"TensorArrayWriteV3":{const s=H("tensorArrayId",t,e,n),r=H("index",t,e,n),o=H("tensor",t,e,n),a=n.getTensorArray(s.id);return a.write(r,o),[a.idTensor]}case"TensorArrayReadV3":{const s=H("tensorArrayId",t,e,n),r=H("index",t,e,n);return[n.getTensorArray(s.id).read(r)]}case"TensorArrayGatherV3":{const s=H("tensorArrayId",t,e,n),r=H("indices",t,e,n),o=H("dtype",t,e,n);return[n.getTensorArray(s.id).gather(r,o)]}case"TensorArrayScatterV3":{const s=H("tensorArrayId",t,e,n),r=H("indices",t,e,n),o=H("tensor",t,e,n),a=n.getTensorArray(s.id);return a.scatter(r,o),[a.idTensor]}case"TensorArrayConcatV3":{const s=H("tensorArrayId",t,e,n),r=n.getTensorArray(s.id),o=H("dtype",t,e,n);return[r.concat(o)]}case"TensorArraySplitV3":{const s=H("tensorArrayId",t,e,n),r=H("tensor",t,e,n),o=H("lengths",t,e,n),a=n.getTensorArray(s.id);return a.split(o,r),[a.idTensor]}case"TensorArraySizeV3":{const s=H("tensorArrayId",t,e,n),r=n.getTensorArray(s.id);return[Pt(r.size(),"int32")]}case"TensorArrayCloseV3":{const s=H("tensorArrayId",t,e,n),r=n.getTensorArray(s.id);return r.clearAndClose(),[r.idTensor]}case"TensorListSetItem":{const s=H("tensorListId",t,e,n),r=H("index",t,e,n),o=H("tensor",t,e,n),a=n.getTensorList(s.id);return a.setItem(r,o),[a.idTensor]}case"TensorListGetItem":{const s=H("tensorListId",t,e,n),r=H("index",t,e,n),o=H("elementShape",t,e,n),a=H("elementDType",t,e,n);return[n.getTensorList(s.id).getItem(r,o,a)]}case"TensorListScatterV2":case"TensorListScatter":{const s=H("indices",t,e,n),r=H("tensor",t,e,n),o=H("elementShape",t,e,n),a=H("numElements",t,e,n),i=Zgt(r,s,o,a);return n.addTensorList(i),[i.idTensor]}case"TensorListReserve":case"EmptyTensorList":{const s=H("elementShape",t,e,n),r=H("elementDType",t,e,n);let o;t.op==="TensorListReserve"?o="numElements":o="maxNumElements";const a=H(o,t,e,n),i=t.op==="TensorListReserve"?-1:a,l=Ygt(s,r,a,i);return n.addTensorList(l),[l.idTensor]}case"TensorListGather":{const s=H("tensorListId",t,e,n),r=H("indices",t,e,n),o=H("elementShape",t,e,n),a=H("elementDType",t,e,n);return[n.getTensorList(s.id).gather(r,a,o)]}case"TensorListStack":{const s=H("tensorListId",t,e,n),r=H("elementShape",t,e,n),o=H("elementDType",t,e,n),a=H("numElements",t,e,n);return[n.getTensorList(s.id).stack(r,o,a)]}case"TensorListFromTensor":{const s=H("tensor",t,e,n),r=H("elementShape",t,e,n),o=H("elementDType",t,e,n),a=Xgt(s,r,o);return n.addTensorList(a),[a.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{const s=H("tensorListId",t,e,n),r=n.getTensorList(s.id),o=H("dtype",t,e,n),a=H("elementShape",t,e,n);return[r.concat(o,a)]}case"TensorListPushBack":{const s=H("tensorListId",t,e,n),r=H("tensor",t,e,n),o=n.getTensorList(s.id);return o.pushBack(r),[o.idTensor]}case"TensorListPopBack":{const s=H("tensorListId",t,e,n),r=H("elementShape",t,e,n),o=H("elementDType",t,e,n);return[n.getTensorList(s.id).popBack(r,o)]}case"TensorListSplit":{const s=H("tensor",t,e,n),r=H("elementShape",t,e,n),o=H("lengths",t,e,n),a=Jgt(s,o,r);return n.addTensorList(a),[a.idTensor]}case"TensorListLength":{const s=H("tensorListId",t,e,n),r=n.getTensorList(s.id);return[Pt(r.size(),"int32")]}case"TensorListResize":{const s=H("tensorListId",t,e,n),r=H("size",t,e,n),a=n.getTensorList(s.id).resize(r);return n.addTensorList(a),[a.idTensor]}default:throw TypeError(`Node type ${t.op} is not implemented`)}};function OD(t,e,n){const[s,r]=H("fusedOps",t,e,n),o=s==="biasadd",a=!o,i=r==="prelu",l=s==="fusedbatchnorm",u=H("numArgs",t,e,n);if(o){if(i&&u!==2)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!i&&o&&u!==1)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(l)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");const c=H("strides",t,e,n),d=hy(t,e,n),f=H("dataFormat",t,e,n).toUpperCase(),h=H("dilations",t,e,n);let[p,m]=H("args",t,e,n);a&&(m=p,p=void 0);const g=H("leakyreluAlpha",t,e,n);return{stride:c,pad:d,dataFormat:f,dilations:h,biasArg:p,preluArg:m,activationFunc:r,leakyreluAlpha:g}}const e1t=(t,e,n,s=dr)=>{switch(t.op){case"Conv1D":{const r=H("stride",t,e,n),o=H("pad",t,e,n),a=H("dataFormat",t,e,n).toUpperCase(),i=H("dilation",t,e,n);return[s.conv1d(H("x",t,e,n),H("filter",t,e,n),r,o,a,i)]}case"Conv2D":{const r=H("strides",t,e,n),o=hy(t,e,n),a=H("dataFormat",t,e,n).toUpperCase(),i=H("dilations",t,e,n);return[s.conv2d(H("x",t,e,n),H("filter",t,e,n),[r[1],r[2]],o,a,[i[1],i[2]])]}case"_FusedConv2D":{const{stride:r,pad:o,dataFormat:a,dilations:i,biasArg:l,preluArg:u,activationFunc:c,leakyreluAlpha:d}=OD(t,e,n);return[s.fused.conv2d({x:H("x",t,e,n),filter:H("filter",t,e,n),strides:[r[1],r[2]],pad:o,dataFormat:a,dilations:[i[1],i[2]],bias:l,activation:c,preluActivationWeights:u,leakyreluAlpha:d})]}case"FusedDepthwiseConv2dNative":{const{stride:r,pad:o,dataFormat:a,dilations:i,biasArg:l,preluArg:u,activationFunc:c,leakyreluAlpha:d}=OD(t,e,n);return[s.fused.depthwiseConv2d({x:H("x",t,e,n),filter:H("filter",t,e,n),strides:[r[1],r[2]],pad:o,dataFormat:a,dilations:[i[1],i[2]],bias:l,activation:c,preluActivationWeights:u,leakyreluAlpha:d})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{const r=H("outputShape",t,e,n),o=H("strides",t,e,n),a=hy(t,e,n);return[s.conv2dTranspose(H("x",t,e,n),H("filter",t,e,n),r,[o[1],o[2]],a)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{const r=H("strides",t,e,n),o=hy(t,e,n),a=H("dilations",t,e,n),i=H("dataFormat",t,e,n).toUpperCase();return[s.depthwiseConv2d(H("input",t,e,n),H("filter",t,e,n),[r[1],r[2]],o,i,[a[1],a[2]])]}case"Conv3D":{const r=H("strides",t,e,n),o=H("pad",t,e,n),a=H("dataFormat",t,e,n).toUpperCase(),i=H("dilations",t,e,n);return[s.conv3d(H("x",t,e,n),H("filter",t,e,n),[r[1],r[2],r[3]],o,a,[i[1],i[2],i[3]])]}case"AvgPool":{const r=H("strides",t,e,n),o=H("pad",t,e,n),a=H("kernelSize",t,e,n);return[s.avgPool(H("x",t,e,n),[a[1],a[2]],[r[1],r[2]],o)]}case"MaxPool":{const r=H("strides",t,e,n),o=H("pad",t,e,n),a=H("kernelSize",t,e,n);return[s.maxPool(H("x",t,e,n),[a[1],a[2]],[r[1],r[2]],o)]}case"MaxPoolWithArgmax":{const r=H("strides",t,e,n),o=H("pad",t,e,n),a=H("kernelSize",t,e,n),i=H("includeBatchInIndex",t,e,n),{result:l,indexes:u}=s.maxPoolWithArgmax(H("x",t,e,n),[a[1],a[2]],[r[1],r[2]],o,i);return[l,u]}case"AvgPool3D":{const r=H("strides",t,e,n),o=H("pad",t,e,n),a=H("kernelSize",t,e,n);return[s.avgPool3d(H("x",t,e,n),[a[1],a[2],a[3]],[r[1],r[2],r[3]],o)]}case"MaxPool3D":{const r=H("strides",t,e,n),o=H("pad",t,e,n),a=H("kernelSize",t,e,n);return[s.maxPool3d(H("x",t,e,n),[a[1],a[2],a[3]],[r[1],r[2],r[3]],o)]}case"Dilation2D":{const r=H("strides",t,e,n),o=H("pad",t,e,n),a=H("dilations",t,e,n),i=r[1],l=r[2],u=a[1],c=a[2];return[s.dilation2d(H("x",t,e,n),H("filter",t,e,n),[i,l],o,[u,c],"NHWC")]}default:throw TypeError(`Node type ${t.op} is not implemented`)}};const t1t=(t,e,n,s=dr)=>{switch(t.op){case"Fill":{const r=H("shape",t,e,n),o=H("dtype",t,e,n),a=H("value",t,e,n);return[s.fill(r,a,o)]}case"LinSpace":{const r=H("start",t,e,n),o=H("stop",t,e,n),a=H("num",t,e,n);return[s.linspace(r,o,a)]}case"Multinomial":{const r=H("logits",t,e,n),o=H("numSamples",t,e,n),a=H("seed",t,e,n);return[s.multinomial(r,o,a)]}case"OneHot":{const r=H("indices",t,e,n),o=H("depth",t,e,n),a=H("onValue",t,e,n),i=H("offValue",t,e,n),l=H("dtype",t,e,n);return[s.oneHot(r,o,a,i,l)]}case"Ones":return[s.ones(H("shape",t,e,n),H("dtype",t,e,n))];case"OnesLike":return[s.onesLike(H("x",t,e,n))];case"RandomStandardNormal":return[s.randomStandardNormal(H("shape",t,e,n),H("dtype",t,e,n),H("seed",t,e,n))];case"RandomUniform":return[s.randomUniform(H("shape",t,e,n),H("minval",t,e,n),H("maxval",t,e,n),H("dtype",t,e,n))];case"Range":{const r=H("start",t,e,n),o=H("stop",t,e,n),a=H("step",t,e,n);return[s.range(r,o,a,H("dtype",t,e,n))]}case"TruncatedNormal":{const r=H("shape",t,e,n),o=H("mean",t,e,n),a=H("stdDev",t,e,n),i=H("seed",t,e,n);return[s.truncatedNormal(r,o,a,H("dtype",t,e,n),i)]}case"Zeros":return[s.zeros(H("shape",t,e,n),H("dtype",t,e,n))];case"ZerosLike":return[s.zerosLike(H("x",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};function C$(t,e,n){const s=H("boxes",t,e,n),r=H("scores",t,e,n),o=H("maxOutputSize",t,e,n),a=H("iouThreshold",t,e,n),i=H("scoreThreshold",t,e,n),l=H("softNmsSigma",t,e,n);return{boxes:s,scores:r,maxOutputSize:o,iouThreshold:a,scoreThreshold:i,softNmsSigma:l}}const n1t=async(t,e,n,s,r=dr)=>{switch(t.op){case"NonMaxSuppressionV5":{const{boxes:o,scores:a,maxOutputSize:i,iouThreshold:l,scoreThreshold:u,softNmsSigma:c}=C$(t,e,n),d=await r.image.nonMaxSuppressionWithScoreAsync(o,a,i,l,u,c);return[d.selectedIndices,d.selectedScores]}case"NonMaxSuppressionV4":{const{boxes:o,scores:a,maxOutputSize:i,iouThreshold:l,scoreThreshold:u}=C$(t,e,n),c=H("padToMaxOutputSize",t,e,n),d=await r.image.nonMaxSuppressionPaddedAsync(o,a,i,l,u,c);return[d.selectedIndices,d.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{const{boxes:o,scores:a,maxOutputSize:i,iouThreshold:l,scoreThreshold:u}=C$(t,e,n);return[await r.image.nonMaxSuppressionAsync(o,a,i,l,u)]}case"Where":{const o=r.cast(H("condition",t,e,n),"bool"),a=[await r.whereAsync(o)];return o.dispose(),a}case"ListDiff":return r.setdiff1dAsync(H("x",t,e,n),H("y",t,e,n));default:throw TypeError(`Node type ${t.op} is not implemented`)}};const s1t=(t,e,n,s=dr)=>{switch(t.op){case"LowerBound":{const r=H("sortedSequence",t,e,n),o=H("values",t,e,n);return[s.lowerBound(r,o)]}case"TopKV2":{const r=H("x",t,e,n),o=H("k",t,e,n),a=H("sorted",t,e,n),i=s.topk(r,o,a);return[i.values,i.indices]}case"UpperBound":{const r=H("sortedSequence",t,e,n),o=H("values",t,e,n);return[s.upperBound(r,o)]}case"Unique":{const r=H("x",t,e,n),o=s.unique(r);return[o.values,o.indices]}case"UniqueV2":{const r=H("x",t,e,n),o=H("axis",t,e,n),a=s.unique(r,o);return[a.values,a.indices]}default:throw TypeError(`Node type ${t.op} is not implemented`)}};const r1t=(t,e,n,s=dr)=>{switch(t.op){case"Const":return e[t.name];case"PlaceholderWithDefault":const r=H("default",t,e,n);return[Nr(t.name,e,n)||r];case"Placeholder":return[Nr(t.name,e,n)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":{const c=H("x",t,e,n);return[ul(c)]}case"IdentityN":return H("x",t,e,n).map(c=>ul(c));case"Snapshot":const o=H("x",t,e,n);return[ul(o)];case"Shape":return[s.tensor1d(H("x",t,e,n).shape,"int32")];case"ShapeN":return H("x",t,e,n).map(c=>s.tensor1d(c.shape));case"Size":return[s.scalar(H("x",t,e,n).size,"int32")];case"Rank":return[s.scalar(H("x",t,e,n).rank,"int32")];case"NoOp":return[s.scalar(1)];case"Print":const a=H("x",t,e,n),i=H("data",t,e,n),l=H("message",t,e,n),u=H("summarize",t,e,n);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(l);for(let c=0;c<i.length;c++)console.log(Array.prototype.slice.call(i[c].dataSync()).slice(0,u));return[a];default:throw TypeError(`Node type ${t.op} is not implemented`)}};let o1t=class{constructor(e,n){this.keyDType=e,this.valueDType=n,this.handle=Pt(0),this.tensorMap=new Map,As(this.handle)}get id(){return this.handle.id}clearAndClose(){this.tensorMap.forEach(e=>e.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return Pt(this.size(),"int32")}async import(e,n){this.checkKeyAndValueTensor(e,n);const s=await e.data();return this.tensorMap.forEach(r=>r.dispose()),this.tensorMap.clear(),Le(()=>{const r=Yo(n),o=s.length,a=r.length;q(o===a,()=>`The number of elements doesn't match, keys has ${o} elements, the values has ${a} elements.`);for(let i=0;i<o;i++){const l=s[i],u=r[i];As(u),this.tensorMap.set(l,u)}return this.handle})}async find(e,n){this.checkKeyAndValueTensor(e,n);const s=await e.data();return Le(()=>{const r=[];for(let o=0;o<s.length;o++){const a=s[o],i=this.findWithDefault(a,n);r.push(i)}return Jr(r)})}findWithDefault(e,n){const s=this.tensorMap.get(e);return s??n}checkKeyAndValueTensor(e,n){if(e.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${e.dtype}`);if(n.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${n.dtype}`)}};const a1t=async(t,e,n,s)=>{switch(t.op){case"HashTable":case"HashTableV2":{const r=s.getHashTableHandleByName(t.name);if(r!=null)return[r];{const o=H("keyDType",t,e,n),a=H("valueDType",t,e,n),i=new o1t(o,a);return s.addHashTable(t.name,i),[i.handle]}}case"InitializeTable":case"InitializeTableV2":case"LookupTableImport":case"LookupTableImportV2":{const r=H("tableHandle",t,e,n,s),o=H("keys",t,e,n),a=H("values",t,e,n);return[await s.getHashTableById(r.id).import(o,a)]}case"LookupTableFind":case"LookupTableFindV2":{const r=H("tableHandle",t,e,n,s),o=H("keys",t,e,n),a=H("defaultValue",t,e,n);return[await s.getHashTableById(r.id).find(o,a)]}case"LookupTableSize":case"LookupTableSizeV2":{const r=H("tableHandle",t,e,n,s);return[s.getHashTableById(r.id).tensorSize()]}default:throw TypeError(`Node type ${t.op} is not implemented`)}};const i1t=(t,e,n,s=dr)=>{switch(t.op){case"ResizeBilinear":{const r=H("images",t,e,n),o=H("size",t,e,n),a=H("alignCorners",t,e,n),i=H("halfPixelCenters",t,e,n);return[s.image.resizeBilinear(r,[o[0],o[1]],a,i)]}case"ResizeNearestNeighbor":{const r=H("images",t,e,n),o=H("size",t,e,n),a=H("alignCorners",t,e,n),i=H("halfPixelCenters",t,e,n);return[s.image.resizeNearestNeighbor(r,[o[0],o[1]],a,i)]}case"CropAndResize":{const r=H("image",t,e,n),o=H("boxes",t,e,n),a=H("boxInd",t,e,n),i=H("cropSize",t,e,n),l=H("method",t,e,n),u=H("extrapolationValue",t,e,n);return[s.image.cropAndResize(r,o,a,i,l,u)]}case"ImageProjectiveTransformV3":{const r=H("images",t,e,n),o=H("transforms",t,e,n),a=H("outputShape",t,e,n),i=H("fillValue",t,e,n),l=H("interpolation",t,e,n),u=H("fillMode",t,e,n);return[s.image.transform(r,o,l.toLowerCase(),u.toLowerCase(),i,a)]}default:throw TypeError(`Node type ${t.op} is not implemented`)}};const l1t=(t,e,n,s=dr)=>{switch(t.op){case"Equal":return[s.equal(H("a",t,e,n),H("b",t,e,n))];case"NotEqual":return[s.notEqual(H("a",t,e,n),H("b",t,e,n))];case"Greater":return[s.greater(H("a",t,e,n),H("b",t,e,n))];case"GreaterEqual":return[s.greaterEqual(H("a",t,e,n),H("b",t,e,n))];case"Less":return[s.less(H("a",t,e,n),H("b",t,e,n))];case"LessEqual":return[s.lessEqual(H("a",t,e,n),H("b",t,e,n))];case"LogicalAnd":return[s.logicalAnd(H("a",t,e,n),H("b",t,e,n))];case"LogicalNot":return[s.logicalNot(H("a",t,e,n))];case"LogicalOr":return[s.logicalOr(H("a",t,e,n),H("b",t,e,n))];case"Select":case"SelectV2":return[s.where(H("condition",t,e,n),H("a",t,e,n),H("b",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};const u1t=(t,e,n,s=dr)=>{switch(t.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[s.matMul(H("a",t,e,n),H("b",t,e,n),H("transposeA",t,e,n),H("transposeB",t,e,n))];case"Einsum":return[s.einsum(H("equation",t,e,n),...H("tensors",t,e,n))];case"Transpose":return[s.transpose(H("x",t,e,n),H("perm",t,e,n))];case"_FusedMatMul":const[r,o]=H("fusedOps",t,e,n),a=r==="biasadd",i=o==="prelu",l=H("numArgs",t,e,n),u=H("leakyreluAlpha",t,e,n);if(a){if(i&&l!==2)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!i&&l!==1)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}const[c,d]=H("args",t,e,n);return[s.fused.matMul({a:H("a",t,e,n),b:H("b",t,e,n),transposeA:H("transposeA",t,e,n),transposeB:H("transposeB",t,e,n),bias:c,activation:o,preluActivationWeights:d,leakyreluAlpha:u})];default:throw TypeError(`Node type ${t.op} is not implemented`)}};const c1t=(t,e,n,s=dr)=>{switch(t.op){case"EuclideanNorm":return[s.euclideanNorm(H("x",t,e,n),H("axis",t,e,n),H("keepDims",t,e,n))];case"FusedBatchNorm":case"FusedBatchNormV2":return[s.batchNorm(H("x",t,e,n),H("mean",t,e,n),H("variance",t,e,n),H("offset",t,e,n),H("scale",t,e,n),H("epsilon",t,e,n))];case"FusedBatchNormV3":return[s.batchNorm(H("x",t,e,n),H("mean",t,e,n),H("variance",t,e,n),H("offset",t,e,n),H("scale",t,e,n),H("epsilon",t,e,n))];case"LRN":return[s.localResponseNormalization(H("x",t,e,n),H("radius",t,e,n),H("bias",t,e,n),H("alpha",t,e,n),H("beta",t,e,n))];case"Softmax":return[s.softmax(H("x",t,e,n))];case"LogSoftmax":return[s.logSoftmax(H("x",t,e,n))];case"SparseToDense":return[s.sparseToDense(H("sparseIndices",t,e,n),H("outputShape",t,e,n),H("sparseValues",t,e,n),H("defaultValue",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};const d1t=(t,e,n,s=dr)=>{switch(t.op){case"RaggedGather":{const{outputNestedSplits:r,outputDenseValues:o}=s.raggedGather(H("paramsNestedSplits",t,e,n),H("paramsDenseValues",t,e,n),H("indices",t,e,n),H("outputRaggedRank",t,e,n));return r.concat(o)}case"RaggedRange":{const{rtNestedSplits:r,rtDenseValues:o}=s.raggedRange(H("starts",t,e,n),H("limits",t,e,n),H("splits",t,e,n));return[r,o]}case"RaggedTensorToTensor":return[s.raggedTensorToTensor(H("shape",t,e,n),H("values",t,e,n),H("defaultValue",t,e,n),H("rowPartitionTensors",t,e,n),H("rowPartitionTypes",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};const f1t=(t,e,n,s=dr)=>{switch(t.op){case"Max":{const i=H("axis",t,e,n),l=H("keepDims",t,e,n);return[s.max(H("x",t,e,n),i,l)]}case"Mean":{const i=H("axis",t,e,n),l=H("keepDims",t,e,n);return[s.mean(H("x",t,e,n),i,l)]}case"Min":{const i=H("axis",t,e,n),l=H("keepDims",t,e,n);return[s.min(H("x",t,e,n),i,l)]}case"Sum":{const i=H("axis",t,e,n),l=H("keepDims",t,e,n);return[s.sum(H("x",t,e,n),i,l)]}case"All":{const i=H("axis",t,e,n),l=H("keepDims",t,e,n);return[s.all(H("x",t,e,n),i,l)]}case"Any":{const i=H("axis",t,e,n),l=H("keepDims",t,e,n);return[s.any(H("x",t,e,n),i,l)]}case"ArgMax":{const i=H("axis",t,e,n);return[s.argMax(H("x",t,e,n),i)]}case"ArgMin":{const i=H("axis",t,e,n);return[s.argMin(H("x",t,e,n),i)]}case"Prod":{const i=H("axis",t,e,n),l=H("keepDims",t,e,n);return[s.prod(H("x",t,e,n),i,l)]}case"Cumprod":{const i=H("axis",t,e,n),l=H("exclusive",t,e,n),u=H("reverse",t,e,n);return[s.cumprod(H("x",t,e,n),i,l,u)]}case"Cumsum":{const i=H("axis",t,e,n),l=H("exclusive",t,e,n),u=H("reverse",t,e,n);return[s.cumsum(H("x",t,e,n),i,l,u)]}case"Bincount":const r=H("x",t,e,n),o=H("weights",t,e,n),a=H("size",t,e,n);return[s.bincount(r,o,a)];case"DenseBincount":{const i=H("x",t,e,n),l=H("weights",t,e,n),u=H("size",t,e,n),c=H("binaryOutput",t,e,n);return[s.denseBincount(i,l,u,c)]}default:throw TypeError(`Node type ${t.op} is not implemented`)}};const h1t=(t,e,n,s=dr)=>{switch(t.op){case"ConcatV2":case"Concat":{const r=H("n",t,e,n),o=H("axis",t,e,n);let a=H("tensors",t,e,n);return a=a.slice(0,r),[s.concat(a,o)]}case"Gather":{const r=H("x",t,e,n),o=H("indices",t,e,n);return[s.gather(r,s.cast(o,"int32"),0)]}case"GatherV2":{const r=H("axis",t,e,n),o=H("batchDims",t,e,n),a=H("x",t,e,n),i=H("indices",t,e,n);return[s.gather(a,s.cast(i,"int32"),r,o)]}case"Reverse":{const r=H("dims",t,e,n),o=[];for(let i=0;i<r.length;i++)r[i]&&o.push(i);const a=H("x",t,e,n);return[s.reverse(a,o)]}case"ReverseV2":{const r=H("axis",t,e,n),o=H("x",t,e,n);return[s.reverse(o,r)]}case"Slice":{const r=H("begin",t,e,n),o=H("size",t,e,n);return[s.slice(H("x",t,e,n),r,o)]}case"StridedSlice":{const r=H("begin",t,e,n),o=H("end",t,e,n),a=H("strides",t,e,n),i=H("beginMask",t,e,n),l=H("endMask",t,e,n),u=H("ellipsisMask",t,e,n),c=H("newAxisMask",t,e,n),d=H("shrinkAxisMask",t,e,n),f=H("x",t,e,n);return[s.stridedSlice(f,r,o,a,i,l,u,c,d)]}case"Pack":return Le(()=>{const r=H("axis",t,e,n),o=H("tensors",t,e,n),a=o[0].shape,i=s.squeeze(o[0]).shape,l=o.map(u=>{const c=hn(u.shape,a);if(!c&&!hn(s.squeeze(u).shape,i))throw new Error("the input tensors shape does not match");return c?u:s.reshape(u,a)});return[s.stack(l,r)]});case"Unpack":{const r=H("axis",t,e,n),o=H("tensor",t,e,n);return s.unstack(o,r)}case"Tile":{const r=H("reps",t,e,n);return[s.tile(H("x",t,e,n),r)]}case"Split":case"SplitV":{const r=H("axis",t,e,n),o=H("numOrSizeSplits",t,e,n),a=H("x",t,e,n);return s.split(a,o,r)}case"ScatterNd":{const r=H("indices",t,e,n),o=H("values",t,e,n),a=H("shape",t,e,n);return[s.scatterND(r,o,a)]}case"GatherNd":{const r=H("x",t,e,n),o=H("indices",t,e,n);return[s.gatherND(r,o)]}case"SparseToDense":{const r=H("sparseIndices",t,e,n),o=H("outputShape",t,e,n),a=H("sparseValues",t,e,n),i=H("defaultValue",t,e,n);return[s.sparseToDense(r,a,o,a.dtype===i.dtype?i:s.cast(i,a.dtype))]}default:throw TypeError(`Node type ${t.op} is not implemented`)}};const p1t=(t,e,n,s=dr)=>{switch(t.op){case"SparseFillEmptyRows":{const{outputIndices:r,outputValues:o,emptyRowIndicator:a,reverseIndexMap:i}=s.sparse.sparseFillEmptyRows(H("indices",t,e,n),H("values",t,e,n),H("denseShape",t,e,n),H("defaultValue",t,e,n));return[r,o,a,i]}case"SparseReshape":{const{outputIndices:r,outputShape:o}=s.sparse.sparseReshape(H("inputIndices",t,e,n),H("inputShape",t,e,n),H("newShape",t,e,n));return[r,o]}case"SparseSegmentMean":return[s.sparse.sparseSegmentMean(H("data",t,e,n),H("indices",t,e,n),H("segmentIds",t,e,n))];case"SparseSegmentSum":return[s.sparse.sparseSegmentSum(H("data",t,e,n),H("indices",t,e,n),H("segmentIds",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};const m1t=(t,e,n,s=dr)=>{switch(t.op){case"FFT":return[s.fft(H("x",t,e,n))];case"IFFT":return[s.ifft(H("x",t,e,n))];case"RFFT":return[s.rfft(H("x",t,e,n))];case"IRFFT":return[s.irfft(H("x",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};const g1t=(t,e,n,s=dr)=>{switch(t.op){case"StringNGrams":{const{nGrams:r,nGramsSplits:o}=s.string.stringNGrams(H("data",t,e,n),H("dataSplits",t,e,n),H("separator",t,e,n),H("nGramWidths",t,e,n),H("leftPad",t,e,n),H("rightPad",t,e,n),H("padWidth",t,e,n),H("preserveShortSequences",t,e,n));return[r,o]}case"StringSplit":{const{indices:r,values:o,shape:a}=s.string.stringSplit(H("input",t,e,n),H("delimiter",t,e,n),H("skipEmpty",t,e,n));return[r,o,a]}case"StringToHashBucketFast":return[s.string.stringToHashBucketFast(H("input",t,e,n),H("numBuckets",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};const v1t=(t,e,n,s=dr)=>{switch(t.op){case"Cast":return[s.cast(H("x",t,e,n),H("dtype",t,e,n))];case"ExpandDims":{const r=H("axis",t,e,n);return[s.expandDims(H("x",t,e,n),r)]}case"Squeeze":{const r=H("axis",t,e,n);return[s.squeeze(H("x",t,e,n),r)]}case"Reshape":return[s.reshape(H("x",t,e,n),H("shape",t,e,n))];case"MirrorPad":return[s.mirrorPad(H("x",t,e,n),H("padding",t,e,n),H("mode",t,e,n))];case"PadV2":case"Pad":return[s.pad(H("x",t,e,n),H("padding",t,e,n),H("constantValue",t,e,n))];case"SpaceToBatchND":{const r=H("blockShape",t,e,n),o=H("paddings",t,e,n);return[s.spaceToBatchND(H("x",t,e,n),r,o)]}case"BatchToSpaceND":{const r=H("blockShape",t,e,n),o=H("crops",t,e,n);return[s.batchToSpaceND(H("x",t,e,n),r,o)]}case"DepthToSpace":{const r=H("blockSize",t,e,n),o=H("dataFormat",t,e,n).toUpperCase();return[s.depthToSpace(H("x",t,e,n),r,o)]}case"BroadcastTo":return[s.broadcastTo(H("x",t,e,n),H("shape",t,e,n))];case"BroadcastArgs":return[s.broadcastArgs(H("s0",t,e,n),H("s1",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};function RD(t,e,n,s,r=Le){const o=((a,i,l)=>{switch(a.category){case"arithmetic":return r(()=>jgt(a,i,l));case"basic_math":return r(()=>Kgt(a,i,l));case"control":return Qgt(a,i,l);case"convolution":return r(()=>e1t(a,i,l));case"creation":return r(()=>t1t(a,i,l));case"dynamic":return n1t(a,i,l);case"evaluation":return r(()=>s1t(a,i,l));case"image":return r(()=>i1t(a,i,l));case"graph":return r(()=>r1t(a,i,l));case"logical":return r(()=>l1t(a,i,l));case"matrices":return r(()=>u1t(a,i,l));case"normalization":return r(()=>c1t(a,i,l));case"ragged":return r(()=>d1t(a,i,l));case"reduction":return r(()=>f1t(a,i,l));case"slice_join":return r(()=>h1t(a,i,l));case"sparse":return r(()=>p1t(a,i,l));case"spectral":return r(()=>m1t(a,i,l));case"string":return r(()=>g1t(a,i,l));case"transformation":return r(()=>v1t(a,i,l));case"hash_table":return a1t(a,i,l,s);case"custom":const u=cU(a.op);if(u&&u.customExecutor)return u.customExecutor(new Ggt(a,i,l));throw TypeError(`Custom op ${a.op} is not registered.`);default:throw TypeError(`Unknown op '${a.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(t,e,n);return Yu(o)?o.then(a=>[].concat(a)):[].concat(o)}let DD=class{constructor(e={},n={},s={},r={}){this.weightMap=e,this.tensorArrayMap=n,this.tensorListMap=s,this.functionMap=r,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(e,n){return{id:e,frameName:n,iterationId:0}}set currentContext(e){this.contexts!==e&&(this.contexts=e,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){const e=[];for(let n=0;n<this.contexts.length-1;n++){const s=this.contexts.slice(0,this.contexts.length-n);e.push(this.contextIdforContexts(s))}e.push(""),this._currentContextIds=e}contextIdforContexts(e){return e?e.map(n=>n.id===0&&n.iterationId===0?"":`${n.frameName}-${n.iterationId}`).join("/"):""}enterFrame(e){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,e)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(this.contexts&&this.contexts.length>1)this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift();else throw new Error("Cannot exit frame, the context is empty")}nextIteration(){if(this.contexts&&this.contexts.length>0){this.contexts=this.contexts.slice(),this.lastId++;const e=Object.assign({},this.contexts[this.contexts.length-1]);e.iterationId+=1,e.id=this.lastId,this.contexts.splice(-1,1,e),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}else throw new Error("Cannot increase frame iteration, the context is empty")}getWeight(e){return this.weightMap[e]}addTensorArray(e){this.tensorArrayMap[e.id]=e}getTensorArray(e){return this.tensorArrayMap[e]}addTensorList(e){this.tensorListMap[e.id]=e}getTensorList(e){return this.tensorListMap[e]}dispose(e){for(const n in this.tensorArrayMap)this.tensorArrayMap[n].clearAndClose(e);for(const n in this.tensorListMap)this.tensorListMap[n].clearAndClose(e)}};function FD(t,e,n,s){const r=new Set,o=[];let a=null,i=null;const l=new Set,u=Object.keys(t).map(f=>lo(f)[0]);let c=[];s!=null&&(c=s.map(f=>lo(f.name)[0]));const d=[...e];for(;d.length>0;){const f=d.pop();if((hU(f)||$1t(f)||x1t(f))&&a==null&&(a=f,i=a.children.map(h=>h.name).filter(h=>r.has(h))),r.add(f.name),n[f.name]==null&&u.indexOf(f.name)===-1&&c.indexOf(f.name)===-1){if(f.inputs.length===0){o.push(f.name);continue}f.inputs.forEach(h=>{l.has(h.name)||(l.add(h.name),d.push(h))})}}return{inputs:t,outputs:e,usedNodes:r,missingInputs:o,dynamicNode:a,syncInputs:i}}function y1t(t,e,n){const{usedNodes:s,inputs:r}=n,o=[],a=Object.keys(r).map(c=>lo(c)[0]).map(c=>t.nodes[c]),i=t.initNodes;a.forEach(c=>{s.has(c.name)&&o.push(c)}),t.weights.forEach(c=>{s.has(c.name)&&o.push(c)}),i!=null&&i.forEach(c=>{s.has(c.name)&&o.push(c)});const l=new Set,u=[];for(;o.length>0;){const c=o.pop();l.add(c.name),e[c.name]||u.push(c),c.children.forEach(d=>{!l.has(d.name)&&s.has(d.name)&&d.inputs.every(f=>l.has(f.name))&&o.push(d)})}return u}const b1t=["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"],w1t=["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"],_1t=["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"];function hU(t){return b1t.indexOf(t.op)>=0}function $1t(t){return w1t.indexOf(t.op)>=0}function x1t(t){return _1t.indexOf(t.op)>=0}let Xx=class{constructor(e,n){this.graph=e,this.parent=n,this.compiledMap=new Map,this._weightMap={},this.SEPERATOR=",",this._functions={},this._functionExecutorMap={},this.keepIntermediateTensors=!1,this._outputs=e.outputs,this._inputs=e.inputs,this._initNodes=e.initNodes,this._signature=e.signature,this._functions=e.functions,e.functions!=null&&Object.keys(e.functions).forEach(s=>{this._functionExecutorMap[s]=new Xx(e.functions[s],this)})}get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(e){const n=Object.keys(e).map(s=>e[s].map(r=>r.id));this._weightIds=[].concat(...n),this._weightMap=e}set resourceManager(e){this._resourceManager=e}get inputs(){return this._inputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(e=>e.signatureKey||e.name)}get outputNodes(){return this._outputs.map(e=>{const n=e.signatureKey||e.name;return e.defaultOutput?`${n}:${e.defaultOutput}`:n})}get functions(){return Object.keys(this._functions).reduce((e,n)=>(e[n]=this._functions[n].signature,e),{})}getCompilationKey(e,n){const s=e.map(o=>o.name).sort(),r=n.map(o=>o.name).sort();return s.join(this.SEPERATOR)+"--"+r.join(this.SEPERATOR)}compile(e,n){const s=FD(e,n,this.weightMap,this._initNodes),{missingInputs:r,dynamicNode:o,syncInputs:a}=s;if(o!=null)throw new Error(`This execution contains the node '${o.name}', which has the dynamic op '${o.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${a}]`);if(r.length>0){const i=n.map(u=>u.name),l=Object.keys(e);throw new Error(`Cannot compute the outputs [${i}] from the provided inputs [${l}]. Missing the following inputs: [${r}]`)}return y1t(this.graph,this.weightMap,s)}cloneAndKeepTensor(e){if(e==null)return null;const n=e.clone();return As(n),n}cloneTensorList(e){return e?e.map(s=>this.cloneAndKeepTensor(s)):null}cloneTensorMap(e){return Object.fromEntries(Object.entries(e).map(([n,s])=>[n,this.cloneTensorList(s)]))}execute(e,n){this.disposeIntermediateTensors(),e=this.mapInputs(e);const s=Object.keys(e).sort();this.checkInputs(e),this.checkInputShapeAndType(e),n=this.mapOutputs(n),this.checkOutputs(n);const r=s.map(d=>this.graph.nodes[lo(d)[0]]),o=n.map(d=>lo(d)[0]);let a=o.map(d=>this.graph.nodes[d]);a.length===0&&(a=this._outputs);const i=this.getCompilationKey(r,a);let l=this.compiledMap.get(i);l==null&&(l=this.compile(e,a),this.compiledMap.set(i,l));try{this.keepIntermediateTensors=Be().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(d){this.keepIntermediateTensors=!1,console.warn(d.message)}const u={},c={};return Le(()=>{const d=new DD(this.weightMap,u,c,this.functionExecutorMap),f=Object.assign({},this.weightMap);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap)),Object.keys(e).forEach(m=>{const[g,y]=lo(m),w=[];w[y]=e[m],f[g]=w,this.keepIntermediateTensors&&(this.clonedTensorsMap[g]=this.cloneTensorList(w))});const h=this.getFrozenTensorIds(f),p={};for(let m=0;m<l.length;m++){const g=l[m];if(!f[g.name]){const y=RD(g,f,d,this._resourceManager);if(Yu(y))throw new Error(`The execution of the op '${g.op}' returned a promise. Please use model.executeAsync() instead.`);f[g.name]=y,this.keepIntermediateTensors&&(this.clonedTensorsMap[g.name]=this.cloneTensorList(y)),this.checkTensorForDisposal(g.name,g,f,d,h,o,p)}}return this.parent==null&&d.dispose(h),n.map(m=>Nr(m,f,d))})}getFrozenTensorIds(e){const n=[].concat.apply([],Object.keys(e).map(s=>e[s]).map(s=>s.map(r=>r.id)));return new Set(n)}checkTensorForDisposal(e,n,s,r,o,a,i){n.category==="control"||a.indexOf(e)!==-1||(s[e].forEach(l=>{l!=null&&(i[l.id]=(i[l.id]||0)+n.children.length)}),n.inputs.forEach(l=>{if(l.category!=="control"){const u=ogt(l.name,s,r);u!=null&&u.forEach(c=>{if(c&&!c.kept&&!o.has(c.id)){const d=i[c.id];d===1?(c.dispose(),delete i[c.id]):d!=null&&i[c.id]--}})}}))}async executeAsync(e,n){return this._executeAsync(e,n)}disposeIntermediateTensors(){!this.clonedTensorsMap||(Object.values(this.clonedTensorsMap).forEach(e=>{for(const n of e)n&&!n.isDisposed&&n.dispose()}),this.clonedTensorsMap=null)}getIntermediateTensors(){return this.clonedTensorsMap}async _executeAsync(e,n,s=!1,r={},o={}){this.disposeIntermediateTensors(),s||(e=this.mapInputs(e),this.checkInputs(e),this.checkInputShapeAndType(e),n=this.mapOutputs(n),this.checkOutputs(n));try{this.keepIntermediateTensors=Be().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(f){this.keepIntermediateTensors=!1,console.warn(f.message)}const a=new DD(this.weightMap,r,o,this.functionExecutorMap);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap));const i=await this.executeWithControlFlow(e,a,n,s),l=n.map(f=>Nr(f,i,a)),u=l.map(f=>f.id),c=Object.keys(e).map(f=>e[f].id),d=new Set([...u,...c,...this.weightIds]);return Object.values(i).forEach(f=>{f.forEach(h=>{h&&!h.isDisposed&&!d.has(h.id)&&h.dispose()})}),this.parent==null&&a.dispose(d),l}async executeFunctionAsync(e,n,s){const r=e.reduce((o,a,i)=>(o[this.inputs[i].name]=a,o),{});return this._executeAsync(r,this.outputNodes,!0,n,s)}async executeWithControlFlow(e,n,s,r){const o=Object.keys(e),a=o.map(b=>this.graph.nodes[lo(b)[0]]),i=s.map(b=>lo(b)[0]);let l=i.map(b=>this.graph.nodes[b]);l.length===0&&(l=this._outputs);const{usedNodes:u,missingInputs:c,dynamicNode:d,syncInputs:f}=FD(e,l,this.weightMap,this._initNodes),h=[...a,...this.graph.weights,...this._initNodes||[]].map(b=>({node:b,contexts:n.currentContext})),p=Object.assign({},this.weightMap);Object.keys(e).forEach(b=>{const[_,$]=lo(b),x=[];x[$]=e[b],p[_]=x});const m={},g=this.getFrozenTensorIds(p),y={};for(;h.length>0;){const b=this.processStack(a,h,n,p,y,g,i,m,u);await Promise.all(b)}d==null&&!r&&console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");const w=l.filter(b=>!hU(b)&&!Nr(b.name,p,n)).map(b=>b.name);if(w.length>0){let b="";throw d!=null&&(b=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${f}]`),new Error(`Cannot compute the outputs [${w}] from the provided inputs [${o}]. Consider providing the following inputs: [${c}]. ${b}`)}return p}processStack(e,n,s,r,o,a,i,l,u){const c=[];for(;n.length>0;){const d=n.pop();s.currentContext=d.contexts;let f="";if(d.node.op==="Enter"&&H("isConstant",d.node,r,s)&&([f]=ll(d.node.name,s)),r[d.node.name]==null){const h=RD(d.node,r,s,this._resourceManager);f||([f]=ll(d.node.name,s));const p=s.currentContext;Yu(h)?c.push(h.then(m=>(r[f]=m,this.keepIntermediateTensors&&(this.clonedTensorsMap[f]=this.cloneTensorList(m)),s.currentContext=p,this.checkTensorForDisposal(f,d.node,r,s,a,i,l),this.processChildNodes(d.node,n,s,r,o,u),m))):(r[f]=h,this.keepIntermediateTensors&&(this.clonedTensorsMap[f]=this.cloneTensorList(h)),this.checkTensorForDisposal(f,d.node,r,s,a,i,l),this.processChildNodes(d.node,n,s,r,o,u))}else this.processChildNodes(d.node,n,s,r,o,u)}return c}processChildNodes(e,n,s,r,o,a){e.children.forEach(i=>{const[l]=ll(i.name,s);o[l]||!a.has(i.name)||(i.op==="Merge"?i.inputNames.some(u=>!!Nr(u,r,s))&&(o[l]=!0,n.push({contexts:s.currentContext,node:i})):i.inputNames.every(u=>!!Nr(u,r,s))&&(o[l]=!0,n.push({contexts:s.currentContext,node:i})))})}dispose(){Object.keys(this.weightMap).forEach(e=>this.weightMap[e].forEach(n=>n.dispose()))}checkInputShapeAndType(e){Object.keys(e).forEach(n=>{const s=e[n],[r]=lo(n),o=this.graph.nodes[r];if(o.attrParams.shape&&o.attrParams.shape.value){const a=o.attrParams.shape.value,i=a.length===s.shape.length&&s.shape.every((l,u)=>a[u]===-1||a[u]===l);q(i,()=>`The shape of dict['${o.name}'] provided in model.execute(dict) must be [${a}], but was [${s.shape}]`)}o.attrParams.dtype&&o.attrParams.dtype.value&&q(s.dtype===o.attrParams.dtype.value,()=>`The dtype of dict['${o.name}'] provided in model.execute(dict) must be ${o.attrParams.dtype.value}, but was ${s.dtype}`)})}mapInputs(e){var n,s;const r={};for(const o in e){const a=(s=(n=this._signature)===null||n===void 0?void 0:n.inputs)===null||s===void 0?void 0:s[o];a!=null?r[a.name]=e[o]:r[o]=e[o]}return r}checkInputs(e){const n=Object.keys(e).filter(s=>{const[r]=lo(s);return this.graph.nodes[r]==null});if(n.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${n}] that are not part of graph`)}mapOutputs(e){return e.map(n=>{var s,r;const o=(r=(s=this._signature)===null||s===void 0?void 0:s.outputs)===null||r===void 0?void 0:r[n];return o!=null?o.name:n},{})}checkOutputs(e){e.forEach(n=>{const[s]=lo(n);if(!this.graph.nodes[s])throw new Error(`The output '${n}' is not found in the graph`)})}},S1t=class{constructor(e={},n={}){this.hashTableNameToHandle=e,this.hashTableMap=n}addHashTable(e,n){this.hashTableNameToHandle[e]=n.handle,this.hashTableMap[n.id]=n}getHashTableHandleByName(e){return this.hashTableNameToHandle[e]}getHashTableById(e){return this.hashTableMap[e]}dispose(){for(const e in this.hashTableMap)this.hashTableMap[e].clearAndClose(),delete this.hashTableMap[e];for(const e in this.hashTableNameToHandle)this.hashTableNameToHandle[e].dispose(),delete this.hashTableNameToHandle[e]}};const C1t="?tfjs-format=file",k1t="model.json";let hI=class{constructor(e,n={},s=o8){this.modelUrl=e,this.loadOptions=n,this.version="n/a",this.io=s,n==null&&(this.loadOptions={}),this.resourceManager=new S1t}get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}findIOHandler(){const e=this.modelUrl;if(e.load!=null)this.handler=e;else if(this.loadOptions.requestInit!=null)this.handler=this.io.browserHTTPRequest(e,this.loadOptions);else{const n=this.io.getLoadHandlers(e,this.loadOptions);if(n.length===0)n.push(this.io.browserHTTPRequest(e,this.loadOptions));else if(n.length>1)throw new Error(`Found more than one (${n.length}) load handlers for URL '${[e]}'`);this.handler=n[0]}}load(){if(this.findIOHandler(),this.handler.load==null)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const e=this.handler.load();return Yu(e)?e.then(n=>this.loadSync(n)):this.loadSync(e)}loadSync(e){this.artifacts=e;const n=this.artifacts.modelTopology;let s=this.artifacts.signature;if(this.artifacts.userDefinedMetadata!=null){const o=this.artifacts.userDefinedMetadata;o.signature!=null&&(s=o.signature),o.structuredOutputKeys!=null&&(this.structuredOutputKeys=o.structuredOutputKeys)}this.signature=s,this.version=`${n.versions.producer}.${n.versions.minConsumer}`;const r=this.io.decodeWeights(this.artifacts.weightData,this.artifacts.weightSpecs);if(this.executor=new Xx(ID.Instance.transformGraph(n,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(r),this.executor.resourceManager=this.resourceManager,e.modelInitializer!=null&&e.modelInitializer.node!=null){const o=ID.Instance.transformGraph(e.modelInitializer);this.initializer=new Xx(o),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializerSignature=e.initializerSignature}return!0}async save(e,n){if(typeof e=="string"){const s=this.io.getSaveHandlers(e);if(s.length===0)throw new Error(`Cannot find any save handlers for URL '${e}'`);if(s.length>1)throw new Error(`Found more than one (${s.length}) save handlers for URL '${e}'`);e=s[0]}if(e.save==null)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return e.save(this.artifacts)}addStructuredOutputNames(e){if(this.structuredOutputKeys){const n=e instanceof $n?[e]:e,s={};return n.forEach((r,o)=>s[this.structuredOutputKeys[o]]=r),s}return e}predict(e,n){const s=this.execute(e,this.outputNodes);return this.addStructuredOutputNames(s)}async predictAsync(e,n){const s=await this.executeAsync(e,this.outputNodes);return this.addStructuredOutputNames(s)}normalizeInputs(e){var n;if(!(e instanceof $n)&&!Array.isArray(e)){const o=(n=this.signature)===null||n===void 0?void 0:n.inputs;if(o!=null)for(const a in o){const i=o[a];i.resourceId!=null&&(e[a]=this.resourceIdToCapturedInput[i.resourceId])}return e}e=Array.isArray(e)?e:[e];const s=Object.keys(this.resourceIdToCapturedInput).length;if(e.length+s!==this.inputNodes.length)throw new Error(`Input tensor count mismatch, the graph model has ${this.inputNodes.length-s} non-resource placeholders, while there are ${e.length} input tensors provided.`);let r=0;return this.inputNodes.reduce((o,a)=>{var i,l,u;const c=(u=(l=(i=this.signature)===null||i===void 0?void 0:i.inputs)===null||l===void 0?void 0:l[a])===null||u===void 0?void 0:u.resourceId;return c!=null?o[a]=this.resourceIdToCapturedInput[c]:o[a]=e[r++],o},{})}normalizeOutputs(e){return e=e||this.outputNodes,Array.isArray(e)?e:[e]}executeInitializerGraph(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.execute({},[]):this.initializer.execute({},Object.keys(this.initializerSignature.outputs))}async executeInitializerGraphAsync(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.executeAsync({},[]):this.initializer.executeAsync({},Object.keys(this.initializerSignature.outputs))}setResourceIdToCapturedInput(e){if(this.resourceIdToCapturedInput={},this.initializerSignature){const n=this.initializerSignature.outputs,s=Object.keys(n);for(let r=0;r<s.length;r++){const o=s[r],a=n[o];this.resourceIdToCapturedInput[a.resourceId]=e[r]}}}execute(e,n){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(this.executeInitializerGraph()),e=this.normalizeInputs(e),n=this.normalizeOutputs(n);const s=this.executor.execute(e,n);return s.length>1?s:s[0]}async executeAsync(e,n){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(await this.executeInitializerGraphAsync()),e=this.normalizeInputs(e),n=this.normalizeOutputs(n);const s=await this.executor.executeAsync(e,n);return s.length>1?s:s[0]}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(e){return Object.keys(e).reduce((n,s)=>(n[s]=[e[s]],n),{})}dispose(){this.executor.dispose(),this.initializer&&(this.initializer.dispose(),this.resourceIdToCapturedInput&&Xt(this.resourceIdToCapturedInput)),this.resourceManager.dispose()}};async function T1t(t,e={},n=o8){if(t==null)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");e==null&&(e={}),e.fromTFHub&&typeof t=="string"&&(t=I1t(t));const s=new hI(t,e,n);return await s.load(),s}function N1t(t){if(t==null)throw new Error("modelUrl in loadGraphModelSync() cannot be null. Please provide model artifacts or an IOHandler that loads the model");let e;if(t instanceof Array){const[s,r]=t;if(!s)throw new Error("modelJSON must be the first element of the array");if(!r||!(r instanceof ArrayBuffer))throw new Error("An ArrayBuffer of weights must be the second element of the array");if(!("modelTopology"in s))throw new Error("Model JSON is missing 'modelTopology'");if(!("weightsManifest"in s))throw new Error("Model JSON is missing 'weightsManifest'");const o=t8(s.weightsManifest),a=Qk(s,o,r);e=nb(a)}else if("load"in t)e=t;else if("modelTopology"in t&&"weightSpecs"in t&&"weightData"in t)e=nb(t);else throw new Error("Unknown model format");const n=new hI(e);return n.load(),n}function I1t(t){return t.endsWith("/")||(t=t+"/"),`${t}${k1t}${C1t}`}const pU="4.1.0";function E1t(t,e){return gb(t,e)}function gb(t,e,n=new Map,s=new Set){if(t==null)return null;if(typeof Blob=="function"&&t instanceof Blob)return t.slice();if(s.has(t))throw new Error("Circular references are not supported.");if(n.has(t))return n.get(t);const r=e(t);if(r.recurse&&r.value!==null)throw new Error("A deep map function may not return both a value and recurse=true.");if(r.recurse)if(Oh(t)){const o=Array.isArray(t)?[]:{};s.add(t);for(const a in t){const i=t[a],l=gb(i,e,n,s);o[a]=l}return s.delete(t),t.__proto__&&(o.__proto__=t.__proto__),o}else throw new Error(`Can't recurse into non-iterable type: ${t}`);else return n.set(t,r.value),r.value}function A1t(t,e=gU){return mU(t,e)}function mU(t,e,n=new Set){const s=t[0];if(n.has(s))throw new Error("Circular references are not supported.");const r=e(t);if(r.recurse&&r.value!==null)throw new Error("A deep zip function may not return both a value and recurse=true.");if(r.recurse)if(Oh(s)){const o=Array.isArray(s)?[]:{};n.add(s);for(const a in s){const i=t.map(u=>u[a]),l=mU(i,e,n);o[a]=l}return n.delete(s),o}else throw new Error(`Can't recurse into non-iterable type: ${s}`);else return r.value}function gU(t){return t===null?null:Oh(t[0])?{value:null,recurse:!0}:{value:t,recurse:!1}}async function vU(t,e){const n=new Map;gb(t,e,n);for(const r of Array.from(n.keys())){const o=n.get(r);if(Yu(o)){const a=await o;n.set(r,a)}}return gb(t,e,n)}function Oh(t){let e=!1;if(Be().get("IS_BROWSER"))e=t instanceof TextDecoder;else{const{StringDecoder:n}=require("string_decoder");e=t instanceof n}return t!=null&&!ArrayBuffer.isView(t)&&(Array.isArray(t)||typeof t=="object"&&!(t instanceof $n)&&!(t instanceof Promise)&&!e)}function O1t(t){return t==null||R1t(t)||Array.isArray(t)||typeof t=="object"&&t instanceof $n||Zs(t)}function R1t(t){return t===null||typeof t!="object"&&typeof t!="function"}function D1t(t){return E1t(t,F1t)}function F1t(t){return t instanceof $n?{value:t.clone(),recurse:!1}:Oh(t)?{value:null,recurse:!0}:{value:t,recurse:!1}}class yU{constructor(e){if(this.capacity=e,this.begin=0,this.end=0,e==null)throw new RangeError("Can't create a ring buffer of unknown capacity.");if(e<1)throw new RangeError("Can't create ring buffer of capacity < 1.");this.data=new Array(e),this.doubledCapacity=2*e}wrap(e){for(;e<0;)e+=this.doubledCapacity;return e%this.doubledCapacity}get(e){if(e<0)throw new RangeError("Can't get item at a negative index.");return this.data[e%this.capacity]}set(e,n){if(e<0)throw new RangeError("Can't set item at a negative index.");this.data[e%this.capacity]=n}length(){let e=this.end-this.begin;return e<0&&(e=this.doubledCapacity+e),e}isFull(){return this.length()===this.capacity}isEmpty(){return this.length()===0}push(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.set(this.end,e),this.end=this.wrap(this.end+1)}pushAll(e){for(const n of e)this.push(n)}pop(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");this.end=this.wrap(this.end-1);const e=this.get(this.end);return this.set(this.end,void 0),e}unshift(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.begin=this.wrap(this.begin-1),this.set(this.begin,e)}shift(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");const e=this.get(this.begin);return this.set(this.begin,void 0),this.begin=this.wrap(this.begin+1),e}shuffleExcise(e){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");const n=this.wrap(this.begin+e),s=this.get(n);return this.set(n,this.pop()),s}}class Y3 extends yU{constructor(){super(Y3.INITIAL_CAPACITY)}isFull(){return!1}push(e){super.isFull()&&this.expand(),super.push(e)}unshift(e){super.isFull()&&this.expand(),super.unshift(e)}expand(){const e=this.capacity*2,n=new Array(e),s=this.length();for(let r=0;r<s;r++)n[r]=this.get(this.wrap(this.begin+r));this.data=n,this.capacity=e,this.doubledCapacity=2*this.capacity,this.begin=0,this.end=s}}Y3.INITIAL_CAPACITY=32;function bU(t){return new L1t(t)}function pI(t){return new z1t(t)}function M1t(t,e){return new wU(t,e)}function P1t(t,e=Tu.FAIL){return new q1t(t,e)}class Us{async toArray(){const e=[];let n=await this.next();for(;!n.done;)e.push(n.value),n=await this.next();return e}async toArrayForTest(){const e=this.prefetch(100),n=[];let s=await e.next();for(;!s.done;)n.push(s.value),s=await e.next();return n}async resolveFully(){let e=await this.next();for(;!e.done;)e=await this.next()}async resolveWhile(e){let n=await this.next(),s=e(n.value);for(;!n.done&&s;)n=await this.next(),s=e(n.value)}handleErrors(e){return new j1t(this,e)}filter(e){return new U1t(this,e)}map(e){return new G1t(this,e)}mapAsync(e){return new MD(this,e)}serialMapAsync(e){return new MD(this,e).serial()}flatmap(e){return new K1t(this,e)}async forEachAsync(e){return this.map(e).resolveFully()}async serialForEach(e){return this.serialMapAsync(e).resolveWhile(n=>n===!0)}rowMajorBatch(e,n=!0){return new W1t(this,e,n)}columnMajorBatch(e,n=!0,s=gU){return this.rowMajorBatch(e,n).map(o=>A1t(o,s))}concatenate(e,n){return new wU(bU([this,e]),n)}take(e){return e<0||e==null?this:new H1t(this,e)}skip(e){return e<0||e==null?this:new V1t(this,e)}prefetch(e){return new _U(this,e)}shuffle(e,n){return new X1t(this,e,n)}serial(){return new B1t(this)}}class L1t extends Us{constructor(e){super(),this.items=e,this.trav=0}summary(){return`Array of ${this.items.length} items`}async next(){if(this.trav>=this.items.length)return{value:null,done:!0};const e=this.items[this.trav];return this.trav++,{value:D1t(e),done:!1}}}class z1t extends Us{constructor(e){super(),this.nextFn=e}summary(){return"Function call"}async next(){try{return this.nextFn()}catch(e){throw e.message=`Error thrown while iterating through a dataset: ${e.message}`,e}}}class B1t extends Us{constructor(e){super(),this.upstream=e,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Serial`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){return this.upstream.next()}}class V1t extends Us{constructor(e,n){super(),this.upstream=e,this.maxCount=n,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Skip`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;this.count++<this.maxCount;){const e=await this.upstream.next();if(e.done)return e;Xt(e.value)}return this.upstream.next()}}class H1t extends Us{constructor(e,n){super(),this.upstream=e,this.maxCount=n,this.count=0}summary(){return`${this.upstream.summary()} -> Take`}async next(){return this.count++>=this.maxCount?{value:null,done:!0}:this.upstream.next()}}class W1t extends Us{constructor(e,n,s=!0){super(),this.upstream=e,this.batchSize=n,this.enableSmallLastBatch=s,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> RowMajorBatch`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){const e=[];for(;e.length<this.batchSize;){const n=await this.upstream.next();if(n.done)return this.enableSmallLastBatch&&e.length>0?{value:e,done:!1}:{value:null,done:!0};e.push(n.value)}return{value:e,done:!1}}}class U1t extends Us{constructor(e,n){super(),this.upstream=e,this.predicate=n,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Filter`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;;){const e=await this.upstream.next();if(e.done||this.predicate(e.value))return e;Xt(e.value)}}}class G1t extends Us{constructor(e,n){super(),this.upstream=e,this.transform=n}summary(){return`${this.upstream.summary()} -> Map`}async next(){const e=await this.upstream.next();if(e.done)return{value:null,done:!0};const n=Il(e.value),s=this.transform(e.value),r=Il(s);for(const o of n)M_(o,r)||o.dispose();return{value:s,done:!1}}}class j1t extends Us{constructor(e,n){super(),this.upstream=e,this.handler=n,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> handleErrors`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;;)try{return await this.upstream.next()}catch(e){if(!this.handler(e))return{value:null,done:!0}}}}class MD extends Us{constructor(e,n){super(),this.upstream=e,this.transform=n}summary(){return`${this.upstream.summary()} -> AsyncMap`}async next(){const e=await this.upstream.next();if(e.done)return{value:null,done:!0};const n=Il(e.value),s=await this.transform(e.value),r=Il(s);for(const o of n)M_(o,r)||o.dispose();return{value:s,done:!1}}}class mI extends Us{constructor(){super(),this.outputQueue=new Y3,this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;this.outputQueue.length()===0;)if(!await this.pump())return{value:null,done:!0};return{value:this.outputQueue.shift(),done:!1}}}class K1t extends mI{constructor(e,n){super(),this.upstream=e,this.transform=n}summary(){return`${this.upstream.summary()} -> Flatmap`}async pump(){const e=await this.upstream.next();if(e.done)return!1;const n=Il(e.value),s=this.transform(e.value),r=Il(s);this.outputQueue.pushAll(s);for(const o of n)M_(o,r)||o.dispose();return!0}}class wU extends Us{constructor(e,n){super(),this.baseErrorHandler=n,this.lastRead=null,this.iterator=null,this.moreIterators=e}summary(){return"TODO: fill in upstream of chained summaries -> Chained"}async next(){return this.lastRead=this.readFromChain(this.lastRead),this.lastRead}async readFromChain(e){if(await e,this.iterator==null){const s=await this.moreIterators.next();if(s.done)return{value:null,done:!0};this.iterator=s.value,this.baseErrorHandler!=null&&(this.iterator=this.iterator.handleErrors(this.baseErrorHandler))}const n=await this.iterator.next();return n.done?(this.iterator=null,this.readFromChain(e)):n}}var Tu;(function(t){t[t.FAIL=0]="FAIL",t[t.SHORTEST=1]="SHORTEST",t[t.LONGEST=2]="LONGEST"})(Tu||(Tu={}));class q1t extends Us{constructor(e,n=Tu.FAIL){super(),this.iterators=e,this.mismatchMode=n,this.count=0,this.currentPromise=null}summary(){return"{TODO: fill in upstream of zip summaries} -> Zip"}async nextState(e){await e;let n=0,s=0;function r(a){return a instanceof Us?{value:a.next().then(l=>(n++,l.done&&s++,l.value)),recurse:!1}:{value:null,recurse:!0}}const o=await vU(this.iterators,r);if(n===s)return{value:null,done:!0};if(s>0)switch(this.mismatchMode){case Tu.FAIL:throw new Error(`Zipped streams should have the same length. Mismatched at element ${this.count}.`);case Tu.SHORTEST:return{value:null,done:!0};case Tu.LONGEST:}return this.count++,{value:o,done:!1}}async next(){return this.currentPromise=this.nextState(this.currentPromise),this.currentPromise}}class _U extends Us{constructor(e,n){super(),this.upstream=e,this.bufferSize=n,this.buffer=new yU(n)}summary(){return`${this.upstream.summary()} -> Prefetch`}refill(){for(;!this.buffer.isFull();){const e=this.upstream.next();this.buffer.push(e)}}next(){return this.refill(),this.buffer.shift()}}class X1t extends _U{constructor(e,n,s){super(e,n),this.upstream=e,this.windowSize=n,this.upstreamExhausted=!1,this.random=Ji.alea(s||Ys().toString()),this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}randomInt(e){return Math.floor(this.random()*e)}chooseIndex(){return this.randomInt(this.buffer.length())}async serialNext(){for(this.upstreamExhausted||this.refill();!this.buffer.isEmpty();){const e=this.chooseIndex(),n=await this.buffer.shuffleExcise(e);if(n.done)this.upstreamExhausted=!0;else return this.refill(),n}return{value:null,done:!0}}}class dm{constructor(){this.size=null}batch(e,n=!0){const s=this;q(e>0,()=>`batchSize needs to be positive, but it is
      ${e}`);let r;return this.size===1/0||this.size==null?r=this.size:n?r=Math.ceil(this.size/e):r=Math.floor(this.size/e),io(async()=>(await s.iterator()).columnMajorBatch(e,n,J1t),r)}concatenate(e){const n=this;let s;return this.size===1/0||e.size===1/0?s=1/0:this.size!=null&&e.size!=null?s=this.size+e.size:s=null,io(async()=>(await n.iterator()).concatenate(await e.iterator()),s)}filter(e){const n=this;let s;return this.size===1/0?s=1/0:s=null,io(async()=>(await n.iterator()).filter(r=>Le(()=>e(r))),s)}async forEachAsync(e){return(await this.iterator()).forEachAsync(e)}map(e){const n=this;return io(async()=>(await n.iterator()).map(s=>Le(()=>e(s))),this.size)}mapAsync(e){const n=this;return io(async()=>(await n.iterator()).mapAsync(e),this.size)}prefetch(e){if(e==null)throw new RangeError("`Dataset.prefetch()` requires bufferSize to be specified.");const n=this;return io(async()=>(await n.iterator()).prefetch(e),this.size)}repeat(e){const n=this;let s;return this.size!=null&&e>0?s=this.size*e:e===0?s=0:this.size!=null&&(e===void 0||e<0)?s=1/0:s=null,io(async()=>{const r=pI(async()=>({value:await n.iterator(),done:!1}));return M1t(r.take(e))},s)}skip(e){const n=this;let s;return this.size!=null&&e>=0&&this.size>=e?s=this.size-e:this.size!=null&&(this.size<e||e===void 0||e<0)?s=0:s=null,io(async()=>(await n.iterator()).skip(e),s)}shuffle(e,n,s=!0){if(e==null||e<0)throw this.size==null?new RangeError("`Dataset.shuffle()` requires bufferSize to be specified."):new RangeError(`\`Dataset.shuffle()\` requires bufferSize to be specified.  If your data fits in main memory (for regular JS objects), and/or GPU memory (for \`tf.Tensor\`s), consider setting bufferSize to the dataset size (${this.size} elements)`);const r=this,o=Ji.alea(n||Ys().toString());return io(async()=>{let a=o.int32();return s&&(a+=o.int32()),(await r.iterator()).shuffle(e,a.toString())},this.size)}take(e){const n=this;let s;return this.size!=null&&this.size>e?s=e:this.size!=null&&this.size<=e?s=this.size:s=null,io(async()=>(await n.iterator()).take(e),s)}async toArray(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArray()}async toArrayForTest(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArrayForTest()}}dm.MAX_BUFFER_SIZE=1e4;function io(t,e=null){return new class extends dm{constructor(){super(...arguments),this.size=e}async iterator(){return t()}}}function Y1t(t){return io(async()=>bU(t),t.length)}function Z1t(t){if(!Oh(t))throw new Error("The argument to zip() must be an object or array.");let e;if(Array.isArray(t))for(let n=0;n<t.length;n++)e=e==null?t[n].size:Math.min(e,t[n].size);else if(t instanceof Object)for(const n in t)e=e==null?t[n].size:Math.min(e,t[n].size);return io(async()=>{const n=await vU(t,s=>{if(s instanceof dm)return{value:s.iterator(),recurse:!1};if(Oh(s))return{value:null,recurse:!0};throw new Error("Leaves of the structure passed to zip() must be Datasets, not primitives.")});return P1t(n,Tu.SHORTEST)},e)}function J1t(t){if(t===null)return null;const e=t[0];return O1t(e)?{value:Q1t(t),recurse:!1}:{value:null,recurse:!0}}function Q1t(t){if(t.length===0)throw new Error("Can't make a batch of zero elements.");return t[0]instanceof $n?Jr(t):yo(t)}class $U extends dm{constructor(e){super(),this.input=e}async iterator(){return(await this.input.iterator()).decodeUTF8().split(`
`).map(r=>(r.endsWith("\r")&&(r=r.slice(0,-1)),r))}}const _v='"',Lm=Symbol("out"),PD=Symbol("field"),$v=Symbol("quote"),k$=Symbol("quoteafterquote"),LD=Symbol("quoteinquote");class xU extends dm{constructor(e,n){super(),this.input=e,this.hasHeader=!0,this.fullColumnNames=null,this.columnNamesValidated=!1,this.columnConfigs=null,this.configuredColumnsOnly=!1,this.delimiter=",",this.delimWhitespace=!1,this.base=new $U(e),n||(n={}),this.hasHeader=n.hasHeader!==!1,this.fullColumnNames=n.columnNames,this.columnConfigs=n.columnConfigs,this.configuredColumnsOnly=n.configuredColumnsOnly,n.delimWhitespace?(q(n.delimiter==null,()=>"Delimiter should not be provided when delimWhitespace is true."),this.delimWhitespace=!0,this.delimiter=" "):this.delimiter=n.delimiter?n.delimiter:","}async columnNames(){return this.columnNamesValidated||await this.setColumnNames(),this.configuredColumnsOnly?Object.keys(this.columnConfigs):this.fullColumnNames}async setColumnNames(){const e=await this.maybeReadHeaderLine();if(!this.fullColumnNames&&!e)throw new Error("Column names must be provided if there is no header line.");this.fullColumnNames&&e&&q(e.length===this.fullColumnNames.length,()=>"The length of provided columnNames ("+this.fullColumnNames.length.toString()+") does not match the length of the header line read from file ("+e.length.toString()+")."),this.fullColumnNames||(this.fullColumnNames=e);const n=this.fullColumnNames.reduce((r,o)=>(r[o]=r[o]+1||1,r),{}),s=Object.keys(n).filter(r=>n[r]>1);if(q(s.length===0,()=>"Duplicate column names found: "+s.toString()),this.columnConfigs){for(const r of Object.keys(this.columnConfigs))if(this.fullColumnNames.indexOf(r)===-1)throw new Error('The key "'+r+'" provided in columnConfigs does not match any of the column names ('+this.fullColumnNames.toString()+").")}this.columnNamesValidated=!0}async maybeReadHeaderLine(){if(this.hasHeader){const n=await(await this.base.iterator()).next();if(n.done)throw new Error("No data was found for CSV parsing.");const s=n.value;return this.parseRow(s,!1)}else return null}async iterator(){this.columnNamesValidated||await this.setColumnNames();let e=await this.base.iterator();return this.hasHeader&&(e=e.skip(1)),e.map(n=>this.makeDataElement(n))}makeDataElement(e){const n=this.parseRow(e),s={},r={};for(let o=0;o<this.fullColumnNames.length;o++){const a=this.fullColumnNames[o],i=this.columnConfigs?this.columnConfigs[a]:null;if(!(this.configuredColumnsOnly&&!i)){const l=n[o];let u=null;if(l==="")if(i&&i.default!==void 0)u=i.default;else{if(i&&(i.required||i.isLabel))throw new Error(`Required column ${a} is empty in this line: ${e}`);u=void 0}else{const c=Number(l);if(isNaN(c))i&&i.dtype==="bool"?u=this.getBoolean(l):u=l;else if(!i||!i.dtype)u=c;else switch(i.dtype){case"float32":u=c;break;case"int32":u=Math.floor(c);break;case"bool":u=this.getBoolean(l);break;default:u=c}}i&&i.isLabel?r[a]=u:s[a]=u}}return Object.keys(r).length===0?s:{xs:s,ys:r}}getBoolean(e){return e==="1"||e.toLowerCase()==="true"?1:0}parseRow(e,n=!0){const s=[];let r=0;const o=e.length;let a=Lm;for(let i=0;i<o;i++)switch(a){case Lm:switch(e.charAt(i)){case _v:r=i+1,a=$v;break;case this.delimiter:if(r=i+1,this.delimiter===" "&&this.delimWhitespace)break;s.push(""),a=Lm;break;default:a=PD,r=i;break}break;case PD:switch(e.charAt(i)){case this.delimiter:s.push(e.substring(r,i)),a=Lm,r=i+1;break}break;case $v:switch(e.charAt(i)){case _v:a=k$;break}break;case k$:switch(e.charAt(i)){case this.delimiter:s.push(e.substring(r,i-1)),a=Lm,r=i+1;break;case _v:a=$v;break;default:a=LD;break}break;case LD:switch(e.charAt(i)){case _v:a=$v;break}break}if(a===k$?s.push(e.substring(r,o-1)):s.push(e.substring(r)),n&&s.length!==this.fullColumnNames.length)throw new Error(`Invalid row in csv file. Should have ${this.fullColumnNames.length} elements in a row, but got ${s}`);return s}}class gI extends Us{constructor(e){super(),this.microphoneConfig=e,this.isClosed=!1,this.fftSize=e.fftSize||1024;const n=Math.log2(this.fftSize);if(this.fftSize<0||n<4||n>14||!Number.isInteger(n))throw new Error(`Invalid fftSize: it must be a power of 2 between 2 to 4 and 2 to 14, but got ${this.fftSize}`);if(this.numFrames=e.numFramesPerSpectrogram||43,this.sampleRateHz=e.sampleRateHz,this.columnTruncateLength=e.columnTruncateLength||this.fftSize,this.audioTrackConstraints=e.audioTrackConstraints,this.smoothingTimeConstant=e.smoothingTimeConstant||0,this.includeSpectrogram=e.includeSpectrogram!==!1,this.includeWaveform=e.includeWaveform===!0,!this.includeSpectrogram&&!this.includeWaveform)throw new Error("Both includeSpectrogram and includeWaveform are false. At least one type of data should be returned.")}summary(){return"microphone"}static async create(e={}){if(!Be().get("IS_BROWSER"))throw new Error("microphone API is only supported in browser environment.");const n=new gI(e);return await n.start(),n}async start(){try{this.stream=await navigator.mediaDevices.getUserMedia({audio:this.audioTrackConstraints==null?!0:this.audioTrackConstraints,video:!1})}catch(s){throw new Error(`Error thrown while initializing video stream: ${s.message}`)}if(!this.stream)throw new Error("Could not obtain audio from microphone.");const e=window.AudioContext||window.webkitAudioContext;if(this.audioContext=new e,!this.sampleRateHz)this.sampleRateHz=this.audioContext.sampleRate;else if(this.audioContext.sampleRate!==this.sampleRateHz)throw new Error(`Mismatch in sampling rate: Expected: ${this.sampleRateHz}; Actual: ${this.audioContext.sampleRate}`);const n=this.audioContext.createMediaStreamSource(this.stream);this.analyser=this.audioContext.createAnalyser(),this.analyser.fftSize=this.fftSize*2,this.analyser.smoothingTimeConstant=this.smoothingTimeConstant,n.connect(this.analyser),this.freqData=new Float32Array(this.fftSize),this.timeData=new Float32Array(this.fftSize)}async next(){if(this.isClosed)return{value:null,done:!0};let e,n;const s=await this.getAudioData();if(this.includeSpectrogram){const r=this.flattenQueue(s.freqDataQueue);e=this.getTensorFromAudioDataArray(r,[this.numFrames,this.columnTruncateLength,1])}if(this.includeWaveform){const r=this.flattenQueue(s.timeDataQueue);n=this.getTensorFromAudioDataArray(r,[this.numFrames*this.fftSize,1])}return{value:{spectrogram:e,waveform:n},done:!1}}async capture(){return(await this.next()).value}async getAudioData(){const e=[],n=[];let s=0;return new Promise(r=>{const o=setInterval(()=>{this.includeSpectrogram&&(this.analyser.getFloatFrequencyData(this.freqData),this.freqData[0]===-1/0&&r({freqDataQueue:e,timeDataQueue:n}),e.push(this.freqData.slice(0,this.columnTruncateLength))),this.includeWaveform&&(this.analyser.getFloatTimeDomainData(this.timeData),n.push(this.timeData.slice())),++s===this.numFrames&&(clearInterval(o),r({freqDataQueue:e,timeDataQueue:n}))},this.fftSize/this.sampleRateHz*1e3)})}stop(){this.isClosed||(this.isClosed=!0,this.analyser.disconnect(),this.audioContext.close(),this.stream!=null&&this.stream.getTracks().length>0&&this.stream.getTracks()[0].stop())}toArray(){throw new Error("Can not convert infinite audio stream to array.")}getSampleRate(){return this.sampleRateHz}flattenQueue(e){const n=e[0].length,s=new Float32Array(e.length*n);return e.forEach((r,o)=>s.set(r,o*n)),s}getTensorFromAudioDataArray(e,n){const s=new Float32Array(Ge(n));return s.set(e,s.length-e.length),yo(s,n)}}class vI extends Us{constructor(e,n){if(super(),this.webcamVideoElement=e,this.webcamConfig=n,this.isClosed=!0,this.resize=!1,this.needToResize())if(this.resize=!0,this.cropSize=[this.webcamConfig.resizeHeight,this.webcamConfig.resizeWidth],this.cropBoxInd=vr([0],"int32"),this.webcamConfig.centerCrop){const s=this.webcamConfig.resizeWidth*1/this.webcamVideoElement.width,r=this.webcamConfig.resizeHeight*1/this.webcamVideoElement.height,o=(1-s)/2,a=(1-r)/2,i=o+s,l=r+a;this.cropBox=Mu([a,o,l,i],[1,4])}else this.cropBox=Mu([0,0,1,1],[1,4])}summary(){return"webcam"}static async create(e,n={}){if(!Be().get("IS_BROWSER"))throw new Error("tf.data.webcam is only supported in browser environment.");if(!e){if(e=document.createElement("video"),!n.resizeWidth||!n.resizeHeight)throw new Error("Please provide webcam video element, or resizeWidth and resizeHeight to create a hidden video element.");e.width=n.resizeWidth,e.height=n.resizeHeight}const s=new vI(e,n);return await s.start(),s}async start(){this.webcamConfig.facingMode&&q(this.webcamConfig.facingMode==="user"||this.webcamConfig.facingMode==="environment",()=>`Invalid webcam facing mode: ${this.webcamConfig.facingMode}. Please provide 'user' or 'environment'`);try{this.stream=await navigator.mediaDevices.getUserMedia({video:{deviceId:this.webcamConfig.deviceId,facingMode:this.webcamConfig.facingMode?this.webcamConfig.facingMode:"user",width:this.webcamVideoElement.width,height:this.webcamVideoElement.height}})}catch(e){throw e.message=`Error thrown while initializing video stream: ${e.message}`,e}if(!this.stream)throw new Error("Could not obtain video from webcam.");try{this.webcamVideoElement.srcObject=this.stream}catch(e){console.log(e),this.webcamVideoElement.src=window.URL.createObjectURL(this.stream)}return this.webcamVideoElement.play(),this.isClosed=!1,new Promise(e=>{this.webcamVideoElement.onloadedmetadata=()=>{e()}})}async next(){if(this.isClosed)return{value:null,done:!0};let e;try{e=lV(this.webcamVideoElement)}catch(n){throw new Error(`Error thrown converting video to pixels: ${JSON.stringify(n)}`)}if(this.resize)try{return{value:this.cropAndResizeFrame(e),done:!1}}catch(n){throw new Error(`Error thrown cropping the video: ${n.message}`)}finally{e.dispose()}else return{value:e,done:!1}}needToResize(){return!!(this.webcamConfig.resizeWidth&&this.webcamConfig.resizeHeight&&(this.webcamVideoElement.width!==this.webcamConfig.resizeWidth||this.webcamVideoElement.height!==this.webcamConfig.resizeHeight))}cropAndResizeFrame(e){return Le(()=>{const n=hr(ht(e,"float32"),0);let s;s=Ti.cropAndResize(n,this.cropBox,this.cropBoxInd,this.cropSize,"bilinear");const r=s.shape;return Ne(s,r.slice(1))})}async capture(){return(await this.next()).value}stop(){this.stream.getTracks().forEach(n=>n.stop());try{this.webcamVideoElement.srcObject=null}catch(n){console.log(n),this.webcamVideoElement.src=null}this.isClosed=!0}toArray(){throw new Error("Can not convert infinite video stream to array.")}}class SU{}class CU extends Us{split(e){return new e2t(this,e)}}class e2t extends CU{constructor(e,n){super(),this.upstream=e,this.impl=new t2t(e,n)}summary(){return this.impl.summary()}async next(){return this.impl.next()}}class t2t extends mI{constructor(e,n){super(),this.upstream=e,this.separator=n,this.carryover=""}summary(){return`${this.upstream.summary()} -> Split('${this.separator}')`}async pump(){const e=await this.upstream.next();if(e.done)return this.carryover===""?!1:(this.outputQueue.push(this.carryover),this.carryover="",!0);const n=e.value.split(this.separator);n[0]=this.carryover+n[0];for(const s of n.slice(0,-1))this.outputQueue.push(s);return this.carryover=n[n.length-1],!0}}class n2t extends Us{decodeUTF8(){return new s2t(this)}}class s2t extends CU{constructor(e){super(),this.upstream=e,this.impl=new r2t(e)}summary(){return this.impl.summary()}async next(){return this.impl.next()}}class r2t extends mI{constructor(e){if(super(),this.upstream=e,Be().get("IS_BROWSER"))this.decoder=new TextDecoder("utf-8");else{const{StringDecoder:n}=require("string_decoder");this.decoder=new n("utf8")}}summary(){return`${this.upstream.summary()} -> Utf8`}async pump(){const e=await this.upstream.next();let n;if(e.done)return!1;n=e.value;let s;return Be().get("IS_BROWSER")?s=this.decoder.decode(n,{stream:!0}):s=this.decoder.write(Buffer.from(n.buffer)),this.outputQueue.push(s),!0}}class kU extends n2t{constructor(e,n={}){super(),this.file=e,this.options=n,q(e instanceof Uint8Array||(Be().get("IS_BROWSER")?e instanceof File||e instanceof Blob:!1),()=>"FileChunkIterator only supports File, Blob and Uint8Array right now."),this.offset=n.offset||0,this.chunkSize=n.chunkSize||1024*1024}summary(){return`FileChunks ${this.file}`}async next(){return this.offset>=(this.file instanceof Uint8Array?this.file.byteLength:this.file.size)?{value:null,done:!0}:{value:await new Promise((n,s)=>{const r=this.offset+this.chunkSize;if(this.file instanceof Uint8Array)n(new Uint8Array(this.file.slice(this.offset,r)));else{const o=new FileReader;o.onload=i=>{let l=o.result;if(l instanceof ArrayBuffer&&(l=new Uint8Array(l)),!(l instanceof Uint8Array))return s(new TypeError("FileReader returned unknown type."));n(l)},o.onabort=i=>s(new Error("Aborted")),o.onerror=i=>s(new Error(i.type));const a=this.file.slice(this.offset,r);o.readAsArrayBuffer(a)}this.offset=r}),done:!1}}}async function o2t(t,e={},n){let s,r;typeof t=="string"?s=t:(s=t.url,r=a2t(t));const o=await(n||LB)(s,r);if(o.ok){const a=new Uint8Array(await o.arrayBuffer());return new kU(a,e)}else throw new Error(o.statusText)}const a2t=t=>({method:t.method,headers:t.headers,body:t.body,mode:t.mode,credentials:t.credentials,cache:t.cache,redirect:t.redirect,referrer:t.referrer,integrity:t.integrity});function TU(t){return typeof t=="string"&&t.slice(0,7)==="file://"}class NU extends SU{constructor(e,n={}){super(),this.input=e,this.options=n}async iterator(){if(TU(this.input)&&Be().get("IS_NODE")){const e=require("fs");this.input=e.readFileSync(this.input.slice(7))}return new kU(this.input,this.options)}}class IU extends SU{constructor(e,n={}){super(),this.url=e,this.fileOptions=n}async iterator(){return TU(this.url)?new NU(this.url,this.fileOptions).iterator():o2t(this.url,this.fileOptions)}}function i2t(t,e={}){return new xU(new IU(t),e)}function l2t(t){const e=pI(t);return io(async()=>e)}function u2t(t){return io(async()=>{const e=await t();return pI(()=>e.next())})}async function c2t(t,e){return vI.create(t,e)}async function d2t(t){return gI.create(t)}const EU="4.1.0";const f2t=Object.freeze(Object.defineProperty({__proto__:null,array:Y1t,Dataset:dm,zip:Z1t,CSVDataset:xU,TextLineDataset:$U,csv:i2t,func:l2t,generator:u2t,microphone:d2t,webcam:c2t,FileDataSource:NU,URLDataSource:IU,version_data:EU},Symbol.toStringTag,{value:"Module"}));function Tt(t,e){Array.isArray(t)||(t=[t]),t.forEach(n=>{n!=null&&q(n.dtype!=="complex64",()=>`${e} does not support complex64 tensors in the CPU backend.`)})}const h2t=f3;class Z3 extends Nw{constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new zk(this,Ma())}nextDataId(){return Z3.nextDataId++}write(e,n,s){this.firstUse&&(this.firstUse=!1,Be().get("IS_NODE")&&Fo(`
============================
Hi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. 
============================`));const r={id:this.nextDataId()};return this.data.set(r,{values:e,dtype:s,refCount:1}),r}makeTensorInfo(e,n,s){let r;if(n==="string"&&s!=null&&s.length>0&&ki(s[0])){const o=s.map(a=>Oi(a));r=this.write(o,e,n)}else r=this.write(s,e,n);return{dataId:r,shape:e,dtype:n}}refCount(e){return this.data.has(e)?this.data.get(e).refCount:0}incRef(e){const n=this.data.get(e);n.refCount++}decRef(e){if(this.data.has(e)){const n=this.data.get(e);n.refCount--}}move(e,n,s,r,o){this.data.set(e,{values:n,dtype:r,refCount:o})}numDataIds(){return this.data.numDataIds()}async read(e){return this.readSync(e)}readSync(e){const{dtype:n,complexTensorInfos:s}=this.data.get(e);if(n==="complex64"){const r=this.readSync(s.real.dataId),o=this.readSync(s.imag.dataId);return Rl(r,o)}return this.data.get(e).values}bufferSync(e){const n=this.readSync(e.dataId);if(e.dtype==="string")try{const s=n.map(r=>Nl(r));return tn(e.shape,e.dtype,s)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return tn(e.shape,e.dtype,n)}makeOutput(e,n,s){return Ma().makeTensorFromTensorInfo(this.makeTensorInfo(n,s,e),this)}disposeData(e,n=!1){if(this.data.has(e)){if(this.data.get(e).refCount--,!n&&this.data.get(e).refCount>0)return!1;const{complexTensorInfos:s}=this.data.get(e);s!=null&&(this.disposeData(s.real.dataId,!0),this.disposeData(s.imag.dataId,!0)),this.data.delete(e)}return!0}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}async time(e){const n=Ys();return e(),{kernelMs:Ys()-n}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(e){Tt([e],"where");const n=this.readSync(e.dataId);return h2t(e.shape,n)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}Z3.nextDataId=0;function AU(t){const e=new Float32Array(t.length);for(let n=0;n<t.length;++n)e[n]=Math.abs(t[n]);return e}const p2t=t=>{const{x:e}=t.inputs,n=t.backend;Tt(e,"abs");let s=new Float32Array(Ge(e.shape));const r=n.data.get(e.dataId).values;return s=AU(r),n.makeOutput(s,e.shape,e.dtype)},m2t={kernelName:Vg,backendName:"cpu",kernelFunc:p2t};function Is(t){return(e,n,s,r,o)=>{const a=Zt(e,n),i=a.length,l=Mt(a),u=Ge(a),c=zs(o,u),d=e.length,f=n.length,h=Mt(e),p=Mt(n),m=Ad(e,a),g=Ad(n,a);if(m.length+g.length===0)for(let y=0;y<c.length;++y)c[y]=t(s[y%s.length],r[y%r.length]);else for(let y=0;y<c.length;++y){const w=tf(y,i,l),b=w.slice(-d);m.forEach(k=>b[k]=0);const _=Ka(b,d,h),$=w.slice(-f);g.forEach(k=>$[k]=0);const x=Ka($,f,p);c[y]=t(s[_],r[x])}return[c,a]}}function fo(t){const{inputs:e,backend:n}=t,{real:s,imag:r}=e,o=n.data.get(s.dataId).values,a=n.data.get(r.dataId).values,i=n.makeTensorInfo(s.shape,"complex64"),l=n.data.get(i.dataId);return l.complexTensorInfos={real:n.makeTensorInfo(s.shape,"float32",o),imag:n.makeTensorInfo(r.shape,"float32",a)},i}const g2t={kernelName:Pw,backendName:"cpu",kernelFunc:fo};function vb(t,e,n="float32"){if(n==="complex64"){const r=vb(t,e,"float32"),o=vb(t,e,"float32");return fo({inputs:{real:r,imag:o},backend:t})}const s=or(Ge(e),n);return t.makeTensorInfo(e,n,s)}function Wi(t){const{inputs:e,backend:n}=t,{x:s}=e;return n.incRef(s.dataId),{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}const v2t={kernelName:xp,backendName:"cpu",kernelFunc:Wi};function zd(t){const{inputs:e,backend:n}=t,{input:s}=e,r=n.data.get(s.dataId).complexTensorInfos.real,o=n.data.get(r.dataId).values;return n.makeTensorInfo(r.shape,r.dtype,o)}const y2t={kernelName:m_,backendName:"cpu",kernelFunc:zd};function OU(t,e,n,s){if(s==="int32"){const r=Int32Array.from(t);return[e,"int32",r]}if(s==="bool"){const r=dc([0],n),[o,a]=Is((i,l)=>i!==l?1:0)(e,[],t,r,"bool");return[a,"bool",o]}throw new Error(`Error in Cast: failed to cast ${n} to ${s}`)}function nc(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{dtype:o}=s;if(o==="complex64"){if(r.dtype==="complex64")return Wi({inputs:{x:r},backend:n});const c=vb(n,r.shape,r.dtype),d=nc({inputs:{x:r},backend:n,attrs:{dtype:"float32"}}),f=fo({inputs:{real:d,imag:c},backend:n});return n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(d),f}if(r.dtype==="complex64"){const c=zd({inputs:{input:r},backend:n}),d=nc({inputs:{x:c},backend:n,attrs:{dtype:o}});return n.disposeIntermediateTensorInfo(c),d}if(!Hk(r.dtype,o)){const c=Wi({inputs:{x:r},backend:n});return{dataId:c.dataId,shape:c.shape,dtype:o}}const a=n.data.get(r.dataId).values,[i,l,u]=OU(a,r.shape,r.dtype,o);return n.makeTensorInfo(i,l,u)}const b2t={kernelName:cp,backendName:"cpu",kernelFunc:nc};function Ks(t,e,n,s){return n==null?({inputs:r,backend:o})=>{const{a,b:i}=r,l=o;Tt([a,i],t);const u=l.data.get(a.dataId).values,c=l.data.get(i.dataId).values,d=a.dtype==="string"?Md(u):u,f=a.dtype==="string"?Md(c):c,h=s||a.dtype,[p,m]=e(a.shape,i.shape,d,f,h);return l.makeTensorInfo(m,h,p)}:({inputs:r,backend:o})=>{const{a,b:i}=r,l=o;if(a.dtype==="complex64"||i.dtype==="complex64"){const u=nc({inputs:{x:a},backend:l,attrs:{dtype:"complex64"}}),c=l.data.get(u.dataId),d=c.complexTensorInfos.real,f=c.complexTensorInfos.imag,h=l.data.get(d.dataId).values,p=l.data.get(f.dataId).values,m=nc({inputs:{x:i},backend:l,attrs:{dtype:"complex64"}}),g=l.data.get(m.dataId),y=g.complexTensorInfos.real,w=g.complexTensorInfos.imag,b=l.data.get(y.dataId).values,_=l.data.get(w.dataId).values,[$,x,k]=n(a.shape,i.shape,h,p,b,_),C=l.makeTensorInfo(k,"float32",$),T=l.makeTensorInfo(k,"float32",x),N=fo({inputs:{real:C,imag:T},backend:l});return l.disposeIntermediateTensorInfo(u),l.disposeIntermediateTensorInfo(m),l.disposeIntermediateTensorInfo(C),l.disposeIntermediateTensorInfo(T),N}else{const u=l.data.get(a.dataId).values,c=l.data.get(i.dataId).values,d=s||a.dtype,[f,h]=e(a.shape,i.shape,u,c,d);return l.makeTensorInfo(h,d,f)}}}function yI(t){return(e,n,s,r,o,a)=>{const i=Zt(e,n),l=Ge(i),u=i.length,c=Mt(i),d=zs("float32",l),f=zs("float32",l),h=Ad(e,i),p=Ad(n,i),m=Rl(s,r),g=Rl(o,a),y=e.length,w=Mt(e),b=n.length,_=Mt(n);if(h.length+p.length===0)for(let $=0;$<d.length;$++){const x=$%m.length,k=$%g.length,C=t(m[x*2],m[x*2+1],g[k*2],g[k*2+1]);d[$]=C.real,f[$]=C.imag}else for(let $=0;$<d.length;$++){const x=tf($,u,c),k=x.slice(-y);h.forEach(R=>k[R]=0);const C=Ka(k,y,w),T=x.slice(-b);p.forEach(R=>T[R]=0);const N=Ka(T,b,_),M=t(m[C*2],m[C*2+1],g[N*2],g[N*2+1]);d[$]=M.real,f[$]=M.imag}return[d,f,i]}}const RU=Is((t,e)=>t+e),w2t=yI((t,e,n,s)=>({real:t+n,imag:e+s})),Rh=Ks(nf,RU,w2t),_2t={kernelName:nf,backendName:"cpu",kernelFunc:Rh};function bI(t,e,n,s,r){const o=Ge(s),a=or(r,n);for(let i=0;i<t.length;i++){const l=t[i];if(l<0)throw new Error("Input x must be non-negative!");l>=r||(o>0?a[l]+=e[i]:a[l]+=1)}return a}function DU(t,e,n,s=!1){const r=t.shape[0],o=t.shape[1],a=tn([r,n],e.dtype);for(let i=0;i<r;i++)for(let l=0;l<o;l++){const u=t.get(i,l);if(u<0)throw new Error("Input x must be non-negative!");u>=n||(s?a.set(1,i,u):e.size>0?a.set(a.get(i,u)+e.get(i,l),i,u):a.set(a.get(i,u)+1,i,u))}return a}function vc(t){return(e,n,s)=>{const r=zs(n,e.length);for(let o=0;o<e.length;++o)r[o]=t(e[o],s);return r}}function An(t,e,n){return({inputs:s,attrs:r,backend:o})=>{const{x:a}=s;if(Tt(a,t),a.dtype==="string"||n==="string")throw new Error("unaryKernelFunc does not support string input/output");const i=o,l=i.data.get(a.dataId).values,u=Ge(a.shape),c=n||a.dtype,d=gs(c,u);for(let f=0;f<u;++f)d[f]=e(l[f],r);return i.makeTensorInfo(a.shape,c,d)}}function fm(t,e,n){return({inputs:s,attrs:r,backend:o})=>{const{x:a}=s;if(Tt(a,t),a.dtype==="string"||n==="string")throw new Error("unaryKernelFunc does not support string input/output");const i=o,l=i.data.get(a.dataId).values,u=n||a.dtype,c=e(l,u,r);return i.makeTensorInfo(a.shape,u,c)}}const FU=vc(t=>Math.ceil(t)),$2t=fm(dp,FU),x2t={kernelName:dp,backendName:"cpu",kernelFunc:$2t};function MU(t,e,n,s){const r=gs(n,Ge(e));if(s&&n!=="string"){let o=0;t.forEach(a=>{const i=Ge(a.shape);r.set(a.vals,o),o+=i})}else{let o=0;t.forEach(a=>{const i=n==="string"?Md(a.vals):a.vals;let l=0;for(let u=0;u<a.shape[0];++u){const c=u*e[1]+o;for(let d=0;d<a.shape[1];++d)r[c+d]=i[l++]}o+=a.shape[1]})}return r}const PU=Is((t,e)=>t===e?1:0),LU=Ks(s1,PU,null,"bool"),S2t={kernelName:s1,backendName:"cpu",kernelFunc:LU};const zU=vc(t=>Math.exp(t)),BU=fm(yp,zU,"float32"),C2t={kernelName:yp,backendName:"cpu",kernelFunc:BU};const VU=vc(t=>Math.expm1(t)),k2t=fm(bp,VU),T2t={kernelName:bp,backendName:"cpu",kernelFunc:k2t};const HU=vc(t=>Math.floor(t)),N2t=fm(wp,HU),I2t={kernelName:wp,backendName:"cpu",kernelFunc:N2t};function WU(t,e,n,s,r,o,a,i,l){const u=tn([s,o],n);for(let c=0;c<s;c++){const d=[];let f=0;for(let h=0;h<r;h++){const p=t[c*r+h];f+=p*a[h],d.push(p)}if(f<0||f>=l/o)throw new Error(`Invalid indices: ${d} does not index into ${i}`);for(let h=0;h<o;h++)u.values[c*o+h]=e.get(...e.indexToLoc(f*o+h))}return u}function UU(t,e,n){const s=tn(n,t.dtype);for(let r=0;r<s.size;++r){const a=s.indexToLoc(r).slice(),i=a[0],l=a[2],u=e.locToIndex([i,l]);a[2]=e.values[u];const c=t.locToIndex(a);0<=c&&c<t.values.length&&(s.values[r]=t.values[c])}return s}const GU=Is((t,e)=>t>e?1:0),E2t=Ks(i1,GU,null,"bool"),A2t={kernelName:i1,backendName:"cpu",kernelFunc:E2t};const jU=Is((t,e)=>t>=e?1:0),O2t=Ks($p,jU,null,"bool"),R2t={kernelName:$p,backendName:"cpu",kernelFunc:O2t};const KU=Is((t,e)=>t<e?1:0),D2t=Ks(u1,KU,null,"bool"),F2t={kernelName:u1,backendName:"cpu",kernelFunc:D2t};const qU=Is((t,e)=>t<=e?1:0),M2t=Ks(c1,qU,null,"bool"),P2t={kernelName:c1,backendName:"cpu",kernelFunc:M2t};function XU(t,e,n){const s=(e-t)/(n-1),r=or(n,"float32");r[0]=t;for(let o=1;o<r.length;o++)r[o]=r[o-1]+s;return r}const YU=vc(t=>Math.log(t)),L2t=fm(Tp,YU),z2t={kernelName:Tp,backendName:"cpu",kernelFunc:L2t};function ZU(t,e,n,s){const r=zs(s,Ge(n));for(let o=0;o<r.length;++o){const a=o*e;let i=t[a];for(let l=0;l<e;++l){const u=t[a+l];(Number.isNaN(u)||u>i)&&(i=u)}r[o]=i}return r}const JU=Is((t,e)=>Math.max(t,e)),B2t=Ks(Ip,JU),V2t={kernelName:Ip,backendName:"cpu",kernelFunc:B2t};const QU=Is((t,e)=>Math.min(t,e)),H2t=Ks(Ep,QU),W2t={kernelName:Ep,backendName:"cpu",kernelFunc:H2t};const wI=Is((t,e)=>t*e),U2t=yI((t,e,n,s)=>({real:t*n-e*s,imag:t*s+e*n})),J3=Ks(Op,wI,U2t),G2t={kernelName:Op,backendName:"cpu",kernelFunc:J3};function eG(t,e,n){const s=ql(-1,n);return wI([],e,s,t,n)}function j2t(t){const{inputs:e,backend:n}=t,{x:s}=e;Tt(s,"neg");const r=n.data.get(s.dataId).values,[o,a]=eG(r,s.shape,s.dtype);return n.makeTensorInfo(a,s.dtype,o)}const K2t={kernelName:_1,backendName:"cpu",kernelFunc:j2t};const tG=Is((t,e)=>t!==e?1:0),q2t=Ks($1,tG,null,"bool"),X2t={kernelName:$1,backendName:"cpu",kernelFunc:q2t};function _I(t,e,n,s,r){const o=e.length,a=Ge(e),i=Mt(e),l=Mt(r),u=zs(n,Ge(r));for(let c=0;c<a;++c){const d=tf(c,o,i),f=new Array(d.length);for(let p=0;p<f.length;p++)f[p]=d[s[p]];const h=Ka(f,o,l);u[h]=t[c]}return u}function eo(t){const{inputs:e,attrs:n,backend:s}=t,{x:r}=e,{perm:o}=n;Tt(r,"transpose");const a=r.shape.length,i=new Array(a);for(let d=0;d<i.length;d++)i[d]=r.shape[o[d]];const l=s.data.get(r.dataId).values,u=_I(l,r.shape,r.dtype,o,i);return{dataId:s.write(u,i,r.dtype),shape:i,dtype:r.dtype}}const Y2t={kernelName:ld,backendName:"cpu",kernelFunc:eo};function nG(t,e,n,s){const[r,o]=js(t,s),a=Yr(e,"int32"),i=or(Ge(r),a),l=Ge(o);for(let u=0;u<i.length;++u){const c=u*l;let d=1;for(let f=0;f<l;++f)d*=n[c+f];i[u]=d}return{outVals:i,outShape:r,outDtype:a}}function Z2t(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{axis:o,keepDims:a}=s;Tt(r,"prod");const i=r.shape.length,l=un(o,r.shape),u=hs(l,i);let c=l,d=r;const f=[];u!=null&&(d=eo({inputs:{x:r},backend:n,attrs:{perm:u}}),f.push(d),c=bs(c.length,i));const h=n.data.get(d.dataId).values,{outVals:p,outShape:m,outDtype:g}=nG(d.shape,d.dtype,h,c);let y=m;return a&&(y=ys(m,l)),f.forEach(w=>n.disposeIntermediateTensorInfo(w)),n.makeTensorInfo(y,g,p)}const J2t={kernelName:N1,backendName:"cpu",kernelFunc:Z2t};function Q2t(t,e,n){t.forEach((s,r)=>{if(s<0||s>=n){const o=tf(r,e.length,Mt(e)).join(",");throw new Error(`indices[${o}] = ${s} is not in [0, ${n})`)}})}function evt(t,e){for(let n=0;n<t.length;++n){const s=t[n],r=n===t.length-1?e:t[n+1].length;if(s.length===0)throw new Error("Ragged splits may not be empty");if(s[0]<0)throw new Error("Ragged splits must be non-negative");if(s[s.length-1]>r)throw new Error("Ragged splits must not point past values");for(let o=1;o<s.length;++o)if(s[o-1]>s[o])throw new Error("Ragged splits must be sorted in ascending order")}}function tvt(t,e,n,s){const r=[];let o=0;const a=e.length-1+n.length,i=new Array(a).fill(null).map(()=>[0]);evt(n,s);let l=1;for(let u=0;u<e.length-1;++u){l*=e[u];const c=e[u+1];for(let d=1;d<l+1;++d)i[u].push(d*c)}for(let u=0;u<t.length;++u){let c=t[u],d=t[u]+1;for(let f=0;f<n.length;++f){const h=n[f],p=f+e.length-1;if(p>=0){const m=i[p],g=m[m.length-1]-h[c];for(let y=c;y<d;++y)i[p].push(h[y+1]+g)}c=h[c],d=h[d]}d!==c&&(r.push([c,d]),o+=d-c)}return{outSplits:i,valueSlices:r,numValues:o}}function nvt(t){const e=[];for(let n=0;n<t.length;++n){const s=t[n].length,r=gs("int32",s);e.push(r),t[n].forEach((o,a)=>r[a]=o)}return e}function zD(t,e){const n=t.slice(0,e);for(;n.length<e;)n.push(1);for(let s=e;s<t.length;s++)n[e-1]*=t[s];return n}function svt(t,e,n,s,r,o){const a=zD(e,2)[1],i=zD(o,2)[1];let l=0;for(const u of n)for(let c=u[0];c<u[1];++c){for(let d=0;d<s;++d)r[l*i+d]=t[c*a+d];++l}}function rvt(t,e,n,s,r){const o=e.slice();o[0]=r;const a=gs(n,Ge(o)),i=t.length,l=i===0?0:i/e[0];return svt(t,e,s,l,a,o),[a,o]}function sG(t,e,n,s,r,o,a,i){if(t.length===0)throw new Error("paramsNestedSplits must be non empty");if(e[0].length===0)throw new Error("Split tensors must not be scalars");const l=e[0][0]-1;if(Q2t(o,a,l),s.length===0)throw new Error("params.rank must be nonzero");const u=s[0],{outSplits:c,valueSlices:d,numValues:f}=tvt(o,a,t,u),h=nvt(c),p=rvt(n,s,r,d,f);return[h,p[0],p[1]]}const BD=2147483647;function rG(t,e,n,s,r,o,a){if(e.length>1)throw new Error("starts must be a scalar or vector");if(r.length>1)throw new Error("limits must be a scalar or vector");if(a.length>1)throw new Error("deltas must be a scalar or vector");const i=e.length===0,l=r.length===0,u=a.length===0,c=[];i||c.push(e[0]),l||c.push(r[0]),u||c.push(a[0]);for(let g=1;g<c.length;++g)if(c[g]!==c[g-1])throw new Error("starts, limits, and deltas must have the same shape");const d=c.length===0?1:c[0],f=gs("int32",d+1);f[0]=0;for(let g=0;g<d;++g){const y=i?t[0]:t[g],w=l?s[0]:s[g],b=u?o[0]:o[g];if(b===0)throw new Error("Requires delta != 0");let _;if(b>0&&w<y||b<0&&w>y)_=0;else if(_=Math.ceil(Math.abs((w-y)/b)),_>BD)throw new Error(`Requires ((limit - start) / delta) <= ${BD}`);f[g+1]=f[g]+_}const h=f[d],p=gs(n,h);let m=0;for(let g=0;g<d;++g){const y=f[g+1]-f[g];let w=i?t[0]:t[g];const b=u?o[0]:o[g];for(let _=0;_<y;++_)p[m++]=w,w+=b}return[f,p]}var ta=za;class yb{constructor(e,n,s,r,o,a,i,l,u,c){this.shape=e,this.shapeShape=n,this.values=s,this.valuesShape=r,this.valuesDType=o,this.defaultValue=a,this.defaultValueShape=i,this.rowPartitionValues=l,this.rowPartitionValuesShapes=u,this.rowPartitionTypes=IH(c),this.raggedRank=EH(this.rowPartitionTypes)}getRowPartitionTypeByDimension(e){return this.rowPartitionTypes[0]===ta.FIRST_DIM_SIZE?this.rowPartitionTypes[e+1]:this.rowPartitionTypes[e]}getRowPartitionTensor(e){return this.rowPartitionTypes[0]===ta.FIRST_DIM_SIZE?this.rowPartitionValues[e+1]:this.rowPartitionValues[e]}getMaxWidth(e){const n=this.getRowPartitionTensor(e-1);switch(this.getRowPartitionTypeByDimension(e-1)){case ta.VALUE_ROWIDS:return yb.getMaxWidthValueRowID(n);case ta.ROW_SPLITS:return yb.getMaxWidthRowSplit(n);default:throw new Error(`Cannot handle partition type ${ta[this.getRowPartitionTypeByDimension(e-1)]}`)}}static getMaxWidthRowSplit(e){const n=e.length;if(n===0||n===1)return 0;let s=0;for(let r=0;r<n-1;++r){const o=e[r+1]-e[r];o>s&&(s=o)}return s}static getMaxWidthValueRowID(e){const n=e.length;if(n===0)return 0;let s=0,r=e[0],o=0;for(let a=1;a<n;++a){const i=e[a];i!==r&&(r=i,o=Math.max(a-s,o),s=a)}return Math.max(n-s,o)}tensorShapeFromTensor(e,n,s=!0){if(n.length===0){if(e[0]===-1)return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return HD(e,s)}calculateOutputSize(e){const n=this.valuesShape,s=this.defaultValueShape;AH(s,n);const r=this.tensorShapeFromTensor(this.shape,this.shapeShape),a=NH(this.raggedRank,r,n);a[0]<0&&(a[0]=e);for(let i=1;i<=this.raggedRank;++i)a[i]<0&&(a[i]=this.getMaxWidth(i));return a}calculateFirstParentOutputIndex(e,n,s){const r=Math.min(e,s),o=[];let a=0;for(let i=0;i<r;++i,a+=n)o.push(a);for(let i=r;i<e;++i)o.push(-1);return q(o.length===e,()=>"Final length of result must be equal to firstDimension."),o}calculateOutputIndexRowSplit(e,n,s,r){const o=e.length,a=[];for(let i=0;i<o-1;++i){const l=e[i+1]-e[i];let u=Math.min(r,l),c=n[i];c===-1&&(u=0);for(let d=0;d<u;++d)a.push(c),c+=s;for(let d=0;d<l-u;++d)a.push(-1)}if(o>0&&a.length!==e[o-1])throw new Error("Invalid row split size.");return a}calculateOutputIndexValueRowID(e,n,s,r){const o=e.length,a=[];if(o===0)return[];let i=0,l=e[0];if(l>=n.length)throw new Error(`Got currentValueRowId=${l}, which is not less than ${n.length}`);let u=n[l];a.push(u);for(let c=1;c<o;++c){const d=e[c];if(d===l)u>=0&&(++i,i<r?u+=s:u=-1);else{if(i=0,l=d,d>=n.length)throw new Error(`Got nextValueRowId=${d} which is not less than ${n.length}`);u=n[d]}a.push(u)}if(a.length!==e.length)throw new Error("Invalid row ids.");return a}calculateOutputIndex(e,n,s,r){const o=this.getRowPartitionTensor(e),a=this.getRowPartitionTypeByDimension(e);switch(a){case ta.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(o,n,s,r);case ta.ROW_SPLITS:if(o.length-1>n.length)throw new Error(`Row partition size is greater than output size: ${o.length-1} > ${n.length}`);return this.calculateOutputIndexRowSplit(o,n,s,r);default:throw new Error(`Unsupported partition type: ${ta[a]}`)}}getFirstDimensionSize(){const e=this.rowPartitionValues[0];if(this.rowPartitionTypes.length===0)throw new Error("No row_partition_types given.");const n=this.rowPartitionTypes[0];switch(n){case ta.FIRST_DIM_SIZE:return e[0];case ta.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case ta.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${ta[n]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");const n=this.getFirstDimensionSize(),s=this.calculateOutputSize(n),r=new Array(this.raggedRank+1);r[r.length-1]=1;for(let l=r.length-2;l>=0;--l)r[l]=r[l+1]*s[l+1];const o=HD(s,!1),a=gs(this.valuesDType,Ge(o));if(r[0]*s[0]>0){let l=this.calculateFirstParentOutputIndex(n,r[0],s[0]);for(let u=1;u<=this.raggedRank;++u)l=this.calculateOutputIndex(u-1,l,r[u],s[u]);this.setOutput(this.raggedRank,l,a,o)}return[o,a]}setOutput(e,n,s,r){if(s.length===0)return;const o=this.values,a=s;let i=r.slice();i=i.slice(e+1);const l=Ge(i),u=n.length;let c=this.defaultValue;if(c.length!==l&&c.length!==1){const p=this.defaultValueShape;Le(()=>{const m=Ne(c,p);c=cd(m,i).dataSync()})}let d=0,f=0,h=0;for(let p=0;p<=u;++p){let m=p<u?n[p]:-1;if(m===h){++h;continue}if(f<h){const g=o.subarray(d*l),y=a.subarray(f*l),w=(h-f)*l;VD(y,g,w)}if(p>=u){const g=s.length;m=Math.floor(g/l)}if(m>h)if(this.defaultValue.length===1)a.subarray(h*l,m*l).fill(this.defaultValue[0]),h=m;else for(;m>h;){const g=a.slice(h*l);VD(g,c,l),++h}m<0?(d=p+1,f=h):(d=p,f=h,h=f+1)}}}function VD(t,e,n){for(let s=0;s<n;s++)t[s]=e[s]}function HD(t,e){const n=[];for(let s of t){if(s<0){if(!e)throw new Error(`Dimension ${s} must be >= 0`);if(s<-1)throw new Error(`Dimension ${s} must be >= -1`);s=-1}n.push(s)}return n}function oG(t,e,n,s,r,o,a,i,l,u){return new yb(t,e,n,s,r,o,a,i,l,u).compute()}function aG(t,e,n,s){const r=t===e,o=t<e&&n<0,a=e<t&&n>1;if(r||o||a)return or(0,s);const i=Math.abs(Math.ceil((e-t)/n)),l=or(i,s);e<t&&n===1&&(n=-1),l[0]=t;for(let u=1;u<l.length;u++)l[u]=l[u-1]+n;return l}const iG=vc(t=>1/Math.sqrt(t)),ovt=fm(Lp,iG),avt={kernelName:Lp,backendName:"cpu",kernelFunc:ovt};function zf(t,e,n,s,r,o,a,i,l,u){const c=[s/r,r],d=t.values,f=e.values;if(s===0)return tn(n,e.dtype);const h=tn(c,e.dtype);typeof l=="string"||typeof l=="number"?h.values.fill(l):typeof l=="boolean"&&h.values.fill(+l);for(let p=0;p<o;p++){const m=[];let g=0;for(let y=0;y<a;y++){const w=d[p*a+y];m.push(w),g+=w*i[y]}if(g<0||g>=s/r)throw new Error(`Invalid indices: ${m} does not index into ${n}`);for(let y=0;y<r;y++)u?h.values[g*r+y]+=f[p*r+y]:h.values[g*r+y]=e.rank===0?f[0]:f[p*r+y]}return h}const ivt=vc(t=>1/(1+Math.exp(-t))),lG=An(Wp,t=>1/(1+Math.exp(-t))),lvt={kernelName:Wp,backendName:"cpu",kernelFunc:lG};function uG(t,e,n,s,r){const o=f8(s,e,n),a=Ge(n),i=Mt(s);if(o){const d=h8(e,i);return r==="string"?t.slice(d,d+a):t.subarray(d,d+a)}const l=r==="string"?Md(t):t,u=tn(s,r,l),c=tn(n,r);for(let d=0;d<c.size;++d){const f=c.indexToLoc(d),h=f.map((p,m)=>p+e[m]);c.set(u.get(...h),...f)}return r==="string"?ZH(c.values):c.values}function Bd(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{begin:o,size:a}=s;Tt(r,"slice");const[i,l]=z_(r,o,a);c8(r,i,l);const u=n.data.get(r.dataId).values,c=uG(u,i,l,r.shape,r.dtype);return n.makeTensorInfo(l,r.dtype,c)}const uvt={kernelName:D1,backendName:"cpu",kernelFunc:Bd};function cG(t,e,n,s,r,o,a){const i=e[0],l=o[0],u=new Array(l),c=new Array(i),d=e[1];if(l===0){if(i!==0)throw new Error(LH(i));const g=gs(n,0),y=gs(r,0);return[g,[0,d],y,u,c]}let f=!0,h=0;const p=new Array(l).fill(0);for(let g=0;g<i;++g){const y=t[g*d];if(y<0)throw new Error(zH(g,y));if(y>=l)throw new Error(BH(g,y,l));++p[y],f=f&&y>=h,h=y}let m=!0;for(let g=0;g<l;++g){const y=p[g]===0;u[g]=y,m=m&&!y,p[g]=Math.max(p[g],1),g>0&&(p[g]+=p[g-1])}if(m&&f){const g=t,y=s;for(let w=0;w<i;++w)c[w]=w;return[g,[i,d],y,u,c]}else{const g=p[l-1],y=gs(n,g*d),w=gs(r,g),b=new Array(l).fill(0);for(let _=0;_<i;++_){const $=t[_*d],x=b[$],k=($===0?0:p[$-1])+x;b[$]++;for(let C=0;C<d;++C)y[k*d+C]=t[_*d+C];w[k]=s[_],c[_]=k}for(let _=0;_<l;++_)if(b[_]===0){const x=_===0?0:p[_-1];y[x*d+0]=_;for(let k=1;k<d;++k)y[x*d+k]=0;w[x]=a}return[y,[g,d],w,u,c]}}function dG(t,e,n,s,r){const o=Ge(s),a=e[0],i=r.length,l=[];let u=1,c=-1;for(let g=0;g<i;++g){const y=r[g];if(y===-1){if(c!==-1)throw new Error(VH(c,g));c=g,l.push(1)}else{if(y<0)throw new Error(HH(g,y));u*=y,l.push(y)}}if(c!==-1){if(u<=0)throw new Error(WH());const g=Math.trunc(o/u);if(u*g!==o)throw new Error(UH(s,l));l[c]=g}if(Ge(l)!==o)throw new Error(GH(s,l));const f=s.length,h=[];if(f>0){h[f-1]=1;for(let g=f-2;g>=0;--g)h[g]=h[g+1]*s[g+1]}const p=[];if(i>0){p[i-1]=1;for(let g=i-2;g>=0;--g)p[g]=p[g+1]*l[g+1]}const m=gs(n,a*i);for(let g=0;g<a;++g){let y=0;for(let w=0;w<f;++w)y+=t[g*f+w]*h[w];for(let w=0;w<i;++w)m[g*i+w]=Math.trunc(y/p[w]),y%=p[w]}return[m,[a,i],l]}function $I(t,e,n,s,r,o=!1,a=0){const i=s.length,l=[e[0],t.length/e[0]],u=l[1],d=i>0?r[i-1]+1:0;if(d<0)throw new Error(Nx());const f=e.slice();f[0]=d;const h=f.reduce((b,_)=>b*_,1),p=gs(n,h);if(i===0)return d>0&&p.fill(a),[p,f];if(d<=0)throw new Error(Nx());let m=0,g=1,y=0,w=r[m];for(;;){let b=0;if(g<i){if(b=r[g],w===b){++g;continue}if(w>=b)throw new Error(jH())}if(w<0||w>=d)throw new Error(KH(w,d));w>y&&p.fill(a,y*u,w*u);for(let _=m;_<g;++_){const $=s[_];if($<0||$>=l[0])throw new Error(qH(_,s[_],l[0]));for(let x=0;x<u;x++)p[w*u+x]+=t[$*u+x]}if(o)for(let _=0;_<u;_++)p[w*u+_]/=g-m;if(m=g,++g,y=w+1,w=b,g>i)break}return y<d&&p.fill(a,y*u,d*u),[p,f]}const cvt=vc(t=>Math.sqrt(t)),dvt=An(Gp,t=>Math.sqrt(t)),fvt={kernelName:Gp,backendName:"cpu",kernelFunc:dvt};const fG=Is((t,e)=>{const n=t-e;return n*n}),hvt=Ks(jp,fG),pvt={kernelName:jp,backendName:"cpu",kernelFunc:hvt};function hG(t,e,n,s){const r=tn(t,e.dtype);for(let o=0;o<r.size;o++){const a=r.indexToLoc(o),i=new Array(a.length);for(let l=0;l<i.length;l++)i[l]=a[l]*n[l]+s[l];r.set(e.get(...i),...a)}return r}class mvt{constructor(e,n,s,r,o,a){this.separator=Oi(e),this.nGramWidths=n,this.leftPad=Oi(s),this.rightPad=Oi(r),this.padWidth=o,this.preserveShort=a}getPadWidth(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)}getNumNGrams(e,n){const s=this.getPadWidth(n);return Math.max(0,e+2*s-n+1)}createNGrams(e,n,s,r,o,a){for(let i=0;i<o;++i){const l=this.getPadWidth(a),u=Math.max(0,l-i),c=Math.max(0,l-(o-(i+1))),d=a-(u+c),f=n+(u>0?0:i-l);let h=0;h+=u*this.leftPad.length;for(let w=0;w<d;++w)h+=e[f+w].length;h+=c*this.rightPad.length;const p=u+c+d-1;h+=p*this.separator.length,s[r+i]=new Uint8Array(h);const m=s[r+i];let g=0;const y=w=>w.forEach(b=>m[g++]=b);for(let w=0;w<u;++w)y(this.leftPad),y(this.separator);for(let w=0;w<d-1;++w)y(e[f+w]),y(this.separator);if(d>0){y(e[f+d-1]);for(let w=0;w<c;++w)y(this.separator),y(this.rightPad)}else{for(let w=0;w<c-1;++w)y(this.rightPad),y(this.separator);y(this.rightPad)}}}compute(e,n){const s=e.length,r=n.length;if(r>0){let l=n[0];if(l!==0)throw new Error(`First split value must be 0, got ${l}`);for(let u=1;u<r;++u){let c=n[u]>=l;if(c=c&&n[u]<=s,!c)throw new Error(`Invalid split value ${n[u]}, must be in [${l}, ${s}]`);l=n[u]}if(l!==s)throw new Error(`Last split value must be data size. Expected ${s}, got ${l}`)}const o=r-1,a=gs("int32",r);if(s===0||r===0){const l=new Array(s);for(let u=0;u<=o;++u)a[u]=0;return[l,a]}a[0]=0;for(let l=1;l<=o;++l){const u=n[l]-n[l-1];let c=0;this.nGramWidths.forEach(d=>{c+=this.getNumNGrams(u,d)}),this.preserveShort&&u>0&&c===0&&(c=1),a[l]=a[l-1]+c}const i=new Array(a[o]);for(let l=0;l<o;++l){const u=n[l];let c=a[l];if(this.nGramWidths.forEach(d=>{const f=n[l+1]-n[l],h=this.getNumNGrams(f,d);this.createNGrams(e,u,i,c,h,d),c+=h}),this.preserveShort&&c===a[l]){const d=n[l+1]-n[l];if(d===0)continue;const f=d+2*this.padWidth,h=1;this.createNGrams(e,u,i,c,h,f)}}return[i,a]}}function pG(t,e,n,s,r,o,a,i){return new mvt(n,s,r,o,a,i).compute(t,e)}function gvt(t,e,n,s){if(!t.length)return;if(e.length===0){for(let o=0;o<t.length;++o)s.push(t.subarray(o,o+1));return}if(e.length===1){const o=e[0];let a=t.indexOf(o);for(;a!==-1;){const i=t.subarray(0,a);(!n||i.length!==0)&&s.push(i),t=t.subarray(a+1),a=t.indexOf(o)}(!n||t.length!==0)&&s.push(t);return}let r=0;for(let o=0;o<t.length+1;o++)if(o===t.length||e.indexOf(t[o])!==-1){const a=t.subarray(r,o);(!n||a.length!==0)&&s.push(a),r=o+1}}function mG(t,e,n){const s=t.length,r=[];let o=0,a=0;const i=new Array(s);for(let f=0;f<s;++f){const h=r.length;gvt(t[f],e,n,r);const p=r.length-h;i[f]=p,o+=p,a=Math.max(a,p)}const l=gs("int32",o*2),u=new Array(o),c=[s,a];let d=0;for(let f=0;f<s;++f)for(let h=0;h<i[f];++h)l[d*2]=f,l[d*2+1]=h,u[d]=r[d],++d;return[l,u,c]}function gG(t,e){const n=gs("int32",t.length);for(let s=0;s<t.length;++s)n[s]=PB(t[s]).modulo(e).getLowBitsUnsigned();return n}const vG=Is((t,e)=>t-e),vvt=yI((t,e,n,s)=>({real:t-n,imag:e-s})),xI=Ks(Kp,vG,vvt),yvt={kernelName:Kp,backendName:"cpu",kernelFunc:xI};function yG(t,e){const n=new Array(t.rank);for(let r=0;r<n.length;r++)n[r]=t.shape[r]*e[r];const s=tn(n,t.dtype);for(let r=0;r<s.values.length;++r){const o=s.indexToLoc(r),a=new Array(t.rank);for(let l=0;l<a.length;l++)a[l]=o[l]%t.shape[l];const i=t.locToIndex(a);s.values[r]=t.values[i]}return s}const qm=(t,e)=>{const n=e.value-t.value;return n===0?t.index-e.index:n};function bG(t,e,n=0,s=t.length-1){for(;s>n;){if(s-n>600){const i=s-n+1,l=e-n+1,u=Math.log(i),c=.5*Math.exp(2*u/3),d=.5*Math.sqrt(u*c*(i-c)/i)*Math.sign(l-i/2),f=Math.max(n,Math.floor(e-l*c/i+d)),h=Math.min(s,Math.floor(e+(i-l)*c/i+d));bG(t,e,f,h)}const r=t[e];let o=n,a=s;for(hl(t,n,e),qm(t[s],r)>0&&hl(t,n,s);o<a;){for(hl(t,o,a),o++,a--;qm(t[o],r)<0;)o=o+1;for(;qm(t[a],r)>0;)a=a-1}qm(t[n],r)===0?hl(t,n,a):(a=a+1,hl(t,a,s)),a<=e&&(n=a+1),e<=a&&(s=a-1)}}function wG(t,e,n,s,r){const o=e[e.length-1],[a,i]=[t.length/o,o],l=zs(n,a*s),u=zs("int32",a*s);for(let d=0;d<a;d++){const f=d*i,h=t.subarray(f,f+i);let p=new Array(h.length);h.forEach((w,b)=>p[b]={value:w,index:b}),s<p.length&&(bG(p,s),p=p.slice(0,s)),r&&p.sort(qm);const m=d*s,g=l.subarray(m,m+s),y=u.subarray(m,m+s);for(let w=0;w<s;w++)g[w]=p[w].value,y[w]=p[w].index}const c=e.slice();return c[c.length-1]=s,[tn(c,n,l),tn(c,"int32",u)]}function _G(t,e,n,s){const r=un(e,n)[0],o=[1,n[0],1];for(let p=0;p<r;p++)o[0]*=n[p];o[1]=n[r];for(let p=r+1;p<n.length;p++)o[2]*=n[p];const a={},i=new Int32Array(n[r]),l=new Ds(o,s,t),u=[],c=o[0]===1&&o[2]===1;for(let p=0;p<n[r];p++){let m;if(c)m=t[p].toString();else{const g=[];for(let y=0;y<o[0];y++)for(let w=0;w<o[2];w++)g.push(l.get(y,p,w));m=g.join(",")}if(a[m]!==void 0)i[p]=a[m];else{const g=Object.keys(a).length;a[m]=g,i[p]=g,u.push(p)}}const d=o.slice();d[1]=Object.keys(a).length;const f=new Ds(d,s);u.forEach((p,m)=>{for(let g=0;g<o[0];g++)for(let y=0;y<o[2];y++)f.set(l.get(g,p,y),g,m,y)});const h=n.slice();return h[r]=d[1],{outputValues:f.values,outputShape:h,indices:i}}const bvt=Object.freeze(Object.defineProperty({__proto__:null,simpleAbsImpl:AU,addImpl:RU,bincountImpl:bI,bincountReduceImpl:DU,castImpl:OU,ceilImpl:FU,concatImpl:MU,equalImpl:PU,expImpl:zU,expm1Impl:VU,floorImpl:HU,gatherNdImpl:WU,gatherV2Impl:UU,greaterImpl:GU,greaterEqualImpl:jU,lessImpl:KU,lessEqualImpl:qU,linSpaceImpl:XU,logImpl:YU,maxImpl:ZU,maximumImpl:JU,minimumImpl:QU,multiplyImpl:wI,negImpl:eG,notEqualImpl:tG,prodImpl:nG,raggedGatherImpl:sG,raggedRangeImpl:rG,raggedTensorToTensorImpl:oG,rangeImpl:aG,rsqrtImpl:iG,scatterImpl:zf,sigmoidImpl:ivt,sliceImpl:uG,sparseFillEmptyRowsImpl:cG,sparseReshapeImpl:dG,sparseSegmentReductionImpl:$I,sqrtImpl:cvt,squaredDifferenceImpl:fG,stridedSliceImpl:hG,stringNGramsImpl:pG,stringSplitImpl:mG,stringToHashBucketFastImpl:gG,subImpl:vG,tileImpl:yG,topKImpl:wG,transposeImpl:_I,uniqueImpl:_G},Symbol.toStringTag,{value:"Module"}));const wvt="4.1.0";a8("cpu",()=>new Z3,1);const $G=An(gp,t=>t>=0?t:Math.exp(t)-1),_vt={kernelName:gp,backendName:"cpu",kernelFunc:$G};function xG(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{alpha:o}=s;Tt([r],"leakyRelu");const a=Ge(r.shape),i=n.data.get(r.dataId).values,l=zs("float32",a);for(let u=0;u<i.length;u++)l[u]=i[u]<0?o*i[u]:i[u];return n.makeTensorInfo(r.shape,"float32",l)}const $vt={kernelName:l1,backendName:"cpu",kernelFunc:xG};const xvt=Is((t,e)=>t<0?e*t:t);function SG(t){const{inputs:e,backend:n}=t,{x:s,alpha:r}=e;Tt([s,r],"prelu");const o=n.data.get(s.dataId).values,a=n.data.get(r.dataId).values,[i,l]=xvt(s.shape,r.shape,o,a,"float32");return n.makeTensorInfo(l,"float32",i)}const Svt={kernelName:T1,backendName:"cpu",kernelFunc:SG};const CG=An(Fp,t=>Math.max(0,t)),Cvt={kernelName:Fp,backendName:"cpu",kernelFunc:CG};const kG=An(Mp,t=>Math.min(Math.max(0,t),6)),kvt={kernelName:Mp,backendName:"cpu",kernelFunc:kG};function bb(t,e,n,s,r){if(n==="linear")return Wi({inputs:{x:e},backend:t});if(n==="relu")return CG({inputs:{x:e},backend:t});if(n==="elu")return $G({inputs:{x:e},backend:t});if(n==="relu6")return kG({inputs:{x:e},backend:t});if(n==="prelu")return SG({inputs:{x:e,alpha:s},backend:t});if(n==="leakyrelu")return xG({inputs:{x:e},backend:t,attrs:{alpha:r}});if(n==="sigmoid")return lG({inputs:{x:e},backend:t});throw new Error(`Activation ${n} has not been implemented for the CPU backend.`)}function Gn(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{shape:o}=s,a=Ge(r.shape),i=Vk(o,a),l=Ge(i);q(a===l,()=>`The new shape (${i}) has ${l} elements and the old shape (${r.shape}) has ${a} elements. The new shape and old shape must have the same number of elements.`),n.incRef(r.dataId);const u=n.data.get(r.dataId);if(u.complexTensorInfos!=null){const c=u.complexTensorInfos.real,d=u.complexTensorInfos.imag;c.shape=i,d.shape=i}return{dataId:r.dataId,shape:i,dtype:r.dtype}}const Tvt={kernelName:I1,backendName:"cpu",kernelFunc:Gn};function TG(t){const{inputs:e,backend:n,attrs:s}=t,{a:r,b:o}=e,{transposeA:a,transposeB:i}=s;Tt([r,o],"matMul");const l=r.shape.length,u=o.shape.length,c=a?r.shape[l-2]:r.shape[l-1],d=i?o.shape[u-1]:o.shape[u-2],f=a?r.shape[l-1]:r.shape[l-2],h=i?o.shape[u-2]:o.shape[u-1],p=r.shape.slice(0,-2),m=o.shape.slice(0,-2),g=Ge(p),y=Ge(m),b=Zt(r.shape.slice(0,-2),o.shape.slice(0,-2)).concat([f,h]);q(c===d,()=>`Error in matMul: inner shapes (${c}) and (${d}) of Tensors with shapes ${r.shape} and ${o.shape} and transposeA=${a} and transposeB=${i} must match.`);const _=a?[g,c,f]:[g,f,c],$=i?[y,h,d]:[y,d,h],x=Gn({inputs:{x:r},backend:n,attrs:{shape:_}}),k=Gn({inputs:{x:o},backend:n,attrs:{shape:$}}),C=a?x.shape[1]:x.shape[2],T=a?x.shape[2]:x.shape[1],N=i?k.shape[1]:k.shape[2],M=Math.max(g,y),R=n.data.get(x.dataId).values,D=n.data.get(k.dataId).values,z=Mt(x.shape),B=Mt(k.shape),[V,O,F]=a?[z[0],1,z[1]]:[z[0],z[1],1],[L,G,Z]=i?[1,B[1],B[0]]:[B[1],1,B[0]],j=T*N,J=tn([M,T,N],x.dtype),fe=J.values,X=n.blockSize;for(let oe=0;oe<M;oe++)for(let ee=0;ee<T;ee+=X)for(let Q=0;Q<N;Q+=X)for(let ie=0;ie<C;ie+=X){const pe=Math.min(ee+X,T),Re=Math.min(Q+X,N),K=Math.min(ie+X,C);for(let re=ee;re<pe;re++)for(let we=Q;we<Re;we++){let Ee=0;for(let De=ie;De<K;De++){const _e=Math.min(oe,g-1)*V,ze=Math.min(oe,y-1)*Z,Ae=R[_e+re*O+De*F],he=D[De*L+we*G+ze];Ee+=Ae*he}fe[oe*j+(re*N+we)]+=Ee}}return n.disposeIntermediateTensorInfo(x),n.disposeIntermediateTensorInfo(k),n.makeTensorInfo(b,J.dtype,J.values)}const Nvt={kernelName:Kg,backendName:"cpu",kernelFunc:TG};function Ivt(t){const{inputs:e,backend:n,attrs:s}=t,{a:r,b:o,bias:a,preluActivationWeights:i}=e,{transposeA:l,transposeB:u,activation:c,leakyreluAlpha:d}=s;let f,h,p;const m=[];f=TG({inputs:{a:r,b:o},attrs:{transposeA:l,transposeB:u},backend:n}),a&&(h=Rh({inputs:{a:f,b:a},backend:n}),m.push(f),f=h),c&&(p=bb(n,f,c,i,d),m.push(f),f=p);for(const y of m)n.disposeIntermediateTensorInfo(y);return f}const Evt={kernelName:Y0,backendName:"cpu",kernelFunc:Ivt};const Avt=An(sp,t=>Math.acos(t)),Ovt={kernelName:sp,backendName:"cpu",kernelFunc:Avt};const Rvt=An(rp,t=>Math.acosh(t)),Dvt={kernelName:rp,backendName:"cpu",kernelFunc:Rvt};function Fvt(t){const{inputs:e,backend:n}=t,s=e;Tt(e,"addN");const r=s.map(i=>n.data.get(i.dataId).values),o=tn(s[0].shape,s[0].dtype),a=o.values;for(let i=0;i<s.length;i++){const l=r[i];for(let u=0;u<a.length;u++)a[u]+=l[u]}return n.makeTensorInfo(o.shape,o.dtype,o.values)}const Mvt={kernelName:Hg,backendName:"cpu",kernelFunc:Fvt};function Pvt(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{axis:o,keepDims:a}=s;Tt(r,"all");const i=un(o,r.shape);let l=i;const u=hs(l,r.shape.length);let c=r;u!=null&&(c=eo({inputs:{x:r},backend:n,attrs:{perm:u}}),l=bs(l.length,r.shape.length)),cr("all",l,c.shape.length);const[d,f]=js(c.shape,l),h=Ge(f),p=or(Ge(d),c.dtype),m=n.data.get(c.dataId).values;for(let y=0;y<p.length;++y){const w=y*h;let b=m[w];for(let _=0;_<h;++_){const $=m[w+_];b=b&&$}p[y]=b}u!=null&&n.disposeIntermediateTensorInfo(c);const g=n.makeTensorInfo(d,c.dtype,p);if(a){const y=ys(d,i),w=Gn({inputs:{x:g},backend:n,attrs:{shape:y}});return n.disposeIntermediateTensorInfo(g),w}return g}const Lvt={kernelName:Aw,backendName:"cpu",kernelFunc:Pvt};function zvt(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{axis:o,keepDims:a}=s;Tt(r,"any");const i=un(o,r.shape);let l=i;const u=hs(l,r.shape.length);let c=r;u!=null&&(c=eo({inputs:{x:r},backend:n,attrs:{perm:u}}),l=bs(l.length,r.shape.length)),cr("any",l,c.shape.length);const[d,f]=js(c.shape,l),h=Ge(f),p=or(Ge(d),c.dtype),m=n.data.get(c.dataId).values;for(let y=0;y<p.length;++y){const w=y*h;let b=m[w];for(let _=0;_<h;++_){const $=m[w+_];b=b||$}p[y]=b}u!=null&&n.disposeIntermediateTensorInfo(c);const g=n.makeTensorInfo(d,c.dtype,p);if(a){const y=ys(d,i),w=Gn({inputs:{x:g},backend:n,attrs:{shape:y}});return n.disposeIntermediateTensorInfo(g),w}return g}const Bvt={kernelName:Ow,backendName:"cpu",kernelFunc:zvt};function Vvt(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{axis:o}=s;Tt(r,"argMax");let a=un(o,r.shape);const i=hs(a,r.shape.length);let l=r;const u=[];i!=null&&(l=eo({inputs:{x:r},backend:n,attrs:{perm:i}}),u.push(l),a=bs(a.length,l.shape.length)),a=[a[0]],cr("argMax",a,l.shape.length);const[c,d]=js(l.shape,a),f=Ge(c),h=or(f,"int32"),p=Ge(d),m=n.data.get(l.dataId).values;for(let g=0;g<h.length;++g){const y=g*p;let w=m[y],b=0;for(let _=0;_<p;++_){const $=m[y+_];$>w&&(w=$,b=_)}h[g]=b}return u.forEach(g=>n.disposeIntermediateTensorInfo(g)),n.makeTensorInfo(c,"int32",h)}const Hvt={kernelName:Wg,backendName:"cpu",kernelFunc:Vvt};function Wvt(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{axis:o}=s;Tt(r,"argMin");let a=un(o,r.shape);const i=hs(a,r.shape.length);let l=r;const u=[];i!=null&&(l=eo({inputs:{x:r},backend:n,attrs:{perm:i}}),u.push(l),a=bs(a.length,l.shape.length)),a=[a[0]],cr("argMin",a,l.shape.length);const[c,d]=js(l.shape,a),f=Ge(c),h=or(f,"int32"),p=Ge(d),m=n.data.get(l.dataId).values;for(let g=0;g<h.length;++g){const y=g*p;let w=m[y],b=0;for(let _=0;_<p;++_){const $=m[y+_];$<w&&(w=$,b=_)}h[g]=b}return u.forEach(g=>n.disposeIntermediateTensorInfo(g)),n.makeTensorInfo(c,"int32",h)}const Uvt={kernelName:Ug,backendName:"cpu",kernelFunc:Wvt};const Gvt=An(op,t=>Math.asin(t)),jvt={kernelName:op,backendName:"cpu",kernelFunc:Gvt};const Kvt=An(ap,t=>Math.asinh(t)),qvt={kernelName:ap,backendName:"cpu",kernelFunc:Kvt};const Xvt=An(ip,t=>Math.atan(t)),Yvt={kernelName:ip,backendName:"cpu",kernelFunc:Xvt};const Zvt=Is((t,e)=>Math.atan2(t,e)),Jvt=Ks(up,Zvt),Qvt={kernelName:up,backendName:"cpu",kernelFunc:Jvt};const eyt=An(lp,t=>Math.atanh(t)),tyt={kernelName:lp,backendName:"cpu",kernelFunc:eyt};function SI(t,e,n,s,r,o){const a=r.strideHeight,i=r.strideWidth,l=r.dilationHeight,u=r.dilationWidth,c=r.effectiveFilterHeight,d=r.effectiveFilterWidth,f=r.padInfo.top,h=r.padInfo.left,p=o==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,m=tn(r.outShape,n),g=m.values,y=r.outShape[1]*r.outShape[2]*r.outShape[3],w=r.outShape[2]*r.outShape[3],b=r.outShape[3];for(let _=0;_<r.batchSize;++_){const $=_*y,x=_*s[0];for(let k=0;k<r.inChannels;++k)for(let C=0;C<r.outHeight;++C){const T=C*a-f,N=Math.max(0,T),M=Math.min(r.inHeight,c+T),R=$+C*w;for(let D=0;D<r.outWidth;++D){const z=D*i-h,B=Math.max(0,z),V=Math.min(r.inWidth,d+z);let O=p,F=0,L=0;for(let Z=N;Z<M;Z+=l){const j=x+Z*s[1];for(let J=B;J<V;J+=u){const fe=j+J*s[2],X=t[fe+k];o==="max"&&X>O?O=X:o==="avg"&&(F+=X,L++)}if(isNaN(O))break}const G=R+D*b+k;g[G]=o==="avg"?F/L:O}}}return m}function NG(t,e,n,s,r=!1,o=!1){const a=tn(s.outShape,"int32"),i=s.strideHeight,l=s.strideWidth,u=s.dilationHeight,c=s.dilationWidth,d=s.effectiveFilterHeight,f=s.effectiveFilterWidth,h=s.padInfo.top,p=s.padInfo.left,m=tn(e,n,t);for(let g=0;g<s.batchSize;++g)for(let y=0;y<s.inChannels;++y)for(let w=0;w<s.outHeight;++w){const b=w*i-h;let _=b;for(;_<0;)_+=u;const $=Math.min(s.inHeight,d+b);for(let x=0;x<s.outWidth;++x){const k=x*l-p;let C=k;for(;C<0;)C+=c;const T=Math.min(s.inWidth,f+k);let N=Number.NEGATIVE_INFINITY,M=-1;for(let R=_;R<$;R+=u){const D=R-b;for(let z=C;z<T;z+=c){const B=z-k,V=m.get(g,R,z,y);V>N&&(N=V,r?M=o?((g*s.inHeight+R)*s.inWidth+z)*s.inChannels+y:(R*s.inWidth+z)*s.inChannels+y:M=D*f+B)}}a.set(M,g,w,x,y)}}return a}function IG(t,e,n,s,r,o){const a=r.strideDepth,i=r.strideHeight,l=r.strideWidth,u=r.dilationDepth,c=r.dilationHeight,d=r.dilationWidth,f=r.effectiveFilterDepth,h=r.effectiveFilterHeight,p=r.effectiveFilterWidth,m=r.padInfo.front,g=r.padInfo.top,y=r.padInfo.left,w=o==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,b=tn(r.outShape,n),_=b.values,$=r.outShape[1]*r.outShape[2]*r.outShape[3]*r.outShape[4],x=r.outShape[2]*r.outShape[3]*r.outShape[4],k=r.outShape[3]*r.outShape[4],C=r.outShape[4];for(let T=0;T<r.batchSize;++T){const N=T*$,M=T*s[0];for(let R=0;R<r.inChannels;++R)for(let D=0;D<r.outDepth;++D){const z=D*a-m;let B=z;for(;B<0;)B+=u;const V=Math.min(r.inDepth,f+z),O=N+D*x;for(let F=0;F<r.outHeight;++F){const L=F*i-g;let G=L;for(;G<0;)G+=c;const Z=Math.min(r.inHeight,h+L),j=O+F*k;for(let J=0;J<r.outWidth;++J){const fe=J*l-y;let X=fe;for(;X<0;)X+=d;const oe=Math.min(r.inWidth,p+fe),ee=j+J*C;let Q=w,ie=0,pe=0;for(let K=B;K<V;K+=u){const re=M+K*s[1];for(let we=G;we<Z;we+=c){const Ee=re+we*s[2];for(let De=X;De<oe;De+=d){const _e=Ee+De*s[3],ze=t[_e+R];if(o==="max"&&ze>Q?Q=ze:o==="avg"&&(ie+=ze,pe++),isNaN(Q))break}if(isNaN(Q))break}if(isNaN(Q))break}const Re=ee+R;_[Re]=o==="avg"?ie/pe:Q}}}}return b}function nyt(t,e){const n=tn(e.outShape,"int32"),s=e.strideDepth,r=e.strideHeight,o=e.strideWidth,a=e.dilationDepth,i=e.dilationHeight,l=e.dilationWidth,u=e.effectiveFilterDepth,c=e.effectiveFilterHeight,d=e.effectiveFilterWidth,f=e.padInfo.front,h=e.padInfo.top,p=e.padInfo.left;for(let m=0;m<e.batchSize;++m)for(let g=0;g<e.inChannels;++g)for(let y=0;y<e.outDepth;++y){const w=y*s-f;let b=w;for(;b<0;)b+=a;const _=Math.min(e.inDepth,u+w);for(let $=0;$<e.outHeight;++$){const x=$*r-h;let k=x;for(;k<0;)k+=i;const C=Math.min(e.inHeight,c+x);for(let T=0;T<e.outWidth;++T){const N=T*o-p;let M=N;for(;M<0;)M+=l;const R=Math.min(e.inWidth,d+N);let D=Number.NEGATIVE_INFINITY,z=-1;for(let B=b;B<_;B+=a){const V=B-w;for(let O=k;O<C;O+=i){const F=O-x;for(let L=M;L<R;L+=l){const G=L-N,Z=t.get(m,B,O,L,g);Z>=D&&(D=Z,z=V*c*d+F*c+G)}}}n.set(z,m,y,$,T,g)}}}return n}function syt(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e;Tt(r,"avgPool");const{filterSize:o,strides:a,pad:i,dimRoundingMode:l}=s,u=1;q(ur(a,u),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${u}'`);const c=Na(r.shape,o,a,u,i,l);let d;if(c.filterWidth===1&&c.filterHeight===1&&hn(c.inShape,c.outShape))d=Wi({inputs:{x:r},backend:n});else{const f=n.data.get(r.dataId).values,h=Mt(r.shape),p=SI(f,r.shape,r.dtype,h,c,"avg");d=n.makeTensorInfo(c.outShape,r.dtype,p.values)}return d}const ryt={kernelName:Gg,backendName:"cpu",kernelFunc:syt};function oyt(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{filterSize:o,strides:a,pad:i,dimRoundingMode:l,dataFormat:u}=s;Tt(r,"avgPool3d");const c=Xl(r.shape,o,a,1,i,l,u),d=n.data.get(r.dataId).values,f=IG(d,r.shape,r.dtype,Mt(r.shape),c,"avg");return n.makeTensorInfo(f.shape,"float32",f.values)}const ayt={kernelName:jg,backendName:"cpu",kernelFunc:oyt};function iyt(t){const{inputs:e,backend:n,attrs:s}=t,{dy:r,input:o}=e,{filterSize:a,strides:i,pad:l,dimRoundingMode:u}=s;Tt([r,o],"avgPool3DGrad");const c=Xl(o.shape,a,i,1,l,u),d=c.strideDepth,f=c.strideHeight,h=c.strideWidth,p=c.filterDepth,m=c.filterHeight,g=c.filterWidth,y=c.dilationDepth,w=c.dilationHeight,b=c.dilationWidth,_=c.effectiveFilterDepth,$=c.effectiveFilterHeight,x=c.effectiveFilterWidth,k=_-1-c.padInfo.front,C=x-1-c.padInfo.left,T=$-1-c.padInfo.top,N=tn(o.shape,"float32"),M=1/(p*m*g),R=n.bufferSync(r);for(let D=0;D<c.batchSize;++D)for(let z=0;z<c.inChannels;++z)for(let B=0;B<c.inDepth;++B)for(let V=0;V<c.inHeight;++V)for(let O=0;O<c.inWidth;++O){const F=B-k,L=V-T,G=O-C;let Z=0;for(let j=0;j<_;j+=y){const J=(F+j)/d;if(!(J<0||J>=c.outDepth||Math.floor(J)!==J))for(let fe=0;fe<$;fe+=w){const X=(L+fe)/f;if(!(X<0||X>=c.outHeight||Math.floor(X)!==X))for(let oe=0;oe<x;oe+=b){const ee=(G+oe)/h;if(ee<0||ee>=c.outWidth||Math.floor(ee)!==ee)continue;const Q=R.get(D,J,X,ee,z);Z+=Q}}}N.set(Z*M,D,B,V,O,z)}return n.makeTensorInfo(N.shape,N.dtype,N.values)}const lyt={kernelName:Dw,backendName:"cpu",kernelFunc:iyt};function uyt(t){const{inputs:e,backend:n,attrs:s}=t,{dy:r,input:o}=e,a=o;Tt([r,o],"avgPoolGrad");const{filterSize:i,strides:l,pad:u}=s,c=Na(a.shape,i,l,1,u),d=c.strideHeight,f=c.strideWidth,h=c.filterHeight,p=c.filterWidth,m=c.dilationHeight,g=c.dilationWidth,y=c.effectiveFilterHeight,w=c.effectiveFilterWidth,b=w-1-c.padInfo.left,_=y-1-c.padInfo.top,$=tn(a.shape,"float32"),x=1/(h*p),k=n.data.get(r.dataId).values,C=tn(r.shape,"float32",k);for(let T=0;T<c.batchSize;++T)for(let N=0;N<c.inChannels;++N)for(let M=0;M<c.inHeight;++M)for(let R=0;R<c.inWidth;++R){const D=M-_,z=R-b;let B=0;for(let V=0;V<y;V+=m){const O=(D+V)/d;if(!(O<0||O>=c.outHeight||Math.floor(O)!==O))for(let F=0;F<w;F+=g){const L=(z+F)/f;if(L<0||L>=c.outWidth||Math.floor(L)!==L)continue;const G=C.get(T,O,L,N);B+=G}}$.set(B*x,T,M,R,N)}return n.makeTensorInfo($.shape,$.dtype,$.values)}const cyt={kernelName:Rw,backendName:"cpu",kernelFunc:uyt};function dyt(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,scale:o,offset:a,mean:i,variance:l}=e;q(i.shape.length===l.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),q(a==null||i.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),q(o==null||i.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),Tt([r,i,l,o,a],"batchNorm");let{varianceEpsilon:u}=s;u==null&&(u=.001);const c=n.data.get(r.dataId).values,d=n.data.get(i.dataId).values,f=n.data.get(l.dataId).values,h=o?n.data.get(o.dataId).values:new Float32Array([1]),p=a?n.data.get(a.dataId).values:new Float32Array([0]),m=new Float32Array(c.length),g=p.length,y=h.length,w=f.length,b=d.length;let _=0,$=0,x=0,k=0;for(let C=0;C<c.length;++C)m[C]=p[_++]+(c[C]-d[$++])*h[x++]/Math.sqrt(f[k++]+u),_>=g&&(_=0),$>=b&&($=0),x>=y&&(x=0),k>=w&&(k=0);return n.makeTensorInfo(r.shape,r.dtype,m)}const fyt={kernelName:o1,backendName:"cpu",kernelFunc:dyt};function hyt(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{blockShape:o,crops:a}=s;Tt([r],"batchToSpaceND");const i=o.reduce((y,w)=>y*w),l=l2(r.shape,o,i),u=u2(l.length,o.length),c=c2(r.shape,o,i),d=$T(a,o.length),f=xT(c,a,o.length),h=Gn({inputs:{x:r},backend:n,attrs:{shape:l}}),p=eo({inputs:{x:h},backend:n,attrs:{perm:u}}),m=Gn({inputs:{x:p},backend:n,attrs:{shape:c}}),g=Bd({inputs:{x:m},backend:n,attrs:{begin:d,size:f}});return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(m),g}const pyt={kernelName:qg,backendName:"cpu",kernelFunc:hyt};function myt(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,weights:o}=e,{size:a}=s,i=n.data.get(r.dataId).values,l=n.data.get(o.dataId).values,u=bI(i,l,o.dtype,o.shape,a);return n.makeTensorInfo([a],o.dtype,u)}const gyt={kernelName:Fw,backendName:"cpu",kernelFunc:myt};function vyt(t){const{inputs:e,backend:n}=t,{s0:s,s1:r}=e,o=n.data.get(s.dataId).values,a=n.data.get(r.dataId).values,i=Zt(Array.from(o),Array.from(a));return n.makeTensorInfo([i.length],"int32",Int32Array.from(i))}const yyt={kernelName:Mw,backendName:"cpu",kernelFunc:vyt};const byt=An(fp,(t,e)=>{const n=e;return t>n.clipValueMax?n.clipValueMax:t<n.clipValueMin?n.clipValueMin:t}),wyt={kernelName:fp,backendName:"cpu",kernelFunc:byt};const _yt=t=>{const{x:e}=t.inputs,n=t.backend,s=new Float32Array(Ge(e.shape)),r=n.data.get(e.dataId),o=r.complexTensorInfos.real,a=r.complexTensorInfos.imag,i=n.data.get(o.dataId).values,l=n.data.get(a.dataId).values;for(let u=0;u<i.length;u++){const c=i[u],d=l[u];s[u]=Math.hypot(c,d)}return n.makeOutput(s,e.shape,"float32")},$yt={kernelName:Xg,backendName:"cpu",kernelFunc:_yt};function Dh(t){const{inputs:e,backend:n}=t,{input:s}=e,r=n.data.get(s.dataId).complexTensorInfos.imag,o=n.data.get(r.dataId).values;return n.makeTensorInfo(r.shape,r.dtype,o)}const xyt={kernelName:t_,backendName:"cpu",kernelFunc:Dh};function Fh(t){const{inputs:e,backend:n,attrs:s}=t,{axis:r}=s,o=un(r,e[0].shape)[0],a=e.map(m=>m.shape);bT(a,o);let i=Di(e.map(m=>m.shape),o);if(Ge(i)===0)return n.makeTensorInfo(i,e[0].dtype,[]);const l=e.filter(m=>Ge(m.shape)>0);if(l.length===1)return Wi({inputs:{x:l[0]},backend:n});if(l[0].dtype==="complex64"){const m=l.map(_=>zd({inputs:{input:_},backend:n})),g=l.map(_=>Dh({inputs:{input:_},backend:n})),y=Fh({inputs:m,backend:n,attrs:{axis:o}}),w=Fh({inputs:g,backend:n,attrs:{axis:o}}),b=fo({inputs:{real:y,imag:w},backend:n});return m.forEach(_=>n.disposeIntermediateTensorInfo(_)),g.forEach(_=>n.disposeIntermediateTensorInfo(_)),n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(w),b}const u=l.map(m=>{const y=[-1,Ge(m.shape.slice(o))];return Gn({inputs:{x:m},backend:n,attrs:{shape:y}})}),c=u.map(m=>({vals:n.data.get(m.dataId).values,shape:m.shape}));i=Di(u.map(m=>m.shape),1);const d=u[0].shape[0]===1,f=MU(c,i,e[0].dtype,d),h=Di(l.map(m=>m.shape),o),p=n.makeTensorInfo(h,e[0].dtype,f);return u.forEach(m=>n.disposeIntermediateTensorInfo(m)),p}const Syt={kernelName:Yg,backendName:"cpu",kernelFunc:Fh};function EG(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,filter:o}=e,{strides:a,pad:i,dataFormat:l,dilations:u,dimRoundingMode:c}=s;Tt([r,o],"conv2d");const d=Yl(l),f=Gs(r.shape,o.shape,a,u,i,c,!1,d),h=f.filterHeight,p=f.filterWidth,m=f.dilationHeight,g=f.dilationWidth,y=f.padInfo.left,w=f.padInfo.top,b=f.dataFormat==="channelsLast",_=new Ds(f.outShape,r.dtype),$=Mt(r.shape),x=Mt(o.shape),k=$[0],C=b?$[1]:$[2],T=b?$[2]:1,N=b?1:$[1],M=_.strides[0],R=b?_.strides[1]:_.strides[2],D=b?_.strides[2]:1,z=b?1:_.strides[1],B=n.data.get(r.dataId).values,V=n.data.get(o.dataId).values,O=_.values;for(let F=0;F<f.batchSize;++F){const L=F*k,G=F*M;for(let Z=0;Z<f.outHeight;++Z){const j=G+Z*R,J=Z*f.strideHeight-w;for(let fe=0;fe<h;++fe){const X=J+fe*m;if(X<0||X>=f.inHeight)continue;const oe=fe*x[0],ee=L+X*C;for(let Q=0;Q<f.outWidth;++Q){const ie=j+Q*D,pe=Q*f.strideWidth-y;for(let Re=0;Re<p;++Re){const K=pe+Re*g;if(K<0||K>=f.inWidth)continue;const re=oe+Re*x[1],we=ee+K*T;let Ee=re;for(let De=0;De<f.inChannels;++De){const _e=B[we+De*N];for(let ze=0;ze<f.outChannels;++ze)O[ie+ze*z]+=_e*V[Ee+ze];Ee+=f.outChannels}}}}}}return n.makeTensorInfo(_.shape,_.dtype,O)}const Cyt={kernelName:Zg,backendName:"cpu",kernelFunc:EG};function kyt(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,dy:o}=e,{strides:a,pad:i,dataFormat:l,dimRoundingMode:u,filterShape:c}=s;Tt([r,o],"conv2dBackpropFilter");const d=Yl(l),f=Gs(r.shape,c,a,1,i,u,!1,d),{strideHeight:h,strideWidth:p,filterHeight:m,filterWidth:g}=f,y=f.dataFormat==="channelsLast",w=new Ds(f.filterShape,"float32"),b=f.padInfo.left,_=f.padInfo.top,$=n.data.get(r.dataId).values,x=n.data.get(o.dataId).values,k=new Ds(r.shape,r.dtype,$),C=new Ds(o.shape,o.dtype,x);for(let T=0;T<m;++T){const N=Math.max(0,Math.ceil((_-T)/h)),M=Math.min(f.outHeight,(f.inHeight+_-T)/h);for(let R=0;R<g;++R){const D=Math.max(0,Math.ceil((b-R)/p)),z=Math.min(f.outWidth,(f.inWidth+b-R)/p);for(let B=0;B<f.inChannels;++B)for(let V=0;V<f.outChannels;++V){let O=0;for(let F=0;F<f.batchSize;++F)for(let L=N;L<M;++L){const G=T+L*h-_;for(let Z=D;Z<z;++Z){const j=R+Z*p-b;y?O+=k.get(F,G,j,B)*C.get(F,L,Z,V):O+=k.get(F,B,G,j)*C.get(F,V,L,Z)}}w.set(O,T,R,B,V)}}}return n.makeTensorInfo(w.shape,w.dtype,w.values)}const Tyt={kernelName:Lw,backendName:"cpu",kernelFunc:kyt};function Nyt(t){const{inputs:e,backend:n,attrs:s}=t,{dy:r,filter:o}=e,{inputShape:a,strides:i,pad:l,dataFormat:u,dimRoundingMode:c}=s;Tt([r,o],"conv2dBackpropInput");const d=Mt(o.shape),f=Mt(r.shape);let h=Yl(u);const p=Gs(a,o.shape,i,1,l,c,!1,h),m=new Ds(p.inShape,"float32"),g=m.values,y=n.data.get(r.dataId).values,w=n.data.get(o.dataId).values,[b,_,$]=d,{batchSize:x,filterHeight:k,filterWidth:C,inChannels:T,inHeight:N,inWidth:M,outChannels:R,outHeight:D,outWidth:z,strideHeight:B,strideWidth:V}=p;h=p.dataFormat;const O=k-1-p.padInfo.top,F=C-1-p.padInfo.left,L=h==="channelsLast",G=m.strides[0],Z=L?m.strides[1]:m.strides[2],j=L?m.strides[2]:1,J=L?1:m.strides[1],fe=f[0],X=L?f[1]:f[2],oe=L?f[2]:1,ee=L?1:f[1];for(let Q=0;Q<x;++Q)for(let ie=0;ie<T;++ie)for(let pe=0;pe<N;++pe){const Re=pe-O,K=Math.max(0,Math.ceil(Re/B)),re=Math.min(D,(k+Re)/B);for(let we=0;we<M;++we){const Ee=we-F,De=Math.max(0,Math.ceil(Ee/V)),_e=Math.min(z,(C+Ee)/V);let ze=0;for(let he=K;he<re;++he){const ve=he*B-Re;for(let me=De;me<_e;++me){const Ve=me*V-Ee,Ye=fe*Q+X*he+oe*me,Je=b*(k-1-ve)+_*(C-1-Ve)+$*ie;for(let ct=0;ct<R;++ct){const xt=y[Ye+ee*ct],dt=w[Je+ct];ze+=xt*dt}}}const Ae=G*Q+Z*pe+j*we+J*ie;g[Ae]=ze}}return n.makeTensorInfo(m.shape,m.dtype,m.values)}const Iyt={kernelName:Jg,backendName:"cpu",kernelFunc:Nyt};function Eyt(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,filter:o}=e,{strides:a,pad:i,dilations:l}=s;Tt([r,o],"conv3d");const u=hc(r.shape,o.shape,a,l,i),{filterDepth:c,filterHeight:d,filterWidth:f,dilationDepth:h,dilationHeight:p,dilationWidth:m,padInfo:g}=u,y=g.front,w=g.left,b=g.top,_=new Ds(u.outShape,r.dtype),$=n.data.get(r.dataId).values,x=n.data.get(o.dataId).values,k=_.values,C=Mt(r.shape),T=Mt(o.shape);for(let N=0;N<u.batchSize;++N){const M=N*C[0],R=N*_.strides[0];for(let D=0;D<u.outDepth;++D){const z=R+D*_.strides[1],B=D*u.strideDepth-y;for(let V=0;V<c;++V){const O=B+V*h;if(O<0||O>=u.inDepth)continue;const F=V*T[0],L=M+O*C[1];for(let G=0;G<u.outHeight;++G){const Z=z+G*_.strides[2],j=G*u.strideHeight-b;for(let J=0;J<d;++J){const fe=j+J*p;if(fe<0||fe>=u.inHeight)continue;const X=F+J*T[1],oe=L+fe*C[2];for(let ee=0;ee<u.outWidth;++ee){const Q=Z+ee*u.outChannels,ie=ee*u.strideWidth-w;for(let pe=0;pe<f;++pe){const Re=ie+pe*m;if(Re<0||Re>=u.inWidth)continue;const K=X+pe*T[2],re=oe+Re*u.inChannels;let we=K;for(let Ee=0;Ee<u.inChannels;++Ee){const De=$[re+Ee];for(let _e=0;_e<u.outChannels;++_e)k[Q+_e]+=De*x[we+_e];we+=u.outChannels}}}}}}}}return n.makeTensorInfo(_.shape,_.dtype,_.values)}const Ayt={kernelName:Qg,backendName:"cpu",kernelFunc:Eyt};function Oyt(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,dy:o}=e,{strides:a,pad:i,filterShape:l}=s;Tt([r,o],"conv3dBackpropFilterV2");const u=Mt(r.shape),c=Mt(o.shape),d=hc(r.shape,l,a,1,i),f=d.strideDepth,h=d.strideHeight,p=d.strideWidth,m=d.filterDepth,g=d.filterHeight,y=d.filterWidth,w=new Ds(d.filterShape,"float32"),b=w.values,[_,$,x,k]=w.strides,C=n.data.get(o.dataId).values,[T,N,M,R]=c,D=n.data.get(r.dataId).values,[z,B,V,O]=u,F=d.padInfo.front,L=d.padInfo.left,G=d.padInfo.top;for(let Z=0;Z<m;++Z){const j=Math.max(0,Math.ceil((F-Z)/f)),J=Math.min(d.outDepth,(d.inDepth+F-Z)/f),fe=Z*_;for(let X=0;X<g;++X){const oe=Math.max(0,Math.ceil((G-X)/h)),ee=Math.min(d.outHeight,(d.inHeight+G-X)/h),Q=X*$+fe;for(let ie=0;ie<y;++ie){const pe=Math.max(0,Math.ceil((L-ie)/p)),Re=Math.min(d.outWidth,(d.inWidth+L-ie)/p),K=ie*x+Q;for(let re=0;re<d.inChannels;++re){const we=re*k+K;for(let Ee=0;Ee<d.outChannels;++Ee){let De=0;for(let _e=0;_e<d.batchSize;++_e){const ze=_e*z,Ae=_e*T;for(let he=j;he<J;++he){const me=(Z+he*f-F)*B+ze,Ve=he*N+Ae;for(let Ye=oe;Ye<ee;++Ye){const ct=(X+Ye*h-G)*V+me,xt=Ye*M+Ve;for(let dt=pe;dt<Re;++dt){const Ke=(ie+dt*p-L)*O+ct,at=dt*R+xt;De+=D[Ke+re]*C[at+Ee]}}}}b[we+Ee]=De}}}}}return n.makeTensorInfo(w.shape,w.dtype,w.values)}const Ryt={kernelName:zw,backendName:"cpu",kernelFunc:Oyt};function Dyt(t){const{inputs:e,backend:n,attrs:s}=t,{dy:r,filter:o}=e,{pad:a,strides:i,inputShape:l}=s;Tt([r],"conv3dBackpropInputV2");const u=Mt(r.shape),c=Mt(o.shape),d=hc(l,o.shape,i,1,a),f=new Ds(d.inShape,"float32"),h=f.values,[p,m,g,y]=f.strides,w=n.data.get(r.dataId).values,[b,_,$,x]=u,k=n.data.get(o.dataId).values,[C,T,N,M]=c,{batchSize:R,filterDepth:D,filterHeight:z,filterWidth:B,inChannels:V,inDepth:O,inHeight:F,inWidth:L,outChannels:G,outDepth:Z,outHeight:j,outWidth:J,strideDepth:fe,strideHeight:X,strideWidth:oe}=d,ee=D-1-d.padInfo.front,Q=z-1-d.padInfo.top,ie=B-1-d.padInfo.left;for(let pe=0;pe<R;++pe)for(let Re=0;Re<V;++Re)for(let K=0;K<O;++K){const re=K-ee,we=Math.max(0,Math.ceil(re/fe)),Ee=Math.min(Z,(D+re)/fe);for(let De=0;De<F;++De){const _e=De-Q,ze=Math.max(0,Math.ceil(_e/X)),Ae=Math.min(j,(z+_e)/X);for(let he=0;he<L;++he){const ve=he-ie,me=Math.max(0,Math.ceil(ve/oe)),Ve=Math.min(J,(B+ve)/oe);let Ye=0;for(let Je=we;Je<Ee;++Je){const ct=Je*fe-re;for(let xt=ze;xt<Ae;++xt){const dt=xt*X-_e;for(let xe=me;xe<Ve;++xe){const Ke=xe*oe-ve,at=b*pe+_*Je+$*xt+x*xe,Y=C*(D-1-ct)+T*(z-1-dt)+N*(B-1-Ke)+M*Re;for(let de=0;de<G;++de){const Pe=w[at+de],We=k[Y+de];Ye+=Pe*We}}}}h[p*pe+m*K+g*De+y*he+Re]=Ye}}}return n.makeTensorInfo(f.shape,f.dtype,f.values)}const Fyt={kernelName:Bw,backendName:"cpu",kernelFunc:Dyt};const Myt=An(hp,t=>Math.cos(t)),Pyt={kernelName:hp,backendName:"cpu",kernelFunc:Myt};const Lyt=An(pp,t=>Math.cosh(t)),zyt={kernelName:pp,backendName:"cpu",kernelFunc:Lyt};function Byt(t){const{inputs:e,backend:n,attrs:s}=t,{image:r,boxes:o,boxInd:a}=e,{cropSize:i,method:l,extrapolationValue:u}=s,[c,d,f,h]=r.shape,p=o.shape[0],[m,g]=i,y=tn([p,m,g,h],"float32"),w=n.data.get(o.dataId).values,b=n.data.get(a.dataId).values,_=n.data.get(r.dataId).values,$=Mt(r.shape),x=Mt(y.shape);for(let k=0;k<p;k++){const C=k*4,T=w[C],N=w[C+1],M=w[C+2],R=w[C+3],D=b[k];if(D>=c)continue;const z=m>1?(M-T)*(d-1)/(m-1):0,B=g>1?(R-N)*(f-1)/(g-1):0;for(let V=0;V<m;V++){const O=m>1?T*(d-1)+V*z:.5*(T+M)*(d-1);if(O<0||O>d-1){for(let F=0;F<g;F++)for(let L=0;L<h;L++){const G=L+F*x[2]+V*x[1]+k*x[0];y.values[G]=u}continue}if(l==="bilinear"){const F=Math.floor(O),L=Math.ceil(O),G=O-F;for(let Z=0;Z<g;Z++){const j=g>1?N*(f-1)+Z*B:.5*(N+R)*(f-1);if(j<0||j>f-1){for(let oe=0;oe<h;oe++){const ee=oe+Z*x[2]+V*x[1]+k*x[0];y.values[ee]=u}continue}const J=Math.floor(j),fe=Math.ceil(j),X=j-J;for(let oe=0;oe<h;oe++){let ee=oe+J*$[2]+F*$[1]+D*$[0];const Q=_[ee];ee=oe+fe*$[2]+F*$[1]+D*$[0];const ie=_[ee];ee=oe+J*$[2]+L*$[1]+D*$[0];const pe=_[ee];ee=oe+fe*$[2]+L*$[1]+D*$[0];const Re=_[ee],K=Q+(ie-Q)*X,re=pe+(Re-pe)*X;ee=oe+Z*x[2]+V*x[1]+k*x[0],y.values[ee]=K+(re-K)*G}}}else for(let F=0;F<g;++F){const L=g>1?N*(f-1)+F*B:.5*(N+R)*(f-1);if(L<0||L>f-1){for(let j=0;j<h;j++){const J=j+F*x[2]+V*x[1]+k*x[0];y.values[J]=u}continue}const G=Math.round(L),Z=Math.round(O);for(let j=0;j<h;j++){const J=j+G*$[2]+Z*$[1]+D*$[0],fe=j+F*x[2]+V*x[1]+k*x[0];y.values[fe]=_[J]}}}}return n.makeTensorInfo(y.shape,y.dtype,y.values)}const Vyt={kernelName:Hw,backendName:"cpu",kernelFunc:Byt};function Hyt(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{axis:o,exclusive:a,reverse:i}=s;Tt(r,"cumprod");const l=hs([o],r.shape.length);let u=r;l!=null&&(u=eo({inputs:{x:r},backend:n,attrs:{perm:l}}));const c=bs(1,r.shape.length)[0];if(c!==u.shape.length-1)throw new Error(`backend.cumprod in CPU expects an inner-most axis=${u.shape.length-1} but got axis=${c}`);const d=Yr(u.dtype,"int32"),f=Ew(Ge(u.shape),d),h=n.data.get(u.dataId).values,p=u.shape[u.shape.length-1],m=i?(y,w)=>y+p-w-1:(y,w)=>y+w;for(let y=0;y<h.length;y+=p)for(let w=0;w<p;w++){const b=m(y,w);if(w===0)f[b]=a?1:h[b];else{const _=m(y,w-1);f[b]=a?h[_]*f[_]:h[b]*f[_]}}const g=n.makeTensorInfo(u.shape,d,f);if(l!=null){const y=pc(l),w=eo({inputs:{x:g},backend:n,attrs:{perm:y}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(u),w}return g}const Wyt={kernelName:Vw,backendName:"cpu",kernelFunc:Hyt};function Uyt(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{axis:o,exclusive:a,reverse:i}=s;Tt(r,"cumsum");const l=hs([o],r.shape.length);let u=r;l!=null&&(u=eo({inputs:{x:r},backend:n,attrs:{perm:l}}));const c=bs(1,r.shape.length)[0];if(c!==u.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${u.shape.length-1} but got axis=${c}`);const d=Yr(u.dtype,"int32"),f=or(Ge(u.shape),d),h=n.data.get(u.dataId).values,p=u.shape[u.shape.length-1],m=i?(y,w)=>y+p-w-1:(y,w)=>y+w;for(let y=0;y<h.length;y+=p)for(let w=0;w<p;w++){const b=m(y,w);if(w===0)f[b]=a?0:h[b];else{const _=m(y,w-1);f[b]=a?h[_]+f[_]:h[b]+f[_]}}const g=n.makeTensorInfo(u.shape,d,f);if(l!=null){const y=pc(l),w=eo({inputs:{x:g},backend:n,attrs:{perm:y}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(u),w}return g}const Gyt={kernelName:e1,backendName:"cpu",kernelFunc:Uyt};function jyt(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,weights:o}=e,{size:a,binaryOutput:i}=s;if(r.shape.length===1){const l=n.data.get(r.dataId).values,u=n.data.get(o.dataId).values,c=bI(l,u,o.dtype,o.shape,a);return n.makeTensorInfo([a],o.dtype,c)}else if(r.shape.length===2){const l=n.bufferSync(r),u=n.bufferSync(o),c=DU(l,u,a,i);return n.makeTensorInfo(c.shape,o.dtype,c.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${r.shape.length}.`)}const Kyt={kernelName:Ww,backendName:"cpu",kernelFunc:jyt};function qyt(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{blockSize:o,dataFormat:a}=s;q(a==="NHWC",()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${a}`);const i=r.shape[0],l=r.shape[1],u=r.shape[2],c=r.shape[3],d=l*o,f=u*o,h=c/(o*o),p=n.data.get(r.dataId).values,m=new Float32Array(i*d*f*h);let g=0;for(let y=0;y<i;++y)for(let w=0;w<d;++w){const b=Math.floor(w/o),_=w%o;for(let $=0;$<f;++$){const x=Math.floor($/o),k=$%o,C=(_*o+k)*h;for(let T=0;T<h;++T){const M=T+C+c*(x+u*(b+l*y));m[g++]=p[M]}}}return n.makeTensorInfo([i,d,f,h],r.dtype,m)}const Xyt={kernelName:Uw,backendName:"cpu",kernelFunc:qyt};function AG(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,filter:o}=e,{strides:a,pad:i,dilations:l,dimRoundingMode:u}=s;Tt([r,o],"depthwiseConv2DNative");const c=Mt(r.shape),d=Mt(o.shape);let f=l;f==null&&(f=[1,1]),q(ur(a,f),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${a} and dilations '${f}'`);const h=Gs(r.shape,o.shape,a,f,i,u,!0),{filterHeight:p,filterWidth:m,dilationHeight:g,dilationWidth:y,padInfo:w}=h,b=w.left,_=w.top,$=h.outChannels/h.inChannels,x=new Ds(h.outShape,r.dtype),k=n.data.get(r.dataId).values,C=n.data.get(o.dataId).values,T=x.values;for(let N=0;N<h.batchSize;++N){const M=N*c[0],R=N*x.strides[0];for(let D=0;D<h.outHeight;++D){const z=R+D*x.strides[1],B=D*h.strideHeight-_;for(let V=0;V<p;++V){const O=B+V*g;if(O<0||O>=h.inHeight)continue;const F=V*d[0],L=M+O*c[1];for(let G=0;G<h.outWidth;++G){const Z=z+G*x.strides[2],j=G*h.strideWidth-b;for(let J=0;J<m;++J){const fe=j+J*y;if(fe<0||fe>=h.inWidth)continue;const X=F+J*d[1],oe=L+fe*h.inChannels;let ee=Z,Q=X;for(let ie=0;ie<h.inChannels;++ie){const pe=k[oe+ie];for(let Re=0;Re<$;++Re)T[ee+Re]+=pe*C[Q+Re];ee+=$,Q+=$}}}}}}return n.makeTensorInfo(x.shape,x.dtype,x.values)}const Yyt={kernelName:t1,backendName:"cpu",kernelFunc:AG};function Zyt(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,dy:o}=e,{strides:a,dilations:i,pad:l,dimRoundingMode:u,filterShape:c}=s;Tt([r,o],"depthwiseConv2dNativeBackpropFilter");const d=Gs(r.shape,c,a,i,l,u,!0),{strideHeight:f,strideWidth:h,filterHeight:p,filterWidth:m}=d,g=new Ds(d.filterShape,"float32"),y=d.padInfo.left,w=d.padInfo.top,b=d.outChannels/d.inChannels,_=n.data.get(r.dataId).values,$=new Ds(r.shape,r.dtype,_),x=n.data.get(o.dataId).values,k=new Ds(o.shape,o.dtype,x);for(let C=0;C<p;++C){const T=Math.max(0,Math.ceil((w-C)/f)),N=Math.min(d.outHeight,(d.inHeight+w-C)/f);for(let M=0;M<m;++M){const R=Math.max(0,Math.ceil((y-M)/h)),D=Math.min(d.outWidth,(d.inWidth+y-M)/h);for(let z=0;z<d.outChannels;++z){const B=Math.trunc(z/b),V=z%b;let O=0;for(let F=0;F<d.batchSize;++F)for(let L=T;L<N;++L){const G=C+L*f-w;for(let Z=R;Z<D;++Z){const j=M+Z*h-y;O+=$.get(F,G,j,B)*k.get(F,L,Z,z)}}g.set(O,C,M,B,V)}}}return n.makeTensorInfo(g.shape,g.dtype,g.values)}const Jyt={kernelName:Gw,backendName:"cpu",kernelFunc:Zyt};function Qyt(t){const{inputs:e,backend:n,attrs:s}=t,{dy:r,filter:o}=e,{strides:a,dilations:i,pad:l,dimRoundingMode:u,inputShape:c}=s;Tt([r,o],"depthwiseConv2DNativeBackpropInput");const d=Mt(r.shape),f=Mt(o.shape),h=Gs(c,o.shape,a,i,l,u,!0),p=new Ds(h.inShape,"float32"),m=p.values,[g,y,w]=p.strides,b=n.data.get(r.dataId).values,[_,$,x]=d,k=n.data.get(o.dataId).values,[C,T,N]=f,{batchSize:M,filterHeight:R,filterWidth:D,inChannels:z,inHeight:B,inWidth:V,outChannels:O,outHeight:F,outWidth:L,strideHeight:G,strideWidth:Z}=h,j=R-1-h.padInfo.top,J=D-1-h.padInfo.left,fe=O/z;for(let X=0;X<M;++X)for(let oe=0;oe<z;++oe)for(let ee=0;ee<B;++ee){const Q=ee-j,ie=Math.max(0,Math.ceil(Q/G)),pe=Math.min(F,(R+Q)/G);for(let Re=0;Re<V;++Re){const K=Re-J,re=Math.max(0,Math.ceil(K/Z)),we=Math.min(L,(D+K)/Z);let Ee=0;for(let De=ie;De<pe;++De){const _e=De*G-Q;for(let ze=re;ze<we;++ze){const Ae=ze*Z-K,he=_*X+$*De+x*ze,ve=C*(R-1-_e)+T*(D-1-Ae)+N*oe;for(let me=0;me<fe;++me){const Ve=oe*fe+me,Ye=b[he+Ve],Je=k[ve+me];Ee+=Ye*Je}}}m[g*X+y*ee+w*Re+oe]=Ee}}return n.makeTensorInfo(p.shape,p.dtype,p.values)}const ebt={kernelName:jw,backendName:"cpu",kernelFunc:Qyt};function tbt(t){const{inputs:e,backend:n}=t,{x:s}=e,r=Ge(s.shape),o=n.data.get(s.dataId).values,a=tn([r,r],s.dtype),i=a.values;for(let u=0;u<o.length;u++)i[u*r+u]=o[u];const l=[...s.shape,...s.shape];return n.makeTensorInfo(l,a.dtype,a.values)}const nbt={kernelName:Kw,backendName:"cpu",kernelFunc:tbt};const sbt={kernelName:n1,backendName:"cpu",kernelFunc:({inputs:t,backend:e,attrs:n})=>{const{x:s,filter:r}=t,{strides:o,pad:a,dilations:i}=n,l=e,u=l.data.get(s.dataId).values,c=s.shape.length,d=l.data.get(r.dataId).values,f=r.shape.length,{batchSize:h,inHeight:p,inWidth:m,inChannels:g,outHeight:y,outWidth:w,padInfo:b,strideHeight:_,strideWidth:$,filterHeight:x,filterWidth:k,dilationHeight:C,dilationWidth:T,outShape:N}=G1(s.shape,r.shape,o,a,"NHWC",i),M=Ge(N),R=N.length,D=gs(s.dtype,M);for(let B=0;B<h;++B)for(let V=0;V<y;++V){const O=V*_-b.top;for(let F=0;F<w;++F){const L=F*$-b.left;for(let G=0;G<g;++G){let Z=Number.MIN_SAFE_INTEGER;for(let J=0;J<x;++J){const fe=O+J*C;if(fe>=0&&fe<p)for(let X=0;X<k;++X){const oe=L+X*T;if(oe>=0&&oe<m){const ee=Ka([B,fe,oe,G],c,Mt(s.shape)),Q=Ka([J,X,G],f,Mt(r.shape)),ie=u[ee]+d[Q];ie>Z&&(Z=ie)}}}const j=Ka([B,V,F,G],R,Mt(N));D[j]=Z}}}return{dataId:l.write(dc(D,s.dtype),N,s.dtype),shape:N,dtype:s.dtype}}};const rbt={kernelName:Xy,backendName:"cpu",kernelFunc:({inputs:t,backend:e,attrs:n})=>{const{x:s,filter:r,dy:o}=t,{strides:a,pad:i,dilations:l}=n,u=e,c=Uo(s.shape,u.data.get(s.dataId).values),d=Uo(r.shape,u.data.get(r.dataId).values),{batchSize:f,inHeight:h,inWidth:p,inChannels:m,outHeight:g,outWidth:y,padInfo:w,strideHeight:b,strideWidth:_,filterHeight:$,filterWidth:x,dilationHeight:k,dilationWidth:C,outShape:T}=G1(s.shape,r.shape,a,i,"NHWC",l);q(o.rank===T.length,()=>`Error in ${Xy}, dy must have the same rank as output ${T.length}, but got ${o.rank}`);const N=Uo(T,u.data.get(o.dataId).values),M=Wk(r.shape,r.dtype);for(let D=0;D<f;++D)for(let z=0;z<g;++z){const B=z*b-w.top;for(let V=0;V<y;++V){const O=V*_-w.left;for(let F=0;F<m;++F){let L=Number.MIN_SAFE_INTEGER,G=0,Z=0;for(let j=0;j<$;++j){const J=B+j*k;if(J>=0&&J<h)for(let fe=0;fe<x;++fe){const X=O+fe*C;if(X>=0&&X<p){const oe=c[D][J][X][F]+d[j][fe][F];oe>L&&(L=oe,G=j,Z=fe)}}}M[G][Z][F]+=N[D][z][V][F]}}}return{dataId:u.write(dc(M,s.dtype),r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}};const obt={kernelName:qy,backendName:"cpu",kernelFunc:({inputs:t,backend:e,attrs:n})=>{const{x:s,filter:r,dy:o}=t,{strides:a,pad:i,dilations:l}=n,u=e,c=Uo(s.shape,u.data.get(s.dataId).values),d=Uo(r.shape,u.data.get(r.dataId).values),{batchSize:f,inHeight:h,inWidth:p,inChannels:m,outHeight:g,outWidth:y,padInfo:w,strideHeight:b,strideWidth:_,filterHeight:$,filterWidth:x,dilationHeight:k,dilationWidth:C,outShape:T}=G1(s.shape,r.shape,a,i,"NHWC",l);q(o.rank===T.length,()=>`Error in ${qy}, dy must have the same rank as output ${T.length}, but got ${o.rank}`);const N=Uo(T,u.data.get(o.dataId).values),M=Wk(s.shape,s.dtype);for(let D=0;D<f;++D)for(let z=0;z<g;++z){const B=z*b-w.top;for(let V=0;V<y;++V){const O=V*_-w.left;for(let F=0;F<m;++F){let L=Number.MIN_SAFE_INTEGER,G=B<0?0:B,Z=O<0?0:O;for(let j=0;j<$;++j){const J=B+j*k;if(J>=0&&J<h)for(let fe=0;fe<x;++fe){const X=O+fe*C;if(X>=0&&X<p){const oe=c[D][J][X][F]+d[j][fe][F];oe>L&&(L=oe,G=J,Z=X)}}}M[D][G][Z][F]+=N[D][z][V][F]}}}return{dataId:u.write(dc(M,s.dtype),s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}};function $2(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{axis:o,keepDims:a}=s;Tt(r,"sum");let i;r.dtype==="bool"?i=nc({inputs:{x:r},backend:n,attrs:{dtype:"int32"}}):i=Wi({inputs:{x:r},backend:n});const l=i.shape.length,u=un(o,i.shape),c=hs(u,l);let d=u,f=i;c!=null&&(f=eo({inputs:{x:i},backend:n,attrs:{perm:c}}),d=bs(d.length,l)),cr("sum",d,f.shape.length);const[h,p]=js(f.shape,d),m=Yr(f.dtype,"int32");let g=vb(n,h,m);const y=Ge(p),w=n.data.get(g.dataId).values,b=n.data.get(f.dataId).values;for(let _=0;_<w.length;++_){const $=_*y;let x=0;for(let k=0;k<y;++k)x+=b[$+k];w[_]=x}if(a){const _=ys(g.shape,u),$=g;g=Gn({inputs:{x:g},backend:n,attrs:{shape:_}}),n.disposeIntermediateTensorInfo($)}return n.disposeIntermediateTensorInfo(i),c!=null&&n.disposeIntermediateTensorInfo(f),g}const abt={kernelName:F1,backendName:"cpu",kernelFunc:$2};function ibt(t){const{inputs:e,backend:n,attrs:s}=t,{equation:r}=s,o=e,{allDims:a,summedDims:i,idDims:l}=AT(r,o.length);RT(a.length,l,o);const{path:u,steps:c}=DT(i,l),d=c.length;let f=null,h=a.length;const p=[];for(let m=0;m<d;++m){for(const g of c[m]){const{permutationIndices:y,expandDims:w}=OT(h,l[g]);let b;FT(y)?b=o[g]:(b=eo({inputs:{x:o[g]},backend:n,attrs:{perm:y}}),p.push(b));const _=b.shape.slice();for(let $=0;$<w.length;++$)_.splice(w[$],0,1);hn(b.shape,_)||(b=Gn({inputs:{x:b},backend:n,attrs:{shape:_}}),p.push(b)),f===null?f=b:(f=J3({inputs:{a:b,b:f},backend:n}),p.push(f))}m<d-1&&(u[m]>=0&&(f=$2({inputs:{x:f},backend:n,attrs:{axis:u[m]-(a.length-h),keepDims:!1}}),p.push(f)),h--)}for(const m of p)m!==f&&n.disposeIntermediateTensorInfo(m);return f}const lbt={kernelName:qw,backendName:"cpu",kernelFunc:ibt};function ubt(t){const{inputs:e,backend:n}=t,{dy:s,y:r}=e;Tt([s,r],"eluGrad");const o=new Float32Array(Ge(r.shape)),a=n.data.get(r.dataId).values,i=n.data.get(s.dataId).values;for(let l=0;l<a.length;++l){const u=a[l];u>=1?o[l]=i[l]:o[l]=i[l]*(u+1)}return n.makeTensorInfo(r.shape,"float32",o)}const cbt={kernelName:Xw,backendName:"cpu",kernelFunc:ubt};const dbt=ST,fbt=CT,hbt=kT,pbt=TT,mbt=NT,gbt=IT,vbt=An(vp,t=>{const e=Math.sign(t),n=Math.abs(t),s=1/(1+dbt*n);return e*(1-((((gbt*s+mbt)*s+pbt)*s+hbt)*s+fbt)*s*Math.exp(-n*n))}),ybt={kernelName:vp,backendName:"cpu",kernelFunc:vbt};function wb(t){const{inputs:e,backend:n,attrs:s}=t,{input:r}=e,{dim:o}=s,a=r.shape.length,i=r.shape.slice();let l=o;return o<0&&(q(-(a+1)<=o,()=>`Axis must be in the interval [${-(a+1)}, ${a}]`),l=a+o+1),i.splice(l,0,1),Gn({inputs:{x:r},backend:n,attrs:{shape:i}})}const bbt={kernelName:r1,backendName:"cpu",kernelFunc:wb};const wbt=Is((t,e)=>t/e),CI=Ks(mp,wbt),Yx={kernelName:mp,backendName:"cpu",kernelFunc:CI};function OG(t,e,n){const s=t.shape,r=s[0],o=s[1],a=n.data.get(t.dataId),i=a.complexTensorInfos.real,l=a.complexTensorInfos.imag,u=[r,o],c=Ge(u),d=zs("float32",c),f=zs("float32",c);for(let g=0;g<r;g++){const y=Bd({inputs:{x:i},backend:n,attrs:{begin:[g,0],size:[1,o]}}),w=Bd({inputs:{x:l},backend:n,attrs:{begin:[g,0],size:[1,o]}}),b=fo({inputs:{real:y,imag:w},backend:n}),{real:_,imag:$}=_bt(b,e,n),x=Rl(_,$);for(let k=0;k<o;k++){const C=ET(x,k);d[g*o+k]=C.real,f[g*o+k]=C.imag}n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(w),n.disposeIntermediateTensorInfo(b)}const h=n.makeTensorInfo(u,"float32",d),p=n.makeTensorInfo(u,"float32",f),m=fo({inputs:{real:h,imag:p},backend:n});return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(p),m}function _bt(t,e,n){const s=Ge(t.shape),r=n.data.get(t.dataId),o=n.data.get(r.complexTensorInfos.real.dataId).values,a=n.data.get(r.complexTensorInfos.imag.dataId).values;if($bt(s)){const i=Zx(o,a,s,e,n),l=[t.shape[0],t.shape[1]];if(e){const u=n.makeTensorInfo(l,"float32",i.real),c=n.makeTensorInfo(l,"float32",i.imag),d=n.makeTensorInfo([],"float32",ql(s,"float32")),f=Wi({inputs:{x:d},backend:n}),h=Yx.kernelFunc({inputs:{a:u,b:d},backend:n}),p=Yx.kernelFunc({inputs:{a:c,b:f},backend:n}),m=n.data.get(h.dataId).values,g=n.data.get(p.dataId).values;return n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(p),{real:m,imag:g}}return i}else{const i=Rl(o,a),l=xbt(i,s,e);return OH(l)}}function $bt(t){return(t&t-1)===0}function Zx(t,e,n,s,r){if(n===1)return{real:t,imag:e};const o=Rl(t,e),a=n/2,i=RH(o),l=i.real,u=i.imag,c=[l.length],d=r.makeTensorInfo(c,"float32",l),f=r.makeTensorInfo(c,"float32",u),h=fo({inputs:{real:d,imag:f},backend:r}),p=DH(o),m=p.real,g=p.imag,y=[m.length],w=r.makeTensorInfo(y,"float32",m),b=r.makeTensorInfo(y,"float32",g),_=fo({inputs:{real:w,imag:b},backend:r}),$=Zx(l,u,a,s,r),x=$.real,k=$.imag,C=[x.length],T=r.makeTensorInfo(C,"float32",x),N=r.makeTensorInfo(C,"float32",k),M=fo({inputs:{real:T,imag:N},backend:r}),R=Zx(m,g,a,s,r),D=R.real,z=R.imag,B=[D.length],V=r.makeTensorInfo(B,"float32",D),O=r.makeTensorInfo(B,"float32",z),F=fo({inputs:{real:V,imag:O},backend:r}),L=MH(n,s),G=[L.real.length],Z=r.makeTensorInfo(G,"float32",L.real),j=r.makeTensorInfo(G,"float32",L.imag),J=fo({inputs:{real:Z,imag:j},backend:r}),fe=J3({inputs:{a:J,b:F},backend:r}),X=Rh({inputs:{a:M,b:fe},backend:r}),oe=xI({inputs:{a:M,b:fe},backend:r}),ee=zd({inputs:{input:X},backend:r}),Q=zd({inputs:{input:oe},backend:r}),ie=Dh({inputs:{input:X},backend:r}),pe=Dh({inputs:{input:oe},backend:r}),Re=Fh({inputs:[ee,Q],backend:r,attrs:{axis:0}}),K=Fh({inputs:[ie,pe],backend:r,attrs:{axis:0}}),re=r.data.get(Re.dataId).values,we=r.data.get(K.dataId).values;return r.disposeIntermediateTensorInfo(d),r.disposeIntermediateTensorInfo(f),r.disposeIntermediateTensorInfo(h),r.disposeIntermediateTensorInfo(w),r.disposeIntermediateTensorInfo(b),r.disposeIntermediateTensorInfo(_),r.disposeIntermediateTensorInfo(T),r.disposeIntermediateTensorInfo(N),r.disposeIntermediateTensorInfo(M),r.disposeIntermediateTensorInfo(V),r.disposeIntermediateTensorInfo(O),r.disposeIntermediateTensorInfo(F),r.disposeIntermediateTensorInfo(Z),r.disposeIntermediateTensorInfo(j),r.disposeIntermediateTensorInfo(J),r.disposeIntermediateTensorInfo(fe),r.disposeIntermediateTensorInfo(X),r.disposeIntermediateTensorInfo(oe),r.disposeIntermediateTensorInfo(ee),r.disposeIntermediateTensorInfo(ie),r.disposeIntermediateTensorInfo(Q),r.disposeIntermediateTensorInfo(pe),r.disposeIntermediateTensorInfo(Re),r.disposeIntermediateTensorInfo(K),{real:re,imag:we}}function xbt(t,e,n){const s=new Float32Array(e*2);for(let r=0;r<e;r++){let o=0,a=0;for(let i=0;i<e;i++){const l=PH(r*i,e,n),u=ET(t,i);o+=u.real*l.real-u.imag*l.imag,a+=u.real*l.imag+u.imag*l.real}n&&(o/=e,a/=e),FH(s,o,a,r)}return s}function Sbt(t){const{inputs:e,backend:n}=t,{input:s}=e,r=Ge(s.shape),o=s.shape[s.shape.length-1],a=r/o,i=Gn({inputs:{x:s},backend:n,attrs:{shape:[a,o]}}),l=OG(i,!1,n),u=Gn({inputs:{x:l},backend:n,attrs:{shape:s.shape}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(l),u}const Cbt={kernelName:Yw,backendName:"cpu",kernelFunc:Sbt};function kI(t){const{backend:e,attrs:n}=t,{shape:s,value:r,dtype:o}=n,a=o||np(r),i=gs(a,Ge(s));return Tbt(i,r,a),e.makeTensorInfo(s,a,i)}const kbt={kernelName:Zw,backendName:"cpu",kernelFunc:kI};function Tbt(t,e,n){t.fill(e)}const Nbt={kernelName:Jw,backendName:"cpu",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{image:s}=t,r=n,o=zs(s.dtype,Ge(s.shape)),[a,i,l,u]=s.shape,c=r.data.get(s.dataId).values;for(let f=0;f<a;f++){const h=f*l*i*u;for(let p=0;p<i;p++){const m=p*(l*u);for(let g=0;g<l;g++){const y=g*u;for(let w=0;w<u;w++){const b=Math.round(l-g-1),_=h+m+y+w;let $=c[_];if(b>=0&&b<l){const x=b*u,k=h+m+x+w;$=c[k]}o[_]=$}}}}return{dataId:r.write(o,s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}};const Ibt=Is((t,e)=>Math.floor(t/e)),Ebt=Ks(_p,Ibt,null,"int32"),Abt={kernelName:_p,backendName:"cpu",kernelFunc:Ebt};function Obt(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,filter:o,bias:a,preluActivationWeights:i}=e,{strides:l,pad:u,dataFormat:c,dilations:d,dimRoundingMode:f,activation:h,leakyreluAlpha:p}=s;let m=EG({inputs:{x:r,filter:o},backend:n,attrs:{strides:l,pad:u,dataFormat:c,dilations:d,dimRoundingMode:f}});if(a){const g=m;if(c==="NCHW"&&a.shape.length===1&&a.shape[0]!==1){const y=Gn({inputs:{x:a},backend:n,attrs:{shape:[a.shape[0],1,1]}});m=Rh({inputs:{a:m,b:y},backend:n}),n.disposeIntermediateTensorInfo(y)}else m=Rh({inputs:{a:m,b:a},backend:n});n.disposeIntermediateTensorInfo(g)}if(h){const g=m;if(c==="NCHW"&&h==="prelu"&&i.shape.length===1&&i.shape[0]!==1){const y=Gn({inputs:{x:i},backend:n,attrs:{shape:[i.shape[0],1,1]}});m=bb(n,m,h,y,p),n.disposeIntermediateTensorInfo(y)}else m=bb(n,m,h,i,p);n.disposeIntermediateTensorInfo(g)}return m}const Rbt={kernelName:Z0,backendName:"cpu",kernelFunc:Obt};function Dbt(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,filter:o,bias:a,preluActivationWeights:i}=e,{strides:l,pad:u,dataFormat:c,dilations:d,dimRoundingMode:f,activation:h,leakyreluAlpha:p}=s;let m=AG({inputs:{x:r,filter:o},backend:n,attrs:{strides:l,pad:u,dataFormat:c,dilations:d,dimRoundingMode:f}});if(a){const g=m;m=Rh({inputs:{a:m,b:a},backend:n}),n.disposeIntermediateTensorInfo(g)}if(h){const g=m;m=bb(n,m,h,i,p),n.disposeIntermediateTensorInfo(g)}return m}const Fbt={kernelName:J0,backendName:"cpu",kernelFunc:Dbt};function Mbt(t){const{inputs:e,backend:n}=t,{params:s,indices:r}=e,o=Ge(s.shape),a=r.shape,i=a[a.length-1],[l,u,c,d]=L_(s,r);if(u===0)return n.makeTensorInfo(l,s.dtype,[]);const f=n.data.get(r.dataId).values,h=n.bufferSync(s),p=WU(f,h,s.dtype,u,i,c,d,s.shape,o);return n.makeTensorInfo(l,s.dtype,p.values)}const Pbt={kernelName:Qw,backendName:"cpu",kernelFunc:Mbt};function Lbt(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,indices:o}=e,{axis:a,batchDims:i}=s;Tt([r,o],"gatherV2");const l=un(a,r.shape)[0],u=n.data.get(o.dataId).values,c=r.shape[l];for(let _=0;_<u.length;++_){const $=u[_];q($<=c-1&&$>=0,()=>`GatherV2: the index value ${$} is not in [0, ${c-1}]`)}let d=i;i==null&&(d=0);const f=Ge(o.shape),h=PT(r,o,l,d),p=Gn({inputs:{x:r},backend:n,attrs:{shape:[h.batchSize,h.outerSize,h.dimSize,h.sliceSize]}}),m=Gn({inputs:{x:o},backend:n,attrs:{shape:[h.batchSize,f/h.batchSize]}}),g=[h.batchSize,h.outerSize,f/h.batchSize,h.sliceSize],y=n.bufferSync(m),w=n.bufferSync(p),b=UU(w,y,g);return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(m),n.makeTensorInfo(h.outputShape,b.dtype,b.values)}const zbt={kernelName:a1,backendName:"cpu",kernelFunc:Lbt};function Bbt(t){const{inputs:e,backend:n}=t,{input:s}=e,r=Ge(s.shape),o=s.shape[s.shape.length-1],a=r/o,i=Gn({inputs:{x:s},backend:n,attrs:{shape:[a,o]}}),l=OG(i,!0,n),u=Gn({inputs:{x:l},backend:n,attrs:{shape:s.shape}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(l),u}const Vbt={kernelName:e_,backendName:"cpu",kernelFunc:Bbt};const Hbt=An(Sp,t=>Number.isFinite(t)?1:0,"bool"),Wbt={kernelName:Sp,backendName:"cpu",kernelFunc:Hbt};const Ubt=An(Cp,t=>Math.abs(t)===1/0?1:0,"bool"),Gbt={kernelName:Cp,backendName:"cpu",kernelFunc:Ubt};const jbt=An(kp,t=>Number.isNaN(t)?1:0,"bool"),Kbt={kernelName:kp,backendName:"cpu",kernelFunc:jbt};function qbt(t){const{backend:e,attrs:n}=t,{start:s,stop:r,num:o}=n,a=XU(s,r,o);return e.makeTensorInfo([a.length],"float32",a)}const Xbt={kernelName:n_,backendName:"cpu",kernelFunc:qbt};const Ybt=An(Np,t=>Math.log1p(t)),Zbt={kernelName:Np,backendName:"cpu",kernelFunc:Ybt};const Jbt=Is((t,e)=>t&&e),Qbt=Ks(d1,Jbt,null,"bool"),ewt={kernelName:d1,backendName:"cpu",kernelFunc:Qbt};const twt=An(f1,t=>t?0:1,"bool"),nwt={kernelName:f1,backendName:"cpu",kernelFunc:twt};const swt=Is((t,e)=>t||e),rwt=Ks(h1,swt,null,"bool"),owt={kernelName:h1,backendName:"cpu",kernelFunc:rwt};function awt(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{depthRadius:o,bias:a,alpha:i,beta:l}=s;Tt(r,"LRN");const u=r.shape[3],c=u-1,d=n.data.get(r.dataId).values,f=Ge(r.shape),h=new Float32Array(f);function p(m){const g=m%u;let y=m-g+Math.max(0,g-o);const w=m-g+Math.min(g+o,c);let b=0;for(;y<=w;y++){const _=d[y];b+=_*_}return b}for(let m=0;m<f;m++){const g=p(m),y=d[m]*Math.pow(a+i*g,-l);h[m]=y}return n.makeTensorInfo(r.shape,r.dtype,h)}const iwt={kernelName:p1,backendName:"cpu",kernelFunc:awt};function lwt(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,y:o,dy:a}=e,{depthRadius:i,bias:l,alpha:u,beta:c}=s;Tt(a,"LRNGrad");const d=Ge(a.shape),f=a.shape[3],h=n.data.get(a.dataId).values,p=n.data.get(r.dataId).values,m=n.data.get(o.dataId).values,g=new Float32Array(d),y=d;for(let w=0;w<y;w++){const b=w%f,_=w-b+Math.max(0,b-i),$=w-b+Math.min(f,b+i+1);let x=0;for(let k=_;k<$;k++)x+=Math.pow(p[k],2);x=u*x+l;for(let k=_;k<$;k++){let C=-2*u*c*p[k]*m[w]/x;w===k&&(C+=Math.pow(x,-c)),C*=h[w],g[k]+=C}}return n.makeTensorInfo(a.shape,r.dtype,g)}const uwt={kernelName:s_,backendName:"cpu",kernelFunc:lwt};function RG(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{reductionIndices:o,keepDims:a}=s,i=n;let l=r.shape;const u=l.length,c=un(o,l);let d=c;const f=hs(d,u);let h=i.data.get(r.dataId).values;if(f!=null){const _=new Array(u);for(let $=0;$<_.length;$++)_[$]=l[f[$]];h=_I(h,l,r.dtype,f,_),d=bs(d.length,u),l=_}Tt(r,"max"),cr("max",d,u);const[p,m]=js(l,d),g=Ge(m),y=ZU(h,g,p,r.dtype),w=i.write(y,p,r.dtype);let b=p;return a&&(b=ys(p,c)),{dataId:w,shape:b,dtype:r.dtype}}const cwt={kernelName:m1,backendName:"cpu",kernelFunc:RG};function dwt(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e;Tt(r,"maxPool");const{filterSize:o,strides:a,pad:i,dimRoundingMode:l}=s,u=1;q(ur(a,u),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${u}'`);const c=Na(r.shape,o,a,u,i,l);let d;if(c.filterWidth===1&&c.filterHeight===1&&hn(c.inShape,c.outShape))d=Wi({inputs:{x:r},backend:n});else{const f=n.data.get(r.dataId).values,h=Mt(r.shape),p=SI(f,r.shape,r.dtype,h,c,"max");d=n.makeTensorInfo(c.outShape,r.dtype,p.values)}return d}const fwt={kernelName:g1,backendName:"cpu",kernelFunc:dwt};function hwt(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{filterSize:o,strides:a,pad:i,dimRoundingMode:l,dataFormat:u}=s;Tt(r,"maxPool3d");const c=Xl(r.shape,o,a,1,i,l,u),d=n.data.get(r.dataId).values,f=IG(d,r.shape,r.dtype,Mt(r.shape),c,"max");return n.makeTensorInfo(f.shape,"float32",f.values)}const pwt={kernelName:v1,backendName:"cpu",kernelFunc:hwt};function mwt(t){const{inputs:e,backend:n,attrs:s}=t,{dy:r,input:o}=e,{filterSize:a,strides:i,pad:l,dimRoundingMode:u}=s;Tt([r,o],"maxPool3DGrad");const c=Xl(o.shape,a,i,1,l,u),d=n.bufferSync(o),f=nyt(d,c),h=c.strideDepth,p=c.strideHeight,m=c.strideWidth,g=c.dilationDepth,y=c.dilationHeight,w=c.dilationWidth,b=c.effectiveFilterDepth,_=c.effectiveFilterHeight,$=c.effectiveFilterWidth,x=b-1-c.padInfo.front,k=$-1-c.padInfo.left,C=_-1-c.padInfo.top,T=tn(o.shape,"float32"),N=n.bufferSync(r);for(let M=0;M<c.batchSize;++M)for(let R=0;R<c.inChannels;++R)for(let D=0;D<c.inDepth;++D)for(let z=0;z<c.inHeight;++z)for(let B=0;B<c.inWidth;++B){const V=D-x,O=z-C,F=B-k;let L=0;for(let G=0;G<b;G+=g){const Z=(V+G)/h;if(!(Z<0||Z>=c.outDepth||Math.floor(Z)!==Z))for(let j=0;j<_;j+=y){const J=(O+j)/p;if(!(J<0||J>=c.outHeight||Math.floor(J)!==J))for(let fe=0;fe<$;fe+=w){const X=(F+fe)/m;if(X<0||X>=c.outWidth||Math.floor(X)!==X)continue;const oe=b*_*$-1-f.get(M,Z,J,X,R),ee=G*_*$+j*$+fe,Q=oe===ee?1:0;if(Q===0)continue;const ie=N.get(M,Z,J,X,R);L+=ie*Q}}}T.set(L,M,D,z,B,R)}return n.makeTensorInfo(T.shape,T.dtype,T.values)}const gwt={kernelName:o_,backendName:"cpu",kernelFunc:mwt};function vwt(t){const{inputs:e,backend:n,attrs:s}=t,{dy:r,input:o,output:a}=e,i=o;Tt([o,a],"maxPoolGrad");const{filterSize:l,strides:u,pad:c,dimRoundingMode:d}=s,f=Na(i.shape,l,u,1,c,d),h=n.data.get(i.dataId).values,p=tn(f.outShape,i.dtype,NG(h,i.shape,i.dtype,f).values),m=f.strideHeight,g=f.strideWidth,y=f.dilationHeight,w=f.dilationWidth,b=f.effectiveFilterHeight,_=f.effectiveFilterWidth,$=_-1-f.padInfo.left,x=b-1-f.padInfo.top,k=tn(i.shape,"float32"),C=n.data.get(r.dataId).values,T=tn(r.shape,"float32",C);for(let N=0;N<f.batchSize;++N)for(let M=0;M<f.inChannels;++M)for(let R=0;R<f.inHeight;++R)for(let D=0;D<f.inWidth;++D){const z=R-x,B=D-$;let V=0;for(let O=0;O<b;O+=y){const F=(z+O)/m;if(!(F<0||F>=f.outHeight||Math.floor(F)!==F))for(let L=0;L<_;L+=w){const G=(B+L)/g;if(G<0||G>=f.outWidth||Math.floor(G)!==G)continue;const Z=b*_-1-p.get(N,F,G,M),j=O*_+L,J=Z===j?1:0;if(J===0)continue;const fe=T.get(N,F,G,M);V+=fe*J}}k.set(V,N,R,D,M)}return n.makeTensorInfo(k.shape,k.dtype,k.values)}const ywt={kernelName:r_,backendName:"cpu",kernelFunc:vwt};function bwt(t,e,n,s,r){const o=Mt(e),a=SI(t,e,n,o,r,"max"),i=NG(t,e,n,r,!0,s);return[a.values,i.values]}const wwt={kernelName:a_,backendName:"cpu",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{x:s}=t,{filterSize:r,strides:o,pad:a,includeBatchInIndex:i}=e,l=n;Tt(s,"MaxPoolWithArgmax");const u=l.data.get(s.dataId).values,c=Na(s.shape,r,o,[1,1],a),[d,f]=bwt(u,s.shape,s.dtype,i,c),h=l.write(d,c.outShape,s.dtype),p=l.write(f,c.outShape,s.dtype);return[{dataId:h,shape:c.outShape,dtype:s.dtype},{dataId:p,shape:c.outShape,dtype:"int32"}]}};function _wt(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{axis:o,keepDims:a}=s,i=un(o,r.shape),u=js(r.shape,i)[1],c=Ge(u),d=[],f=n.makeTensorInfo([],"float32",new Float32Array([c]));d.push(f);const h=nc({inputs:{x:r},backend:n,attrs:{dtype:"float32"}});d.push(h);const p=CI({inputs:{a:h,b:f},backend:n});d.push(p);const m=$2({inputs:{x:p},backend:n,attrs:{axis:o,keepDims:a}});return d.forEach(g=>n.disposeIntermediateTensorInfo(g)),m}const $wt={kernelName:y1,backendName:"cpu",kernelFunc:_wt};function xwt(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{axis:o,keepDims:a}=s;Tt(r,"min");const i=un(o,r.shape);let l=i;const u=hs(l,r.shape.length);let c=r;u!=null&&(c=eo({inputs:{x:r},backend:n,attrs:{perm:u}}),l=bs(l.length,r.shape.length)),cr("min",l,c.shape.length);const[d,f]=js(c.shape,l),h=Ge(f),p=or(Ge(d),c.dtype),m=n.data.get(c.dataId).values;for(let y=0;y<p.length;++y){const w=y*h;let b=m[w];for(let _=0;_<h;++_){const $=m[w+_];(Number.isNaN($)||$<b)&&(b=$)}p[y]=b}u!=null&&n.disposeIntermediateTensorInfo(c);const g=n.makeTensorInfo(d,c.dtype,p);if(a){const y=ys(d,i),w=Gn({inputs:{x:g},backend:n,attrs:{shape:y}});return n.disposeIntermediateTensorInfo(g),w}return g}const Swt={kernelName:b1,backendName:"cpu",kernelFunc:xwt};function Cwt(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{paddings:o,mode:a}=s;Tt(r,"mirrorPad");const i=o.map((b,_)=>b[0]+r.shape[_]+b[1]),l=o.map(b=>b[0]),u=o.map((b,_)=>b[0]+r.shape[_]),c=a==="reflect"?0:1,d=n.data.get(r.dataId).values,f=r.shape.length,h=Mt(r.shape),p=Ge(i),m=i.length,g=Mt(i),y=zs(r.dtype,p);for(let b=0;b<p;b++){let _=tf(b,m,g);for(let x=0;x<m;x++)_[x]<l[x]?_[x]=l[x]*2-_[x]-c:_[x]>=u[x]&&(_[x]=(u[x]-1)*2-_[x]+c);_=_.map((x,k)=>x-l[k]);const $=Ka(_,f,h);y[b]=d[$]}return{dataId:n.write(y,i,r.dtype),shape:i,dtype:r.dtype}}const kwt={kernelName:w1,backendName:"cpu",kernelFunc:Cwt};const Twt=Is((t,e)=>{const n=t%e;return t<0&&e<0||t>=0&&e>=0?n:(n+e)%e}),Nwt=Ks(Ap,Twt),Iwt={kernelName:Ap,backendName:"cpu",kernelFunc:Nwt};function DG(t){const{inputs:e,backend:n,attrs:s}=t,{logits:r}=e,{dim:o}=s,a=r.shape.length;let i=o;if(i===-1&&(i=a-1),i!==a-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${a} and dim was ${i}`);const l=un([i],r.shape),u=RG({inputs:{x:r},backend:n,attrs:{reductionIndices:l,keepDims:!1}}),c=ys(u.shape,l),d=Gn({inputs:{x:u},backend:n,attrs:{shape:c}}),f=xI({inputs:{a:r,b:d},backend:n}),h=BU({inputs:{x:f},backend:n}),p=$2({inputs:{x:h},backend:n,attrs:{axis:l,keepDims:!1}}),m=Gn({inputs:{x:p},backend:n,attrs:{shape:c}}),g=CI({inputs:{a:h,b:m},backend:n});return n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(m),g}const Ewt={kernelName:L1,backendName:"cpu",kernelFunc:DG};function Awt(t){const{inputs:e,backend:n,attrs:s}=t,{logits:r}=e,{numSamples:o,seed:a,normalized:i}=s;Tt(r,"multinomial");const l=i?r:DG({inputs:{logits:r},backend:n,attrs:{dim:-1}}),u=l.shape[0],c=l.shape[1],d=n.data.get(l.dataId).values,f=[u,o],h=or(Ge(f),"int32");for(let p=0;p<u;++p){const m=p*c,g=new Float32Array(c-1);g[0]=d[m];for(let b=1;b<g.length;++b)g[b]=g[b-1]+d[m+b];const y=Ji.alea(a.toString()),w=p*o;for(let b=0;b<o;++b){const _=y();h[w+b]=g.length;for(let $=0;$<g.length;$++)if(_<g[$]){h[w+b]=$;break}}}return i||n.disposeIntermediateTensorInfo(l),n.makeTensorInfo(f,"int32",h)}const Owt={kernelName:i_,backendName:"cpu",kernelFunc:Awt};const Rwt=y3;function Dwt(t){const{inputs:e,backend:n,attrs:s}=t,{boxes:r,scores:o}=e,{maxOutputSize:a,iouThreshold:i,scoreThreshold:l}=s;Tt(r,"NonMaxSuppression");const u=n.data.get(r.dataId).values,c=n.data.get(o.dataId).values,{selectedIndices:d}=Rwt(u,c,a,i,l);return n.makeTensorInfo([d.length],"int32",new Int32Array(d))}const Fwt={kernelName:l_,backendName:"cpu",kernelFunc:Dwt};const Mwt=b3;function Pwt(t){const{inputs:e,backend:n,attrs:s}=t,{boxes:r,scores:o}=e,{maxOutputSize:a,iouThreshold:i,scoreThreshold:l,padToMaxOutputSize:u}=s;Tt(r,"NonMaxSuppressionPadded");const c=n.data.get(r.dataId).values,d=n.data.get(o.dataId).values,{selectedIndices:f,validOutputs:h}=Mwt(c,d,a,i,l,u);return[n.makeTensorInfo([f.length],"int32",new Int32Array(f)),n.makeTensorInfo([],"int32",new Int32Array([h]))]}const Lwt={kernelName:u_,backendName:"cpu",kernelFunc:Pwt};const zwt=w3;function Bwt(t){const{inputs:e,backend:n,attrs:s}=t,{boxes:r,scores:o}=e,{maxOutputSize:a,iouThreshold:i,scoreThreshold:l,softNmsSigma:u}=s;Tt(r,"NonMaxSuppressionWithScore");const c=n.data.get(r.dataId).values,d=n.data.get(o.dataId).values,f=a,h=i,p=l,m=u,{selectedIndices:g,selectedScores:y}=zwt(c,d,f,h,p,m);return[n.makeTensorInfo([g.length],"int32",new Int32Array(g)),n.makeTensorInfo([y.length],"float32",new Float32Array(y))]}const Vwt={kernelName:c_,backendName:"cpu",kernelFunc:Bwt};function Hwt(t){const{inputs:e,backend:n,attrs:s}=t,{indices:r}=e,{dtype:o,depth:a,onValue:i,offValue:l}=s;Tt(r,"oneHot");const u=Ge(r.shape),c=new Float32Array(u*a);c.fill(l);const d=n.data.get(r.dataId).values;for(let f=0;f<u;++f)d[f]>=0&&d[f]<a&&(c[f*a+d[f]]=i);return n.makeTensorInfo([...r.shape,a],o,c)}const Wwt={kernelName:S1,backendName:"cpu",kernelFunc:Hwt};function _b(t){const{inputs:e,backend:n}=t,{x:s}=e;if(s.dtype==="string")throw new Error("zerosLike is not supported for string tensors");if(s.dtype==="complex64"){const r=zd({inputs:{input:s},backend:n}),o=_b({inputs:{x:r},backend:n}),a=Dh({inputs:{input:s},backend:n}),i=_b({inputs:{x:a},backend:n}),l=fo({inputs:{real:o,imag:i},backend:n});return n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(i),l}else return kI({backend:n,attrs:{shape:s.shape,value:0,dtype:s.dtype}})}const Uwt={kernelName:V1,backendName:"cpu",kernelFunc:_b};function FG(t){const{inputs:e,backend:n}=t,{x:s}=e;if(s.dtype==="string")throw new Error("onesLike is not supported for string tensors");if(s.dtype==="complex64"){const r=zd({inputs:{input:s},backend:n}),o=FG({inputs:{x:r},backend:n}),a=Dh({inputs:{input:s},backend:n}),i=_b({inputs:{x:a},backend:n}),l=fo({inputs:{real:o,imag:i},backend:n});return n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(i),l}else return kI({backend:n,attrs:{shape:s.shape,value:1,dtype:s.dtype}})}const Gwt={kernelName:x1,backendName:"cpu",kernelFunc:FG};function MG(t){const{inputs:e,backend:n,attrs:s}=t,{axis:r}=s;if(e.length===1)return wb({inputs:{input:e[0]},backend:n,attrs:{dim:r}});const o=e[0].shape,a=e[0].dtype;e.forEach(c=>{lr(o,c.shape,"All tensors passed to stack must have matching shapes"),q(a===c.dtype,()=>"All tensors passed to stack must have matching dtypes")});const i=[],l=e.map(c=>{const d=wb({inputs:{input:c},backend:n,attrs:{dim:r}});return i.push(d),d}),u=Fh({inputs:l,backend:n,attrs:{axis:r}});return i.forEach(c=>n.disposeIntermediateTensorInfo(c)),u}const jwt={kernelName:C1,backendName:"cpu",kernelFunc:MG};function Kwt(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{paddings:o,constantValue:a}=s;Tt(r,"pad");const i=o.map((w,b)=>w[0]+r.shape[b]+w[1]),l=o.map(w=>w[0]),u=n.data.get(r.dataId).values,c=Ge(r.shape),d=r.shape.length,f=Mt(r.shape),h=Ge(i),p=i.length,m=Mt(i),g=zs(r.dtype,h);a!==0&&g.fill(a);for(let w=0;w<c;w++){const _=tf(w,d,f).map((x,k)=>x+l[k]),$=Ka(_,p,m);g[$]=u[w]}return{dataId:n.write(g,i,r.dtype),shape:i,dtype:r.dtype}}const PG={kernelName:k1,backendName:"cpu",kernelFunc:Kwt};const qwt=Is((t,e)=>Math.pow(t,e)),Xwt=Ks(Rp,qwt),Ywt={kernelName:Rp,backendName:"cpu",kernelFunc:Xwt};function Zwt(t){const{inputs:e,backend:n,attrs:s}=t,{paramsNestedSplits:r,paramsDenseValues:o,indices:a}=e,i=r.map(g=>n.data.get(g.dataId).values),l=r.map(g=>g.shape),u=n.data.get(o.dataId).values,c=n.data.get(a.dataId).values,[d,f,h]=sG(i,l,u,o.shape,o.dtype,c,a.shape),p=d.map(g=>n.makeTensorInfo([g.length],"int32",g)),m=n.makeTensorInfo(h,o.dtype,f);return p.concat([m])}const Jwt={kernelName:d_,backendName:"cpu",kernelFunc:Zwt};function Qwt(t){const{inputs:e,backend:n}=t,{starts:s,limits:r,deltas:o}=e,a=n.data.get(s.dataId).values,i=n.data.get(r.dataId).values,l=n.data.get(o.dataId).values,[u,c]=rG(a,s.shape,s.dtype,i,r.shape,l,o.shape),d=n.makeTensorInfo([u.length],"int32",u),f=n.makeTensorInfo([c.length],s.dtype,c);return[d,f]}const e_t={kernelName:f_,backendName:"cpu",kernelFunc:Qwt};function t_t(t){const{inputs:e,backend:n,attrs:s}=t,{shape:r,values:o,defaultValue:a,rowPartitionTensors:i}=e,{rowPartitionTypes:l}=s,u=n.data.get(r.dataId).values,c=n.data.get(o.dataId).values,d=n.data.get(a.dataId).values,f=i.map(g=>n.data.get(g.dataId).values),h=i.map(g=>g.shape),[p,m]=oG(u,r.shape,c,o.shape,o.dtype,d,a.shape,f,h,l);return n.makeTensorInfo(p,o.dtype,m)}const n_t={kernelName:h_,backendName:"cpu",kernelFunc:t_t};function s_t(t){const{backend:e,attrs:n}=t,{start:s,stop:r,dtype:o,step:a}=n,i=aG(s,r,a,o);return e.makeTensorInfo([i.length],o,i)}const r_t={kernelName:p_,backendName:"cpu",kernelFunc:s_t};const o_t=An(Dp,t=>1/t),a_t={kernelName:Dp,backendName:"cpu",kernelFunc:o_t};function i_t(t){const{inputs:e,backend:n,attrs:s}=t,{images:r}=e,{alignCorners:o,halfPixelCenters:a,size:i}=s;Tt(r,"resizeBilinear");const l=Mt(r.shape),[u,c]=i,[d,f,h,p]=r.shape,m=n.data.get(r.dataId).values,g=new Float32Array(Ge([d,u,c,p])),y=[o&&u>1?f-1:f,o&&c>1?h-1:h],w=[o&&u>1?u-1:u,o&&c>1?c-1:c];let b=0;const _=y[0]/w[0],$=y[1]/w[1];for(let x=0;x<d;x++)for(let k=0;k<u;k++){let C;a?C=_*(k+.5)-.5:C=_*k;const T=Math.max(0,Math.floor(C)),N=C-T,M=Math.min(f-1,Math.ceil(C)),R=x*l[0]+T*l[1],D=x*l[0]+M*l[1];for(let z=0;z<c;z++){let B;a?B=$*(z+.5)-.5:B=$*z;const V=Math.max(0,Math.floor(B)),O=B-V,F=Math.min(h-1,Math.ceil(B)),L=R+V*l[2],G=D+V*l[2],Z=R+F*l[2],j=D+F*l[2];for(let J=0;J<p;J++){const fe=m[L+J],X=m[G+J],oe=m[Z+J],ee=m[j+J],Q=fe+(oe-fe)*O,ie=X+(ee-X)*O,pe=Q+(ie-Q)*N;g[b++]=pe}}}return n.makeTensorInfo([d,u,c,p],"float32",g)}const l_t={kernelName:A1,backendName:"cpu",kernelFunc:i_t};function u_t(t){const{inputs:e,backend:n,attrs:s}=t,{images:r,dy:o}=e,{alignCorners:a}=s;Tt([o,r],"resizeBilinearGrad");const i=Mt(r.shape),[l,u,c,d]=r.shape,[,f,h]=o.shape,p=new Float32Array(l*u*c*d),m=[a&&f>1?u-1:u,a&&h>1?c-1:c],g=[a&&f>1?f-1:f,a&&h>1?h-1:h],y=m[0]/g[0],w=m[1]/g[1],b=n.data.get(o.dataId).values;let _=0;for(let $=0;$<l;$++){const x=$*i[0];for(let k=0;k<f;k++){const C=k*y,T=Math.floor(C),N=Math.min(Math.ceil(C),u-1),M=x+T*i[1],R=x+N*i[1],D=C-T,z=1-D;for(let B=0;B<h;B++){const V=B*w,O=Math.floor(V),F=Math.min(Math.ceil(V),c-1),L=V-O,G=1-L,Z=M+O*i[2],j=M+F*i[2],J=R+O*i[2],fe=R+F*i[2],X=z*G,oe=z*L,ee=D*G,Q=D*L;for(let ie=0;ie<d;ie++){const pe=b[_++];p[Z+ie]+=pe*X,p[j+ie]+=pe*oe,p[J+ie]+=pe*ee,p[fe+ie]+=pe*Q}}}}return n.makeTensorInfo([l,c,u,d],"float32",p)}const c_t={kernelName:v_,backendName:"cpu",kernelFunc:u_t};function d_t(t){const{inputs:e,backend:n,attrs:s}=t,{images:r}=e,{alignCorners:o,halfPixelCenters:a,size:i}=s;Tt(r,"resizeNearestNeighbor");const l=Mt(r.shape),[u,c]=i,[d,f,h,p]=r.shape,m=n.data.get(r.dataId).values,g=new Float32Array(d*u*c*p),y=[o&&u>1?f-1:f,o&&c>1?h-1:h],w=[o&&u>1?u-1:u,o&&c>1?c-1:c],b=y[0]/w[0],_=y[1]/w[1];let $=0;for(let x=0;x<d;x++){const k=x*l[0];for(let C=0;C<u;C++){const T=a?b*(C+.5):b*C;let N=Math.min(f-1,o?Math.round(T):Math.floor(T));a&&(N=Math.max(0,N));const M=k+N*l[1];for(let R=0;R<c;R++){const D=a?_*(R+.5):_*R;let z=Math.min(h-1,o?Math.round(D):Math.floor(D));a&&(z=Math.max(0,z));const B=M+z*l[2];for(let V=0;V<p;V++){const O=m[B+V];g[$++]=O}}}}return n.makeTensorInfo([d,u,c,p],r.dtype,g)}const f_t={kernelName:E1,backendName:"cpu",kernelFunc:d_t};function h_t(t){const{inputs:e,backend:n,attrs:s}=t,{images:r,dy:o}=e,{alignCorners:a}=s;Tt([o,r],"resizeNearestNeighborGrad");const i=Mt(r.shape),l=Mt(o.shape),[u,c,d,f]=r.shape,[,h,p]=o.shape,m=new Float32Array(u*c*d*f),g=n.data.get(o.dataId).values,y=[a&&h>1?c-1:c,a&&p>1?d-1:d],w=[a&&h>1?h-1:h,a&&p>1?p-1:p],b=y[0]/w[0],_=y[1]/w[1],$=1/b,x=1/_,k=Math.ceil($)*2+2,C=Math.ceil(x)*2+2;for(let T=0;T<u;T++){const N=T*i[0];for(let M=0;M<c;M++){const R=N+M*i[1],D=Math.floor(M*$),z=Math.floor(D-k/2);for(let B=0;B<d;B++){const V=R+B*i[2],O=Math.floor(B*x),F=Math.floor(O-C/2);for(let L=0;L<f;L++){let G=0;for(let Z=0;Z<k;Z++){const j=Z+z;if(j<0||j>=h)continue;const J=N+j*l[1],fe=j*b,X=Math.min(c-1,a?Math.round(fe):Math.floor(fe));if(M===X)for(let oe=0;oe<C;oe++){const ee=oe+F;if(ee<0||ee>=p)continue;const Q=J+ee*l[2],ie=ee*_,pe=Math.min(d-1,a?Math.round(ie):Math.floor(ie));B===pe&&(G+=g[Q+L])}}m[V+L]=G}}}}return n.makeTensorInfo(r.shape,r.dtype,m)}const p_t={kernelName:g_,backendName:"cpu",kernelFunc:h_t};function m_t(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{dims:o}=s;Tt(r,"reverse");const a=r.shape.length,i=un(o,r.shape);if(a===0)return Wi({inputs:{x:r},backend:n});const l=new Ds(r.shape,r.dtype),u=n.bufferSync(r);for(let c=0;c<l.size;c++){const d=l.indexToLoc(c),f=d.slice();i.forEach(h=>f[h]=r.shape[h]-1-f[h]),l.set(u.get(...f),...d)}return n.makeTensorInfo(l.shape,l.dtype,l.values)}const g_t={kernelName:O1,backendName:"cpu",kernelFunc:m_t};const v_t={kernelName:R_,backendName:"cpu",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{image:s}=t,{radians:r,fillValue:o,center:a}=e,i=n,l=zs(s.dtype,Ge(s.shape)),[u,c,d,f]=s.shape,[h,p]=_T(a,c,d),m=255,g=Math.sin(r),y=Math.cos(r),w=i.data.get(s.dataId).values;for(let _=0;_<u;_++){const $=_*d*c*f;for(let x=0;x<c;x++){const k=x*(d*f);for(let C=0;C<d;C++){const T=C*f;for(let N=0;N<f;N++){const M=[u,x,C,N],R=M[2],D=M[1];let z=(R-h)*y-(D-p)*g,B=(R-h)*g+(D-p)*y;z=Math.round(z+h),B=Math.round(B+p);let V=o;if(typeof o!="number"&&(N===3?V=m:V=o[N]),z>=0&&z<d&&B>=0&&B<c){const F=B*(d*f),L=z*f,G=$+F+L+N;V=w[G]}const O=$+k+T+N;l[O]=V}}}}return{dataId:i.write(l,s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}};const y_t=An(Pp,t=>{const e=Math.floor(t);return t-e<.5?Math.floor(t):t-e>.5?Math.ceil(t):e%2===0?e:e+1}),b_t={kernelName:Pp,backendName:"cpu",kernelFunc:y_t};function w_t(t){const{inputs:e,backend:n,attrs:s}=t,{indices:r,updates:o}=e,{shape:a}=s,{sliceRank:i,numUpdates:l,sliceSize:u,strides:c,outputSize:d}=Jp(o,r,a),f=!0,h=n.bufferSync(r),p=n.bufferSync(o),m=zf(h,p,a,d,u,l,i,c,0,f);return n.makeTensorInfo(a,m.dtype,m.values)}const __t={kernelName:y_,backendName:"cpu",kernelFunc:w_t};function $_t(t,e){let n=0,s=t.length,r=0;for(;n<s;)r=Math.floor((n+s)/2),t[r]<e?n=r+1:s=r;return s}function x_t(t,e){let n=0,s=t.length,r=0;for(;n<s;)r=Math.floor((n+s)/2),t[r]<=e?n=r+1:s=r;return s}function S_t(t,e,n,s,r,o){const a=gs("int32",n*r);for(let i=0;i<n;++i){const l=t.slice(i*s,(i+1)*s),u=i*r;for(let c=0;c<r;++c)a[u+c]=o==="left"?$_t(l,e[c+u]):x_t(l,e[c+u])}return a}function C_t(t){const{inputs:e,backend:n,attrs:s}=t,{sortedSequence:r,values:o}=e,{side:a}=s,i=n.data.get(r.dataId).values,l=n.data.get(o.dataId).values,u=S_t(i,l,r.shape[0],r.shape[1],o.shape[1],a);return n.makeTensorInfo(o.shape,"int32",u)}const k_t={kernelName:b_,backendName:"cpu",kernelFunc:C_t};function T_t(t){const{inputs:e,backend:n}=t,{condition:s,t:r,e:o}=e;Tt([s,r,o],"select");const a=s.shape.length,i=n.data.get(s.dataId).values,l=n.data.get(r.dataId).values,u=n.data.get(o.dataId).values,c=Yr(r.dtype,o.dtype),d=or(Ge(r.shape),c);let f=0;const h=a===0||a>1||r.shape.length===1?1:Ge(r.shape.slice(1));for(let p=0;p<i.length;p++)for(let m=0;m<h;m++)i[p]===1?d[f++]=l[p]:d[f++]=u[p];return n.makeTensorInfo(r.shape,c,d)}const N_t={kernelName:R1,backendName:"cpu",kernelFunc:T_t};const I_t=N3,E_t=I3,A_t=An(zp,t=>t>=0?E_t*t:I_t*(Math.exp(t)-1)),O_t={kernelName:zp,backendName:"cpu",kernelFunc:A_t};const R_t=An(Hp,t=>t<0?-1:t>0?1:0),D_t={kernelName:Hp,backendName:"cpu",kernelFunc:R_t};const F_t=An(Bp,t=>Math.sin(t)),M_t={kernelName:Bp,backendName:"cpu",kernelFunc:F_t};const P_t=An(Vp,t=>Math.sinh(t)),L_t={kernelName:Vp,backendName:"cpu",kernelFunc:P_t};const z_t=11920928955078125e-23,WD=Math.log(z_t)+2,B_t=An(Up,t=>{const e=t>-WD,n=t<WD,s=Math.exp(t);let r;return n?r=s:e?r=t:r=Math.log(1+s),r}),V_t={kernelName:Up,backendName:"cpu",kernelFunc:B_t};function H_t(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{blockShape:o,paddings:a}=s;Tt([r],"spaceToBatchND");const i=Ge(o),l=[[0,0]];l.push(...a);for(let x=1+o.length;x<r.shape.length;++x)l.push([0,0]);const u=PG.kernelFunc({inputs:{x:r},backend:n,attrs:{paddings:l,constantValue:0}}),c=l2(u.shape,o,i,!1),d=u2(c.length,o.length,!1),f=c2(u.shape,o,i,!1),m=Gn({inputs:{x:u},backend:n,attrs:{shape:c}}),w=eo({inputs:{x:m},backend:n,attrs:{perm:d}}),$=Gn({inputs:{x:w},backend:n,attrs:{shape:f}});return n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(w),$}const W_t={kernelName:M1,backendName:"cpu",kernelFunc:H_t};function U_t(t){const{inputs:e,backend:n}=t,{indices:s,values:r,denseShape:o,defaultValue:a}=e;if(o.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
        ${o.shape}`);if(s.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
        ${s.shape}`);if(r.shape.length!==1)throw new Error(`Values must be a vector, saw:
        ${r.shape}`);if(a.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${a.shape}`);const i=n.data.get(s.dataId).values,l=n.data.get(r.dataId).values,u=n.data.get(o.dataId).values,c=n.data.get(a.dataId).values[0],[d,f,h,p,m]=cG(i,s.shape,s.dtype,l,r.dtype,u,c);return[n.makeTensorInfo(f,s.dtype,d),n.makeTensorInfo([f[0]],r.dtype,h),n.makeTensorInfo([p.length],"bool",new Uint8Array(p.map(g=>Number(g)))),n.makeTensorInfo([m.length],s.dtype,new Int32Array(m))]}const G_t={kernelName:w_,backendName:"cpu",kernelFunc:U_t};function j_t(t){const{inputs:e,backend:n}=t,{inputIndices:s,inputShape:r,newShape:o}=e;if(s.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape
        ${s.shape}`);if(r.shape.length!==1)throw new Error(`Input shape should be a vector but received shape
        ${r.shape}`);if(o.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${o.shape}`);const a=Array.from(n.data.get(r.dataId).values),i=n.data.get(s.dataId).values,l=Array.from(n.data.get(o.dataId).values),[u,c,d]=dG(i,s.shape,s.dtype,a,l);return[n.makeTensorInfo(c,s.dtype,u),n.makeTensorInfo([d.length],o.dtype,new Int32Array(d))]}const K_t={kernelName:__,backendName:"cpu",kernelFunc:j_t};function q_t(t){const{inputs:e,backend:n}=t,{data:s,indices:r,segmentIds:o}=e;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.shape.length!==1)throw new Error(`Indices should be a vector but received shape
          ${r.shape}`);if(o.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
          ${o.shape}`);if(r.shape[0]!==o.shape[0])throw new Error("segmentIds and indices should have same size.");const a=n.data.get(s.dataId).values,i=n.data.get(r.dataId).values,l=n.data.get(o.dataId).values,[u,c]=$I(a,s.shape,s.dtype,i,l,!0);return n.makeTensorInfo(c,s.dtype,u)}const X_t={kernelName:$_,backendName:"cpu",kernelFunc:q_t};function Y_t(t){const{inputs:e,backend:n}=t,{data:s,indices:r,segmentIds:o}=e;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.shape.length!==1)throw new Error(`Indices should be a vector but received shape
         ${r.shape}`);if(o.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
         ${o.shape}`);if(r.shape[0]!==o.shape[0])throw new Error("segmentIds and indices should have same size.");const a=n.data.get(s.dataId).values,i=n.data.get(r.dataId).values,l=n.data.get(o.dataId).values,[u,c]=$I(a,s.shape,s.dtype,i,l);return n.makeTensorInfo(c,s.dtype,u)}const Z_t={kernelName:x_,backendName:"cpu",kernelFunc:Y_t};function J_t(t){const{inputs:e,backend:n,attrs:s}=t,{sparseIndices:r,sparseValues:o,defaultValue:a}=e,{outputShape:i}=s,{sliceRank:l,numUpdates:u,sliceSize:c,strides:d,outputSize:f}=Jp(o,r,i),h=!1,p=n.bufferSync(r);let m;switch(o.dtype){case"bool":{const g=n.bufferSync(o),y=Boolean(n.data.get(a.dataId).values[0]);m=zf(p,g,i,f,c,u,l,d,y,h);break}case"float32":{const g=n.bufferSync(o),y=n.data.get(a.dataId).values[0];m=zf(p,g,i,f,c,u,l,d,y,h);break}case"int32":{const g=n.bufferSync(o),y=n.data.get(a.dataId).values[0];m=zf(p,g,i,f,c,u,l,d,y,h);break}case"string":{const g=n.bufferSync(o),y=Nl(n.data.get(a.dataId).values[0]);m=zf(p,g,i,f,c,u,l,d,y,h);break}default:throw new Error(`Unsupported type ${o.dtype}`)}return n.makeTensorInfo(i,m.dtype,m.values)}const Q_t={kernelName:S_,backendName:"cpu",kernelFunc:J_t};function e3t(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{numOrSizeSplits:o,axis:a}=s,i=un(a,r.shape)[0],l=MT(r,o,i),u=new Array(r.shape.length).fill(0),c=r.shape.slice();return l.map(d=>{const f=[...c];f[i]=d;const h=Bd({inputs:{x:r},backend:n,attrs:{begin:u,size:f}});return u[i]+=d,h})}const t3t={kernelName:P1,backendName:"cpu",kernelFunc:e3t};const n3t={kernelName:C_,backendName:"cpu",kernelFunc:({inputs:t,backend:e})=>{const{x:n}=t,s=e;Tt(n,"square");const r=s.data.get(n.dataId).values,o=new Float32Array(r.length);for(let i=0;i<r.length;++i){const l=r[i];o[i]=l*l}return{dataId:s.write(o,n.shape,n.dtype),shape:n.shape,dtype:n.dtype}}};const s3t=An(Zp,(t,e)=>{const n=e;return isNaN(t)?NaN:t>0?1:n.alpha}),r3t={kernelName:Zp,backendName:"cpu",kernelFunc:s3t};function o3t(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{begin:o,end:a,strides:i,beginMask:l,endMask:u,ellipsisMask:c,newAxisMask:d,shrinkAxisMask:f}=s;Tt(r,"stridedSlice");const{finalShapeSparse:h,finalShape:p,isIdentity:m,sliceDim0:g,isSimpleSlice:y,begin:w,end:b,strides:_}=p8(r.shape,o,a,i,l,u,c,d,f);let $;if(m)$=Gn({inputs:{x:r},backend:n,attrs:{shape:p}});else if(g||y){q(r.shape.length>=1,()=>`Input must have rank at least 1, got: ${r.shape.length}`);const x=d8(w,b,_),k=Bd({inputs:{x:r},backend:n,attrs:{begin:w,size:x}});$=Gn({inputs:{x:k},backend:n,attrs:{shape:p}}),n.disposeIntermediateTensorInfo(k)}else{const x=n.bufferSync(r),k=hG(h,x,_,w);$=n.makeTensorInfo(p,k.dtype,k.values)}return $}const a3t={kernelName:k_,backendName:"cpu",kernelFunc:o3t};function i3t(t){const{inputs:e,backend:n,attrs:s}=t,{separator:r,nGramWidths:o,leftPad:a,rightPad:i,padWidth:l,preserveShortSequences:u}=s,{data:c,dataSplits:d}=e,f=n.data.get(c.dataId).values,h=n.data.get(d.dataId).values,[p,m]=pG(f,h,r,o,a,i,l,u);return[n.makeTensorInfo([p.length],"string",p),n.makeTensorInfo(d.shape,"int32",m)]}const l3t={kernelName:T_,backendName:"cpu",kernelFunc:i3t};function u3t(t){const{inputs:e,backend:n,attrs:s}=t,{skipEmpty:r}=s,{input:o,delimiter:a}=e;if(o.dtype!=="string")throw new Error("Input must be of datatype string");if(o.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${o.shape}`);if(a.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${a.shape}`);const i=n.data.get(o.dataId).values,l=n.data.get(a.dataId).values[0],[u,c,d]=mG(i,l,r),f=c.length;return[n.makeTensorInfo([f,2],"int32",u),n.makeTensorInfo([f],"string",c),n.makeTensorInfo([2],"int32",new Int32Array(d))]}const c3t={kernelName:N_,backendName:"cpu",kernelFunc:u3t};function d3t(t){const{inputs:e,backend:n,attrs:s}=t,{numBuckets:r}=s,{input:o}=e;if(o.dtype!=="string")throw new Error("Input must be of datatype string");if(r<=0)throw new Error("Number of buckets must be at least 1");const a=n.data.get(o.dataId).values,i=gG(a,r);return n.makeTensorInfo(o.shape,"int32",i)}const f3t={kernelName:I_,backendName:"cpu",kernelFunc:d3t};const h3t=An(qp,t=>Math.tan(t)),p3t={kernelName:qp,backendName:"cpu",kernelFunc:h3t};const m3t=An(Xp,t=>Math.tanh(t)),g3t={kernelName:Xp,backendName:"cpu",kernelFunc:m3t};function v3t(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{reps:o}=s;Tt(r,"tile");const a=yG(n.bufferSync(r),o);return n.makeTensorInfo(a.shape,a.dtype,a.values)}const y3t={kernelName:Yp,backendName:"cpu",kernelFunc:v3t};function b3t(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{k:o,sorted:a}=s;Tt(r,"topk");const i=n.data.get(r.dataId).values,[l,u]=wG(i,r.shape,r.dtype,o,a);return[n.makeTensorInfo(l.shape,l.dtype,l.values),n.makeTensorInfo(u.shape,u.dtype,u.values)]}const w3t={kernelName:E_,backendName:"cpu",kernelFunc:b3t};function _3t(t){const{inputs:e,attrs:n,backend:s}=t,{image:r,transforms:o}=e,{interpolation:a,fillMode:i,fillValue:l,outputShape:u}=n,[c,d,f,h]=r.shape,[p,m]=u??[d,f],g=[c,p,m,h],y=Mt(r.shape),w=y[0],b=y[1],_=y[2],$=Mt(g),x=$[0],k=$[1],C=$[2],T=zs(r.dtype,Ge(g));T.fill(l);const N=s.data.get(r.dataId).values,M=s.data.get(o.dataId).values;for(let D=0;D<c;++D){const z=o.shape[0]===1?M:M.subarray(D*8,D*8+8);for(let B=0;B<p;++B)for(let V=0;V<m;++V)for(let O=0;O<h;++O){let F;const L=z[6]*V+z[7]*B+1;if(L===0)continue;const G=(z[0]*V+z[1]*B+z[2])/L,Z=(z[3]*V+z[4]*B+z[5])/L,j=UD(G,f,i),J=UD(Z,d,i);switch(a){case"nearest":F=T3t(N,d,f,w,b,_,D,J,j,O,l);break;case"bilinear":F=N3t(N,d,f,w,b,_,D,J,j,O,l);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${a}`)}const fe=D*x+B*k+V*C+O;T[fe]=F}return s.makeTensorInfo(g,r.dtype,T)}return{dataId:s.write(T,g,r.dtype),shape:r.shape,dtype:r.dtype}}const $3t={kernelName:A_,backendName:"cpu",kernelFunc:_3t};function UD(t,e,n){switch(n){case"reflect":return x3t(t,e);case"wrap":return S3t(t,e);case"nearest":return k3t(t,e);case"constant":default:return C3t(t)}}function x3t(t,e){let n=t;if(n<0)if(e<=1)n=0;else{const s=2*e;n<s&&(n=s*Math.trunc(-n/s)+n),n=n<-e?n+s:-n-1}else if(n>e-1)if(e<=1)n=0;else{const s=2*e;n-=s*Math.trunc(n/s),n>=e&&(n=s-n-1)}return qu(0,n,e-1)}function S3t(t,e){let n=t;if(n<0)if(e<=1)n=0;else{const s=e-1;n+=e*(Math.trunc(-n/s)+1)}else if(n>e-1)if(e<=1)n=0;else{const s=e-1;n-=e*Math.trunc(n/s)}return qu(0,n,e-1)}function C3t(t,e){return t}function k3t(t,e){return qu(0,t,e-1)}function Xm(t,e,n,s,r,o,a,i,l,u,c){const d=a*s+i*r+l*o+u;return 0<=i&&i<e&&0<=l&&l<n?t[d]:c}function T3t(t,e,n,s,r,o,a,i,l,u,c){const d=Math.round(i),f=Math.round(l);return Xm(t,e,n,s,r,o,a,d,f,u,c)}function N3t(t,e,n,s,r,o,a,i,l,u,c){const d=Math.floor(i),f=Math.floor(l),h=d+1,p=f+1,m=(p-l)*Xm(t,e,n,s,r,o,a,d,f,u,c)+(l-f)*Xm(t,e,n,s,r,o,a,d,p,u,c),g=(p-l)*Xm(t,e,n,s,r,o,a,h,f,u,c)+(l-f)*Xm(t,e,n,s,r,o,a,h,p,u,c);return(h-i)*m+(i-d)*g}function I3t(t){const{inputs:e,attrs:n,backend:s}=t,{axis:r}=n,{x:o}=e;Tt(o,"unique");const a=s.data.get(o.dataId).values,{outputValues:i,outputShape:l,indices:u}=_G(a,r,o.shape,o.dtype);return[s.makeTensorInfo(l,o.dtype,i),s.makeTensorInfo([u.length],"int32",u)]}const E3t={kernelName:O_,backendName:"cpu",kernelFunc:I3t};function A3t(t){const{inputs:e,backend:n,attrs:s}=t,{value:r}=e;let{axis:o}=s;o<0&&(o+=r.shape.length);const a=r.shape.length,i=r.shape[o],l=new Array(a-1);let u=0;for(let h=0;h<a;h++)h!==o&&(l[u++]=r.shape[h]);const c=new Array(a).fill(0),d=r.shape.slice();d[o]=1;const f=new Array(i);for(let h=0;h<f.length;h++){c[o]=h;const p=Bd({inputs:{x:r},backend:n,attrs:{begin:c,size:d}});f[h]=Gn({inputs:{x:p},backend:n,attrs:{shape:l}}),n.disposeIntermediateTensorInfo(p)}return f}const O3t={kernelName:z1,backendName:"cpu",kernelFunc:A3t};function R3t(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,segmentIds:o}=e,{numSegments:a}=s;Tt(r,"unsortedSegmentSum");const i=r.shape.length,l=o.shape.length,u=[],c=[],d=i-l;let f=o;for(let p=0;p<d;++p){const m=wb({inputs:{input:f},backend:n,attrs:{dim:p+1}});f=m,c.push(m)}for(let p=0;p<a;++p){const m=ql(p,"int32"),g=n.makeTensorInfo([],"int32",m),y=LU({inputs:{a:g,b:f},backend:n}),w=nc({inputs:{x:y},backend:n,attrs:{dtype:"float32"}}),b=J3({inputs:{a:w,b:r},backend:n}),_=$2({inputs:{x:b},backend:n,attrs:{axis:0,keepDims:!1}});u.push(_),c.push(g),c.push(y),c.push(w),c.push(b),c.push(_)}const h=MG({inputs:u,backend:n,attrs:{axis:0}});return c.forEach(p=>n.disposeIntermediateTensorInfo(p)),h}const D3t={kernelName:B1,backendName:"cpu",kernelFunc:R3t};const F3t=[Evt,m2t,Ovt,Dvt,_2t,Mvt,Lvt,Bvt,Hvt,Uvt,jvt,qvt,Yvt,Qvt,tyt,ryt,ayt,lyt,cyt,Nvt,fyt,pyt,gyt,yyt,b2t,x2t,wyt,g2t,$yt,Syt,Cyt,Tyt,Iyt,Ayt,Ryt,Fyt,Pyt,zyt,Vyt,Wyt,Gyt,Kyt,Xyt,Yyt,Jyt,ebt,nbt,sbt,rbt,obt,lbt,_vt,cbt,S2t,ybt,C2t,bbt,T2t,Cbt,kbt,Nbt,I2t,Abt,Rbt,Fbt,Pbt,zbt,A2t,R2t,v2t,Vbt,xyt,Wbt,Gbt,Kbt,$vt,F2t,P2t,Xbt,z2t,Zbt,ewt,nwt,owt,iwt,uwt,cwt,V2t,fwt,pwt,gwt,ywt,wwt,$wt,Swt,W2t,kwt,Iwt,Owt,G2t,K2t,Fwt,Lwt,Vwt,X2t,Wwt,Gwt,jwt,PG,Ywt,Svt,J2t,Jwt,e_t,n_t,r_t,y2t,Yx,a_t,Cvt,kvt,Tvt,l_t,c_t,f_t,p_t,g_t,v_t,b_t,avt,__t,k_t,N_t,O_t,lvt,D_t,M_t,L_t,uvt,Ewt,V_t,W_t,G_t,K_t,X_t,Z_t,Q_t,t3t,fvt,n3t,pvt,r3t,a3t,l3t,c3t,f3t,yvt,abt,p3t,g3t,y3t,w3t,$3t,Y2t,E3t,O3t,D3t,Uwt];for(const t of F3t)D_(t);const Wc={},xv={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function M3t(t,e){Wc[t]=e}function si(t,e){if(!(t in Wc)||e!=null){const s=L3t(t,e);if(s!==null)Wc[t]=s;else return console.log("Could not get context for WebGL version",t),null}const n=Wc[t];return n==null||n.isContextLost()?(delete Wc[t],si(t)):(n.disable(n.DEPTH_TEST),n.disable(n.STENCIL_TEST),n.disable(n.BLEND),n.disable(n.DITHER),n.disable(n.POLYGON_OFFSET_FILL),n.disable(n.SAMPLE_COVERAGE),n.enable(n.SCISSOR_TEST),n.enable(n.CULL_FACE),n.cullFace(n.BACK),Wc[t])}function P3t(t){if(typeof OffscreenCanvas<"u"&&t===2)return new OffscreenCanvas(300,150);if(typeof document<"u")return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}function L3t(t,e){if(t!==1&&t!==2)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const n=e??P3t(t);return n.addEventListener("webglcontextlost",s=>{s.preventDefault(),delete Wc[t]},!1),Be().getBool("SOFTWARE_WEBGL_ENABLED")&&(xv.failIfMajorPerformanceCaveat=!1),t===1?n.getContext("webgl",xv)||n.getContext("experimental-webgl",xv):n.getContext("webgl2",xv)}var lg;(function(t){t[t.DENSE=0]="DENSE",t[t.SHARED_BATCH=1]="SHARED_BATCH"})(lg||(lg={}));var zo;(function(t){t[t.RENDER=0]="RENDER",t[t.UPLOAD=1]="UPLOAD",t[t.PIXELS=2]="PIXELS",t[t.DOWNLOAD=3]="DOWNLOAD"})(zo||(zo={}));var Qs;(function(t){t[t.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",t[t.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",t[t.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",t[t.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",t[t.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"})(Qs||(Qs={}));function x2(t,e){return[e,t]}function z3t(t,e){return t*e}function Sv(t){const e=Ge(t),n=Math.ceil(e/4);return Uy(n)}function hm(t,e){return[Math.max(1,Math.ceil(e/2)),Math.max(1,Math.ceil(t/2))]}function B3t(t,e){const[n,s]=hm(t,e);return n*s*4}function TI(t,e){const n=t;let s,r,o,a,i,l,u,c,d,f;return Be().getNumber("WEBGL_VERSION")===2?(s=n.R32F,r=n.R16F,o=n.RGBA16F,a=n.RGBA32F,i=n.RED,u=4,c=1,d=n.HALF_FLOAT,f=n.FLOAT,l=n.RGBA8):(s=t.RGBA,r=t.RGBA,o=t.RGBA,a=n.RGBA,i=t.RGBA,u=4,c=4,d=e!=null?e.HALF_FLOAT_OES:null,f=t.FLOAT,l=t.RGBA),{internalFormatFloat:s,internalFormatHalfFloat:r,internalFormatPackedHalfFloat:o,internalFormatPackedFloat:a,textureFormatFloat:i,downloadTextureFormat:l,downloadUnpackNumChannels:u,defaultNumChannels:c,textureTypeHalfFloat:d,textureTypeFloat:f}}function _t(t,e){const n=e();return Be().getBool("DEBUG")&&V3t(t),n}function V3t(t){const e=t.getError();if(e!==t.NO_ERROR)throw new Error("WebGL Error: "+G3t(t,e))}const H3t=596e-10,W3t=65504;function U3t(t){return!!(Be().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||t===0||H3t<Math.abs(t)&&Math.abs(t)<W3t)}function G3t(t,e){switch(e){case t.NO_ERROR:return"NO_ERROR";case t.INVALID_ENUM:return"INVALID_ENUM";case t.INVALID_VALUE:return"INVALID_VALUE";case t.INVALID_OPERATION:return"INVALID_OPERATION";case t.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case t.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case t.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${e}`}}function Cv(t,e){return tu(t,()=>t.getExtension(e),'Extension "'+e+'" not supported on this browser.')}function j3t(t,e){const n=tu(t,()=>t.createShader(t.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(_t(t,()=>t.shaderSource(n,e)),_t(t,()=>t.compileShader(n)),t.getShaderParameter(n,t.COMPILE_STATUS)===!1)throw console.log(t.getShaderInfoLog(n)),new Error("Failed to compile vertex shader.");return n}function K3t(t,e){const n=tu(t,()=>t.createShader(t.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(_t(t,()=>t.shaderSource(n,e)),_t(t,()=>t.compileShader(n)),Be().get("ENGINE_COMPILE_ONLY"))return n;if(t.getShaderParameter(n,t.COMPILE_STATUS)===!1)throw LG(e,t.getShaderInfoLog(n)),new Error("Failed to compile fragment shader.");return n}const q3t=/ERROR: [0-9]+:([0-9]+):/g;function LG(t,e){const n=q3t.exec(e);if(n==null){console.log(`Couldn't parse line number in error: ${e}`),console.log(t);return}const s=+n[1],r=t.split(`
`),o=r.length.toString().length+2,a=r.map((d,f)=>id((f+1).toString(),o)+d);let i=0;for(let d=0;d<a.length;d++)i=Math.max(a[d].length,i);const l=a.slice(0,s-1),u=a.slice(s-1,s),c=a.slice(s);console.log(l.join(`
`)),console.log(e.split(`
`)[0]),console.log(`%c ${id(u[0],i)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(c.join(`
`))}function X3t(t){return tu(t,()=>t.createProgram(),"Unable to create WebGLProgram.")}function Y3t(t,e){if(_t(t,()=>t.linkProgram(e)),!Be().get("ENGINE_COMPILE_ONLY")&&t.getProgramParameter(e,t.LINK_STATUS)===!1)throw console.log(t.getProgramInfoLog(e)),new Error("Failed to link vertex and fragment shaders.")}function T$(t,e){if(_t(t,()=>t.validateProgram(e)),t.getProgramParameter(e,t.VALIDATE_STATUS)===!1)throw console.log(t.getProgramInfoLog(e)),new Error("Shader program validation failed.")}function Z3t(t,e){const n=tu(t,()=>t.createBuffer(),"Unable to create WebGLBuffer");return _t(t,()=>t.bindBuffer(t.ARRAY_BUFFER,n)),_t(t,()=>t.bufferData(t.ARRAY_BUFFER,e,t.STATIC_DRAW)),n}function J3t(t,e){const n=tu(t,()=>t.createBuffer(),"Unable to create WebGLBuffer");return _t(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,n)),_t(t,()=>t.bufferData(t.ELEMENT_ARRAY_BUFFER,e,t.STATIC_DRAW)),n}function Q3t(t){return tu(t,()=>t.createTexture(),"Unable to create WebGLTexture.")}function e4t(t,e){const n=Be().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(t<=0||e<=0){const s=`[${t}x${e}]`;throw new Error("Requested texture size "+s+" is invalid.")}if(t>n||e>n){const s=`[${t}x${e}]`,r=`[${n}x${n}]`;throw new Error("Requested texture size "+s+" greater than WebGL maximum on this browser / GPU "+r+".")}}function t4t(t){return tu(t,()=>t.createFramebuffer(),"Unable to create WebGLFramebuffer.")}function GD(t,e,n,s,r,o,a){const i=t.getAttribLocation(e,n);return i===-1?!1:(_t(t,()=>t.bindBuffer(t.ARRAY_BUFFER,s)),_t(t,()=>t.vertexAttribPointer(i,r,t.FLOAT,!1,o,a)),_t(t,()=>t.enableVertexAttribArray(i)),!0)}function n4t(t,e,n){i4t(t,n),_t(t,()=>t.activeTexture(t.TEXTURE0+n)),_t(t,()=>t.bindTexture(t.TEXTURE_2D,e))}function s4t(t,e,n){return tu(t,()=>t.getUniformLocation(e,n),'uniform "'+n+'" not present in program.')}function r4t(t,e,n){return t.getUniformLocation(e,n)}function o4t(t,e,n,s){_t(t,()=>n4t(t,e,s)),_t(t,()=>t.uniform1i(n,s))}function N$(t,e,n){_t(t,()=>t.bindFramebuffer(t.FRAMEBUFFER,n)),_t(t,()=>t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,e,0))}function jD(t,e){_t(t,()=>t.bindFramebuffer(t.FRAMEBUFFER,e)),_t(t,()=>t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,null,0))}function kv(t){const e=t.checkFramebufferStatus(t.FRAMEBUFFER);if(e!==t.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+a4t(t,e))}function a4t(t,e){switch(e){case t.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case t.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case t.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case t.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${e}`}}function tu(t,e,n){const s=_t(t,()=>e());if(s==null)throw new Error(n);return s}function i4t(t,e){const n=t.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,s=e+t.TEXTURE0;if(s<t.TEXTURE0||s>n){const r=`[gl.TEXTURE0, gl.TEXTURE${n}]`;throw new Error(`textureUnit must be in ${r}.`)}}function Mh(t,e=2){return Ge(t.slice(0,t.length-e))}function Ph(t){if(t.length===0)throw Error("Cannot get rows and columns of an empty shape array.");return[t.length>1?t[t.length-2]:1,t[t.length-1]]}function Tv(t){let e=[1,1,1];return t.length===0||t.length===1&&t[0]===1||(e=[Mh(t),...Ph(t)]),e}function l4t(t,e=!1){let n=Be().getNumber("WEBGL_MAX_TEXTURE_SIZE"),s=Be().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");s===1/0&&Be().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(s=n/2),e&&(n=n*2,s=s*2,t=t.map((i,l)=>l>=t.length-2?Iw(t[l]):t[l]),t.length===1&&(t=[2,t[0]])),t.length!==2&&(t=Kl(t).newShape);let r=Ge(t),o=null;t.length<=1&&r<=n?o=[1,r]:t.length===2&&t[0]<=n&&t[1]<=n?o=t:t.length===3&&t[0]*t[1]<=n&&t[2]<=n?o=[t[0]*t[1],t[2]]:t.length===3&&t[0]<=n&&t[1]*t[2]<=n?o=[t[0],t[1]*t[2]]:t.length===4&&t[0]*t[1]*t[2]<=n&&t[3]<=n?o=[t[0]*t[1]*t[2],t[3]]:t.length===4&&t[0]<=n&&t[1]*t[2]*t[3]<=n&&(o=[t[0],t[1]*t[2]*t[3]]);const a=o!=null&&Math.max(...o)>s&&Math.min(...o)<=(e?2:1)&&Math.min(...o)>0;if(o==null||a)if(e){const i=Mh(t);let l=2,u=2;t.length&&([l,u]=Ph(t)),r=i*(l/2)*(u/2),o=Uy(r).map(c=>c*2)}else o=Uy(r);return o}function Nv(t){return t%2===0}function $b(t,e){if(t=t.slice(-2),e=e.slice(-2),hn(t,e)||!t.length||!e.length||t[0]===0||t[1]===0||e[0]===0||e[1]===0)return!0;if(t.length!==e.length){const n=t.slice(-1)[0],s=e.slice(-1)[0];if(n===s||Nv(n)&&Nv(s)&&(t[0]===1||e[0]===1))return!0}return t[1]===e[1]&&Nv(t[0])&&Nv(e[0])}let I$,E$;function u4t(t){if(I$==null){const e=si(t);I$=e.getParameter(e.MAX_TEXTURE_SIZE)}return I$}function c4t(t){if(E$==null){const e=si(t);E$=e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,E$)}function d4t(t){if(t===0)return 0;let e;const n=si(t);return ma(n,"EXT_disjoint_timer_query_webgl2")&&t===2?e=2:ma(n,"EXT_disjoint_timer_query")?e=1:e=0,e}function ma(t,e){return t.getExtension(e)!=null}function KD(t){try{if(si(t)!=null)return!0}catch(e){return console.log("Error when getting WebGL context: ",e),!1}return!1}function f4t(t){if(t===0)return!1;const e=si(t);if(t===1){if(!ma(e,"OES_texture_float"))return!1}else if(!ma(e,"EXT_color_buffer_float"))return!1;return Jx(e)}function h4t(t){if(t===0)return!1;const e=si(t);if(t===1){if(!ma(e,"OES_texture_float")||!ma(e,"WEBGL_color_buffer_float"))return!1}else{if(ma(e,"EXT_color_buffer_float"))return Jx(e);const s="EXT_color_buffer_half_float";if(ma(e,s)){const r=e.getExtension(s);return p4t(e,r)}return!1}return Jx(e)}function Jx(t){const e=TI(t),n=t.createTexture();t.bindTexture(t.TEXTURE_2D,n);const s=1,r=1;t.texImage2D(t.TEXTURE_2D,0,e.internalFormatFloat,s,r,0,e.textureFormatFloat,e.textureTypeFloat,null);const o=t.createFramebuffer();t.bindFramebuffer(t.FRAMEBUFFER,o),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,n,0);const a=t.checkFramebufferStatus(t.FRAMEBUFFER)===t.FRAMEBUFFER_COMPLETE;return t.bindTexture(t.TEXTURE_2D,null),t.bindFramebuffer(t.FRAMEBUFFER,null),t.deleteTexture(n),t.deleteFramebuffer(o),a}function p4t(t,e){const n=TI(t,e),s=t.createTexture();t.bindTexture(t.TEXTURE_2D,s);const r=1,o=1;t.texImage2D(t.TEXTURE_2D,0,n.internalFormatHalfFloat,r,o,0,n.textureFormatFloat,n.textureTypeHalfFloat,null);const a=t.createFramebuffer();t.bindFramebuffer(t.FRAMEBUFFER,a),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,s,0);const i=t.checkFramebufferStatus(t.FRAMEBUFFER)===t.FRAMEBUFFER_COMPLETE;return t.bindTexture(t.TEXTURE_2D,null),t.bindFramebuffer(t.FRAMEBUFFER,null),t.deleteTexture(s),t.deleteFramebuffer(a),i}function m4t(t){return t!==2?!1:si(t).fenceSync!=null}function S2(t,e){Array.isArray(t)||(t=[t]),t.forEach(n=>{n!=null&&q(n.dtype!=="complex64",()=>`${e} does not support complex64 tensors in the WebGL backend.`)})}const At=Be();At.registerFlag("HAS_WEBGL",()=>At.getNumber("WEBGL_VERSION")>0);At.registerFlag("WEBGL_VERSION",()=>KD(2)?2:KD(1)?1:0);At.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1);At.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>At.get("WEBGL_VERSION")===2);At.registerFlag("WEBGL_CPU_FORWARD",()=>!0);At.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1);At.registerFlag("WEBGL_PACK",()=>At.getBool("HAS_WEBGL"));At.registerFlag("WEBGL_PACK_NORMALIZATION",()=>At.getBool("WEBGL_PACK"));At.registerFlag("WEBGL_PACK_CLIP",()=>At.getBool("WEBGL_PACK"));At.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>At.getBool("WEBGL_PACK"));At.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>At.getBool("WEBGL_PACK"));At.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>At.getBool("WEBGL_PACK"));At.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>At.getBool("WEBGL_PACK"));At.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>At.getBool("WEBGL_PACK"));At.registerFlag("WEBGL_PACK_REDUCE",()=>At.getBool("WEBGL_PACK"));At.registerFlag("WEBGL_LAZILY_UNPACK",()=>At.getBool("WEBGL_PACK"));At.registerFlag("WEBGL_CONV_IM2COL",()=>At.getBool("WEBGL_PACK"));At.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>u4t(At.getNumber("WEBGL_VERSION")));At.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>c4t(At.getNumber("WEBGL_VERSION")));At.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{const t=At.getNumber("WEBGL_VERSION");return t===0?0:d4t(t)});At.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>At.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!qk());At.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>f4t(At.getNumber("WEBGL_VERSION")));At.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>At.getBool("WEBGL_FORCE_F16_TEXTURES")?!1:At.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"));At.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>h4t(At.getNumber("WEBGL_VERSION")));At.registerFlag("WEBGL_FENCE_API_ENABLED",()=>m4t(At.getNumber("WEBGL_VERSION")));At.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>At.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0);At.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,t=>{if(t<0&&t!==-1)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${t}.`)});At.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>qk()?1:-1,t=>{if(t<0&&t!==-1)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${t}.`)});At.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128);At.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1);At.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5);At.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128);At.registerFlag("WEBGL_EXP_CONV",()=>!1);At.registerFlag("SOFTWARE_WEBGL_ENABLED",()=>At.getBool("IS_TEST"));At.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",()=>1/0);At.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",()=>!1);At.registerFlag("WEBGL2_ISNAN_CUSTOM",()=>!1);At.registerFlag("ENGINE_COMPILE_ONLY",()=>!1);function Lr(){let t,e,n,s,r,o,a,i,l,u;return Be().getNumber("WEBGL_VERSION")===2?(t="#version 300 es",e="in",n="out",s="in",r="texture",o="outputColor",a="out vec4 outputColor;",i=Be().getBool("WEBGL2_ISNAN_CUSTOM")?`
      bool isnan_custom(float val) {
        uint floatToUint = floatBitsToUint(val);
        return (floatToUint & 0x7fffffffu) > 0x7f800000u;
      }

      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan_custom(val.x),
          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));
      }

      #define isnan(value) isnan_custom(value)
    `:"",l="",u=`
      #define round(value) newRound(value)
      int newRound(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 newRound(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `):(t="",e="attribute",n="varying",s="varying",r="texture2D",o="gl_FragColor",a="",i=`
      #define isnan(value) isnan_custom(value)
      bool isnan_custom(float val) {
        return (val > 0. || val < 1. || val == 0.) ? false : true;
      }
      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));
      }
    `,l=`
      uniform float INFINITY;

      bool isinf(float val) {
        return abs(val) == INFINITY;
      }
      bvec4 isinf(vec4 val) {
        return equal(abs(val), vec4(INFINITY));
      }
    `,u=`
      int round(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 round(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `),{version:t,attribute:e,varyingVs:n,varyingFs:s,texture2D:r,output:o,defineOutput:a,defineSpecialNaN:i,defineSpecialInf:l,defineRound:u}}function hf(t,e,n="index"){const s=Mt(e);return s.map((r,o)=>{const a=`int ${t[o]} = ${n} / ${r}`,i=o===s.length-1?`int ${t[o+1]} = ${n} - ${t[o]} * ${r}`:`index -= ${t[o]} * ${r}`;return`${a}; ${i};`}).join("")}function Q3(t,e,n="index"){const s=Mt(e);return s.map((r,o)=>{const a=`int ${t[o]} = ${n} / outShapeStrides[${o}]`,i=o===s.length-1?`int ${t[o+1]} = ${n} - ${t[o]} * outShapeStrides[${o}]`:`index -= ${t[o]} * outShapeStrides[${o}]`;return`${a}; ${i};`}).join("")}function g4t(t,e){const n=t.length,s=t.map(o=>`${e}[${o}]`),r=new Array(n-1);r[n-2]=s[n-1];for(let o=n-3;o>=0;--o)r[o]=`(${r[o+1]} * ${s[o+1]})`;return r}function v4t(t,e,n="index"){const s=t.map((o,a)=>a),r=g4t(s,e);return r.map((o,a)=>{const i=`int ${t[a]} = ${n} / ${r[a]}`,l=a===r.length-1?`int ${t[a+1]} = ${n} - ${t[a]} * ${r[a]}`:`index -= ${t[a]} * ${r[a]}`;return`${i}; ${l};`}).join("")}function NI(t){const e=Mt(t).map(n=>n.toString());return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * ${e[0]} + coords.y * ${e[1]} + coords.z;
  }
`}function II(){return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;
  }
`}const zG=`
  const float FLOAT_MAX = 1.70141184e38;
  const float FLOAT_MIN = 1.17549435e-38;

  lowp vec4 encode_float(highp float v) {
    if (isnan(v)) {
      return vec4(255, 255, 255, 255);
    }

    highp float av = abs(v);

    if(av < FLOAT_MIN) {
      return vec4(0.0, 0.0, 0.0, 0.0);
    } else if(v > FLOAT_MAX) {
      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
    } else if(v < -FLOAT_MAX) {
      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
    }

    highp vec4 c = vec4(0,0,0,0);

    highp float e = floor(log2(av));
    highp float m = exp2(fract(log2(av))) - 1.0;

    c[2] = floor(128.0 * m);
    m -= c[2] / 128.0;
    c[1] = floor(32768.0 * m);
    m -= c[1] / 32768.0;
    c[0] = floor(8388608.0 * m);

    highp float ebias = e + 127.0;
    c[3] = floor(ebias / 2.0);
    ebias -= c[3] * 2.0;
    c[2] += floor(ebias) * 128.0;

    c[3] += 128.0 * step(0.0, -v);

    return c / 255.0;
  }
`;const{getBroadcastDims:BG}=JH;function y4t(t,e,n){const s=[];if(t.forEach(h=>{const p=Ge(h.shapeInfo.logicalShape);if(h.shapeInfo.isUniform?s.push(`uniform float ${h.name}${p>1?`[${p}]`:""};`):(s.push(`uniform sampler2D ${h.name};`),s.push(`uniform int offset${h.name};`)),n.enableShapeUniforms){const{uniformShape:m}=EI(n.packedInputs,h.shapeInfo.logicalShape,h.shapeInfo.texShape);switch(m.length){case 1:s.push(`uniform int ${h.name}Shape;`);break;case 2:s.push(`uniform ivec2 ${h.name}Shape;`);break;case 3:s.push(`uniform ivec3 ${h.name}Shape;`);break;case 4:s.push(`uniform ivec4 ${h.name}Shape;`);break}s.push(`uniform ivec2 ${h.name}TexShape;`)}}),n.enableShapeUniforms){switch(e.logicalShape.length){case 1:s.push("uniform int outShape;");break;case 2:s.push("uniform ivec2 outShape;"),s.push("uniform int outShapeStrides;");break;case 3:s.push("uniform ivec3 outShape;"),s.push("uniform ivec2 outShapeStrides;");break;case 4:s.push("uniform ivec4 outShape;"),s.push("uniform ivec3 outShapeStrides;");break}s.push("uniform ivec2 outTexShape;")}n.customUniforms&&n.customUniforms.forEach(h=>{s.push(`uniform ${h.type} ${h.name}${h.arrayIndex?`[${h.arrayIndex}]`:""};`)});const r=s.join(`
`),o=t.map(h=>b4t(h,e,n.packedInputs,n.enableShapeUniforms)).join(`
`),a=e.texShape,i=Lr(),l=$4t(i);let u,c,d=C4t(i);return e.isPacked?(u=w4t(e.logicalShape,a,n.enableShapeUniforms),c=S4t(i)):(u=_4t(e.logicalShape,a,n.enableShapeUniforms),c=x4t(i)),n.packedInputs&&(d+=I4t),[d,l,c,r,u,o,n.userCode].join(`
`)}function pm(t,e=!1){const n=t.shapeInfo.logicalShape;switch(n.length){case 0:return V4t(t,e);case 1:return W4t(t,e);case 2:return G4t(t,e);case 3:return K4t(t,e);case 4:return X4t(t,e);case 5:return Y4t(t);case 6:return Z4t(t);default:throw new Error(`${n.length}-D input sampling is not yet supported`)}}function VG(t,e){switch(t.shapeInfo.logicalShape.length){case 0:return B4t(t);case 1:return H4t(t,e);case 2:return U4t(t,e);case 3:return j4t(t,e);default:return q4t(t,e)}}function b4t(t,e,n=!1,s){let r="";n?r+=VG(t,s):r+=pm(t,s);const o=t.shapeInfo.logicalShape,a=e.logicalShape;return o.length<=a.length&&(n?r+=J4t(t,e):r+=Q4t(t,e)),r}function w4t(t,e,n){switch(t.length){case 0:return HG();case 1:return E4t(t,e,n);case 2:return L4t(t,e,n);case 3:return O4t(t,e,n);default:return D4t(t,e,n)}}function _4t(t,e,n){switch(t.length){case 0:return HG();case 1:return A4t(t,e,n);case 2:return z4t(t,e,n);case 3:return R4t(t,e,n);case 4:return F4t(t,e,n);case 5:return M4t(t,e);case 6:return P4t(t,e);default:throw new Error(`${t.length}-D output sampling is not yet supported`)}}function $4t(t){return`
    float sampleTexture(sampler2D textureSampler, vec2 uv) {
      return ${t.texture2D}(textureSampler, uv).r;
    }
  `}function x4t(t){return`
    void setOutput(float val) {
      ${t.output} = vec4(val, 0, 0, 0);
    }
  `}function S4t(t){return`
    void setOutput(vec4 val) {
      ${t.output} = val;
    }
  `}function C4t(t){return`${t.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${t.varyingFs} vec2 resultUV;
    ${t.defineOutput}
    const vec2 halfCR = vec2(0.5, 0.5);

    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    uniform float NAN;
    ${t.defineSpecialNaN}
    ${t.defineSpecialInf}
    ${t.defineRound}

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    int idiv(int a, int b, float sign) {
      int res = a / b;
      int mod = imod(a, b);
      if (sign < 0. && mod != 0) {
        res -= 1;
      }
      return res;
    }

    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    #define HASHSCALE1 443.8975
    float random(float seed){
      vec2 p = resultUV * seed;
      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
      p3 += dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${k4t}
    ${T4t}
    ${N4t}
  `}const k4t=`
vec2 uvFromFlat(int texNumR, int texNumC, int index) {
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
  int texelIndex = index / 2;
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,T4t=`
vec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,
  int texNumC, int row, int col) {
  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,N4t=`
vec2 packedUVfrom3D(int texNumR, int texNumC,
    int texelsInBatch, int texelsInLogicalRow, int b,
    int row, int col) {
  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,I4t=`
  float getChannel(vec4 frag, vec2 innerDims) {
    vec2 modCoord = mod(innerDims, 2.);
    return modCoord.x == 0. ?
      (modCoord.y == 0. ? frag.r : frag.g) :
      (modCoord.y == 0. ? frag.b : frag.a);
  }
  float getChannel(vec4 frag, int dim) {
    float modCoord = mod(float(dim), 2.);
    return modCoord == 0. ? frag.r : frag.g;
  }
`;function HG(){return`
    int getOutputCoords() {
      return 0;
    }
  `}function E4t(t,e,n){const s=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];return s[0]===1?n?`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ${s[1]}.0);
      }
    `:s[1]===1?n?`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ${s[0]}.0);
      }
    `:n?`
    int getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));
      return 2 * (resTexRC.x * ${s[1]} + resTexRC.y);
    }
  `}function A4t(t,e,n){return e[0]===1?n?`
      int getOutputCoords() {
        return int(resultUV.x * float(outTexShape[1]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.x * ${e[1]}.0);
      }
    `:e[1]===1?n?`
      int getOutputCoords() {
        return int(resultUV.y * float(outTexShape[0]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.y * ${e[0]}.0);
      }
    `:n?`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      return resTexRC.x * outTexShape[1] + resTexRC.y;
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      return resTexRC.x * ${e[1]} + resTexRC.y;
    }
  `}function O4t(t,e,n){if(n)return`
    ivec3 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec3(b, r, c);
    }
  `;const s=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],r=Math.ceil(t[2]/2),o=r*Math.ceil(t[1]/2);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));
      int index = resTexRC.x * ${s[1]} + resTexRC.y;

      int b = index / ${o};
      index -= b * ${o};

      int r = 2 * (index / ${r});
      int c = imod(index, ${r}) * 2;

      return ivec3(b, r, c);
    }
  `}function R4t(t,e,n){if(n)return`
  ivec3 getOutputCoords() {
    ivec2 resTexRC = ivec2(resultUV.yx *
                           vec2(outTexShape[0], outTexShape[1]));
    int index = resTexRC.x * outTexShape[1] + resTexRC.y;
    ${Q3(["r","c","d"],t)}
    return ivec3(r, c, d);
  }
`;const s=hf(["r","c","d"],t);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      ${s}
      return ivec3(r, c, d);
    }
  `}function D4t(t,e,n){if(n)return`
    ivec4 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatchN = texelsInBatch * outShape[1];

      int b2 = index / texelsInBatchN;
      index -= b2 * texelsInBatchN;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec4(b2, b, r, c);
    }
  `;const s=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],r=Math.ceil(t[t.length-1]/2),o=r*Math.ceil(t[t.length-2]/2);let a=o,i="",l="b, r, c";for(let u=2;u<t.length-1;u++)a*=t[t.length-u-1],i=`
      int b${u} = index / ${a};
      index -= b${u} * ${a};
    `+i,l=`b${u}, `+l;return`
    ivec${t.length} getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));
      int index = resTexRC.x * ${s[1]} + resTexRC.y;

      ${i}

      int b = index / ${o};
      index -= b * ${o};

      int r = 2 * (index / ${r});
      int c = imod(index, ${r}) * 2;

      return ivec${t.length}(${l});
    }
  `}function F4t(t,e,n){if(n)return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      ${Q3(["r","c","d","d2"],t)}
      return ivec4(r, c, d, d2);
    }
  `;const s=hf(["r","c","d","d2"],t);return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      ${s}
      return ivec4(r, c, d, d2);
    }
  `}function M4t(t,e){const n=hf(["r","c","d","d2","d3"],t);return`
    ivec5 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${e[0]},
                             ${e[1]}));

      int index = resTexRC.x * ${e[1]} + resTexRC.y;

      ${n}

      ivec5 outShape = ivec5(r, c, d, d2, d3);
      return outShape;
    }
  `}function P4t(t,e){const n=hf(["r","c","d","d2","d3","d4"],t);return`
    ivec6 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;

      ${n}

      ivec6 result = ivec6(r, c, d, d2, d3, d4);
      return result;
    }
  `}function L4t(t,e,n){const s=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];if(hn(t,e))return n?`
      ivec2 getOutputCoords() {
        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return 2 * ivec2(resultUV.yx * vec2(${s[0]}, ${s[1]}));
      }
    `;const r=Math.ceil(t[1]/2);return n?`
    ivec2 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));

      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;
      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));

      int index = resTexRC.x * ${s[1]} + resTexRC.y;
      int r = 2 * (index / ${r});
      int c = imod(index, ${r}) * 2;

      return ivec2(r, c);
    }
  `}function z4t(t,e,n){return hn(t,e)?n?`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(${e[0]}, ${e[1]}));
      }
    `:t[1]===1?n?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(index, 0);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${e[0]}, ${e[1]}));
        int index = resTexRC.x * ${e[1]} + resTexRC.y;
        return ivec2(index, 0);
      }
    `:t[0]===1?n?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(0, index);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${e[0]}, ${e[1]}));
        int index = resTexRC.x * ${e[1]} + resTexRC.y;
        return ivec2(0, index);
      }
    `:n?`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      int r = index / outShape[1];
      int c = index - r * outShape[1];
      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      int r = index / ${t[1]};
      int c = index - r * ${t[1]};
      return ivec2(r, c);
    }
  `}function pf(t){return`offset${t}`}function B4t(t){const e=t.name,n="get"+e.charAt(0).toUpperCase()+e.slice(1),s=Lr();return`
    vec4 ${n}() {
      return ${s.texture2D}(${e}, halfCR);
    }
  `}function V4t(t,e){const n=t.name,s="get"+n.charAt(0).toUpperCase()+n.slice(1);if(t.shapeInfo.isUniform)return`float ${s}() {return ${n};}`;const[r,o]=t.shapeInfo.texShape;if(r===1&&o===1)return`
      float ${s}() {
        return sampleTexture(${n}, halfCR);
      }
    `;const a=pf(n);if(e)return`
    float ${s}() {
      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], ${a});
      return sampleTexture(${n}, uv);
    }
  `;const[i,l]=t.shapeInfo.texShape;return`
    float ${s}() {
      vec2 uv = uvFromFlat(${i}, ${l}, ${a});
      return sampleTexture(${n}, uv);
    }
  `}function H4t(t,e){const n=t.name,s="get"+n.charAt(0).toUpperCase()+n.slice(1),r=t.shapeInfo.texShape,o=Lr();if(e)return`
    vec4 ${s}(int index) {
      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));
      vec2 uv = packedUVfrom1D(
        packedTexShape[0], packedTexShape[1], index);
      return ${o.texture2D}(${n}, uv);
    }
  `;const a=[Math.ceil(r[0]/2),Math.ceil(r[1]/2)];return`
    vec4 ${s}(int index) {
      vec2 uv = packedUVfrom1D(
        ${a[0]}, ${a[1]}, index);
      return ${o.texture2D}(${n}, uv);
    }
  `}function W4t(t,e){const n=t.name,s="get"+n.charAt(0).toUpperCase()+n.slice(1);if(t.shapeInfo.isUniform)return`
      float ${s}(int index) {
        ${mm(t)}
      }
    `;const r=t.shapeInfo.texShape,o=r[0],a=r[1];if(a===1&&o===1)return`
      float ${s}(int index) {
        return sampleTexture(${n}, halfCR);
      }
    `;const i=pf(n);return a===1?e?`
      float ${s}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${i}) + 0.5) / float(${n}TexShape[0]));
        return sampleTexture(${n}, uv);
      }
    `:`
      float ${s}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${i}) + 0.5) / ${o}.0);
        return sampleTexture(${n}, uv);
      }
    `:o===1?e?`
      float ${s}(int index) {
        vec2 uv = vec2((float(index + ${i}) + 0.5) / float(${n}TexShape[1]), 0.5);
        return sampleTexture(${n}, uv);
      }
    `:`
      float ${s}(int index) {
        vec2 uv = vec2((float(index + ${i}) + 0.5) / ${a}.0, 0.5);
        return sampleTexture(${n}, uv);
      }
    `:e?`
    float ${s}(int index) {
      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], index + ${i});
      return sampleTexture(${n}, uv);
    }
  `:`
    float ${s}(int index) {
      vec2 uv = uvFromFlat(${o}, ${a}, index + ${i});
      return sampleTexture(${n}, uv);
    }
  `}function U4t(t,e){const n=t.shapeInfo.logicalShape,s=t.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),o=t.shapeInfo.texShape,a=o[0],i=o[1],l=Lr();if(o!=null&&hn(n,o))return e?`
      vec4 ${r}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${s}TexShape[1], ${s}TexShape[0]);

        return ${l.texture2D}(${s}, uv);
      }
    `:`
      vec4 ${r}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${i}.0, ${a}.0);

        return ${l.texture2D}(${s}, uv);
      }
    `;if(e)return`
    vec4 ${r}(int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${s}TexShape[0]) / 2.0), ceil(float(${s}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${s}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);
      return ${l.texture2D}(${s}, uv);
    }
  `;const u=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)],c=Math.ceil(n[1]/2);return`
    vec4 ${r}(int row, int col) {
      vec2 uv = packedUVfrom2D(${c}, ${u[0]}, ${u[1]}, row, col);
      return ${l.texture2D}(${s}, uv);
    }
  `}function G4t(t,e){const n=t.shapeInfo.logicalShape,s=t.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),o=t.shapeInfo.texShape;if(o!=null&&hn(n,o)){if(e)return`
      float ${r}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `;const f=o[0],h=o[1];return`
    float ${r}(int row, int col) {
      vec2 uv = (vec2(col, row) + halfCR) / vec2(${h}.0, ${f}.0);
      return sampleTexture(${s}, uv);
    }
  `}const{newShape:a,keptDims:i}=Kl(n),l=a;if(l.length<n.length){const f=gm(t,l),h=["row","col"];return`
      ${pm(f,e)}
      float ${r}(int row, int col) {
        return ${r}(${vm(h,i)});
      }
    `}if(t.shapeInfo.isUniform)return`
      float ${r}(int row, int col) {
        int index = round(dot(vec2(row, col), vec2(${n[1]}, 1)));
        ${mm(t)}
      }
    `;const u=o[0],c=o[1],d=pf(s);return c===1?e?`
      float ${r}(int row, int col) {
        float index = dot(vec3(row, col, ${d}), vec3(${s}Shape[1], 1, 1));
        vec2 uv = vec2(0.5, (index + 0.5) / float(${s}TexShape[0]));
        return sampleTexture(${s}, uv);
      }
    `:`
    float ${r}(int row, int col) {
      float index = dot(vec3(row, col, ${d}), vec3(${n[1]}, 1, 1));
      vec2 uv = vec2(0.5, (index + 0.5) / ${u}.0);
      return sampleTexture(${s}, uv);
    }
  `:u===1?e?`
      float ${r}(int row, int col) {
        float index = dot(vec3(row, col, ${d}), vec3(${s}Shape[1], 1, 1));
        vec2 uv = vec2((index + 0.5) / float(${s}TexShape[1]), 0.5);
        return sampleTexture(${s}, uv);
      }
    `:`
    float ${r}(int row, int col) {
      float index = dot(vec3(row, col, ${d}), vec3(${n[1]}, 1, 1));
      vec2 uv = vec2((index + 0.5) / ${c}.0, 0.5);
      return sampleTexture(${s}, uv);
    }
  `:e?`
      float ${r}(int row, int col) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${s}Shape[1] + col + ${d};
        vec2 uv = uvFromFlat(${s}TexShape[0], ${s}TexShape[1], index);
        return sampleTexture(${s}, uv);
      }
    `:`
  float ${r}(int row, int col) {
    // Explicitly use integer operations as dot() only works on floats.
    int index = row * ${n[1]} + col + ${d};
    vec2 uv = uvFromFlat(${u}, ${c}, index);
    return sampleTexture(${s}, uv);
  }
`}function j4t(t,e){const n=t.shapeInfo.logicalShape,s=t.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),o=t.shapeInfo.texShape,a=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)];if(n[0]===1){const f=n.slice(1),h=[1,2],p=gm(t,f),m=["b","row","col"];return`
        ${VG(p,e)}
        vec4 ${r}(int b, int row, int col) {
          return ${r}(${vm(m,h)});
        }
      `}const i=Lr();if(e)return`
    vec4 ${r}(int b, int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${s}TexShape[0]) / 2.0), ceil(float(${s}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${s}Shape[2]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${s}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom3D(
        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);
      return ${i.texture2D}(${s}, uv);
    }
  `;const l=a[0],u=a[1],c=Math.ceil(n[2]/2),d=c*Math.ceil(n[1]/2);return`
    vec4 ${r}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${l}, ${u}, ${d}, ${c}, b, row, col);
      return ${i.texture2D}(${s}, uv);
    }
  `}function K4t(t,e){const n=t.shapeInfo.logicalShape,s=t.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),o=n[1]*n[2],a=n[2],{newShape:i,keptDims:l}=Kl(n),u=i;if(u.length<n.length){const m=gm(t,u),g=["row","col","depth"];return`
        ${pm(m,e)}
        float ${r}(int row, int col, int depth) {
          return ${r}(${vm(g,l)});
        }
      `}if(t.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth) {
        int index = round(dot(vec3(row, col, depth),
                          vec3(${o}, ${a}, 1)));
        ${mm(t)}
      }
    `;const c=t.shapeInfo.texShape,d=c[0],f=c[1],h=t.shapeInfo.flatOffset;if(f===o&&h==null)return e?`
      float ${r}(int row, int col, int depth) {
        int stride1 = ${s}Shape[2];
        float texR = float(row);
        float texC = dot(vec2(col, depth), vec2(stride1, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `:`
        float ${r}(int row, int col, int depth) {
          float texR = float(row);
          float texC = dot(vec2(col, depth), vec2(${a}, 1));
          vec2 uv = (vec2(texC, texR) + halfCR) /
                     vec2(${f}.0, ${d}.0);
          return sampleTexture(${s}, uv);
        }
      `;if(f===a&&h==null)return e?`
      float ${r}(int row, int col, int depth) {
        float texR = dot(vec2(row, col), vec2(${s}Shape[1], 1));
        float texC = float(depth);
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `:`
    float ${r}(int row, int col, int depth) {
      float texR = dot(vec2(row, col), vec2(${n[1]}, 1));
      float texC = float(depth);
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${f}.0, ${d}.0);
      return sampleTexture(${s}, uv);
    }
  `;const p=pf(s);return e?`
    float ${r}(int row, int col, int depth) {
      // Explicitly use integer operations as dot() only works on floats.
      int stride0 = ${s}Shape[1] * ${s}Shape[2];
      int stride1 = ${s}Shape[2];
      int index = row * stride0 + col * stride1 + depth + ${p};
      vec2 uv = uvFromFlat(${s}TexShape[0], ${s}TexShape[1], index);
      return sampleTexture(${s}, uv);
    }
    `:`
      float ${r}(int row, int col, int depth) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${o} + col * ${a} + depth + ${p};
        vec2 uv = uvFromFlat(${d}, ${f}, index);
        return sampleTexture(${s}, uv);
      }
  `}function q4t(t,e){const n=t.name,s="get"+n.charAt(0).toUpperCase()+n.slice(1),r=Lr();if(e)return`
    vec4 ${s}(int b2, int b, int row, int col) {
      int valuesPerRow = int(ceil(float(${n}Shape[3]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${n}Shape[2]) / 2.0));
      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);
      texelsInBatch *= ${n}Shape[1];
      index = b2 * texelsInBatch + index;
      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));
      int texR = index / packedTexShape[1];
      int texC = index - texR * packedTexShape[1];
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${r.texture2D}(${n}, uv);
    }
  `;const o=t.shapeInfo.logicalShape,a=o.length,i=t.shapeInfo.texShape,l=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)],u=l[0],c=l[1],d=Math.ceil(o[a-1]/2);let f=d*Math.ceil(o[a-2]/2),h="int b, int row, int col",p=`b * ${f} + (row / 2) * ${d} + (col / 2)`;for(let m=2;m<a-1;m++)h=`int b${m}, `+h,f*=o[a-m-1],p=`b${m} * ${f} + `+p;return`
    vec4 ${s}(${h}) {
      int index = ${p};
      int texR = index / ${c};
      int texC = index - texR * ${c};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${c}, ${u});
      return ${r.texture2D}(${n}, uv);
    }
  `}function X4t(t,e){const n=t.shapeInfo.logicalShape,s=t.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),o=n[3],a=n[2]*o,i=n[1]*a,{newShape:l,keptDims:u}=Kl(n);if(l.length<n.length){const w=gm(t,l),b=["row","col","depth","depth2"];return`
      ${pm(w,e)}
      float ${r}(int row, int col, int depth, int depth2) {
        return ${r}(${vm(b,u)});
      }
    `}if(t.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth, int depth2) {
        int index = round(dot(vec4(row, col, depth, depth2),
                          vec4(${i}, ${a}, ${o}, 1)));
        ${mm(t)}
      }
    `;const c=t.shapeInfo.flatOffset,d=t.shapeInfo.texShape,f=d[0],h=d[1],p=`int stride2 = ${s}Shape[3];`,m=`int stride1 = ${s}Shape[2] * stride2;`,g=`int stride0 = ${s}Shape[1] * stride1;`;if(h===i&&c==null)return e?`
      float ${r}(int row, int col, int depth, int depth2) {
        ${p}
        ${m}
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(stride1, stride2, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `:`
      float ${r}(int row, int col, int depth, int depth2) {
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(${a}, ${o}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${h}.0, ${f}.0);
        return sampleTexture(${s}, uv);
      }
    `;if(h===o&&c==null)return e?`
      float ${r}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${s}Shape[1] * ${s}Shape[2], ${s}Shape[2], 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `:`
      float ${r}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${n[1]*n[2]}, ${n[2]}, 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${h}.0, ${f}.0);
        return sampleTexture(${s}, uv);
      }
    `;const y=pf(s);return e?`
    float ${r}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      ${p}
      ${m}
      ${g}
      int index = row * stride0 + col * stride1 +
          depth * stride2 + depth2;
      vec2 uv = uvFromFlat(${s}TexShape[0], ${s}TexShape[1], index + ${y});
      return sampleTexture(${s}, uv);
    }
  `:`
    float ${r}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${i} + col * ${a} +
          depth * ${o} + depth2;
      vec2 uv = uvFromFlat(${f}, ${h}, index + ${y});
      return sampleTexture(${s}, uv);
    }
  `}function Y4t(t){const e=t.shapeInfo.logicalShape,n=t.name,s="get"+n.charAt(0).toUpperCase()+n.slice(1),r=e[4],o=e[3]*r,a=e[2]*o,i=e[1]*a,{newShape:l,keptDims:u}=Kl(e);if(l.length<e.length){const m=gm(t,l),g=["row","col","depth","depth2","depth3"];return`
      ${pm(m)}
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        return ${s}(${vm(g,u)});
      }
    `}if(t.shapeInfo.isUniform)return`
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        float index = dot(
          vec4(row, col, depth, depth2),
          vec4(${i}, ${a}, ${o}, ${r})) +
          depth3;
        ${mm(t)}
      }
    `;const c=t.shapeInfo.flatOffset,d=t.shapeInfo.texShape,f=d[0],h=d[1];if(h===i&&c==null)return`
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
                         vec4(${a}, ${o}, ${r}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${h}.0, ${f}.0);
        return sampleTexture(${n}, uv);
      }
    `;if(h===r&&c==null)return`
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        float texR = dot(
          vec4(row, col, depth, depth2),
          vec4(${e[1]*e[2]*e[3]},
               ${e[2]*e[3]}, ${e[3]}, 1));
        int texC = depth3;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${h}.0, ${f}.0);
        return sampleTexture(${n}, uv);
      }
    `;const p=pf(n);return`
    float ${s}(int row, int col, int depth, int depth2, int depth3) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${i} + col * ${a} + depth * ${o} +
          depth2 * ${r} + depth3 + ${p};
      vec2 uv = uvFromFlat(${f}, ${h}, index);
      return sampleTexture(${n}, uv);
    }
  `}function Z4t(t){const e=t.shapeInfo.logicalShape,n=t.name,s="get"+n.charAt(0).toUpperCase()+n.slice(1),{newShape:r,keptDims:o}=Kl(e);if(r.length<e.length){const g=gm(t,r),y=["row","col","depth","depth2","depth3","depth4"];return`
      ${pm(g)}
      float ${s}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        return ${s}(${vm(y,o)});
      }
    `}const a=e[5],i=e[4]*a,l=e[3]*i,u=e[2]*l,c=e[1]*u;if(t.shapeInfo.isUniform)return`
      float ${s}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
        int index = round(dot(
          vec4(row, col, depth, depth2),
          vec4(${c}, ${u}, ${l}, ${i})) +
          dot(
            vec2(depth3, depth4),
            vec2(${a}, 1)));
        ${mm(t)}
      }
    `;const d=t.shapeInfo.flatOffset,f=t.shapeInfo.texShape,h=f[0],p=f[1];if(p===c&&d==null)return`
      float ${s}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
          vec4(${u}, ${l}, ${i}, ${a})) +
               float(depth4);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${p}.0, ${h}.0);
        return sampleTexture(${n}, uv);
      }
    `;if(p===a&&d==null)return`
      float ${s}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        float texR = dot(vec4(row, col, depth, depth2),
          vec4(${e[1]*e[2]*e[3]*e[4]},
               ${e[2]*e[3]*e[4]},
               ${e[3]*e[4]},
               ${e[4]})) + float(depth3);
        int texC = depth4;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${p}.0, ${h}.0);
        return sampleTexture(${n}, uv);
      }
    `;const m=pf(n);return`
    float ${s}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${c} + col * ${u} + depth * ${l} +
          depth2 * ${i} + depth3 * ${a} + depth4 + ${m};
      vec2 uv = uvFromFlat(${h}, ${p}, index);
      return sampleTexture(${n}, uv);
    }
  `}function mm(t){const e=t.name,n=Ge(t.shapeInfo.logicalShape);return n<2?`return ${e};`:`
    for (int i = 0; i < ${n}; i++) {
      if (i == index) {
        return ${e}[i];
      }
    }
  `}function J4t(t,e){const n=t.name,s=n.charAt(0).toUpperCase()+n.slice(1),r="get"+s+"AtOutCoords",o=t.shapeInfo.logicalShape.length,a=e.logicalShape.length,i=BG(t.shapeInfo.logicalShape,e.logicalShape),l=jn(a),u=a-o;let c;const d=["x","y","z","w","u","v"];o===0?c="":a<2&&i.length>=1?c="coords = 0;":c=i.map(w=>`coords.${d[w+u]} = 0;`).join(`
`);let f="";a<2&&o>0?f="coords":f=t.shapeInfo.logicalShape.map((w,b)=>`coords.${d[b+u]}`).join(", ");let h="return outputValue;";const m=Ge(t.shapeInfo.logicalShape)===1,y=Ge(e.logicalShape)===1;if(o===1&&!m&&!y)h=`
      return vec4(outputValue.xy, outputValue.xy);
    `;else if(m&&!y)a===1?h=`
        return vec4(outputValue.x, outputValue.x, 0., 0.);
      `:h=`
        return vec4(outputValue.x);
      `;else if(i.length){const w=o-2,b=o-1;i.indexOf(w)>-1&&i.indexOf(b)>-1?h="return vec4(outputValue.x);":i.indexOf(w)>-1?h="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":i.indexOf(b)>-1&&(h="return vec4(outputValue.xx, outputValue.zz);")}return`
    vec4 ${r}() {
      ${l} coords = getOutputCoords();
      ${c}
      vec4 outputValue = get${s}(${f});
      ${h}
    }
  `}function Q4t(t,e){const n=t.name,s=n.charAt(0).toUpperCase()+n.slice(1),r="get"+s+"AtOutCoords",o=e.texShape,a=t.shapeInfo.texShape,i=t.shapeInfo.logicalShape.length,l=e.logicalShape.length;if(!t.shapeInfo.isUniform&&i===l&&t.shapeInfo.flatOffset==null&&hn(a,o))return`
      float ${r}() {
        return sampleTexture(${n}, resultUV);
      }
    `;const u=jn(l),c=BG(t.shapeInfo.logicalShape,e.logicalShape),d=l-i;let f;const h=["x","y","z","w","u","v"];i===0?f="":l<2&&c.length>=1?f="coords = 0;":f=c.map(m=>`coords.${h[m+d]} = 0;`).join(`
`);let p="";return l<2&&i>0?p="coords":p=t.shapeInfo.logicalShape.map((m,g)=>`coords.${h[g+d]}`).join(", "),`
    float ${r}() {
      ${u} coords = getOutputCoords();
      ${f}
      return get${s}(${p});
    }
  `}function jn(t){if(t<=1)return"int";if(t===2)return"ivec2";if(t===3)return"ivec3";if(t===4)return"ivec4";if(t===5)return"ivec5";if(t===6)return"ivec6";throw Error(`GPU for rank ${t} is not yet supported`)}function EI(t,e,n){const{newShape:s,keptDims:r}=Kl(e),o=e.length,a=t&&o===3&&e[0]===1,i=a?e.slice(1):s,l=!t&&o>1&&!hn(e,n)&&s.length<o||a;return{useSqueezeShape:l,uniformShape:l?i:e,keptDims:r}}function gm(t,e){const n=JSON.parse(JSON.stringify(t));return n.shapeInfo.logicalShape=e,n}function vm(t,e){return e.map(n=>t[n]).join(", ")}function e$t(t,e,n,s){const r=n.map((c,d)=>{const f={logicalShape:c.shape,texShape:c.isUniform?null:c.texData.texShape,isUniform:c.isUniform,isPacked:c.isUniform?!1:c.texData.isPacked,flatOffset:null};return c.texData!=null&&c.texData.slice!=null&&c.texData.slice.flatOffset>0&&(f.flatOffset=c.texData.slice.flatOffset),{name:e.variableNames[d],shapeInfo:f}}),o=r.map(c=>c.shapeInfo),a={logicalShape:s.shape,texShape:s.texData.texShape,isUniform:!1,isPacked:s.texData.isPacked,flatOffset:null},i=y4t(r,a,e),l=K3t(t.gl,i),u=t.createProgram(l);return Be().get("ENGINE_COMPILE_ONLY")?{program:e,fragmentShader:l,source:i,webGLProgram:u,inShapeInfos:o,outShapeInfo:a,uniformLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,inShapesLocations:null,inTexShapesLocations:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:Object.assign({program:e,fragmentShader:l,source:i,webGLProgram:u,inShapeInfos:o,outShapeInfo:a},WG(t,e,u))}function WG(t,e,n){const s={},r={},o={},a=[];let i,l,u,c=null,d=null;d=t.getUniformLocation(n,"NAN",!1),Be().getNumber("WEBGL_VERSION")===1&&(c=t.getUniformLocation(n,"INFINITY",!1));const f=!1;for(let h=0;h<e.variableNames.length;h++){const p=e.variableNames[h];s[p]=t.getUniformLocation(n,p,f),s[`offset${p}`]=t.getUniformLocation(n,`offset${p}`,f),e.enableShapeUniforms&&(r[`${p}Shape`]=t.getUniformLocation(n,`${p}Shape`,f),o[`${p}TexShape`]=t.getUniformLocation(n,`${p}TexShape`,f))}return e.enableShapeUniforms&&(i=t.getUniformLocation(n,"outShape",f),u=t.getUniformLocation(n,"outShapeStrides",f),l=t.getUniformLocation(n,"outTexShape",f)),e.customUniforms&&e.customUniforms.forEach((h,p)=>{a[p]=t.getUniformLocation(n,h.name,f)}),{uniformLocations:s,customUniformLocations:a,infLoc:c,nanLoc:d,inShapesLocations:r,inTexShapesLocations:o,outShapeLocation:i,outShapeStridesLocation:u,outTexShapeLocation:l}}function qD(t,e){if(t.length!==e.length)throw Error(`Binary was compiled with ${t.length} inputs, but was executed with ${e.length} inputs`);t.forEach((n,s)=>{const r=n.logicalShape,o=e[s],a=o.shape;if(!hn(r,a))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${r} and ${a} must match`);if(n.isUniform&&o.isUniform)return;const i=n.texShape,l=o.isUniform?null:o.texData.texShape;if(!hn(i,l))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${i} and ${l} must match`)})}function t$t(t,e,n,s,r){e.program.enableShapeUniforms||(qD(e.inShapeInfos,n),qD([e.outShapeInfo],[s]));const o=s.texData.texture,a=s.texData.texShape;s.texData.isPacked?t.setOutputPackedMatrixTexture(o.texture,a[0],a[1]):t.setOutputMatrixTexture(o.texture,a[0],a[1]),t.setProgram(e.webGLProgram),Be().getNumber("WEBGL_VERSION")===1&&e.infLoc!==null&&t.gl.uniform1f(e.infLoc,1/0),e.nanLoc!==null&&t.gl.uniform1f(e.nanLoc,NaN),n.forEach((l,u)=>{const c=e.program.variableNames[u],d=e.uniformLocations[c],f=e.uniformLocations[`offset${c}`],h=e.inShapesLocations[`${c}Shape`],p=e.inTexShapesLocations[`${c}TexShape`];if(h){const{uniformShape:m}=EI(e.program.packedInputs,l.shape,l.texData.texShape);switch(m.length){case 1:t.gl.uniform1iv(h,new Int32Array(m));break;case 2:t.gl.uniform2iv(h,new Int32Array(m));break;case 3:t.gl.uniform3iv(h,new Int32Array(m));break;case 4:t.gl.uniform4iv(h,new Int32Array(m));break}}if(p&&t.gl.uniform2i(p,l.texData.texShape[0],l.texData.texShape[1]),d!=null){if(l.isUniform){if(Ge(l.shape)<2)t.gl.uniform1f(d,l.uniformValues[0]);else{let m=l.uniformValues;m instanceof Float32Array||(m=new Float32Array(m)),t.gl.uniform1fv(d,m)}return}l.texData.slice!=null&&f!=null&&t.gl.uniform1i(f,l.texData.slice.flatOffset),t.setInputMatrixTexture(l.texData.texture.texture,d,u)}});const i=e.outShapeLocation;if(i)switch(s.shape.length){case 1:t.gl.uniform1iv(i,new Int32Array(s.shape));break;case 2:t.gl.uniform2iv(i,new Int32Array(s.shape));break;case 3:t.gl.uniform3iv(i,new Int32Array(s.shape));break;case 4:t.gl.uniform4iv(i,new Int32Array(s.shape));break}if(e.outShapeStridesLocation){const l=Mt(s.shape);switch(s.shape.length){case 2:t.gl.uniform1iv(e.outShapeStridesLocation,new Int32Array(l));break;case 3:t.gl.uniform2iv(e.outShapeStridesLocation,new Int32Array(l));break;case 4:t.gl.uniform3iv(e.outShapeStridesLocation,new Int32Array(l));break}}e.outTexShapeLocation&&t.gl.uniform2i(e.outTexShapeLocation,s.texData.texShape[0],s.texData.texShape[1]),e.program.customUniforms&&r&&e.program.customUniforms.forEach((l,u)=>{const c=e.customUniformLocations[u],d=r[u];if(l.type==="float")t.gl.uniform1fv(c,d);else if(l.type==="vec2")t.gl.uniform2fv(c,d);else if(l.type==="vec3")t.gl.uniform3fv(c,d);else if(l.type==="vec4")t.gl.uniform4fv(c,d);else if(l.type==="int")t.gl.uniform1iv(c,d);else if(l.type==="ivec2")t.gl.uniform2iv(c,d);else if(l.type==="ivec3")t.gl.uniform3iv(c,d);else if(l.type==="ivec4")t.gl.uniform4iv(c,d);else throw Error(`uniform type ${l.type} is not supported yet.`)}),t.executeProgram()}function n$t(t,e,n){let s="";e.concat(n).forEach(a=>{const i=a.texData!=null&&a.texData.slice!=null&&a.texData.slice.flatOffset>0;if(t.enableShapeUniforms&&!a.isUniform){const l=a.texData.texShape,{useSqueezeShape:u,uniformShape:c,keptDims:d}=EI(t.packedInputs,a.shape,l);let f="",h="",p="";if(c.length===1&&t.packedInputs){const $=[Math.ceil(l[0]/2),Math.ceil(l[1]/2)];f=`${$[0]>1}_${$[1]>1}`}else if(c.length===2&&!t.packedInputs)h=`${c[0]>1}_${c[1]>1}`;else if(c.length>2&&!t.packedInputs){const $=Mt(c);p=`${$[0]===l[1]}_${$[$.length-1]===l[1]}`}const m=a.shape.length,g=c.length===2&&hn(a.shape,l),y=Ge(a.shape)===1,w=Ad(a.shape,n.shape),b=!t.packedInputs&&m===n.shape.length&&hn(l,n.texData.texShape),_=t.packedInputs||c.length>2?"":`${l[0]>1}_${l[1]>1}`;s+=`${m}_${b}_${u?d:""}_${c.length}_${y}_${w}_${g}_${f}_${h}_${p}_${_}_${i}`}else{const l=a.isUniform?"uniform":a.texData.texShape;s+=`${a.shape}_${l}_${i}`}});const r=t.userCode;let o=t.constructor.name;return o+="_"+s+"_"+r+`${Be().getNumber("WEBGL_VERSION")}`,o}function zr(t){return Be().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&t<=4}class s$t{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=lg.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const n=Lr();this.outputShape=e,this.enableShapeUniforms=zr(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?Q3(["r","c","d"],e):hf(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getA(rc.x, rc.y, rc.z);
        }

        ${n.output} = result;
      }
    `}}class r$t{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=lg.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const n=Lr();this.outputShape=e,this.enableShapeUniforms=zr(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?Q3(["r","c","d"],e):hf(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));
        }

        ${n.output} = result;
      }
    `}}class o$t{constructor(e){this.variableNames=["A"],this.outTexUsage=zo.DOWNLOAD;const n=Lr();this.outputShape=e,this.userCode=`
      ${zG}

      void main() {
        float x = getAAtOutCoords();
        ${n.output} = encode_float(x);
      }
    `}}class a$t{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=zo.DOWNLOAD;const n=Lr();this.outputShape=e,this.userCode=`
      ${zG}

      void main() {
        ivec3 coords = getOutputCoords();
        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));
        ${n.output} = encode_float(x);
      }
    `}}const i$t={R:0,G:1,B:2,A:3};class XD{constructor(e,n=!1,s="RGBA"){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];const r=Lr();this.outputShape=e,this.enableShapeUniforms=zr(this.outputShape.length);let o="result";n&&(o="floor(result * 255. + 0.5)");let a="";for(let i=0;i<s.length;i++){const l=s[i];a+=`
          if(offset == ${i}) {
            result = values[${i$t[l]}];
          }`}this.userCode=`
      ${this.enableShapeUniforms?II():NI(e)}

      void main() {
        ivec3 coords = getOutputCoords();
        int flatIndex = getFlatIndex(coords);
        float result = 0.;
        int offset = imod(flatIndex, ${s.length});

        flatIndex = idiv(flatIndex, ${s.length}, 1.);

        int r = flatIndex / texShape[1];
        if (r < texShape[0]) {
          int c = imod(flatIndex, texShape[1]);
          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
          vec4 values = ${r.texture2D}(A, uv);
          ${a}
        }
        ${r.output} = vec4(${o}, 0., 0., 0.);
      }
    `}}class l$t{constructor(e,n=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];const s=Lr();this.outputShape=e,this.enableShapeUniforms=zr(this.outputShape.length);let r="",o="result";n&&(o="floor(result * 255. + 0.5)");for(let a=0;a<=1;a++)for(let i=0;i<=1;i++){const l=a*2+i;r+=`
          localCoords = coords;
          if(localCoords[2] + ${i} < ${this.enableShapeUniforms?"outShape[2]":`${e[2]}`}) {
          localCoords[2] += ${i};
          if (localCoords[1] + ${a} < ${this.enableShapeUniforms?"outShape[1]":`${e[1]}`}) {
            localCoords[1] += ${a};

            flatIndex = getFlatIndex(localCoords);
            offset = imod(flatIndex, 4);

            flatIndex = idiv(flatIndex, 4, 1.);

            int r = flatIndex / texShape[1];
            int c = imod(flatIndex, texShape[1]);
            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
            values = ${s.texture2D}(A, uv);

            if (offset == 0) {
              result[${l}] = values[0];
            } else if (offset == 1) {
              result[${l}] = values[1];
            } else if (offset == 2) {
              result[${l}] = values[2];
            } else {
              result[${l}] = values[3];
            }
          }
        }
        `}this.userCode=`
        ${this.enableShapeUniforms?II():NI(e)}

        void main() {
          ivec3 coords = getOutputCoords();

          vec4 result = vec4(0.);
          int flatIndex, r, c, offset;
          ivec3 localCoords;
          vec2 uv;
          vec4 values;

          ${r}

          ${s.output} = ${o};
        }
    `}}function u$t(t){const e=Lr(),n=`${e.version}
    precision highp float;
    ${e.attribute} vec3 clipSpacePos;
    ${e.attribute} vec2 uv;
    ${e.varyingVs} vec2 resultUV;

    void main() {
      gl_Position = vec4(clipSpacePos, 1);
      resultUV = uv;
    }`;return j3t(t,n)}function c$t(t){const e=new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]);return Z3t(t,e)}function d$t(t){const e=new Uint16Array([0,1,2,2,1,3]);return J3t(t,e)}function C2(t,e,n,s,r,o){e4t(e,n);const a=Q3t(t),i=t.TEXTURE_2D;return _t(t,()=>t.bindTexture(i,a)),_t(t,()=>t.texParameteri(i,t.TEXTURE_WRAP_S,t.CLAMP_TO_EDGE)),_t(t,()=>t.texParameteri(i,t.TEXTURE_WRAP_T,t.CLAMP_TO_EDGE)),_t(t,()=>t.texParameteri(i,t.TEXTURE_MIN_FILTER,t.NEAREST)),_t(t,()=>t.texParameteri(i,t.TEXTURE_MAG_FILTER,t.NEAREST)),Be().getNumber("WEBGL_VERSION")===1?_t(t,()=>t.texImage2D(i,0,s,e,n,0,r,o,null)):_t(t,()=>t.texStorage2D(i,1,s,e,n)),_t(t,()=>t.bindTexture(t.TEXTURE_2D,null)),{texture:a,texShape:[n,e]}}function UG(t){return t.internalFormatFloat}function f$t(t,e,n,s){const[r,o]=x2(e,n);return C2(t,r,o,UG(s),s.textureFormatFloat,t.FLOAT)}function GG(t){return t.internalFormatHalfFloat}function h$t(t,e,n,s){const[r,o]=x2(e,n);return C2(t,r,o,GG(s),s.textureFormatFloat,s.textureTypeHalfFloat)}function jG(t){return t.downloadTextureFormat}function p$t(t,e,n,s){const[r,o]=x2(e,n);return C2(t,r,o,jG(s),t.RGBA,t.UNSIGNED_BYTE)}function KG(t){return t.internalFormatPackedFloat}function m$t(t,e,n,s){const[r,o]=hm(e,n);return C2(t,r,o,KG(s),t.RGBA,t.FLOAT)}function qG(t){return t.internalFormatPackedHalfFloat}function g$t(t,e,n,s){const[r,o]=hm(e,n);return C2(t,r,o,qG(s),t.RGBA,s.textureTypeHalfFloat)}function v$t(t,e,n){return _t(t,()=>t.bindBuffer(t.ARRAY_BUFFER,n)),GD(t,e,"clipSpacePos",n,3,20,0)&&GD(t,e,"uv",n,2,20,12)}function y$t(t,e,n,s,r,o){_t(t,()=>t.bindTexture(t.TEXTURE_2D,e));let a,i,l;r instanceof Uint8Array?(a=new Uint8Array(n*s*4),i=t.UNSIGNED_BYTE,l=t.RGBA):(a=new Float32Array(n*s*4),i=t.FLOAT,l=o.internalFormatPackedFloat),a.set(r),Be().getNumber("WEBGL_VERSION")===2?_t(t,()=>t.texSubImage2D(t.TEXTURE_2D,0,0,0,n,s,t.RGBA,i,a)):_t(t,()=>t.texImage2D(t.TEXTURE_2D,0,l,n,s,0,t.RGBA,i,a)),_t(t,()=>t.bindTexture(t.TEXTURE_2D,null))}function b$t(t,e,n){_t(t,()=>t.bindTexture(t.TEXTURE_2D,e)),n.data instanceof Uint8Array?Be().getNumber("WEBGL_VERSION")===2?_t(t,()=>t.texSubImage2D(t.TEXTURE_2D,0,0,0,n.width,n.height,t.RGBA,t.UNSIGNED_BYTE,n.data)):_t(t,()=>t.texImage2D(t.TEXTURE_2D,0,t.RGBA,n.width,n.height,0,t.RGBA,t.UNSIGNED_BYTE,n.data)):Be().getNumber("WEBGL_VERSION")===2?_t(t,()=>t.texSubImage2D(t.TEXTURE_2D,0,0,0,t.RGBA,t.UNSIGNED_BYTE,n)):_t(t,()=>t.texImage2D(t.TEXTURE_2D,0,t.RGBA,t.RGBA,t.UNSIGNED_BYTE,n)),_t(t,()=>t.bindTexture(t.TEXTURE_2D,null))}function w$t(t,e,n,s){const r=t.createBuffer();_t(t,()=>t.bindBuffer(t.PIXEL_PACK_BUFFER,r));const i=4*4*e*n;return _t(t,()=>t.bufferData(t.PIXEL_PACK_BUFFER,i,t.STREAM_READ)),_t(t,()=>t.readPixels(0,0,n,e,t.RGBA,t.FLOAT,0)),_t(t,()=>t.bindBuffer(t.PIXEL_PACK_BUFFER,null)),r}function _$t(t,e,n){const s=t,r=new Float32Array(n);return s.bindBuffer(s.PIXEL_PACK_BUFFER,e),s.getBufferSubData(s.PIXEL_PACK_BUFFER,0,r),s.bindBuffer(s.PIXEL_PACK_BUFFER,null),r}function $$t(t,e,n,s){const[r,o]=x2(e,n),a=4,i=new Uint8Array(z3t(e*n,a));return _t(t,()=>t.readPixels(0,0,r,o,s.downloadTextureFormat,t.UNSIGNED_BYTE,i)),new Float32Array(i.buffer)}function x$t(t,e,n,s,r,o,a,i){const l=t,u=new Float32Array(B3t(o,a));return l.bindBuffer(l.PIXEL_PACK_BUFFER,e),l.getBufferSubData(l.PIXEL_PACK_BUFFER,0,u),l.bindBuffer(l.PIXEL_PACK_BUFFER,null),u}function S$t(t,e,n){const s=new Float32Array(e*n*4);return _t(t,()=>t.readPixels(0,0,n,e,t.RGBA,t.FLOAT,s)),s}class A${constructor(e){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];const n=Be().getNumber("WEBGL_VERSION");if(e!=null?(this.gl=e,M3t(n,e)):this.gl=si(n),e=this.gl,Be().getNumber("WEBGL_VERSION")===2){const o=e;this.createVertexArray=()=>_t(o,()=>o.createVertexArray()),this.bindVertexArray=a=>_t(o,()=>o.bindVertexArray(a)),this.deleteVertexArray=a=>_t(o,()=>o.deleteVertexArray(a)),this.getVertexArray=()=>_t(o,()=>o.getParameter(o.VERTEX_ARRAY_BINDING))}else if(e!=null){const o=e.getExtension("OES_vertex_array_object");if(o==null)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>_t(e,()=>o.createVertexArrayOES()),this.bindVertexArray=a=>_t(e,()=>o.bindVertexArrayOES(a)),this.deleteVertexArray=a=>_t(e,()=>o.deleteVertexArrayOES(a)),this.getVertexArray=()=>_t(e,()=>e.getParameter(o.VERTEX_ARRAY_BINDING_OES))}let s="WEBGL_color_buffer_float";const r="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),Be().getNumber("WEBGL_VERSION")===1){const o="OES_texture_float",a="OES_texture_half_float";if(this.textureFloatExtension=Cv(this.gl,o),ma(this.gl,a))this.textureHalfFloatExtension=Cv(this.gl,a);else if(Be().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(s),ma(this.gl,r))this.colorBufferHalfFloatExtension=Cv(this.gl,r);else if(Be().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(s="EXT_color_buffer_float",ma(this.gl,s))this.colorBufferFloatExtension=this.gl.getExtension(s);else if(ma(this.gl,r))this.colorBufferHalfFloatExtension=this.gl.getExtension(r);else throw new Error("GL context does not support color renderable floats");this.vertexBuffer=c$t(this.gl),this.indexBuffer=d$t(this.gl),this.framebuffer=t4t(this.gl),this.textureConfig=TI(this.gl,this.textureHalfFloatExtension)}get debug(){return Be().getBool("DEBUG")}dispose(){if(this.disposed)return;this.program!=null&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),this.outputTexture!=null&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const e=this.gl;_t(e,()=>e.finish()),_t(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,null)),_t(e,()=>e.deleteFramebuffer(this.framebuffer)),_t(e,()=>e.bindBuffer(e.ARRAY_BUFFER,null)),_t(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null)),_t(e,()=>e.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(e,n){return this.throwIfDisposed(),f$t(this.gl,e,n,this.textureConfig)}createFloat16MatrixTexture(e,n){return this.throwIfDisposed(),h$t(this.gl,e,n,this.textureConfig)}createUnsignedBytesMatrixTexture(e,n){return this.throwIfDisposed(),p$t(this.gl,e,n,this.textureConfig)}uploadPixelDataToTexture(e,n){this.throwIfDisposed(),b$t(this.gl,e,n)}uploadDenseMatrixToTexture(e,n,s,r){this.throwIfDisposed(),y$t(this.gl,e,n,s,r,this.textureConfig)}createFloat16PackedMatrixTexture(e,n){return this.throwIfDisposed(),g$t(this.gl,e,n,this.textureConfig)}createPackedMatrixTexture(e,n){return this.throwIfDisposed(),m$t(this.gl,e,n,this.textureConfig)}deleteMatrixTexture(e){this.throwIfDisposed(),this.outputTexture===e&&(jD(this.gl,this.framebuffer),this.outputTexture=null),_t(this.gl,()=>this.gl.deleteTexture(e))}downloadByteEncodedFloatMatrixFromOutputTexture(e,n,s){return this.downloadMatrixDriver(e,()=>$$t(this.gl,n,s,this.textureConfig))}downloadPackedMatrixFromBuffer(e,n,s,r,o,a){return x$t(this.gl,e,n,s,r,o,a,this.textureConfig)}downloadFloat32MatrixFromBuffer(e,n){return _$t(this.gl,e,n)}createBufferFromTexture(e,n,s){this.bindTextureToFrameBuffer(e);const r=w$t(this.gl,n,s,this.textureConfig);return this.unbindTextureToFrameBuffer(),r}createAndWaitForFence(){const e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let n,s;if(Be().getBool("WEBGL_FENCE_API_ENABLED")){const r=e,o=r.fenceSync(r.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),s=()=>{const a=r.clientWaitSync(o,0,0);return a===r.ALREADY_SIGNALED||a===r.CONDITION_SATISFIED},n=o}else Be().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(n=this.beginQuery(),this.endQuery(),s=()=>this.isQueryAvailable(n,Be().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):s=()=>!0;return{query:n,isFencePassed:s}}downloadMatrixFromPackedTexture(e,n,s){return this.downloadMatrixDriver(e,()=>S$t(this.gl,n,s))}createProgram(e){this.throwIfDisposed();const n=this.gl;this.vertexShader==null&&(this.vertexShader=u$t(n));const s=X3t(n);_t(n,()=>n.attachShader(s,this.vertexShader)),_t(n,()=>n.attachShader(s,e)),Y3t(n,s);let r;return r=Object.assign(s,{vao:this.createVertexArray()}),this.bindVertexArray(r.vao),_t(n,()=>n.bindBuffer(n.ELEMENT_ARRAY_BUFFER,this.indexBuffer)),console.assert(v$t(n,r,this.vertexBuffer),"gpgpu_util.bindVertexProgramAttributeStreams not fully successful."),this.debug&&T$(n,r),this.setProgram(r),r}deleteProgram(e){this.throwIfDisposed(),e===this.program&&(this.program=null),e!=null&&(_t(this.gl,()=>this.gl.deleteProgram(e)),this.deleteVertexArray(e.vao))}setProgram(e){this.throwIfDisposed(),this.program=e,this.program!=null&&(this.bindVertexArray(this.program.vao),this.debug&&T$(this.gl,this.program)),_t(this.gl,()=>this.gl.useProgram(e))}getUniformLocation(e,n,s=!0){return this.throwIfDisposed(),s?s4t(this.gl,e,n):r4t(this.gl,e,n)}getAttributeLocation(e,n){return this.throwIfDisposed(),_t(this.gl,()=>this.gl.getAttribLocation(e,n))}getUniformLocationNoThrow(e,n){return this.throwIfDisposed(),this.gl.getUniformLocation(e,n)}setInputMatrixTexture(e,n,s){this.throwIfDisposed(),this.throwIfNoProgram(),o4t(this.gl,e,n,s)}setOutputMatrixTexture(e,n,s){this.setOutputMatrixTextureDriver(e,s,n)}setOutputPackedMatrixTexture(e,n,s){this.throwIfDisposed();const[r,o]=hm(n,s);this.setOutputMatrixTextureDriver(e,r,o)}setOutputMatrixWriteRegion(e,n,s,r){this.setOutputMatrixWriteRegionDriver(s,e,r,n)}setOutputPackedMatrixWriteRegion(e,n,s,r){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){this.program!=null&&T$(this.gl,this.program),kv(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const e=this.gl;if(this.debug){const n=this.getVertexArray();console.assert(n===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}_t(e,()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),_t(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return this.disjointQueryTimerExtension==null&&(this.disjointQueryTimerExtension=Cv(this.gl,Be().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(Be().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const s=this.gl,r=this.getQueryTimerExtensionWebGL2(),o=s.createQuery();return s.beginQuery(r.TIME_ELAPSED_EXT,o),o}const e=this.getQueryTimerExtensionWebGL1(),n=e.createQueryEXT();return e.beginQueryEXT(e.TIME_ELAPSED_EXT,n),n}endQuery(){if(Be().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const n=this.gl,s=this.getQueryTimerExtensionWebGL2();n.endQuery(s.TIME_ELAPSED_EXT);return}const e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(e){return await lx(()=>this.disposed||this.isQueryAvailable(e,Be().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),this.getQueryTime(e,Be().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(e,n){if(n===0)return null;if(n===2){const s=this.gl;return s.getQueryParameter(e,s.QUERY_RESULT)/1e6}else{const s=this.getQueryTimerExtensionWebGL1();return s.getQueryObjectEXT(e,s.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(e,n){if(n===0)return!0;if(n===2){const s=this.gl,r=this.getQueryTimerExtensionWebGL2(),o=s.getQueryParameter(e,s.QUERY_RESULT_AVAILABLE);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(r.GPU_DISJOINT_EXT)),o&&!this.disjoint}else{const s=this.getQueryTimerExtensionWebGL1(),r=s.getQueryObjectEXT(e,s.QUERY_RESULT_AVAILABLE_EXT);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(s.GPU_DISJOINT_EXT)),r&&!this.disjoint}}pollFence(e){return new Promise(n=>{this.addItemToPoll(()=>e.isFencePassed(),()=>n())})}pollItems(){const e=C$t(this.itemsToPoll.map(n=>n.isDoneFn));for(let n=0;n<=e;++n){const{resolveFn:s}=this.itemsToPoll[n];s()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}addItemToPoll(e,n){if(this.itemsToPoll.push({isDoneFn:e,resolveFn:n}),this.itemsToPoll.length>1)return;let s;"setTimeoutCustom"in Be().platform&&(s=Be().platform.setTimeoutCustom.bind(Be().platform)),lx(()=>(this.pollItems(),this.itemsToPoll.length===0),()=>0,null,s)}bindTextureToFrameBuffer(e){this.throwIfDisposed(),N$(this.gl,e,this.framebuffer),this.debug&&kv(this.gl)}unbindTextureToFrameBuffer(){this.outputTexture!=null?(N$(this.gl,this.outputTexture,this.framebuffer),this.debug&&kv(this.gl)):jD(this.gl,this.framebuffer)}downloadMatrixDriver(e,n){this.bindTextureToFrameBuffer(e);const s=n();return this.unbindTextureToFrameBuffer(),s}setOutputMatrixTextureDriver(e,n,s){this.throwIfDisposed();const r=this.gl;N$(r,e,this.framebuffer),this.debug&&kv(r),this.outputTexture=e,_t(r,()=>r.viewport(0,0,n,s)),_t(r,()=>r.scissor(0,0,n,s))}setOutputMatrixWriteRegionDriver(e,n,s,r){this.throwIfDisposed(),_t(this.gl,()=>this.gl.scissor(e,n,s,r))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(this.program==null)throw new Error("No GPU program is currently set.")}}function C$t(t){let e=0;for(;e<t.length&&t[e]();++e);return e-1}const{addImpl:k$t,bincountImpl:XG,bincountReduceImpl:T$t,castImpl:N$t,ceilImpl:I$t,concatImpl:E$t,equalImpl:A$t,expImpl:O$t,expm1Impl:R$t,floorImpl:D$t,gatherNdImpl:F$t,gatherV2Impl:M$t,greaterImpl:P$t,greaterEqualImpl:L$t,lessImpl:z$t,lessEqualImpl:B$t,linSpaceImpl:V$t,logImpl:H$t,maxImpl:W$t,maximumImpl:U$t,minimumImpl:G$t,multiplyImpl:j$t,negImpl:K$t,notEqualImpl:q$t,prodImpl:X$t,raggedGatherImpl:Y$t,raggedRangeImpl:Z$t,raggedTensorToTensorImpl:J$t,rangeImpl:Q$t,rsqrtImpl:e6t,scatterImpl:t6t,sigmoidImpl:n6t,simpleAbsImpl:YG,sliceImpl:s6t,sparseFillEmptyRowsImpl:r6t,sparseReshapeImpl:o6t,sparseSegmentReductionImpl:ZG,sqrtImpl:a6t,stridedSliceImpl:i6t,stringNGramsImpl:l6t,stringSplitImpl:u6t,stringToHashBucketFastImpl:c6t,subImpl:d6t,tileImpl:f6t,topKImpl:h6t,transposeImpl:AI,uniqueImpl:p6t}=bvt;function JG(t,e){return["x","y","z","w","u","v"].slice(0,e).map(n=>`${t}.${n}`)}function Ir(t,e){return e===1?[t]:JG(t,e)}function m6t(t,e){if(t===1)return"rc";let n="";for(let s=0;s<t;s++)n+=e[s],s<t-1&&(n+=",");return n}class g6t{constructor(e){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.enableShapeUniforms=zr(this.outputShape.length),this.rank===0)this.userCode=`
        void main() {
          setOutput(vec4(getA(), 0., 0., 0.));
        }
      `;else{const n=Ir("rc",this.rank),s=jn(this.rank),r=this.getOutOfBoundsCondition(n),o=this.getSetup(n),a=this.getOutput(n);this.userCode=`
        void main() {
          ${s} rc = getOutputCoords();

          if(${r}) {
            setOutput(vec4(0));
          } else {
            ${o}

            setOutput(vec4(${a}));
          }
        }
      `}}getSourceCoordsArr(e){const n=[];for(let s=0;s<=1;s++)for(let r=0;r<=1;r++){let o=`${s===0?"r":"rp1"}, ${r===0?"c":"cp1"}`;for(let a=2;a<this.rank;a++)o=`${e[e.length-1-a]},`+o;n.push(o)}return n}getOutOfBoundsCondition(e){if(this.rank===1)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let n="";for(let s=this.rank-2;s<this.rank;s++)n+=`${e[s]} >= ${this.enableShapeUniforms?`outShape[${s}]`:this.outputShape[s]}`,s<this.rank-1&&(n+="||");return n}getSetup(e){if(this.rank===1)return"";const n=e.slice(-2),s=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1],r=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`
      int r = ${n[0]};
      int c = ${n[1]};
      int rp1 = r + 1;
      int cp1 = c + 1;

      bool cEdge = cp1 >= ${s};
      bool rEdge = rp1 >= ${r};
    `}getOutput(e){const n=this.getSourceCoordsArr(e);return this.rank===1?`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`:`getA(${n[0]}),
            cEdge ? 0. : getA(${n[1]}),
            rEdge ? 0. : getA(${n[2]}),
            rEdge || cEdge ? 0. : getA(${n[3]})`}}class QG{constructor(e,n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=e,this.enableShapeUniforms=zr(this.outputShape.length);let s="";for(let r=0;r<4;r++){let o="thisRC = rc;";r%2===1&&(o+="thisRC.z += 1;"),r>1&&(o+="thisRC.y += 1;"),s+=`
        ${o}
        ${r>0?"if(thisRC.y < rows && thisRC.z < cols){":""}
          int flatIndex = getFlatIndex(thisRC);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);
          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${r}] =
            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);
        ${r>0?"}":""}
      `}this.userCode=`
      ${v6t(n,this.enableShapeUniforms)}
      ${this.enableShapeUniforms?II():NI(e)}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.);

        ivec3 thisRC;
        int rows = ${this.enableShapeUniforms?"outShape[1]":e[1]};
        int cols = ${this.enableShapeUniforms?"outShape[2]":e[2]};

        ${s}

        setOutput(result);
      }
    `}}function v6t(t,e){return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${e?v4t(["r","c","d"],"inputShape"):hf(["r","c","d"],t)}
      return ivec3(r, c, d);
    }
  `}class y6t{constructor(e){this.gpgpu=e,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.logEnabled=!1,this.usedTextures={}}acquireTexture(e,n,s){const r=ZD(n,s),o=JD(e,r,s);o in this.freeTextures||(this.freeTextures[o]=[]),o in this.usedTextures||(this.usedTextures[o]=[]);const a=YD(e,r,this.gpgpu.gl,this.gpgpu.textureConfig,s);if(this.freeTextures[o].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=a,this.log();const l=this.freeTextures[o].shift();return this.usedTextures[o].push(l),l}let i;return r===Qs.PACKED_2X2_FLOAT32?i=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):r===Qs.PACKED_2X2_FLOAT16?i=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):r===Qs.UNPACKED_FLOAT32?i=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):r===Qs.UNPACKED_FLOAT16?i=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):r===Qs.PACKED_4X1_UNSIGNED_BYTE&&(i=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[o].push(i),this.numUsedTextures++,this._numBytesAllocated+=a,this.log(),i}releaseTexture(e,n,s,r){if(this.freeTextures==null)return;const o=ZD(s,r),a=JD(n,o,r);a in this.freeTextures||(this.freeTextures[a]=[]);const i=YD(n,o,this.gpgpu.gl,this.gpgpu.textureConfig,r),l=Be().get("WEBGL_DELETE_TEXTURE_THRESHOLD");l!==-1&&this._numBytesAllocated>l?(this.gpgpu.deleteMatrixTexture(e.texture),this._numBytesAllocated-=i):(this.freeTextures[a].push(e),this.numFreeTextures++,this._numBytesFree+=i),this.numUsedTextures--;const u=this.usedTextures[a],c=u.indexOf(e);if(c<0)throw new Error("Cannot release a texture that was never provided by this texture manager");u.splice(c,1),this.log()}log(){if(!this.logEnabled)return;const e=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${e})`);const n=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*n)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(this.freeTextures!=null){for(const e in this.freeTextures)this.freeTextures[e].forEach(n=>{this.gpgpu.deleteMatrixTexture(n.texture)});for(const e in this.usedTextures)this.usedTextures[e].forEach(n=>{this.gpgpu.deleteMatrixTexture(n.texture)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function b6t(t,e){const n=t;if(e===n.R32F)return 4;if(e===n.R16F)return 2;if(e===n.RGBA32F)return 16;if(e===t.RGBA)return 16;if(e===n.RGBA16F)return 8;if(e===n.RGBA8)return 4;throw new Error(`Unknown internal format ${e}`)}function YD(t,e,n,s,r){const o=w6t(e,s);let a;if(r){const[l,u]=hm(t[0],t[1]);a=l*u}else{const[l,u]=x2(t[0],t[1]);a=l*u}const i=b6t(n,o);return a*i}function w6t(t,e){switch(t){case Qs.PACKED_2X2_FLOAT32:return KG(e);case Qs.PACKED_2X2_FLOAT16:return qG(e);case Qs.UNPACKED_FLOAT32:return UG(e);case Qs.UNPACKED_FLOAT16:return GG(e);case Qs.PACKED_4X1_UNSIGNED_BYTE:return jG(e);default:throw new Error(`Unknown physical texture type ${t}`)}}function _6t(t){return Be().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?t?Qs.PACKED_2X2_FLOAT32:Qs.UNPACKED_FLOAT32:t?Qs.PACKED_2X2_FLOAT16:Qs.UNPACKED_FLOAT16}function ZD(t,e){if(t===zo.UPLOAD)return Qs.PACKED_2X2_FLOAT32;if(t===zo.RENDER||t==null)return _6t(e);if(t===zo.DOWNLOAD||t===zo.PIXELS)return Qs.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${t}`)}function JD(t,e,n){return`${t[0]}_${t[1]}_${e}_${n}`}class Ni{constructor(e,n){this.variableNames=["A"],this.outputShape=e,this.enableShapeUniforms=zr(this.outputShape.length),this.userCode=`
      float unaryOperation(float x) {
        ${n}
      }

      void main() {
        float x = getAAtOutCoords();
        float y = unaryOperation(x);

        setOutput(y);
      }
    `}}const Ea="if (isnan(x)) return x;",$6t="return x;",QD="return abs(x);",x6t="return (x >= 0.0) ? x : (exp(x) - 1.0);",S6t=Ea+`
  return (x < 0.0) ? 0.0 : x;
`,C6t=Ea+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,bu="return x;",k6t="return 1.0 / (1.0 + exp(-1.0 * x));";const T6t="return x;",N6t=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,I6t=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,E6t=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,A6t="return 1.0 / (1.0 + exp(-1.0 * x));";class Nu{constructor(e,n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.enableShapeUniforms=zr(this.outputShape.length),this.userCode=`
      vec4 unaryOperation(vec4 x) {
        ${n}
      }

      void main() {
        vec4 x = getAAtOutCoords();
        vec4 y = unaryOperation(x);

        setOutput(y);
      }
    `}}class O6t{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=e,this.enableShapeUniforms=zr(this.outputShape.length);const n=e.length,s=Ir("rc",n),r=jn(n),o=m6t(n,s),a=s.slice(-2),i=n<=1?"rc":`vec2(${a.join(",")})`;this.userCode=`
      void main() {
        ${r} rc = getOutputCoords();
        vec4 packedInput = getA(${o});

        setOutput(getChannel(packedInput, ${i}));
      }
    `}}const R6t=f3,D6t=1e-7,F6t=1e-4,Iv={};function M6t(t){return t in Iv||(Iv[t]={}),Iv[t]}const P6t=Be().getNumber("CPU_HANDOFF_SIZE_THRESHOLD"),L6t=600;function z6t(){return Be().global.screen==null?1024:Be().global.screen.height*Be().global.screen.width*window.devicePixelRatio*L6t/1024/1024}class e4 extends Nw{constructor(e){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!Be().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let n;if(e!=null){if(e instanceof A$)n=e;else{const s=si(Be().getNumber("WEBGL_VERSION"),e);n=new A$(s)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{const s=si(Be().getNumber("WEBGL_VERSION"));n=new A$(s),this.binaryCache=M6t(Be().getNumber("WEBGL_VERSION")),this.gpgpuCreatedLocally=!0}this.gpgpu=n,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new y6t(this.gpgpu),this.numMBBeforeWarning=z6t(),this.texData=new zk(this,Ma())}nextDataId(){return e4.nextDataId++}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(e,n,s,r,o,a){const i=this.makeTensorInfo(n,s),l=this.texData.get(i.dataId);l.isPacked=!1,l.texture={texture:e,texShape:[r,o]},l.texShape=[r,o];const u=Tv(n),c=new XD(u,!1,a),d=this.runWebGLProgram(c,[i],s,[[r,o]]);return d.shape=n,l.texture=null,this.disposeIntermediateTensorInfo(i),d.dataId}write(e,n,s){if((Be().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||Be().getBool("DEBUG"))&&this.checkNumericalProblems(e),s==="complex64"&&e!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const r={id:this.nextDataId()};return this.texData.set(r,{shape:n,dtype:s,values:e,usage:zo.UPLOAD,refCount:1}),r}refCount(e){return this.texData.has(e)?this.texData.get(e).refCount:0}incRef(e){const n=this.texData.get(e);n.refCount++}decRef(e){if(this.texData.has(e)){const n=this.texData.get(e);n.refCount--}}move(e,n,s,r,o){if(Be().getBool("DEBUG")&&this.checkNumericalProblems(n),r==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:s,dtype:r,values:n,usage:zo.UPLOAD,refCount:o})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){const n=this.texData.get(e),{values:s,dtype:r,complexTensorInfos:o,slice:a,shape:i,isPacked:l}=n;if(a!=null){let f;l?f=new Nu(i,bu):f=new Ni(i,bu);const h=this.runWebGLProgram(f,[{dataId:e,shape:i,dtype:r}],r),p=this.readSync(h.dataId);return this.disposeIntermediateTensorInfo(h),p}if(s!=null)return this.convertAndCacheOnCPU(e);if(r==="string")return s;const u=this.activeTimers!=null;let c;u&&(c=Ys());let d;if(r==="complex64"){const f=this.readSync(o.real.dataId),h=this.readSync(o.imag.dataId);d=Rl(f,h)}else d=this.getValuesFromTexture(e);return u&&(this.downloadWaitMs+=Ys()-c),this.convertAndCacheOnCPU(e,d)}async read(e){if(this.pendingRead.has(e)){const p=this.pendingRead.get(e);return new Promise(m=>p.push(m))}const n=this.texData.get(e),{values:s,shape:r,slice:o,dtype:a,complexTensorInfos:i,isPacked:l}=n;if(o!=null){let p;l?p=new Nu(r,bu):p=new Ni(r,bu);const m=this.runWebGLProgram(p,[{dataId:e,shape:r,dtype:a}],a),g=this.read(m.dataId);return this.disposeIntermediateTensorInfo(m),g}if(s!=null)return this.convertAndCacheOnCPU(e);if(Be().getBool("DEBUG")&&!Be().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&Be().getNumber("WEBGL_VERSION")===2)throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let u=null,c;if(a!=="complex64"&&Be().get("WEBGL_BUFFER_SUPPORTED")){c=this.decode(e);const p=this.texData.get(c.dataId);u=this.gpgpu.createBufferFromTexture(p.texture.texture,...Sv(r))}this.pendingRead.set(e,[]),a!=="complex64"&&await this.gpgpu.createAndWaitForFence();let d;if(a==="complex64"){const p=await Promise.all([this.read(i.real.dataId),this.read(i.imag.dataId)]),m=p[0],g=p[1];d=Rl(m,g)}else if(u==null)d=this.getValuesFromTexture(e);else{const p=Ge(r);d=this.gpgpu.downloadFloat32MatrixFromBuffer(u,p)}if(c!=null&&this.disposeIntermediateTensorInfo(c),u!=null){const p=this.gpgpu.gl;_t(p,()=>p.deleteBuffer(u))}const f=this.convertAndCacheOnCPU(e,d),h=this.pendingRead.get(e);return this.pendingRead.delete(e),h.forEach(p=>p(f)),this.pendingDisposal.has(e)&&(this.pendingDisposal.delete(e),this.disposeData(e)&&Ma().removeDataId(e,this),this.pendingDeletes--),f}readToGPU(e,n={}){const s=this.texData.get(e),{values:r,shape:o,slice:a,dtype:i,isPacked:l,texture:u}=s;if(i==="complex64")throw new Error("Does not support reading texture for complex64 dtype.");if(a!=null){let h;l?h=new Nu(o,bu):h=new Ni(o,bu);const p=this.runWebGLProgram(h,[{dataId:e,shape:o,dtype:i}],i),m=this.readToGPU(p,n);return this.disposeIntermediateTensorInfo(p),m}if(u==null)throw r!=null?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const c=this.decode(e,n.customTexShape),d=Ma().makeTensorFromTensorInfo(c),f=this.texData.get(c.dataId);return Object.assign({tensorRef:d},f.texture)}bufferSync(e){const n=this.readSync(e.dataId);if(e.dtype==="string")try{const s=n.map(r=>Nl(r));return tn(e.shape,e.dtype,s)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return tn(e.shape,e.dtype,n)}checkNumericalProblems(e){if(e!=null)for(let n=0;n<e.length;n++){const s=e[n];if(!U3t(s))throw Be().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${s} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${s} cannot be represented on this device.`)}}getValuesFromTexture(e){const{shape:n,dtype:s,isPacked:r}=this.texData.get(e),o=Ge(n);if(Be().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const f=this.decode(e),h=this.texData.get(f.dataId),p=this.gpgpu.downloadMatrixFromPackedTexture(h.texture.texture,...Sv(n)).subarray(0,o);return this.disposeIntermediateTensorInfo(f),p}const a=Be().getBool("WEBGL_PACK")&&r===!0,i=a?Tv(n):n,l=a?new a$t(i):new o$t(i),u=this.runWebGLProgram(l,[{shape:i,dtype:s,dataId:e}],"float32"),c=this.texData.get(u.dataId),d=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(c.texture.texture,c.texShape[0],c.texShape[1]).subarray(0,o);return this.disposeIntermediateTensorInfo(u),d}timerAvailable(){return Be().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(e){const n=this.activeTimers,s=[];let r=!1;this.programTimersStack==null?(this.programTimersStack=s,r=!0):this.activeTimers.push(s),this.activeTimers=s,e();const o=Tl(this.activeTimers.map(l=>l.query)).filter(l=>l!=null),a=Tl(this.activeTimers.map(l=>l.name)).filter(l=>l!=null);this.activeTimers=n,r&&(this.programTimersStack=null);const i={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(Be().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const l=await Promise.all(o);i.kernelMs=bB(l),i.getExtraProfileInfo=()=>l.map((u,c)=>({name:a[c],ms:u})).map(u=>`${u.name}: ${u.ms}`).join(", ")}else i.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,i})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return Be().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:Ys(),endMs:null}}endTimer(e){return Be().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=Ys(),e)}async getQueryTime(e){if(Be().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(e);const n=e;return n.endMs-n.startMs}disposeData(e,n=!1){if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(n?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!n&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);const{complexTensorInfos:s}=this.texData.get(e);return s!=null&&(this.disposeData(s.real.dataId,n),this.disposeData(s.imag.dataId,n)),this.texData.delete(e),!0}releaseGPUData(e){const{texture:n,dtype:s,texShape:r,usage:o,isPacked:a,slice:i}=this.texData.get(e),l=i&&i.origDataId||e,u=this.dataRefCount.get(l);u>1?this.dataRefCount.set(l,u-1):(this.dataRefCount.delete(l),n!=null&&(this.numBytesInGPU-=this.computeBytes(r,s),this.textureManager.releaseTexture(n,r,o,a)));const c=this.texData.get(e);c.texture=null,c.texShape=null,c.isPacked=!1,c.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture.texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e,n=P6t){return Be().getBool("WEBGL_CPU_FORWARD")&&e.every(s=>this.texData.get(s.dataId).texture==null&&Ge(s.shape)<n)}getGPGPUContext(){return this.gpgpu}where(e){Fo("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const n=e.dataSync();return R6t(e.shape,n)}packedUnaryOp(e,n,s){const r=new Nu(e.shape,n),o=this.compileAndRun(r,[e],s);return Ma().makeTensorFromTensorInfo(o)}abs(e){if(this.shouldExecuteOnCPU([e])&&e.dtype!=="complex64"){const r=YG(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,r)}if(Be().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,QD,e.dtype);const n=new Ni(e.shape,QD),s=this.compileAndRun(n,[e]);return Ma().makeTensorFromTensorInfo(s)}makeTensorInfo(e,n,s){let r;if(n==="string"&&s!=null&&s.length>0&&ki(s[0])){const o=s.map(a=>Oi(a));r=this.write(o,e,n)}else r=this.write(s,e,n);return this.texData.get(r).usage=null,{dataId:r,shape:e,dtype:n}}makeOutput(e,n,s){return Ma().makeTensorFromTensorInfo(this.makeTensorInfo(e,n,s),this)}unpackTensor(e){const n=new O6t(e.shape);return this.runWebGLProgram(n,[e],e.dtype)}packTensor(e){const n=new g6t(e.shape),s=!0;return this.runWebGLProgram(n,[e],e.dtype,null,s)}packedReshape(e,n){const s=[Mh(e.shape),...Ph(e.shape)],r={dtype:e.dtype,shape:s,dataId:e.dataId},o=[Mh(n),...Ph(n)],a=new QG(o,s),i=!0,l=[s],u=this.runWebGLProgram(a,[r],e.dtype,l,i);return{dataId:u.dataId,shape:n,dtype:u.dtype}}decode(e,n){const s=this.texData.get(e),{isPacked:r,shape:o,dtype:a}=s;if(n!=null){const f=Ge(o),h=n[0]*n[1]*4;q(f<=h,()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.")}const i=Tv(o);let l;r?l=new r$t(i):l=new s$t(i);const u=!0,c=[n??Sv(i)],d=this.runWebGLProgram(l,[{shape:i,dtype:a,dataId:e}],a,c,u,n);return{dtype:a,shape:o,dataId:d.dataId}}runWebGLProgram(e,n,s,r,o=!1,a){const i=this.makeTensorInfo(e.outputShape,s),l=this.texData.get(i.dataId);if(e.packedOutput&&(l.isPacked=!0),e.outPackingScheme===lg.DENSE){const y=a??Sv(e.outputShape);l.texShape=y.map(w=>w*2)}if(e.outTexUsage!=null&&(l.usage=e.outTexUsage),Ge(i.shape)===0)return l.values=zs(i.dtype,0),i;const u=[],c=n.map(y=>{if(y.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let w=this.texData.get(y.dataId);if(w.texture==null){if(!e.packedInputs&&Ge(y.shape)<=Be().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:y.shape,texData:null,isUniform:!0,uniformValues:w.values};e.packedInputs&&(w.isPacked=!0,w.shape=y.shape)}if(this.uploadToGPU(y.dataId),!!w.isPacked!=!!e.packedInputs)y=w.isPacked?this.unpackTensor(y):this.packTensor(y),u.push(y),w=this.texData.get(y.dataId);else if(w.isPacked&&!$b(w.shape,y.shape)){const b=y,_=y.shape;y.shape=w.shape,y=this.packedReshape(y,_),u.push(y),w=this.texData.get(y.dataId),b.shape=_}return{shape:y.shape,texData:w,isUniform:!1}});this.uploadToGPU(i.dataId);const d={shape:i.shape,texData:l,isUniform:!1},f=n$t(e,c,d),h=this.getAndSaveBinary(f,()=>e$t(this.gpgpu,e,c,d)),p=this.activeTimers!=null;let m;p&&(m=this.startTimer()),Be().get("ENGINE_COMPILE_ONLY")||t$t(this.gpgpu,h,c,d,r),u.forEach(y=>this.disposeIntermediateTensorInfo(y)),p&&(m=this.endTimer(m),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(m)}));const g=Be().get("WEBGL_FLUSH_THRESHOLD");if(g>0){const y=Ys();y-this.lastGlFlushTime>g&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=y)}if(!Be().getBool("WEBGL_LAZILY_UNPACK")&&l.isPacked&&o===!1){const y=this.unpackTensor(i);return this.disposeIntermediateTensorInfo(i),y}return i}compileAndRun(e,n,s,r,o=!1){return s=s||n[0].dtype,this.runWebGLProgram(e,n,s,r,o)}getAndSaveBinary(e,n){return e in this.binaryCache||(this.binaryCache[e]=n()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(Be().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(n=>{this.gpgpu.deleteProgram(this.binaryCache[n].webGLProgram),delete this.binaryCache[n]}),this.textureManager.dispose(),this.canvas!=null&&typeof HTMLCanvasElement<"u"&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return this.floatPrecisionValue==null&&(this.floatPrecisionValue=Le(()=>{if(!Be().get("WEBGL_RENDER_FLOAT32_ENABLED")){const e=Be().getBool("DEBUG");Be().set("DEBUG",!1);const n=this.abs(Pt(1e-8)).dataSync()[0];if(Be().set("DEBUG",e),n>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return this.floatPrecision()===32?D6t:F6t}uploadToGPU(e){const n=this.texData.get(e),{shape:s,dtype:r,values:o,texture:a,usage:i,isPacked:l}=n;if(a!=null)return;const u=this.activeTimers!=null;let c;u&&(c=Ys());let d=n.texShape;if(d==null&&(d=l4t(s,l),n.texShape=d),o!=null){const f=Tv(s);let h,p=d[1],m=d[0];const g=o instanceof Uint8Array||o instanceof Uint8ClampedArray;(l||!g)&&([p,m]=hm(d[0],d[1])),l?h=new l$t(f,g):h=new XD(f,g);const y=g?[m,p]:d,w=this.makeTensorInfo(y,r),b=this.texData.get(w.dataId);g?b.usage=zo.PIXELS:b.usage=zo.UPLOAD,b.texShape=y,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(w.dataId),p,m,o);const _=[[m,p]],$=!0,x=this.runWebGLProgram(h,[w],r,_,$),k=this.texData.get(x.dataId);n.texShape=k.texShape,n.isPacked=k.isPacked,n.usage=k.usage,Be().get("ENGINE_COMPILE_ONLY")?this.disposeData(x.dataId):(n.texture=k.texture,n.values=null,this.texData.delete(x.dataId)),this.disposeIntermediateTensorInfo(w),u&&(this.uploadWaitMs+=Ys()-c)}else{const f=this.acquireTexture(d,i,r,l);n.texture=f}}convertAndCacheOnCPU(e,n){const s=this.texData.get(e),{dtype:r}=s;return n!=null&&(s.values=B6t(n,r)),s.values}acquireTexture(e,n,s,r){if(this.numBytesInGPU+=this.computeBytes(e,s),!this.warnedAboutMemory&&this.numBytesInGPU>this.numMBBeforeWarning*1024*1024){const o=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${o} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(e,n,r)}computeBytes(e,n){return e[0]*e[1]*Gy(n)}checkCompileCompletion(){for(const[,e]of Object.entries(this.binaryCache))this.checkCompletion_(e)}async checkCompileCompletionAsync(){const e=[];if(this.gpgpu.parallelCompilationExtension){for(const[,n]of Object.entries(this.binaryCache))e.push(this.checkCompletionAsync_(n));return Promise.all(e)}else{for(const[,n]of Object.entries(this.binaryCache)){const s=new Promise(r=>{try{this.checkCompletion_(n),r(!0)}catch(o){throw o}});e.push(s)}return Promise.all(e)}}async checkCompletionAsync_(e){return this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(e):(await yT(),this.checkCompletionAsync_(e))}checkCompletion_(e){if(this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.gl.LINK_STATUS)===!1)throw console.log(this.gpgpu.gl.getProgramInfoLog(e.webGLProgram)),this.gpgpu.gl.getShaderParameter(e.fragmentShader,this.gpgpu.gl.COMPILE_STATUS)===!1?(LG(e.source,this.gpgpu.gl.getShaderInfoLog(e.fragmentShader)),new Error("Failed to compile fragment shader.")):new Error("Failed to link vertex and fragment shaders.");return!0}getUniformLocations(){for(const[,e]of Object.entries(this.binaryCache)){const{uniformLocations:n,customUniformLocations:s,infLoc:r,nanLoc:o,inShapesLocations:a,inTexShapesLocations:i,outShapeLocation:l,outShapeStridesLocation:u,outTexShapeLocation:c}=WG(this.gpgpu,e.program,e.webGLProgram);e.uniformLocations=n,e.customUniformLocations=s,e.infLoc=r,e.nanLoc=o,e.inShapesLocations=a,e.inTexShapesLocations=i,e.outShapeLocation=l,e.outShapeStridesLocation=u,e.outTexShapeLocation=c}}createTensorFromTexture(e,n,s){const{texture:r,height:o,width:a,channels:i}=e,l=Ma().backend;if(!l.gpgpu.gl.isTexture(r))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");const u=l.writeTexture(r,n,s,o,a,i);return Ma().makeTensorFromDataId(u,n,s,l)}}e4.nextDataId=0;function B6t(t,e){if(e==="float32"||e==="complex64")return t;if(e==="int32"||e==="bool"){const n=e==="int32"?new Int32Array(t.length):new Uint8Array(t.length);for(let s=0;s<n.length;++s)n[s]=Math.round(t[s]);return n}else throw new Error(`Unknown dtype ${e}`)}const V6t="4.1.0";Xk()&&a8("webgl",()=>new e4,2);const OI=`
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`;class Lh{constructor(e,n,s){this.variableNames=["A","B"],this.outputShape=Zt(n,s),this.enableShapeUniforms=zr(this.outputShape.length),this.userCode=`
      float binaryOperation(float a, float b) {
        ${e}
      }

      void main() {
        float a = getAAtOutCoords();
        float b = getBAtOutCoords();
        setOutput(binaryOperation(a, b));
      }
    `}}const k2=`
  result.r = isNaN.r ? NAN : result.r;
  result.g = isNaN.g ? NAN : result.g;
  result.b = isNaN.b ? NAN : result.b;
  result.a = isNaN.a ? NAN : result.a;
`;class T2{constructor(e,n,s,r=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=Zt(n,s);const o=this.outputShape.length;this.enableShapeUniforms=zr(o);let a="";if(r)if(o===0||Ge(this.outputShape)===1)a=`
          result.y = 0.;
          result.z = 0.;
          result.w = 0.;
        `;else if(a=`
          ${jn(o)} coords = getOutputCoords();
        `,o===1)this.enableShapeUniforms?a+=`
            result.y = (coords + 1) >= outShape ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `:a+=`
            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;else{const l=Ir("coords",o);this.enableShapeUniforms?a+=`
            bool nextRowOutOfBounds =
              (${l[o-2]} + 1) >= outShape[${o} - 2];
            bool nextColOutOfBounds =
              (${l[o-1]} + 1) >= outShape[${o} - 1];
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `:a+=`
            bool nextRowOutOfBounds =
              (${l[o-2]} + 1) >= ${this.outputShape[o-2]};
            bool nextColOutOfBounds =
              (${l[o-1]} + 1) >= ${this.outputShape[o-1]};
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `}this.userCode=`
      vec4 binaryOperation(vec4 a, vec4 b) {
        ${e}
      }

      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();

        vec4 result = binaryOperation(a, b);
        ${a}

        setOutput(result);
      }
    `}}function Co(t){const{inputs:e,backend:n}=t,{x:s}=e;return n.incRef(s.dataId),{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}const H6t={kernelName:xp,backendName:"webgl",kernelFunc:Co};function yc(t){const{inputs:e,backend:n}=t,{real:s,imag:r}=e,o=n.makeTensorInfo(s.shape,"complex64"),a=n.texData.get(o.dataId),i=Co({inputs:{x:s},backend:n}),l=Co({inputs:{x:r},backend:n});return a.complexTensorInfos={real:i,imag:l},o}const W6t={kernelName:Pw,backendName:"webgl",kernelFunc:yc};const ej="return (a < 0.) ? b * a : a;",tj=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function U6t(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{alpha:o}=s,a=n.makeTensorInfo([],"float32",ql(o,"float32")),i=Be().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new T2(tj,r.shape,a.shape):new Lh(ej,r.shape,a.shape),l=n.runWebGLProgram(i,[r,a],"float32");return n.disposeIntermediateTensorInfo(a),l}const G6t={kernelName:l1,backendName:"webgl",kernelFunc:U6t};const nj="return (a < 0.) ? b * a : a;",sj=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function j6t(t){const{inputs:e,backend:n}=t,{x:s,alpha:r}=e,o=Be().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new T2(sj,s.shape,r.shape):new Lh(nj,s.shape,r.shape);return n.runWebGLProgram(o,[s,r],"float32")}const K6t={kernelName:T1,backendName:"webgl",kernelFunc:j6t};const ym="if (isnan(x)) return x;";function xn({opSnippet:t,packedOpSnippet:e,cpuKernelImpl:n,dtype:s}){return({inputs:r,backend:o})=>{const{x:a}=r,i=o,l=s||a.dtype;if(i.shouldExecuteOnCPU([a])&&n!=null){const d=i.texData.get(a.dataId),f=n(d.values,l);return i.makeTensorInfo(a.shape,l,f)}const u=Be().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&e!=null;let c;return u?c=new Nu(a.shape,e):c=new Ni(a.shape,t),i.runWebGLProgram(c,[a],l)}}function fr({opSnippet:t,packedOpSnippet:e,checkOutOfBounds:n=!1,supportsComplex:s=!1,cpuKernelImpl:r,dtype:o}){return({inputs:a,backend:i})=>{const{a:l,b:u}=a,c=i;if(s&&l.dtype==="complex64"){const p=c.texData.get(l.dataId),m=c.texData.get(u.dataId),[g,y]=[[p.complexTensorInfos.real,m.complexTensorInfos.real],[p.complexTensorInfos.imag,m.complexTensorInfos.imag]].map(b=>{const[_,$]=b,x={dataId:_.dataId,dtype:_.dtype,shape:l.shape},k={dataId:$.dataId,dtype:$.dtype,shape:u.shape},C=new Lh(t,l.shape,u.shape);return c.runWebGLProgram(C,[x,k],Yr(_.dtype,$.dtype))}),w=yc({inputs:{real:g,imag:y},backend:c});return c.disposeIntermediateTensorInfo(g),c.disposeIntermediateTensorInfo(y),w}const d=o||Yr(l.dtype,u.dtype);if((l.dtype==="string"||u.dtype==="string"||c.shouldExecuteOnCPU([l,u]))&&r!=null){const p=c.texData.get(l.dataId).values,m=c.texData.get(u.dataId).values,g=l.dtype==="string"?Md(p):p,y=l.dtype==="string"?Md(m):m,[w,b]=r(l.shape,u.shape,g,y,d),_=c.makeTensorInfo(b,d),$=c.texData.get(_.dataId);return $.values=w,_}const f=Be().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&e!=null;let h;return f?h=new T2(e,l.shape,u.shape,n):h=new Lh(t,l.shape,u.shape),c.runWebGLProgram(h,[l,u],d)}}function ug(t,e=!1){if(t==="linear")return e?T6t:$6t;if(t==="relu")return e?I6t:S6t;if(t==="elu")return e?N6t:x6t;if(t==="relu6")return e?E6t:C6t;if(t==="prelu")return e?sj:nj;if(t==="leakyrelu")return e?tj:ej;if(t==="sigmoid")return e?A6t:k6t;throw new Error(`Activation ${t} has not been implemented for the WebGL backend.`)}class rj{constructor(e,n,s,r=!1,o=!1,a=!1,i=null,l=!1,u=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=s,this.enableShapeUniforms=zr(this.outputShape.length);const c=r?e[1]:e[2],d=Math.ceil(c/2),f=r?"i * 2, rc.y":"rc.y, i * 2",h=o?"rc.z, i * 2":"i * 2, rc.z",p=r?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],m=o?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let g="",y="";i&&(l?g=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${i}
        }`:u?g=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${i}
        }`:g=`vec4 activation(vec4 x) {
          ${i}
        }`,y="result = activation(result);");const w=a?"result += getBiasAtOutCoords();":"";a&&this.variableNames.push("bias"),l&&this.variableNames.push("preluActivationWeights"),u&&this.variableNames.push("leakyreluAlpha");let b="rc.x",_="rc.x";e[0]<n[0]?b=`int(min(float(rc.x), ${e[0]-1}.))`:n[0]<e[0]&&(_=`int(min(float(rc.x), ${n[0]-1}.))`),this.userCode=`
      ${g}
      // Don't use uniform for sharedDimensionPacked for performance.
      const float sharedDimension = ${d}.0;

      vec4 dot2x2ARowBCol(ivec3 rc) {
        vec4 result = vec4(0);
        for (int i = 0; i < ${d}; i++) {
          int batchA = ${b};
          int batchB = ${_};
          vec4 a = getMatrixA(batchA, ${f});
          vec4 b = getMatrixB(batchB, ${h});

          // These swizzled products need to be separately added.
          // See: https://github.com/tensorflow/tfjs/issues/1735
          result += (${p[0]} * ${m[0]});
          result += (${p[1]} * ${m[1]});
        }
        return result;
      }

      void main() {
        ivec3 rc = getOutputCoords();
        vec4 result = dot2x2ARowBCol(rc);

        ${w}

        ${y}

        setOutput(result);
      }
    `}}const e9={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"};class t9{constructor(e,n,s){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=Zt(n,s),this.userCode=`
      float binaryOpComplex(
          float areal, float aimag, float breal, float bimag) {
        ${e}
      }

      void main() {
        float areal = getARealAtOutCoords();
        float aimag = getAImagAtOutCoords();
        float breal = getBRealAtOutCoords();
        float bimag = getBImagAtOutCoords();
        setOutput(binaryOpComplex(areal, aimag, breal, bimag));
      }
    `}}const n9="return a * b;";function RI(t){const{inputs:e,backend:n}=t,{a:s,b:r}=e,o=Yr(s.dtype,r.dtype);if(s.dtype==="complex64"){const i=n.texData.get(s.dataId),l=n.texData.get(r.dataId),u=new t9(e9.REAL,s.shape,r.shape),c=new t9(e9.IMAG,s.shape,r.shape),d=[{dataId:i.complexTensorInfos.real.dataId,dtype:i.complexTensorInfos.real.dtype,shape:s.shape},{dataId:i.complexTensorInfos.imag.dataId,dtype:i.complexTensorInfos.imag.dtype,shape:s.shape},{dataId:l.complexTensorInfos.real.dataId,dtype:l.complexTensorInfos.real.dtype,shape:r.shape},{dataId:l.complexTensorInfos.imag.dataId,dtype:l.complexTensorInfos.imag.dtype,shape:r.shape}],f=n.runWebGLProgram(u,d,"float32"),h=n.runWebGLProgram(c,d,"float32"),p=yc({inputs:{real:f,imag:h},backend:n});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(h),p}if(n.shouldExecuteOnCPU([s,r])){const i=n.texData.get(s.dataId),l=n.texData.get(r.dataId),[u,c]=j$t(s.shape,r.shape,i.values,l.values,o),d=n.makeTensorInfo(c,o),f=n.texData.get(d.dataId);return f.values=u,d}let a;return Be().getBool("WEBGL_PACK_BINARY_OPERATIONS")?a=new T2(n9,s.shape,r.shape):a=new Lh(n9,s.shape,r.shape),n.runWebGLProgram(a,[s,r],o)}const q6t={kernelName:Op,backendName:"webgl",kernelFunc:RI};function X6t(t,e,n){const s=[Mh(t.shape),...Ph(t.shape)],r={dtype:t.dtype,shape:s,dataId:t.dataId},o=[Mh(e),...Ph(e)],a=new QG(o,s),i=!0,l=[s],u=n.runWebGLProgram(a,[r],t.dtype,l,i);return{dataId:u.dataId,shape:e,dtype:u.dtype}}function bt(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{shape:o}=s,a=n,i=Ge(r.shape),l=Vk(o,i),u=Ge(l);q(i===u,()=>`The new shape (${l}) has ${u} elements and the old shape (${r.shape}) has ${i} elements. The new shape and old shape must have the same number of elements.`);const c=a.texData.get(r.dataId);return c.isPacked&&!$b(r.shape,l)&&!(c.texture!==null&&$b(c.shape,l))?X6t(r,l,a):(a.incRef(r.dataId),{dataId:r.dataId,shape:l,dtype:r.dtype})}const Y6t={kernelName:I1,backendName:"webgl",kernelFunc:bt};class s9{constructor(e,n){this.variableNames=["x"];const{windowSize:s,batchSize:r,inSize:o,outSize:a}=e;this.outputShape=[r,a];const i=Math.floor(s/4)*4,l=s%4;let u="sumValue += dot(values, ones);";if(n!=null){const d=1/n;u=`sumValue += dot(values * ${Nd(d)?d.toPrecision(2):d}, ones);`}let c="";o%s>0&&(c=`
        if (inIdx < 0 || inIdx >= ${o}) {
          return 0.0;
        }
      `),this.userCode=`
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${c}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${s};

        float sumValue = 0.0;

        for (int i = 0; i < ${i}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${u}
        }

        int inIdx = inOffset + ${i};
        if (${l===1}) {
          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);

          ${u}
        } else if (${l===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1), 0.0, 0.0);

          ${u}
        } else if (${l===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2), 0.0);

          ${u}
        }
        setOutput(sumValue);
      }
    `}}class Z6t{constructor(e,n){this.variableNames=["x"];const{windowSize:s,batchSize:r,inSize:o,outSize:a}=e;this.outputShape=[r,a];let i="0.0",l="";n==="prod"?i="1.0":n==="min"?(i="1.0 / 1e-20",l="min"):n==="max"&&(i="-1.0 / 1e-20",l="max");let u=`${n}(${n}(${n}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;n==="sum"?u="sumValue":n==="prod"?u="prodValue":n==="all"?u="allValue":n==="any"&&(u="anyValue");const c=Math.floor(s/4)*4,d=s%4;let f=`
      if (${n==="sum"}) {
        sumValue += dot(values, ones);
      } else if (${n==="prod"}) {
        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);
        prodValue *= tmp[0] * tmp[1];
      } else {
        minMaxValue = ${l}(values, minMaxValue);
        if (${n==="min"} || ${n==="max"}) {
          minMaxValue = ${l}(values, minMaxValue);
          bvec4 isNaN = isnan(values);
          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {
            minMaxValue = vec4(NAN);
          }
        }
      }
    `,h="vec4";n==="all"?(i="1.0",f=`
        bool reducedAllValue = all(values);
        float floatedReducedAllValue = float(reducedAllValue);
        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);
      `,h="bvec4"):n==="any"&&(i="0.0",f=`
        bool reducedAnyValue = any(values);
        float floatedReducedAnyValue = float(reducedAnyValue);
        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);
      `,h="bvec4");let p="";o%s>0&&(p=`
        if (inIdx < 0 || inIdx >= ${o}) {
          return initializationValue;
        }
      `),this.userCode=`
      const float initializationValue = ${i};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${p}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${s};

        vec4 minMaxValue = vec4(${i});
        float prodValue = 1.0;
        float sumValue = 0.0;
        float allValue = 1.0;
        float anyValue = 0.0;

        for (int i = 0; i < ${c}; i += 4) {
          int inIdx = inOffset + i;
          ${h} values = ${h}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${f}
        }

        int inIdx = inOffset + ${c};
        if (${d===1}) {
          ${h} values = ${h}(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          ${f}
        } else if (${d===2}) {
          ${h} values = ${h}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          ${f}
        } else if (${d===3}) {
          ${h} values = ${h}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          ${f}
        }
        setOutput(${u});
      }
    `}}function J6t(t){const e=[];for(;e.length===0||e[e.length-1].outSize!==1;){const n=e.length?e[e.length-1].outSize:t[1],s=T3(n);e.push({inSize:n,windowSize:s,outSize:Math.ceil(n/s)})}return e}function mf(t,e,n,s){const r=J6t(t.shape);let o=t;for(let a=0;a<r.length;a++){const{inSize:i,windowSize:l,outSize:u}=r[a];let c,d;n==="mean"?c=a===0?new s9({windowSize:l,inSize:i,batchSize:t.shape[0],outSize:u},i):new s9({windowSize:l,inSize:i,batchSize:t.shape[0],outSize:u}):c=new Z6t({windowSize:l,inSize:i,batchSize:t.shape[0],outSize:u},n),d=o,o=s.runWebGLProgram(c,[o],e),d.dataId!==t.dataId&&s.disposeIntermediateTensorInfo(d)}return o}class Q6t{constructor(e,n){this.variableNames=["A"];const s=new Array(e.length);for(let a=0;a<s.length;a++)s[a]=e[n[a]];this.outputShape=s,this.rank=s.length;const r=jn(this.rank),o=ext(n);this.userCode=`
    void main() {
      ${r} resRC = getOutputCoords();
      setOutput(getA(${o}));
    }
    `}}function ext(t){const e=t.length;if(e>6)throw Error(`Transpose for rank ${e} is not yet supported`);const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],s=new Array(e);for(let r=0;r<t.length;r++)s[t[r]]=n[r];return s.join()}class txt{constructor(e,n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const s=new Array(e.length);for(let c=0;c<s.length;c++)s[c]=e[n[c]];if(this.outputShape=s,this.rank=s.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const r=jn(this.rank),o=JG("rc",this.rank),a=new Array(this.rank);for(let c=0;c<n.length;c++)a[n[c]]=o[c];const i=`vec2(${a.slice(-2).join()})`,l=`++${o[this.rank-1]} < ${s[this.rank-1]}`,u=`getChannel(getA(${a.join()}), ${i})`;this.userCode=`
    void main() {
      ${r} rc = getOutputCoords();
      vec4 result = vec4(0.);
      result[0] = ${u};
      if(${l}) {
        result[1] = ${u};
      }
      --${o[this.rank-1]};
      if(++${o[this.rank-2]} < ${s[this.rank-2]}) {
        result[2] = ${u};
        if(${l}) {
          result[3] = ${u};
        }
      }
      setOutput(result);
    }
    `}}function t4(t,e,n){const s=Be().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new txt(t.shape,e):new Q6t(t.shape,e);return n.runWebGLProgram(s,[t],t.dtype)}function nxt(t,e,n,s){const r=e,o=t.shape.length,a=un(r,t.shape);let i=a;const l=hs(i,o),u=l!=null;let c=t;u&&(c=t4(t,l,s),i=bs(i.length,o)),cr("sum",i,o);const[d,f]=js(c.shape,i);let h=d;n&&(h=ys(d,a));const p=Ge(f),g=Ge(t.shape)/p,y=bt({inputs:{x:c},attrs:{shape:[g,p]},backend:s}),w=F_(t.dtype),b=mf(y,w,"sum",s),_=bt({inputs:{x:b},attrs:{shape:h},backend:s});return s.disposeIntermediateTensorInfo(y),s.disposeIntermediateTensorInfo(b),u&&s.disposeIntermediateTensorInfo(c),_}function n4(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{axis:o,keepDims:a}=s;return nxt(r,o,a,n)}const sxt={kernelName:F1,backendName:"webgl",kernelFunc:n4};function Fr(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{perm:o}=s,a=n,i=r.shape.length,l=new Array(i);for(let c=0;c<l.length;c++)l[c]=r.shape[o[c]];let u;if(a.shouldExecuteOnCPU([r])){const d=a.texData.get(r.dataId).values,f=AI(d,r.shape,r.dtype,o,l);u=a.makeTensorInfo(l,r.dtype);const h=a.texData.get(u.dataId);h.values=f}else u=t4(r,o,a);return u}const rxt={kernelName:ld,backendName:"webgl",kernelFunc:Fr};const oj=1e3;function xb({a:t,b:e,transposeA:n,transposeB:s,backend:r,bias:o=null,preluActivationWeights:a=null,leakyreluAlpha:i=0,activation:l=null}){const u=t.shape.length,c=e.shape.length,d=n?t.shape[u-2]:t.shape[u-1],f=s?e.shape[c-1]:e.shape[c-2],h=n?t.shape[u-1]:t.shape[u-2],p=s?e.shape[c-2]:e.shape[c-1],m=t.shape.slice(0,-2),g=e.shape.slice(0,-2),y=Ge(m),w=Ge(g),_=Zt(t.shape.slice(0,-2),e.shape.slice(0,-2)).concat([h,p]);q(d===f,()=>`Error in matMul: inner shapes (${d}) and (${f}) of Tensors with shapes ${t.shape} and ${e.shape} and transposeA=${n} and transposeB=${s} must match.`);const $=n?[y,d,h]:[y,h,d],x=s?[w,p,f]:[w,f,p],k=bt({inputs:{x:t},backend:r,attrs:{shape:$}}),C=bt({inputs:{x:e},backend:r,attrs:{shape:x}}),T=[k,C],N=Math.max(y,w),M=n?k.shape[1]:k.shape[2],R=o!=null,D=a!=null,z=l==="leakyrelu",B=l!=null?ug(l,!0):null,V=R||D||z||B!=null;let O;if((h===1||p===1)&&M>oj&&V===!1){let L=k,G=C;n&&(L=Fr({inputs:{x:k},backend:r,attrs:{perm:[0,2,1]}}),T.push(L)),s&&(G=Fr({inputs:{x:C},backend:r,attrs:{perm:[0,2,1]}}),T.push(G));const Z=p!==1,j=p===1;let J=L;Z&&(J=bt({inputs:{x:L},backend:r,attrs:{shape:[N,M,1]}}),T.push(J));const fe=p===1?2:1;let X=G;j&&(X=bt({inputs:{x:G},backend:r,attrs:{shape:[N,1,M]}}),T.push(X));const oe=RI({inputs:{a:J,b:X},backend:r});O=n4({inputs:{x:oe},backend:r,attrs:{axis:fe,keepDims:!0}}),T.push(oe)}else{const L=Yr(t.dtype,e.dtype),G=new rj($,x,[N,h,p],n,s,R,B,D,z),Z=[k,C];if(o!=null&&Z.push(o),D&&Z.push(a),z){const j=r.makeTensorInfo([],"float32",ql(i,"float32"));Z.push(j),T.push(j)}O=r.runWebGLProgram(G,Z,L)}const F=bt({inputs:{x:O},backend:r,attrs:{shape:_}});T.push(O);for(const L of T)r.disposeIntermediateTensorInfo(L);return F}function oxt(t){const{inputs:e,backend:n,attrs:s}=t,{a:r,b:o,bias:a,preluActivationWeights:i}=e,{transposeA:l,transposeB:u,activation:c,leakyreluAlpha:d}=s;return xb({a:r,b:o,transposeA:l,transposeB:u,backend:n,bias:a,preluActivationWeights:i,leakyreluAlpha:d,activation:c})}const axt={kernelName:Y0,backendName:"webgl",kernelFunc:oxt};const r9="return abs(x);";function ixt(t){const{inputs:e,backend:n}=t,{x:s}=e;if(n.shouldExecuteOnCPU([s])&&s.dtype!=="complex64"){const o=n.texData.get(s.dataId),a=YG(o.values);return n.makeTensorInfo(s.shape,s.dtype,a)}let r;return Be().getBool("WEBGL_PACK_UNARY_OPERATIONS")?r=new Nu(s.shape,r9):r=new Ni(s.shape,r9),n.runWebGLProgram(r,[s],s.dtype)}const lxt={kernelName:Vg,backendName:"webgl",kernelFunc:ixt};const uxt=Ea+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return acos(x);
`,cxt=xn({opSnippet:uxt}),dxt={kernelName:sp,backendName:"webgl",kernelFunc:cxt};const fxt=Ea+`
  if (x < 1.0) return NAN;
return log(x + sqrt(x * x - 1.0));`,hxt=xn({opSnippet:fxt}),pxt={kernelName:rp,backendName:"webgl",kernelFunc:hxt};const o9="return a + b;",mxt=fr({opSnippet:o9,packedOpSnippet:o9,supportsComplex:!0,cpuKernelImpl:k$t}),gxt={kernelName:nf,backendName:"webgl",kernelFunc:mxt};class vxt{constructor(e,n){this.outputShape=[],this.outputShape=e,this.variableNames=n.map((o,a)=>`T${a}`);const s=[];this.variableNames.forEach(o=>{s.push(`float v${o} = get${o}AtOutCoords();`)});const r=this.variableNames.map(o=>`v${o}`).join(" + ");this.userCode=`
      void main() {
        ${s.join(`
        `)}

        float result = ${r};
        setOutput(result);
      }
    `}}class yxt{constructor(e,n){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.variableNames=n.map((o,a)=>`T${a}`);const s=[];this.variableNames.forEach(o=>{s.push(`vec4 v${o} = get${o}AtOutCoords();`)});const r=this.variableNames.map(o=>`v${o}`).join(" + ");this.userCode=`
      void main() {
        ${s.join(`
        `)}

        vec4 result = ${r};
        setOutput(result);
      }
    `}}function py(t){const{inputs:e,backend:n}=t,s=e;if(s.length===1)return Co({inputs:{x:s[0]},backend:n});if(s.length>Be().get("WEBGL_MAX_TEXTURES_IN_SHADER")){const l=Math.floor(s.length/2),u=py({inputs:s.slice(0,l),backend:n}),c=py({inputs:s.slice(l),backend:n});return py({inputs:[u,c],backend:n})}const r=s.map(l=>l.dtype).reduce((l,u)=>Yr(l,u)),o=s.map(l=>l.shape),i=Be().getBool("WEBGL_PACK")?new yxt(s[0].shape,o):new vxt(s[0].shape,o);return n.runWebGLProgram(i,s,r)}const bxt={kernelName:Hg,backendName:"webgl",kernelFunc:py};function wxt(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{axis:o,keepDims:a}=s,i=r.shape.length,l=un(o,r.shape);let u=l;const c=hs(u,i);let d=r;c!=null&&(d=Fr({inputs:{x:r},backend:n,attrs:{perm:c}}),u=bs(u.length,i)),cr("all",u,i);const[f,h]=js(d.shape,u),p=Ge(h),m=bt({inputs:{x:d},backend:n,attrs:{shape:[-1,p]}}),g=mf(m,m.dtype,"all",n);let y;if(a){const w=ys(f,l);y=bt({inputs:{x:g},backend:n,attrs:{shape:w}})}else y=bt({inputs:{x:g},backend:n,attrs:{shape:f}});return n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),c!=null&&n.disposeIntermediateTensorInfo(d),y}const _xt={kernelName:Aw,backendName:"webgl",kernelFunc:wxt};function $xt(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{axis:o,keepDims:a}=s,i=r.shape.length,l=un(o,r.shape);let u=l;const c=hs(u,i);let d=r;c!=null&&(d=Fr({inputs:{x:r},backend:n,attrs:{perm:c}}),u=bs(u.length,i)),cr("any",u,i);const[f,h]=js(d.shape,u),p=Ge(h),m=bt({inputs:{x:d},backend:n,attrs:{shape:[-1,p]}}),g=mf(m,m.dtype,"any",n);let y;if(a){const w=ys(f,l);y=bt({inputs:{x:g},backend:n,attrs:{shape:w}})}else y=bt({inputs:{x:g},backend:n,attrs:{shape:f}});return n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),c!=null&&n.disposeIntermediateTensorInfo(d),y}const xxt={kernelName:Ow,backendName:"webgl",kernelFunc:$xt};class Sxt{constructor(e,n,s){this.variableNames=["A"];const{windowSize:r,batchSize:o,outSize:a}=e;s||this.variableNames.push("bestIndicesA"),this.outputShape=[o,a];const i=n==="max"?">":"<",l=s?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${r};

        int bestIndex = inOffset;
        float bestValue = getA(batch, bestIndex);

        for (int i = 0; i < ${r}; i++) {
          int inIdx = ${l};
          float candidate = getA(batch, inIdx);
          if (candidate ${i} bestValue) {
            bestValue = candidate;
            bestIndex = inIdx;
          }
        }
        setOutput(float(bestIndex));
      }
    `}}class Cxt{constructor(e,n,s,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,q(e.length>2,()=>`Packed arg${s.charAt(0).toUpperCase()+s.slice(1)} supports only inputs with rank above 2.`);const o=e[e.length-1],a=Math.ceil(o/n);this.outputShape=e.slice(0,-1),a>1&&this.outputShape.push(a),r||this.variableNames.push("bestIndicesA");const i=this.outputShape,l=i.length,u=jn(l),c=Ir("coords",l);let d,f;if(a===1){f=l+1;const C=jn(f);d=`
        ${C} sourceLocR = ${C}(${c.join()}, 0);
        ++${c[l-1]};
        ${C} sourceLocG = ${C}(${c.join()}, 0);
        ++${c[l-2]};
        ${C} sourceLocA = ${C}(${c.join()}, 0);
        --${c[l-1]};
        ${C} sourceLocB = ${C}(${c.join()}, 0);
        --${c[l-2]};`}else f=l,d=`
        ${u} sourceLocR = coords;
        ++${c[l-1]};
        ${u} sourceLocG = coords;
        ++${c[l-2]};
        ${u} sourceLocA = coords;
        --${c[l-1]};
        ${u} sourceLocB = coords;
        --${c[l-2]};`;const h=["x","y","z","w","u","v"].slice(0,f),p="."+h[f-1],m=h.map(C=>"int "+C),g=Ir("sourceLocR",f-1).concat("inIdx.r"),y=Ir("sourceLocG",f-1).concat("inIdx.g"),w=Ir("sourceLocB",f-1).concat("inIdx.b"),b=Ir("sourceLocA",f-1).concat("inIdx.a"),_=s==="max"?"greaterThan":"lessThan",$=r?"":`
          inIdx = round(vec4(getBestIndicesAChannel(${g.join()}),
                             getBestIndicesAChannel(${y.join()}),
                             getBestIndicesAChannel(${w.join()}),
                             getBestIndicesAChannel(${b.join()})));`,x=`vec4(
            getAChannel(${g.join()}),
            hasNextCol ? getAChannel(${y.join()}) : 0.,
            hasNextRow ? getAChannel(${w.join()}) : 0.,
            hasNextRow && hasNextCol ? getAChannel(${b.join()}) : 0.)`,k=r?"":`
      float getBestIndicesAChannel(${m.join()}) {
        return getChannel(getBestIndicesA(${h.join()}),
                                          vec2(${h.slice(-2).join()}));
      }`;this.userCode=`
      float getAChannel(${m.join()}) {
        return getChannel(getA(${h.join()}),
                               vec2(${h.slice(-2).join()}));
      }
      ${k}
      void main() {
        ${u} coords = getOutputCoords();
        bool hasNextCol = ${c[l-1]} < ${i[l-1]-1};
        bool hasNextRow = ${c[l-2]} < ${i[l-2]-1};
        ${d}
        ivec4 srcIdx = ivec4(sourceLocR${p}, sourceLocG${p},
          sourceLocB${p}, sourceLocA${p}) * ${n};
        ivec4 inIdx = srcIdx;
        vec4 bestIndex = vec4(inIdx);
        vec4 bestValue = ${x};

        for (int i = 0; i < ${n}; i++) {
          inIdx = srcIdx;
          ${$}
          vec4 candidate = ${x};
          bvec4 nan = isnan(candidate);
          bvec4 replace = bvec4(
            vec4(${_}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));

          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,
                           replace.y  ? candidate.y : bestValue.y,
                           replace.z  ? candidate.z : bestValue.z,
                           replace.w  ? candidate.w : bestValue.w);
          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));
          srcIdx++;
        }
        setOutput(bestIndex);
      }
    `}}function aj(t,e,n,s=null){let r=e.shape[0],o=e.shape[1];s!=null&&(r=s.shape[0],o=s.shape[1]);const a=T3(o),i={windowSize:a,inSize:o,batchSize:r,outSize:Math.ceil(o/a)},l=new Sxt(i,n,s==null),u=[e];s!=null&&u.push(s);const c=t.runWebGLProgram(l,u,"int32");if(c.shape[1]===1)return c;const d=aj(t,e,n,c);return t.disposeIntermediateTensorInfo(c),d}function ij(t,e,n,s=null){const r=s!=null?s.shape:e.shape,o=r[r.length-1],a=T3(o),i=new Cxt(r,a,n,s==null),l=s==null?[e]:[e,s],u=t.runWebGLProgram(i,l,"int32");if(u.shape.length===e.shape.length){const c=ij(t,e,n,u);return t.disposeIntermediateTensorInfo(u),c}return u}function lj(t,e,n,s){const r=[n];if(cr("arg"+s.charAt(0).toUpperCase()+s.slice(1),r,e.shape.length),!Be().getBool("WEBGL_PACK_REDUCE")||e.shape.length<=2){const o=[],a=t.texData.get(e.dataId),i=a!==null&&a.isPacked;let l=e;i&&(l=t.unpackTensor(e),o.push(l));const[u,c]=js(l.shape,r),d=Ge(c),f=bt({inputs:{x:l},backend:t,attrs:{shape:[-1,d]}});o.push(f);const h=aj(t,f,s);o.push(h);const p=bt({inputs:{x:h},backend:t,attrs:{shape:u}});return o.forEach(m=>t.disposeIntermediateTensorInfo(m)),p}return ij(t,e,s)}function kxt(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{axis:o}=s;let a=un(o,r.shape);const i=hs(a,r.shape.length);let l=r;const u=[];i!=null&&(l=Fr({inputs:{x:r},backend:n,attrs:{perm:i}}),u.push(l),a=bs(a.length,l.shape.length)),cr("argMax",[a[0]],l.shape.length);const c=lj(n,l,a[0],"max");return u.forEach(d=>n.disposeIntermediateTensorInfo(d)),c}const Txt={kernelName:Wg,backendName:"webgl",kernelFunc:kxt};function Nxt(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{axis:o}=s;let a=un(o,r.shape);const i=hs(a,r.shape.length);let l=r;const u=[];i!=null&&(l=Fr({inputs:{x:r},backend:n,attrs:{perm:i}}),u.push(l),a=bs(a.length,l.shape.length)),cr("argMin",[a[0]],l.shape.length);const c=lj(n,l,a[0],"min");return u.forEach(d=>n.disposeIntermediateTensorInfo(d)),c}const Ixt={kernelName:Ug,backendName:"webgl",kernelFunc:Nxt};const Ext=Ea+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return asin(x);
`,Axt=xn({opSnippet:Ext}),Oxt={kernelName:op,backendName:"webgl",kernelFunc:Axt};const Rxt=Ea+"return log(x + sqrt(x * x + 1.0));",Dxt=xn({opSnippet:Rxt}),Fxt={kernelName:ap,backendName:"webgl",kernelFunc:Dxt};const Mxt=Ea+`
  return atan(x);
`,Pxt=xn({opSnippet:Mxt}),Lxt={kernelName:ip,backendName:"webgl",kernelFunc:Pxt};const zxt=OI+`
  return atan(a, b);
`,Bxt=`
  vec4 result = atan(a, b);
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+k2+`
  return result;
`,Vxt=fr({opSnippet:zxt,packedOpSnippet:Bxt}),Hxt={kernelName:up,backendName:"webgl",kernelFunc:Vxt};const Wxt=Ea+`
  if ((x < -1.0) || (x > 1.0)) return NAN;
return (log(1.0 + x) - log(1.0 - x)) / 2.0;`,Uxt=xn({opSnippet:Wxt}),Gxt={kernelName:lp,backendName:"webgl",kernelFunc:Uxt};class cg{constructor(e,n,s,r=!1,o=!1){if(this.variableNames=["x"],n==="avg"&&s)throw new Error("Cannot compute positions for average pool.");const a=e.filterWidth,i=e.strideHeight,l=e.strideWidth,u=e.dilationHeight,c=e.dilationWidth,d=e.effectiveFilterHeight,f=e.effectiveFilterWidth,h=e.padInfo.top,p=e.padInfo.left;this.outputShape=e.outShape;const m=n==="avg",g=`((batch  * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + d`,y=`(xR * ${e.inWidth} + xC) * ${e.inChannels} + d`;let w="0.0";if(m||(w="-1.0 / 1e-20"),s){const C=">=";this.userCode=`
        const ivec2 strides = ivec2(${i}, ${l});
        const ivec2 pads = ivec2(${h}, ${p});

        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d = coords[3];

          ivec2 xRCCorner = coords.yz * strides - pads;
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;

          // max/min x(?, ?, d) to get y(yR, yC, d).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;
          float avgValue = 0.0;

          for (int wR = 0; wR < ${d};
              wR += ${u}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${f};
                wC += ${c}) {
              int xC = xCCorner + wC;

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float value = getX(batch, xR, xC, d);

              // If a min / max value has already been found, use it. If not,
              // use the current value.
              float currMinMaxValue = mix(
                  value, minMaxValue, minMaxValueFound);
              if (value ${C} currMinMaxValue) {
                minMaxValue = value;
                minMaxValueFound = 1.0;
                minMaxPosition = ${r?o?g:y:`wR * ${f} + wC`};
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}const b="max";let _=`${n}(${n}(${n}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;n==="avg"&&(_="avgValue / count");const $=Math.floor(a/4)*4,x=a%4,k=`
      if (${m}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${b}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec2 strides = ivec2(${i}, ${l});
      const ivec2 pads = ivec2(${h}, ${p});
      const float initializationValue = ${w};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xR, int xC, int d) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xR, xC, d);
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d = coords[3];

        ivec2 xRCCorner = coords.yz * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // max/min x(?, ?, d) to get y(yR, yC, d).
        // ? = to be determined
        vec4 minMaxValue = vec4(${w});
        float avgValue = 0.0;
        count = 0.0;

        for (int wR = 0; wR < ${d};
            wR += ${u}) {
          int xR = xRCorner + wR;

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${$}; wC += 4) {
            int xC = xCCorner + wC * ${c};

            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${c}, d),
              getValue(batch, xR, xC + 2 * ${c}, d),
              getValue(batch, xR, xC + 3 * ${c}, d)
            );

            ${k}
          }

          int xC = xCCorner + ${$};
          if (${x===1}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              initializationValue,
              initializationValue,
              initializationValue
            );

            ${k}
          } else if (${x===2}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${c}, d),
              initializationValue,
              initializationValue
            );

            ${k}
          } else if (${x===3}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${c}, d),
              getValue(batch, xR, xC + 2 * ${c}, d),
              initializationValue
            );

            ${k}
          }
        }
        setOutput(${_});
      }
    `}}class DI{constructor(e,n,s,r=!1,o=!1){if(this.variableNames=["x"],n==="avg"&&s)throw new Error("Cannot compute positions for average pool.");const a=e.filterWidth,i=e.strideDepth,l=e.strideHeight,u=e.strideWidth,c=e.dilationDepth,d=e.dilationHeight,f=e.dilationWidth,h=e.effectiveFilterDepth,p=e.effectiveFilterHeight,m=e.effectiveFilterWidth,g=e.padInfo.front,y=e.padInfo.top,w=e.padInfo.left;this.outputShape=e.outShape;const b=n==="avg";let _="0.0";if(b||(_="-1.0 / 1e-20"),s){const N=">=";this.userCode=`
        const ivec3 strides =
            ivec3(${i}, ${l}, ${u});
        const ivec3 pads = ivec3(${g}, ${y}, ${w});

        void main() {
          ivec5 coords = getOutputCoords();
          int batch = coords.x;
          int ch = coords.u;

          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
          int xDCorner = xCorner.x;
          int xRCorner = xCorner.y;
          int xCCorner = xCorner.z;

          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;

          for (int wD = 0; wD < ${h};
              wD += ${c}) {
            int xD = xDCorner + wD;

            if (xD < 0 || xD >= ${e.inDepth}) {
              continue;
            }

            for (int wR = 0; wR < ${p};
                wR += ${d}) {
              int xR = xRCorner + wR;

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int wC = 0; wC < ${m};
                  wC += ${f}) {
                int xC = xCCorner + wC;

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float value = getX(batch, xD, xR, xC, ch);

                // If a min / max value has already been found, use it. If not,
                // use the current value.
                float currMinMaxValue = mix(
                    value, minMaxValue, minMaxValueFound);
                if (value ${N} currMinMaxValue) {
                  minMaxValue = value;
                  minMaxValueFound = 1.0;
                  minMaxPosition = ${r?o?`(((batch * ${e.inDepth} + xD) * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`((xD * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`wD * ${p} * ${m} +
                      wR * ${m} + wC`};
                }
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}const $="max";let x=`${n}(${n}(${n}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;n==="avg"&&(x="avgValue / count");const k=Math.floor(a/4)*4,C=a%4,T=`
      if (${b}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${$}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec3 strides =
        ivec3(${i}, ${l}, ${u});
      const ivec3 pads = ivec3(${g}, ${y}, ${w});
      const float initializationValue = ${_};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xD, int xR, int xC, int ch) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xD, xR, xC, ch);
      }

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xDCorner = xCorner.x;
        int xRCorner = xCorner.y;
        int xCCorner = xCorner.z;

        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).
        // ? = to be determined
        vec4 minMaxValue = vec4(${_});
        float avgValue = 0.0;
        count = 0.0;

        for (int wD = 0; wD < ${h};
            wD += ${c}) {
          int xD = xDCorner + wD;

          if (xD < 0 || xD >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${p};
            wR += ${d}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${k}; wC += 4) {
              int xC = xCCorner + wC * ${f};

              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${f}, ch),
                getValue(batch, xD, xR, xC + 2 * ${f}, ch),
                getValue(batch, xD, xR, xC + 3 * ${f}, ch)
              );

              ${T}
            }

            int xC = xCCorner + ${k};
            if (${C===1}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                initializationValue,
                initializationValue,
                initializationValue
              );

              ${T}
            } else if (${C===2}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${f}, ch),
                initializationValue,
                initializationValue
              );

              ${T}
            } else if (${C===3}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${f}, ch),
                getValue(batch, xD, xR, xC + 2 * ${f}, ch),
                initializationValue
              );

              ${T}
            }
          }
          setOutput(${x});
        }
      }
    `}}function jxt(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e;S2(r,"avgPool");const{filterSize:o,strides:a,pad:i,dimRoundingMode:l}=s,u=1;q(ur(a,u),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${u}'`);const c=Na(r.shape,o,a,u,i,l);if(c.filterWidth===1&&c.filterHeight===1&&hn(c.inShape,c.outShape))return Co({inputs:{x:r},backend:n});const d=new cg(c,"avg",!1);return n.runWebGLProgram(d,[r],"float32")}const Kxt={kernelName:Gg,backendName:"webgl",kernelFunc:jxt};function qxt(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{filterSize:o,strides:a,pad:i,dimRoundingMode:l,dataFormat:u}=s,c=[1,1,1],d=Xl(r.shape,o,a,c,i,l,u),f=new DI(d,"avg",!1);return n.runWebGLProgram(f,[r],"float32")}const Xxt={kernelName:jg,backendName:"webgl",kernelFunc:qxt};class Yxt{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const n=e.filterHeight,s=e.filterWidth,r=e.strideHeight,o=e.strideWidth,a=e.dilationHeight,i=e.dilationWidth,l=e.effectiveFilterHeight,u=e.effectiveFilterWidth,c=l-1-e.padInfo.top,d=u-1-e.padInfo.left,f=1/(n*s);this.userCode=`
      const ivec2 pads = ivec2(${c}, ${d});
      const float avgMultiplier = float(${f});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${l};
            wR += ${a}) {
          float dyR = float(dyRCorner + wR) / ${r}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${u};
            wC+= ${i}) {
            float dyC = float(dyCCorner + wC) / ${o}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);

            dotProd += dyValue * avgMultiplier;
          }
        }
        setOutput(dotProd);
      }
    `}}class Zxt{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const n=e.filterDepth,s=e.filterHeight,r=e.filterWidth,o=e.strideDepth,a=e.strideHeight,i=e.strideWidth,l=e.dilationDepth,u=e.dilationHeight,c=e.dilationWidth,d=e.effectiveFilterDepth,f=e.effectiveFilterHeight,h=e.effectiveFilterWidth,p=d-1-e.padInfo.front,m=f-1-e.padInfo.top,g=h-1-e.padInfo.left,y=1/(n*s*r);this.userCode=`
      const ivec3 pads = ivec3(${p}, ${m}, ${g});
      const float avgMultiplier = float(${y});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${d};
            wD += ${l}) {
          float dyD = float(dyDCorner + wD) / ${o}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${f};
              wR += ${u}) {
            float dyR = float(dyRCorner + wR) / ${a}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${h};
                wC += ${c}) {
              float dyC = float(dyCCorner + wC) / ${i}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);

              dotProd += dyValue * avgMultiplier;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}function Jxt(t){const{inputs:e,backend:n,attrs:s}=t,{dy:r,input:o}=e,a=o,{filterSize:i,strides:l,pad:u,dimRoundingMode:c}=s,d=[1,1,1],f=Xl(a.shape,i,l,d,u,c),h=new Zxt(f);return n.runWebGLProgram(h,[r],a.dtype)}const Qxt={kernelName:Dw,backendName:"webgl",kernelFunc:Jxt};function eSt(t){const{inputs:e,backend:n,attrs:s}=t,{dy:r,input:o}=e,a=o;S2([r,o],"avgPoolGrad");const{filterSize:i,strides:l,pad:u}=s,c=Na(a.shape,i,l,1,u),d=new Yxt(c);return n.runWebGLProgram(d,[r],a.dtype)}const tSt={kernelName:Rw,backendName:"webgl",kernelFunc:eSt};function nSt(t){const{inputs:e,backend:n,attrs:s}=t,{a:r,b:o}=e,{transposeA:a,transposeB:i}=s;return xb({a:r,b:o,transposeA:a,transposeB:i,backend:n})}const sSt={kernelName:Kg,backendName:"webgl",kernelFunc:nSt};class rSt{constructor(e,n,s,r,o,a){this.outputShape=[],this.variableNames=["x","mean","variance"],Zt(e,n),Zt(e,s);let i="0.0";r!=null&&(Zt(e,r),this.variableNames.push("offset"),i="getOffsetAtOutCoords()");let l="1.0";o!=null&&(Zt(e,o),this.variableNames.push("scale"),l="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        float x = getXAtOutCoords();
        float mean = getMeanAtOutCoords();
        float variance = getVarianceAtOutCoords();
        float offset = ${i};
        float scale = ${l};
        float inv = scale * inversesqrt(variance + float(${a}));
        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));
      }
    `}}class oSt{constructor(e,n,s,r,o,a){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],Zt(e,n),Zt(e,s);let i="vec4(0.0)";r!=null&&(Zt(e,r),this.variableNames.push("offset"),i="getOffsetAtOutCoords()");let l="vec4(1.0)";o!=null&&(Zt(e,o),this.variableNames.push("scale"),l="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        vec4 offset = ${i};
        vec4 scale = ${l};

        vec4 x = getXAtOutCoords();
        vec4 mean = getMeanAtOutCoords();
        vec4 variance = getVarianceAtOutCoords();

        vec4 inv = scale * inversesqrt(variance + vec4(${a}));

        setOutput((x - mean) * inv + offset);
      }
    `}}const aSt=({inputs:t,backend:e,attrs:n})=>{const{x:s,mean:r,variance:o,offset:a,scale:i}=t;q(r.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),q(a==null||r.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),q(i==null||r.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:l}=n;l==null&&(l=.001);const u=[s,r,o];let c=null;a!=null&&(c=a.shape,u.push(a));let d=null;i!=null&&(d=i.shape,u.push(i));const f=Be().getBool("WEBGL_PACK_NORMALIZATION")?new oSt(s.shape,r.shape,o.shape,c,d,l):new rSt(s.shape,r.shape,o.shape,c,d,l);return e.runWebGLProgram(f,u,u[0].dtype)},iSt={kernelName:o1,backendName:"webgl",kernelFunc:aSt};class lSt{constructor(e){this.variableNames=["source"],this.outputShape=e,this.rank=e.length;const n=jn(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const s=uSt(this.rank);let r;const o=e.map((a,i)=>`sourceLoc.${Qx[i]} = start[${i}] + coords.${Qx[i]};`);r=`
        ${n} sourceLoc;
        ${n} coords = getOutputCoords();
        ${o.join(`
`)}
      `,this.userCode=`
      void main() {
        ${r}
        setOutput(getSource(${s}));
      }
    `}}const Qx=["x","y","z","w","u","v"];function uSt(t){if(t===1)return"sourceLoc";if(t<=6)return Qx.slice(0,t).map(e=>"sourceLoc."+e).join(",");throw Error(`Slicing for rank ${t} is not yet supported`)}class cSt{constructor(e){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const n=jn(this.rank),s=Ir("coords",this.rank),r=Ir("sourceLoc",this.rank),o=this.rank===1?"sourceLoc":`vec2(${r.slice(-2).join()})`,a=`getChannel(getSource(${r.join()}), ${o})`,i=`
      result.x = ${a};
      if (++${s[this.rank-1]} < ${e[this.rank-1]}) {
        ++${r[this.rank-1]};
        result.y = ${a};
        --${r[this.rank-1]};
      }
    `,l=this.rank===1?"":`
      --${s[this.rank-1]};
      if (++${s[this.rank-2]} < ${e[this.rank-2]}) {
        ++${r[this.rank-2]};
        result.z = ${a};
        if (++${s[this.rank-1]} < ${e[this.rank-1]}) {
          ++${r[this.rank-1]};
          result.w = ${a};
        }
      }
    `,u=this.rank<=4?`sourceLoc = coords +
            ${n}(${e.map((c,d)=>`start[${d}]`).join()});`:e.map((c,d)=>`${r[d]} = ${s[d]} + start[${d}];`).join(`
`);this.userCode=`
      void main() {
        ${n} coords = getOutputCoords();
        ${n} sourceLoc;
        ${u}
        vec4 result = vec4(0.);
        ${i}
        ${l}
        setOutput(result);
      }
    `}}function dSt(t,e,n,s){const r=s.texData.get(t.dataId),o=s.makeTensorInfo(n,t.dtype),a=s.texData.get(o.dataId);Object.assign(a,r),a.refCount=1,a.shape=n,a.dtype=t.dtype;let i=h8(e,Mt(t.shape));r.slice&&(i+=r.slice.flatOffset),a.slice={flatOffset:i,origDataId:r.slice&&r.slice.origDataId||t.dataId};const l=s.dataRefCount.get(a.slice.origDataId)||1;return s.dataRefCount.set(a.slice.origDataId,l+1),o}function bm(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{begin:o,size:a}=s,[i,l]=z_(r,o,a);if(c8(r,i,l),Ge(l)===0)return n.makeTensorInfo(l,r.dtype,[]);if(n.shouldExecuteOnCPU([r])||r.dtype==="string"){const d=n.texData.get(r.dataId),f=s6t(d.values,i,l,r.shape,r.dtype);return n.makeTensorInfo(l,r.dtype,f)}const{isPacked:u}=n.texData.get(r.dataId),c=f8(r.shape,i,l);if(u||!c){const d=Be().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new cSt(l):new lSt(l),f=[i];return n.runWebGLProgram(d,[r],r.dtype,f)}return n.uploadToGPU(r.dataId),dSt(r,i,l,n)}const fSt={kernelName:D1,backendName:"webgl",kernelFunc:bm};const hSt=t=>{const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{blockShape:o,crops:a}=s;q(r.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");const i=o.reduce((w,b)=>w*b),l=l2(r.shape,o,i),u=u2(l.length,o.length),c=c2(r.shape,o,i),d=$T(a,o.length),f=xT(c,a,o.length),h=[],p=bt({inputs:{x:r},backend:n,attrs:{shape:l}}),m=Fr({inputs:{x:p},backend:n,attrs:{perm:u}}),g=bt({inputs:{x:m},backend:n,attrs:{shape:c}}),y=bm({inputs:{x:g},backend:n,attrs:{begin:d,size:f}});return h.push(p),h.push(m),h.push(g),h.forEach(w=>n.disposeIntermediateTensorInfo(w)),y},pSt={kernelName:qg,backendName:"webgl",kernelFunc:hSt};function mSt(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,weights:o}=e,{size:a}=s,i=n.readSync(r.dataId),l=n.readSync(o.dataId),u=XG(i,l,o.dtype,o.shape,a);return n.makeTensorInfo([a],o.dtype,u)}const gSt={kernelName:Fw,backendName:"webgl",kernelFunc:mSt};function vSt(t){const{inputs:e,backend:n}=t,{s0:s,s1:r}=e,o=n.readSync(s.dataId),a=n.readSync(r.dataId),i=Zt(Array.from(o),Array.from(a));return n.makeTensorInfo([i.length],"int32",Int32Array.from(i))}const ySt={kernelName:Mw,backendName:"webgl",kernelFunc:vSt};const bSt="return float(a != b);",uj=fr({opSnippet:bSt,cpuKernelImpl:q$t,dtype:"bool"}),wSt={kernelName:$1,backendName:"webgl",kernelFunc:uj};function N2(t){const{inputs:e,backend:n}=t,{input:s}=e,r=n.texData.get(s.dataId);return Co({inputs:{x:r.complexTensorInfos.real},backend:n})}const _St={kernelName:m_,backendName:"webgl",kernelFunc:N2};const $St="return float(int(x));";function xSt(t,e){const n=new Ni(t.shape,$St),s=e.runWebGLProgram(n,[t],"int32");return{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}function eS(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{dtype:o}=s;if(o==="complex64"){if(r.dtype==="complex64")return Co({inputs:{x:r},backend:n});const a=xs(r.shape),i=eS({inputs:{x:r},backend:n,attrs:{dtype:"float32"}}),l=yc({inputs:{real:i,imag:a},backend:n});return a.dispose(),n.disposeIntermediateTensorInfo(i),l}if(r.dtype==="complex64"){const a=N2({inputs:{input:r},backend:n}),i=eS({inputs:{x:a},backend:n,attrs:{dtype:o}});return n.disposeIntermediateTensorInfo(a),i}if(!Hk(r.dtype,o)){const a=Co({inputs:{x:r},backend:n});return{dataId:a.dataId,shape:a.shape,dtype:o}}if(n.shouldExecuteOnCPU([r])){const a=n.texData.get(r.dataId).values,[i,l,u]=N$t(a,r.shape,r.dtype,o);return n.makeTensorInfo(i,l,u)}if(o==="int32")return xSt(r,n);if(o==="bool"){const a=n.makeTensorInfo([],"bool",zs("bool",1)),l=uj({inputs:{a:r,b:a},backend:n});return n.disposeIntermediateTensorInfo(a),l}throw new Error(`Error in Cast: failed to cast ${r.dtype} to ${o}`)}const SSt={kernelName:cp,backendName:"webgl",kernelFunc:eS};const a9="return ceil(x);",CSt=xn({opSnippet:a9,packedOpSnippet:a9,cpuKernelImpl:I$t}),kSt={kernelName:dp,backendName:"webgl",kernelFunc:CSt};class TSt{constructor(e){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode=`

      void main() {
        float value = getAAtOutCoords();
        if (isnan(value)) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, minVal, maxVal));
      }
    `}}class NSt{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode=`
      void main() {
        vec4 value = getAAtOutCoords();

        if (any(isnan(value))) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));
      }
    `}}function ISt(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{clipValueMin:o,clipValueMax:a}=s;let i;Be().getBool("WEBGL_PACK_CLIP")?i=new NSt(r.shape):i=new TSt(r.shape);const l=[[o],[a]];return n.runWebGLProgram(i,[r],r.dtype,l)}const ESt={kernelName:fp,backendName:"webgl",kernelFunc:ISt};class ASt{constructor(e){this.variableNames=["real","imag"],this.outputShape=e,this.userCode=`
      void main() {
        float re = abs(getRealAtOutCoords());
        float im = abs(getImagAtOutCoords());
        float mx = max(re, im);

        // sadly the length function in glsl is not underflow-safe
        // (at least not on Intel GPUs). So the safe solution is
        // to ensure underflow-safety in all cases.
        setOutput(
          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))
        );
      }
    `}}function i9(t,e){return{dataId:e.dataId,dtype:e.dtype,shape:t.shape}}function OSt(t){const{inputs:e,backend:n}=t,{x:s}=e,r=n.texData.get(s.dataId),o=new ASt(s.shape),a=[i9(s,r.complexTensorInfos.real),i9(s,r.complexTensorInfos.imag)];return n.runWebGLProgram(o,a,a[0].dtype)}const RSt={kernelName:Xg,backendName:"webgl",kernelFunc:OSt};class DSt{constructor(e){this.outputShape=[],this.outputShape=Di(e,1),this.variableNames=e.map((a,i)=>`T${i}`);const n=new Array(e.length-1);n[0]=e[0][1];for(let a=1;a<n.length;a++)n[a]=n[a-1]+e[a][1];const s=[`if (yC < ${n[0]}) setOutput(getT0(yR, yC));`];for(let a=1;a<n.length;a++){const i=n[a-1];s.push(`else if (yC < ${n[a]}) setOutput(getT${a}(yR, yC-${i}));`)}const r=n.length,o=n[n.length-1];s.push(`else setOutput(getT${r}(yR, yC-${o}));`),this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int yR = coords.x;
        int yC = coords.y;

        ${s.join(`
        `)}
      }
    `}}class FSt{constructor(e,n){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=Di(e,n);const s=this.outputShape,r=s.length,o=jn(r),a=Ir("coords",r),i=["x","y","z","w","u","v"].slice(0,r);this.variableNames=e.map((m,g)=>`T${g}`);const l=new Array(e.length-1);l[0]=e[0][n];for(let m=1;m<l.length;m++)l[m]=l[m-1]+e[m][n];const u=i[n],c=i.slice(-2),d=i.join();let f=`if (${u} < ${l[0]}) {
        return getChannel(
            getT0(${d}), vec2(${c.join()}));
        }`;for(let m=1;m<l.length;m++){const g=l[m-1];f+=`
        if (${u} < ${l[m]}  && ${u} >= ${l[m-1]}) {
          return getChannel(
            getT${m}(${Ev(i,u,g)}),
            vec2(${Ev(c,u,g)}));
        }`}const h=l.length,p=l[l.length-1];f+=`
        return getChannel(
          getT${h}(${Ev(i,u,p)}),
          vec2(${Ev(c,u,p)}));`,this.userCode=`
      float getValue(${i.map(m=>"int "+m)}) {
        ${f}
      }

      void main() {
        ${o} coords = getOutputCoords();
        vec4 result = vec4(getValue(${a}), 0., 0., 0.);

        ${a[r-1]} = ${a[r-1]} + 1;
        if (${a[r-1]} < ${s[r-1]}) {
          result.g = getValue(${a});
        }

        ${a[r-2]} = ${a[r-2]} + 1;
        if (${a[r-2]} < ${s[r-2]}) {
          result.a = getValue(${a});
        }

        ${a[r-1]} = ${a[r-1]} - 1;
        if (${a[r-2]} < ${s[r-2]} &&
            ${a[r-1]} < ${s[r-1]}) {
          result.b = getValue(${a});
        }
        setOutput(result);
      }
    `}}function Ev(t,e,n){const s=t.indexOf(e);return t.map((o,a)=>a===s?`${o} - ${n}`:o).join()}function s4(t){const{inputs:e,backend:n}=t,{input:s}=e,r=n.texData.get(s.dataId);return Co({inputs:{x:r.complexTensorInfos.imag},backend:n})}const MSt={kernelName:t_,backendName:"webgl",kernelFunc:s4};function Ym(t,e,n){const s=t[0].dtype;if(s==="complex64"){const h=t.map(w=>N2({inputs:{input:w},backend:n})),p=t.map(w=>s4({inputs:{input:w},backend:n})),m=Ym(h,e,n),g=Ym(p,e,n),y=yc({inputs:{real:m,imag:g},backend:n});return h.forEach(w=>n.disposeIntermediateTensorInfo(w)),p.forEach(w=>n.disposeIntermediateTensorInfo(w)),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),y}let r=n.shouldExecuteOnCPU(t);if(s==="string"&&(r=!0),r){const h=t.map(_=>{const x=[-1,Ge(_.shape.slice(e))];return bt({inputs:{x:_},backend:n,attrs:{shape:x}})}),p=h.map(_=>({vals:n.readSync(_.dataId),shape:_.shape})),m=Di(h.map(_=>_.shape),1),g=h[0].shape[0]===1,y=E$t(p,m,s,g),w=Di(t.map(_=>_.shape),e),b=n.makeTensorInfo(w,s,y);return h.forEach(_=>n.disposeIntermediateTensorInfo(_)),b}const o=t.filter(h=>Ge(h.shape)>0),a=Be().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&o[0].shape.length>1;if(o.length===1){const h=a?new Ni(t[0].shape,bu):new Nu(t[0].shape,bu);return n.runWebGLProgram(h,t,s)}const i=Be().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(o.length>i){const h=[];for(let m=0;m<o.length;m+=i){const g=o.slice(m,m+i);h.push(Ym(g,e,n))}const p=Ym(h,e,n);for(const m of h)n.disposeIntermediateTensorInfo(m);return p}if(a){const h=new FSt(o.map(p=>p.shape),e);return n.runWebGLProgram(h,o,s)}const{tensors2D:l,outShape:u}=PSt(o,e,n),c=new DSt(l.map(h=>h.shape)),d=n.runWebGLProgram(c,l,s);l.forEach(h=>n.disposeIntermediateTensorInfo(h));const f=bt({inputs:{x:d},attrs:{shape:u},backend:n});return n.disposeIntermediateTensorInfo(d),f}function PSt(t,e,n){const s=Di(t.map(o=>o.shape),e);return{tensors2D:t.map(o=>bt({inputs:{x:o},attrs:{shape:[-1,Ge(o.shape.slice(e))]},backend:n})),outShape:s}}function cj(t){const{inputs:e,backend:n,attrs:s}=t,{axis:r}=s,o=un(r,e[0].shape)[0],a=e.map(u=>u.shape);bT(a,o);const i=Di(e.map(u=>u.shape),o);if(Ge(i)===0)return n.makeTensorInfo(i,e[0].dtype,[]);const l=e.filter(u=>Ge(u.shape)>0);return l.length===1?Co({inputs:{x:l[0]},backend:n}):Ym(l,o,n)}const LSt={kernelName:Yg,backendName:"webgl",kernelFunc:cj};class dj{constructor(e,n=!1,s=null,r=!1,o=!1){this.variableNames=["x","W"],this.outputShape=e.outShape;const a=e.padInfo.top,i=e.padInfo.left,l=e.strideHeight,u=e.strideWidth,c=e.dilationHeight,d=e.dilationWidth,f=e.filterHeight,h=e.filterWidth,p=Math.floor(e.inChannels/4)*4,m=e.inChannels%4,g=e.dataFormat==="channelsLast",y=g?1:2,w=g?2:3,b=g?3:1;let _="",$="";s&&(r?_=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${s}
        }`:o?_=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${s}
        }`:_=`
          float activation(float x) {
            ${s}
          }
        `,$="result = activation(result);");const x=n?"result += getBiasAtOutCoords();":"";n&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),o&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${_}

      const ivec2 strides = ivec2(${l}, ${u});
      const ivec2 pads = ivec2(${a}, ${i});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d2 = coords[${b}];

        ivec2 xRCCorner =
            ivec2(coords[${y}], coords[${w}]) * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${f}; wR++) {
          int xR = xRCorner + wR * ${c};

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${h}; wC++) {
            int xC = xCCorner + wC * ${d};

            if (xC < 0 || xC >= ${e.inWidth}) {
              continue;
            }

            for (int d1 = 0; d1 < ${p}; d1 += 4) {
              vec4 wValues = vec4(
                getW(wR, wC, d1, d2),
                getW(wR, wC, d1 + 1, d2),
                getW(wR, wC, d1 + 2, d2),
                getW(wR, wC, d1 + 3, d2)
              );

              if (${g}) {
                vec4 xValues = vec4(
                  getX(batch, xR, xC, d1),
                  getX(batch, xR, xC, d1 + 1),
                  getX(batch, xR, xC, d1 + 2),
                  getX(batch, xR, xC, d1 + 3)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec4 xValues = vec4(
                  getX(batch, d1, xR, xC),
                  getX(batch, d1 + 1, xR, xC),
                  getX(batch, d1 + 2, xR, xC),
                  getX(batch, d1 + 3, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }
            }

            if (${m===1}) {

              if (${g}) {
                dotProd +=
                    getX(batch, xR, xC, ${p}) *
                    getW(wR, wC, ${p}, d2);
              } else {
                dotProd +=
                    getX(batch, ${p}, xR, xC) *
                    getW(wR, wC, ${p}, d2);
              }

            } else if (${m===2}) {
              vec2 wValues = vec2(
                getW(wR, wC, ${p}, d2),
                getW(wR, wC, ${p} + 1, d2)
              );

              if (${g}) {
                vec2 xValues = vec2(
                  getX(batch, xR, xC, ${p}),
                  getX(batch, xR, xC, ${p} + 1)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec2 xValues = vec2(
                  getX(batch, ${p}, xR, xC),
                  getX(batch, ${p} + 1, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            } else if (${m===3}) {
              vec3 wValues = vec3(
                getW(wR, wC, ${p}, d2),
                getW(wR, wC, ${p} + 1, d2),
                getW(wR, wC, ${p} + 2, d2)
              );

              if (${g}) {
                vec3 xValues = vec3(
                  getX(batch, xR, xC, ${p}),
                  getX(batch, xR, xC, ${p} + 1),
                  getX(batch, xR, xC, ${p} + 2)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec3 xValues = vec3(
                  getX(batch, ${p}, xR, xC),
                  getX(batch, ${p} + 1, xR, xC),
                  getX(batch, ${p} + 2, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            }
          }
        }

        float result = dotProd;
        ${x}
        ${$}
        setOutput(result);
      }
    `}}class zSt{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const n=e.padInfo.front,s=e.padInfo.top,r=e.padInfo.left,o=e.strideDepth,a=e.strideHeight,i=e.strideWidth,l=e.dilationDepth,u=e.dilationHeight,c=e.dilationWidth,d=e.filterDepth,f=e.filterHeight,h=e.filterWidth,p=Math.floor(e.inChannels/4)*4,m=e.inChannels%4;this.userCode=`
      const ivec3 strides = ivec3(${o}, ${a}, ${i});
      const ivec3 pads = ivec3(${n}, ${s}, ${r});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d2 = coords.u;

        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xFCorner = xFRCCorner.x;
        int xRCorner = xFRCCorner.y;
        int xCCorner = xFRCCorner.z;

        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get
        // y(yF, yR, yC, d2). ? = to be determined. : = across all
        // values in that axis.
        float dotProd = 0.0;
        for (int wF = 0; wF < ${d}; wF++) {
          int xF = xFCorner + wF * ${l};

          if (xF < 0 || xF >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${f}; wR++) {
            int xR = xRCorner + wR * ${u};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${h}; wC++) {
              int xC = xCCorner + wC * ${c};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              for (int d1 = 0; d1 < ${p}; d1 += 4) {
                vec4 xValues = vec4(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                vec4 wValues = vec4(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (${m===1}) {
                dotProd +=
                  getX(batch, xF, xR, xC, ${p}) *
                  getW(wF, wR, wC, ${p}, d2);
              } else if (${m===2}) {
                vec2 xValues = vec2(
                  getX(batch, xF, xR, xC, ${p}),
                  getX(batch, xF, xR, xC, ${p} + 1)
                );
                vec2 wValues = vec2(
                  getW(wF, wR, wC, ${p}, d2),
                  getW(wF, wR, wC, ${p} + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (${m===3}) {
                vec3 xValues = vec3(
                  getX(batch, xF, xR, xC, ${p}),
                  getX(batch, xF, xR, xC, ${p} + 1),
                  getX(batch, xF, xR, xC, ${p} + 2)
                );
                vec3 wValues = vec3(
                  getW(wF, wR, wC, ${p}, d2),
                  getW(wF, wR, wC, ${p} + 1, d2),
                  getW(wF, wR, wC, ${p} + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class fj{constructor(e,n=!1,s=null,r=!1,o=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=zr(this.outputShape.length);const a=e.padInfo.left,i=e.strideWidth,l=e.dilationWidth,u=e.filterHeight,c=e.filterWidth,d=c;let f=`
       int xR; int xC; int xCOffset;
       vec4 wTexel; vec4 previous; vec4 final;`;for(let g=0;g<c;g++)f+=`
           vec4 xTexelC${g*2};
           int xTexelC${g*2}Ready;
           vec4 xTexelC${g*2+1};
           int xTexelC${g*2+1}Ready;
           vec4 xC${g};`;f+=`
     for (int r = 0; r < ${u}; r++) {
      for (int d1 = 0; d1 < ${e.inChannels}; d1 += 2) {
       `;for(let g=0;g<c;g++)f+=`
           xTexelC${g*2} = vec4(0.0);
           xTexelC${g*2}Ready = 0;
           xTexelC${g*2+1} = vec4(0.0);
           xTexelC${g*2+1}Ready = 0;
           xC${g} = vec4(0.0);`;f+=`
         xR = xRCorner + r * dilations[0];
         if (xR >=0 && xR < inDims[0]) {
       `;for(let g=0;g<(d+1)/2;g++){const y=g*2;if(f+=`
           xC = xCCorner + ${y*l};
           `,i===1){if(y<c&&(a%2===1?(f+=`
                 xCOffset = xC + 1;
                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y}Ready == 0) {
                   xTexelC${y} = getX(batch, xR, xCOffset, d1);

                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${y}.zw = vec2(0.0);
                   }
                   xTexelC${y}Ready = 1;
                 }
               `,l===1&&y>0?f+=`
                 xC${y} = vec4(xTexelC${y-2}.zw, xTexelC${y}.xy);
                 `:f+=`
                   xCOffset = xC + 1 - 2;

                   if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       previous.zw = vec2(0.0);
                     }

                     xC${y} = vec4(previous.zw, xTexelC${y}.xy);
                   } else {
                     xC${y} = vec4(0.0, 0.0, xTexelC${y}.xy);
                   }
                   `):f+=`
                 if (xC >= 0 && xC < inDims[1] && xTexelC${y}Ready == 0) {
                   xTexelC${y} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${y}.zw = vec2(0.0);
                   }
                   xTexelC${y}Ready = 1;
                 }

                 xC${y} = xTexelC${y};
                 `,y+1<c)){const w=a%2===0?Iw(l):l;l%2===0&&a%2===1||l%2!==0&&a%2!==1?(f+=`
                   xCOffset = xC + imod(pads[1], 2) + ${w};

                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y+1}Ready == 0) {
                     xTexelC${y+1} = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       xTexelC${y+1}.zw = vec2(0.0);
                     }
                     xTexelC${y+1}Ready = 1;
                   }
                   `,l>1?f+=`
                     xCOffset -= 2;
                     if (xCOffset >= 0 && xCOffset < inDims[1]) {
                      previous = getX(batch, xR, xCOffset, d1);
                      xC${y+1} = vec4(previous.zw, xTexelC${y+1}.xy);
                     } else {
                      xC${y+1} = vec4(0.0, 0.0, xTexelC${y+1}.xy);
                     }
                     `:f+=`
                     xC${y+1} = vec4(xTexelC${y}.zw, xTexelC${y+1}.xy);
                     `):w===1?f+=`
                     xC${y+1} = xTexelC${y};
                     `:f+=`
                     xCOffset = xC + ${w};

                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y+1}Ready == 0) {
                       xTexelC${y+1} = getX(batch, xR, xCOffset, d1);
                       if (xCOffset + 1 >= inDims[1]) {
                         xTexelC${y+1}.zw = vec2(0.0);
                       }
                       xTexelC${y+1}Ready = 1;
                     }

                     xC${y+1} = xTexelC${y+1};
                     `}}else y<c&&(a%2===1?(f+=`
                 xCOffset = xC + 1 - strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y}Ready == 0) {
                   xTexelC${y} = getX(batch, xR, xCOffset, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${y}.zw = vec2(0.0);
                   }
                   xTexelC${y}Ready = 1;
                 }

                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${y+1}Ready == 0) {
                   xTexelC${y+1} = getX(batch, xR, xC + 1, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xC + 2 >= inDims[1]) {
                     xTexelC${y+1}.zw = vec2(0.0);
                   }
                   xTexelC${y+1}Ready = 1;
                 }

                 xC${y} = vec4(xTexelC${y}.zw, xTexelC${y+1}.zw);
               `,y+1<c&&(f+=`
                   final = vec4(0.0);
                   xCOffset = xC + 1 + strides[1];
                   if(xCOffset >= 0 && xCOffset < inDims[1]) {
                     final = getX(batch, xR, xCOffset, d1);
                   }
                   xC${y+1} = vec4(xTexelC${y+1}.xy, final.xy);
                 `)):(f+=`
                 if(xC >= 0 && xC < inDims[1] && xTexelC${y}Ready == 0) {
                   xTexelC${y} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${y}.zw = vec2(0.0);
                   }
                   xTexelC${y}Ready = 1;
                 }

                 xCOffset = xC + strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y+1}Ready == 0) {
                   xTexelC${y+1} = getX(batch, xR, xCOffset, d1);
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${y+1}.zw = vec2(0.);
                   }
                   xTexelC${y+1}Ready = 1;
                 }

                 xC${y} = vec4(
                   xTexelC${y}.xy, xTexelC${y+1}.xy);
               `,y+1<c&&(f+=`
                   xC${y+1} = vec4(xTexelC${y}.zw, xTexelC${y+1}.zw);
                 `)));y<c&&(f+=`
             wTexel = getW(r, ${y}, d1, d2);
             dotProd += xC${y}.xxzz * vec4(wTexel.xy, wTexel.xy);
             if(d1 + 1 < ${e.inChannels}) {
               dotProd += xC${y}.yyww * vec4(wTexel.zw, wTexel.zw);
             }
           `,y+1<c&&(f+=`
               wTexel = getW(r, ${y+1}, d1, d2);
               dotProd += xC${y+1}.xxzz * vec4(wTexel.xy, wTexel.xy);
               if(d1 + 1 < ${e.inChannels}) {
                 dotProd += xC${y+1}.yyww * vec4(wTexel.zw, wTexel.zw);
               }
             `))}f+=`
     }
   `,f+=`
     }
   `,f+=`
     }
   `;let h="",p="";s&&(r?h=`vec4 activation(vec4 a) {
           vec4 b = getPreluActivationWeightsAtOutCoords();
           ${s}
         }`:o?h=`vec4 activation(vec4 a) {
           vec4 b = getLeakyreluAlphaAtOutCoords();
           ${s}
         }`:h=`vec4 activation(vec4 x) {
           ${s}
         }`,p="result = activation(result);");const m=n?"result += getBiasAtOutCoords();":"";n&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),o&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
       ${h}

       void main() {
         ivec4 coords = getOutputCoords();
         int batch = coords.x;
         ivec2 xRCCorner = coords.yz * strides - pads;
         int d2 = coords.w;
         int xRCorner = xRCCorner.x;
         int xCCorner = xRCCorner.y;

         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
         vec4 dotProd = vec4(0.000000000000001);

         ${f}

         vec4 result = dotProd - vec4(0.000000000000001);
         ${m}
         ${p}
         setOutput(result);
       }
     `}}class BSt{constructor(e,n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=e,this.enableShapeUniforms=zr(this.outputShape.length);const{dataFormat:s}=n,r=Lr(),o=s==="channelsLast",a=o?1:2,i=o?2:3,l=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${e[2]} && pos < ${e[1]}) {`;let u="";for(let c=0;c<=1;c++)for(let d=0;d<=1;d++)u+=`
          blockIndex = rc.z + ${d};
          pos = rc.y + ${c};

          ${l}
            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];
            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);

            if(d0 < inputShape[${a}] && d0 >= 0) {
              // Use custom imod instead mod. On Intel GPU, mod may generate
              // unexpected value.
              // https://github.com/tensorflow/tfjs/issues/5447
              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];
              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /
                  inChannels);

              if(d1 < inputShape[${i}] && d1 >= 0) {

                ch = imod(pos, inChannels);

                if (${o}) {
                  innerDims = vec2(d1, ch);
                  result[${c*2+d}] = getChannel(
                    getA(rc.x, d0, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                } else {
                  innerDims = vec2(d0, d1);
                  result[${c*2+d}] = getChannel(
                    getA(rc.x, ch, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                }
              }
            }
          }
        `;this.userCode=`
      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0);

        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
        vec2 innerDims;

        ${u}

        ${r.output} = result;
      }
    `}}function Sb(t,e){const n=t.length;return n>=3?e?[...t.slice(0,-3),t[n-3]*t[n-2],t[n-1]]:[...t.slice(0,-3),t[n-3],t[n-2]*t[n-1]]:!e&&n===1&&t[0]>1?[t[0],1]:null}function hj({x:t,filter:e,convInfo:n,backend:s,bias:r=null,preluActivationWeights:o=null,leakyreluAlpha:a=0,activation:i=null}){const l=t.shape,u=s.texData.get(t.dataId),c=n.inChannels,d=l[0]*l[1]*l[2],f=n.outChannels,h=n.dataFormat==="channelsLast",p=!1,m=!1;let g;const y=[];if(o!=null){const _=Sb(o.shape,h);_!=null&&(o=bt({inputs:{x:o},backend:s,attrs:{shape:_}}),y.push(o))}if(r!=null){const _=Sb(r.shape,h);_!=null&&(r=bt({inputs:{x:r},backend:s,attrs:{shape:_}}),y.push(r))}if(!((d===1||f===1)&&c>oj)&&u.isPacked&&h&&u.texture!=null&&l[2]%2!==0&&hn(u.shape.slice(-3),l.slice(-3))){const _=l[0]*l[1]*(l[2]+1),$={dataId:t.dataId,shape:[1,_,n.inChannels],dtype:t.dtype},x=u.shape;u.shape=u.shape.slice(),u.shape[u.shape.length-2]++,q($b(u.shape,$.shape),()=>`packed reshape ${u.shape} to ${$.shape} isn't free`);const k=bt({inputs:{x:e},backend:s,attrs:{shape:[1,n.inChannels,n.outChannels]}});y.push(k);const C=xb({a:$,b:k,backend:s,transposeA:p,transposeB:m,bias:r,activation:i,preluActivationWeights:o,leakyreluAlpha:a}),T=s.texData.get(C.dataId);q(T.isPacked,()=>"batchMatMul result is expected to be packed"),u.shape=x,T.shape=n.outShape,g=Co({inputs:{x:C},backend:s}),g.shape=n.outShape,y.push(C)}else{const _=n.outHeight*n.outWidth,$=bt({inputs:{x:t},backend:s,attrs:{shape:h?[n.batchSize,_,n.inChannels]:[n.batchSize,n.inChannels,_]}}),x=bt({inputs:{x:e},backend:s,attrs:{shape:[1,n.inChannels,n.outChannels]}}),k=xb({a:h?$:x,b:h?x:$,transposeA:!h,transposeB:m,backend:s,bias:r,activation:i,preluActivationWeights:o,leakyreluAlpha:a});g=bt({inputs:{x:k},backend:s,attrs:{shape:n.outShape}}),y.push($),y.push(x),y.push(k)}for(const _ of y)s.disposeIntermediateTensorInfo(_);return g}function pj({x:t,filter:e,convInfo:n,backend:s,bias:r=null,preluActivationWeights:o=null,leakyreluAlpha:a=0,activation:i=null}){const{filterWidth:l,filterHeight:u,inChannels:c,outWidth:d,outHeight:f,dataFormat:h}=n,p=h==="channelsLast",m=l*u*c,g=f*d,y=[n.batchSize,m,g],w=!0,b=!1,_=[];if(o!=null){const F=Sb(o.shape,p);F!=null&&(o=bt({inputs:{x:o},backend:s,attrs:{shape:F}}),_.push(o))}if(r!=null){const F=Sb(r.shape,p);F!=null&&(r=bt({inputs:{x:r},backend:s,attrs:{shape:F}}),_.push(r))}const $=bt({inputs:{x:e},backend:s,attrs:{shape:[1,m,Ge(e.shape)/m]}});_.push($);const x=new BSt(y,n),k=[t.shape,[n.padInfo.top,n.padInfo.left],[n.strideHeight,n.strideWidth],[n.dilationHeight,n.dilationWidth],[n.inChannels],[n.filterWidth*n.inChannels],[n.outWidth]],C=s.runWebGLProgram(x,[t],"float32",k),T=bt({inputs:{x:C},backend:s,attrs:{shape:y}});_.push(C),_.push(T);const N=r!=null,M=o!=null,R=i==="leakyrelu",D=i?ug(i,!0):null,z=new rj(p?T.shape:$.shape,p?$.shape:T.shape,p?[n.batchSize,g,n.outChannels]:[n.batchSize,n.outChannels,g],w,b,N,D,M,R),B=p?[T,$]:[$,T];if(r&&B.push(r),M&&B.push(o),R){const F=s.makeTensorInfo([],"float32",ql(a,"float32"));B.push(F),_.push(F)}const V=s.runWebGLProgram(z,B,"float32"),O=bt({inputs:{x:V},backend:s,attrs:{shape:n.outShape}});_.push(V);for(const F of _)s.disposeIntermediateTensorInfo(F);return O}function VSt(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,filter:o}=e,{strides:a,pad:i,dataFormat:l,dilations:u,dimRoundingMode:c}=s,d=Yl(l),f=Gs(r.shape,o.shape,a,u,i,c,!1,d);let h;if(f.filterHeight===1&&f.filterWidth===1&&f.dilationHeight===1&&f.dilationWidth===1&&f.strideHeight===1&&f.strideWidth===1&&(f.padInfo.type==="SAME"||f.padInfo.type==="VALID"))h=hj({x:r,filter:o,convInfo:f,backend:n});else if(f.strideWidth<=2&&d==="channelsLast"&&Be().getBool("WEBGL_EXP_CONV")){const m=new fj(f),g=[[f.padInfo.top,f.padInfo.left],[f.strideHeight,f.strideWidth],[f.dilationHeight,f.dilationWidth],[f.inHeight,f.inWidth]];h=n.runWebGLProgram(m,[r,o],"float32",g)}else if(Be().getBool("WEBGL_CONV_IM2COL"))h=pj({x:r,filter:o,convInfo:f,backend:n});else{const m=new dj(f);h=n.runWebGLProgram(m,[r,o],"float32")}const p=bt({inputs:{x:h},backend:n,attrs:{shape:f.outShape}});return n.disposeIntermediateTensorInfo(h),p}const HSt={kernelName:Zg,backendName:"webgl",kernelFunc:VSt};class WSt{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const n=e.strideHeight,s=e.strideWidth,r=e.padInfo.top,o=e.padInfo.left,a=e.dataFormat==="channelsLast";this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int d2 = coords.w;

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${n} - ${r};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${s} - ${o};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              if (${a}) {
                float dyValue = getDy(b, yR, yC, d2);
                float xValue = getX(b, xR, xC, d1);
                dotProd += (xValue * dyValue);
              } else {
                float dyValue = getDy(b, d2, yR, yC);
                float xValue = getX(b, d1, xR, xC);
                dotProd += (xValue * dyValue);
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}}class USt{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const n=e.filterHeight,s=e.filterWidth,r=e.strideHeight,o=e.strideWidth,a=e.dataFormat==="channelsLast",i=n-1-e.padInfo.top,l=s-1-e.padInfo.left,u=a?1:2,c=a?2:3,d=a?3:1;this.userCode=`
      const ivec2 pads = ivec2(${i}, ${l});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[${d}];

        ivec2 dyCorner = ivec2(coords[${u}], coords[${c}]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${n}; wR++) {
          float dyR = float(dyRCorner + wR) / ${r}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${n} - 1 - wR;

          for (int wC = 0; wC < ${s}; wC++) {
            float dyC = float(dyCCorner + wC) / ${o}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${s} - 1 - wC;

            for (int d2 = 0; d2 < ${e.outChannels}; d2++) {

              if (${a}) {
                float xValue = getDy(batch, idyR, idyC, d2);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              } else {
                float xValue = getDy(batch, d2, idyR, idyC);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}}class GSt{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const n=e.strideDepth,s=e.strideHeight,r=e.strideWidth,o=e.padInfo.front,a=e.padInfo.top,i=e.padInfo.left;this.userCode=`
      void main() {
        ivec5 coords = getOutputCoords();
        int wF = coords.x;
        int wR = coords.y;
        int wC = coords.z;
        int d1 = coords.w;
        int d2 = coords.u;

        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yF = 0; yF < ${e.outDepth}; yF++) {
            int xF = wF + yF * ${n} - ${o};

            if (xF < 0 || xF >= ${e.inDepth}) {
              continue;
            }

            for (int yR = 0; yR < ${e.outHeight}; yR++) {
              int xR = wR + yR * ${s} - ${a};

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int yC = 0; yC < ${e.outWidth}; yC++) {
                int xC = wC + yC * ${r} - ${i};

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float dyValue = getDy(b, yF, yR, yC, d2);
                float xValue = getX(b, xF, xR, xC, d1);
                dotProd += (xValue * dyValue);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class jSt{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const n=e.filterDepth,s=e.filterHeight,r=e.filterWidth,o=e.strideDepth,a=e.strideHeight,i=e.strideWidth,l=n-1-e.padInfo.front,u=s-1-e.padInfo.top,c=r-1-e.padInfo.left;this.userCode=`
      const ivec3 pads = ivec3(${l}, ${u}, ${c});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.u;


        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyFCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        float dotProd = 0.0;
        for (int wF = 0; wF < ${n}; wF++) {
          float dyF = float(dyFCorner + wF) / ${o}.0;

          if (dyF < 0.0 || dyF >= ${e.outDepth}.0 || fract(dyF) > 0.0) {
            continue;
          }
          int idyF = int(dyF);

          int wFPerm = ${n} - 1 - wF;

          for (int wR = 0; wR < ${s}; wR++) {
            float dyR = float(dyRCorner + wR) / ${a}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
              fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            int wRPerm = ${s} - 1 - wR;

            for (int wC = 0; wC < ${r}; wC++) {
              float dyC = float(dyCCorner + wC) / ${i}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              int wCPerm = ${r} - 1 - wC;

              for (int d2 = 0; d2 < ${e.outChannels}; d2++) {
                float xValue = getDy(batch, idyF, idyR, idyC, d2);
                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}function KSt(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,dy:o}=e,{strides:a,pad:i,dataFormat:l,dimRoundingMode:u,filterShape:c}=s,d=Yl(l),f=Gs(r.shape,c,a,1,i,u,!1,d),h=new WSt(f);return n.runWebGLProgram(h,[r,o],"float32")}const qSt={kernelName:Lw,backendName:"webgl",kernelFunc:KSt};function XSt(t){const{inputs:e,backend:n,attrs:s}=t,{dy:r,filter:o}=e,{inputShape:a,strides:i,pad:l,dataFormat:u,dimRoundingMode:c}=s,d=Yl(u),f=Gs(a,o.shape,i,1,l,c,!1,d),h=new USt(f);return n.runWebGLProgram(h,[r,o],"float32")}const YSt={kernelName:Jg,backendName:"webgl",kernelFunc:XSt};function ZSt(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,filter:o}=e,{strides:a,pad:i,dilations:l}=s,u=hc(r.shape,o.shape,a,l,i),c=new zSt(u);return n.runWebGLProgram(c,[r,o],"float32")}const JSt={kernelName:Qg,backendName:"webgl",kernelFunc:ZSt};function QSt(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,dy:o}=e,{strides:a,pad:i,filterShape:l}=s,u=hc(r.shape,l,a,1,i),c=new GSt(u);return n.runWebGLProgram(c,[r,o],"float32")}const eCt={kernelName:zw,backendName:"webgl",kernelFunc:QSt};function tCt(t){const{inputs:e,backend:n,attrs:s}=t,{dy:r,filter:o}=e,{pad:a,strides:i,inputShape:l}=s,u=hc(l,o.shape,i,1,a),c=new jSt(u);return n.runWebGLProgram(c,[r,o],"float32")}const nCt={kernelName:Bw,backendName:"webgl",kernelFunc:tCt};const sCt=ym+`
  return cos(x);
`,rCt=xn({opSnippet:sCt}),oCt={kernelName:hp,backendName:"webgl",kernelFunc:rCt};const aCt=`
  float e2x = exp(-x);
  return (e2x + 1.0 / e2x) / 2.0;
`,iCt=xn({opSnippet:aCt}),lCt={kernelName:pp,backendName:"webgl",kernelFunc:iCt};class uCt{constructor(e,n,s,r,o){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[a,i,l,u]=e,[c]=n,[d,f]=s;this.outputShape=[c,d,f,u];const h=r==="bilinear"?1:0,[p,m]=[`${i-1}.0`,`${l-1}.0`],[g,y,w]=d>1?[`${(i-1)/(d-1)}`,"(y2-y1) * height_ratio",`y1*${p} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${p}`],[b,_,$]=f>1?[`${(l-1)/(f-1)}`,"(x2-x1) * width_ratio",`x1*${m} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${m}`];this.userCode=`
      const float height_ratio = float(${g});
      const float width_ratio = float(${b});
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int y = coords[1];
        int x = coords[2];
        int d = coords[3];

        // get box vals
        float y1 = getBoxes(b,0);
        float x1 = getBoxes(b,1);
        float y2 = getBoxes(b,2);
        float x2 = getBoxes(b,3);

        // get image in batch index
        int bInd = round(getBoxInd(b));
        if(bInd < 0 || bInd >= ${a}) {
          return;
        }

        float height_scale = ${y};
        float width_scale = ${_};

        float in_y = ${w};
        if( in_y < 0.0 || in_y > ${p} ) {
          setOutput(float(${o}));
          return;
        }
        float in_x = ${$};
        if( in_x < 0.0 || in_x > ${m} ) {
          setOutput(float(${o}));
          return;
        }

        vec2 sourceFracIndexCR = vec2(in_x,in_y);
        if(${h} == 1) {
          // Compute the four integer indices.
          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);
          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));

          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);
          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);
          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);
          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);

          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);

          float top = topLeft + (topRight - topLeft) * fracCR.x;
          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          float newValue = top + (bottom - top) * fracCR.y;
          setOutput(newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          ivec2 sourceNearestCR = ivec2(floor(
            sourceFracIndexCR + vec2(0.5,0.5)));
          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutput(newValue);
        }
      }
    `}}const cCt=t=>{const{inputs:e,backend:n,attrs:s}=t,{image:r,boxes:o,boxInd:a}=e,{cropSize:i,method:l,extrapolationValue:u}=s,c=new uCt(r.shape,o.shape,i,l,u);return n.runWebGLProgram(c,[r,o,a],"float32")},dCt={kernelName:Hw,backendName:"webgl",kernelFunc:cCt};var dg;(function(t){t.Prod="*",t.Sum="+"})(dg||(dg={}));class l9{constructor(e,n,s,r){this.op=e,this.outputShape=n,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];const o=this.outputShape.length,a=this.op===dg.Prod?"1.0":"0.0",i=s?a:`getX(${u9(o,"coords",this.op)})`,l=this.outputShape[this.outputShape.length-1];let u="",c="";s?(u=r?`end != ${l-1}`:"end != 0",c=r?"end + 1":"end - 1"):(u=r?`end + pow2 < ${l}`:"end >= pow2",c=r?"end + pow2":"end - pow2"),this.userCode=`
      void main() {
        ${jn(o)} coords = getOutputCoords();
        int end = ${c9(o,"coords",this.op)};
        float val = ${i};
        int pow2 = int(pow(2.0, index));
        if (${u}) {
          int idx = ${c};
          ${c9(o,"coords",this.op)} = idx;
          val ${this.op}= getX(${u9(o,"coords",this.op)});
        }
        setOutput(val);
      }
    `}}function u9(t,e,n){if(t===1)return`${e}`;if(t===2)return`${e}.x, ${e}.y`;if(t===3)return`${e}.x, ${e}.y, ${e}.z`;if(t===4)return`${e}.x, ${e}.y, ${e}.z, ${e}.w`;throw new Error(`Cumulative ${n} for rank ${t} is not yet supported`)}function c9(t,e,n){if(t===1)return`${e}`;if(t===2)return`${e}.y`;if(t===3)return`${e}.z`;if(t===4)return`${e}.w`;throw new Error(`Cumulative ${n} for rank ${t} is not yet supported`)}function mj(t,e,n,s,r,o){const a=e.shape.length,i=hs([s],a);let l=e;i!=null&&(l=Fr({inputs:{x:e},backend:n,attrs:{perm:i}}));const u=bs(1,a)[0];if(u!==a-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${e.shape.length-1} but got axis=${s}`);const c=l.shape[u];let d=Co({inputs:{x:l},backend:n});for(let f=0;f<=Math.ceil(Math.log2(c))-1;f++){const h=new l9(t,l.shape,!1,o),p=[[f]],m=d;d=n.runWebGLProgram(h,[d],d.dtype,p),n.disposeIntermediateTensorInfo(m)}if(r){const f=new l9(t,l.shape,r,o),h=d;d=n.runWebGLProgram(f,[d],d.dtype),n.disposeIntermediateTensorInfo(h)}if(i!=null){const f=pc(i),h=Fr({inputs:{x:d},backend:n,attrs:{perm:f}});return n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(l),h}return d}function fCt(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{axis:o,exclusive:a,reverse:i}=s;return mj(dg.Prod,r,n,o,a,i)}const hCt={kernelName:Vw,backendName:"webgl",kernelFunc:fCt};function pCt(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{axis:o,exclusive:a,reverse:i}=s;return mj(dg.Sum,r,n,o,a,i)}const mCt={kernelName:e1,backendName:"webgl",kernelFunc:pCt};function gCt(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,weights:o}=e,{size:a,binaryOutput:i}=s;if(r.shape.length===1){const l=n.readSync(r.dataId),u=n.readSync(o.dataId),c=XG(l,u,o.dtype,o.shape,a);return n.makeTensorInfo([a],o.dtype,c)}else if(r.shape.length===2){const l=n.bufferSync(r),u=n.bufferSync(o),c=T$t(l,u,a,i);return n.makeTensorInfo(c.shape,o.dtype,c.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${r.shape.length}.`)}const vCt={kernelName:Ww,backendName:"webgl",kernelFunc:gCt};class yCt{constructor(e,n,s){this.variableNames=["x"],this.outputShape=[],this.outputShape=e,this.blockSize=n,this.dataFormat=s,this.userCode=`
    void main() {
      ivec4 coords = getOutputCoords();
      int b = coords[0];
      int h = ${this.getHeightCoordString()};
      int w = ${this.getWidthCoordString()};
      int d = ${this.getDepthCoordString()};

      int in_h = h / ${n};
      int offset_h = imod(h, ${n});
      int in_w = w / ${n};
      int offset_w = imod(w, ${n});
      int offset_d = (offset_h * ${n} + offset_w) *
        ${this.getOutputDepthSize()};
      int in_d = d + offset_d;

      float result = ${this.getInputSamplingString()};
      setOutput(result);
    }
  `}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}function bCt(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{blockSize:o,dataFormat:a}=s,i=r.shape[0],l=a==="NHWC"?r.shape[1]:r.shape[2],u=a==="NHWC"?r.shape[2]:r.shape[3],c=a==="NHWC"?r.shape[3]:r.shape[1],d=l*o,f=u*o,h=c/(o*o),p=a==="NHWC"?[i,d,f,h]:[i,h,d,f],m=new yCt(p,o,a);return n.runWebGLProgram(m,[r],r.dtype)}const wCt={kernelName:Uw,backendName:"webgl",kernelFunc:bCt};class gj{constructor(e,n=!1,s=null,r=!1,o=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=zr(this.outputShape.length);const a=e.filterHeight,i=e.filterWidth,l=e.outChannels/e.inChannels;let u="",c="";s&&(r?u=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${s}
        }`:o?u=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${s}
        }`:u=`
          float activation(float x) {
            ${s}
          }
        `,c="result = activation(result);");const d=n?"result += getBiasAtOutCoords();":"";n&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),o&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${u}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${l};
        int q = d2 - d1 * ${l};

        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.
        for (int wR = 0; wR < ${a}; wR++) {
          int xR = xRCorner + wR * dilations[0];

          if (xR < 0 || xR >= inDims[0]) {
            continue;
          }

          for (int wC = 0; wC < ${i}; wC++) {
            int xC = xCCorner + wC * dilations[1];

            if (xC < 0 || xC >= inDims[1]) {
              continue;
            }

            float xVal = getX(batch, xR, xC, d1);
            float wVal = getW(wR, wC, d1, q);
            dotProd += xVal * wVal;
          }
        }

        float result = dotProd;
        ${d}
        ${c}
        setOutput(result);
      }
    `}}class vj{constructor(e,n=!1,s=null,r=!1,o=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=zr(this.outputShape.length);const a=e.outChannels/e.inChannels,i=e.padInfo.left,l=e.strideWidth,u=e.dilationWidth,c=e.filterHeight,d=e.filterWidth,f=d;let h=`
      int xR; int xC; int xCOffset;
      vec4 wTexel; vec4 previous; vec4 final;`;for(let y=0;y<d;y++)h+=`
          vec4 xTexelC${y*2};
          int xTexelC${y*2}Ready;
          vec4 xTexelC${y*2+1};
          int xTexelC${y*2+1}Ready;
          vec4 xC${y};`;h+=`
    for (int r = 0; r < ${c}; r++) {
      `;for(let y=0;y<d;y++)h+=`
          xTexelC${y*2} = vec4(0.0);
          xTexelC${y*2}Ready = 0;
          xTexelC${y*2+1} = vec4(0.0);
          xTexelC${y*2+1}Ready = 0;
          xC${y} = vec4(0.0);`;h+=`
        xR = xRCorner + r * dilations[0];
        if (xR >=0 && xR < inDims[0]) {
      `;for(let y=0;y<(f+1)/2;y++){const w=y*2;if(h+=`
          xC = xCCorner + ${w*u};
          `,l===1){if(w<d&&(i%2===1?(h+=`
                xCOffset = xC + 1;
                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${w}Ready == 0) {
                  xTexelC${w} = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${w}.zw = vec2(0.0);
                  }
                  xTexelC${w}Ready = 1;
                }
              `,u===1&&w>0?h+=`
                xC${w} = vec4(xTexelC${w-2}.zw, xTexelC${w}.xy);
                `:h+=`
                  xCOffset = xC + 1 - 2;

                  if (xCOffset >= 0 && xCOffset < inDims[1]) {
                    previous = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      previous.zw = vec2(0.0);
                    }

                    xC${w} = vec4(previous.zw, xTexelC${w}.xy);
                  } else {
                    xC${w} = vec4(0.0, 0.0, xTexelC${w}.xy);
                  }
                  `):h+=`
                if (xC >= 0 && xC < inDims[1] && xTexelC${w}Ready == 0) {
                  xTexelC${w} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${w}.zw = vec2(0.0);
                  }
                  xTexelC${w}Ready = 1;
                }

                xC${w} = xTexelC${w};
                `,w+1<d)){const b=i%2===0?Iw(u):u;u%2===0&&i%2===1||u%2!==0&&i%2!==1?(h+=`
                  xCOffset = xC + imod(pads[1], 2) + ${b};

                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${w+1}Ready == 0) {
                    xTexelC${w+1} = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      xTexelC${w+1}.zw = vec2(0.0);
                    }
                    xTexelC${w+1}Ready = 1;
                  }
                  `,u>1?h+=`
                    xCOffset -= 2;
                    if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);
                     xC${w+1} = vec4(previous.zw, xTexelC${w+1}.xy);
                    } else {
                     xC${w+1} = vec4(0.0, 0.0, xTexelC${w+1}.xy);
                    }
                    `:h+=`
                    xC${w+1} = vec4(xTexelC${w}.zw, xTexelC${w+1}.xy);
                    `):b===1?h+=`
                    xC${w+1} = xTexelC${w};
                    `:h+=`
                    xCOffset = xC + ${b};

                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${w+1}Ready == 0) {
                      xTexelC${w+1} = getX(batch, xR, xCOffset, d1);
                      if (xCOffset + 1 >= inDims[1]) {
                        xTexelC${w+1}.zw = vec2(0.0);
                      }
                      xTexelC${w+1}Ready = 1;
                    }

                    xC${w+1} = xTexelC${w+1};
                    `}}else w<d&&(i%2===1?(h+=`
                xCOffset = xC + 1 - strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${w}Ready == 0) {
                  xTexelC${w} = getX(batch, xR, xCOffset, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${w}.zw = vec2(0.0);
                  }
                  xTexelC${w}Ready = 1;
                }

                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${w+1}Ready == 0) {
                  xTexelC${w+1} = getX(batch, xR, xC + 1, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xC + 2 >= inDims[1]) {
                    xTexelC${w+1}.zw = vec2(0.0);
                  }
                  xTexelC${w+1}Ready = 1;
                }

                xC${w} = vec4(xTexelC${w}.zw, xTexelC${w+1}.zw);
              `,w+1<d&&(h+=`
                  final = vec4(0.0);
                  xCOffset = xC + 1 + strides[1];
                  if(xCOffset >= 0 && xCOffset < inDims[1]) {
                    final = getX(batch, xR, xCOffset, d1);
                  }
                  xC${w+1} = vec4(xTexelC${w+1}.xy, final.xy);
                `)):(h+=`
                if(xC >= 0 && xC < inDims[1] && xTexelC${w}Ready == 0) {
                  xTexelC${w} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${w}.zw = vec2(0.0);
                  }
                  xTexelC${w}Ready = 1;
                }

                xCOffset = xC + strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${w+1}Ready == 0) {
                  xTexelC${w+1} = getX(batch, xR, xCOffset, d1);
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${w+1}.zw = vec2(0.);
                  }
                  xTexelC${w+1}Ready = 1;
                }

                xC${w} = vec4(
                  xTexelC${w}.xy, xTexelC${w+1}.xy);
              `,w+1<d&&(h+=`
                  xC${w+1} = vec4(xTexelC${w}.zw, xTexelC${w+1}.zw);
                `)));w<d&&(h+=`
            wTexel = getW(r, ${w}, d1, q);
            dotProd += xC${w} * vec4(wTexel.xz, wTexel.xz);
          `,w+1<d&&(h+=`
              wTexel = getW(r, ${w+1}, d1, q);
              dotProd += xC${w+1} * vec4(wTexel.xz, wTexel.xz);
            `))}h+=`
    }
  `,h+=`
      }
    `;let p="",m="";s&&(r?p=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${s}
        }`:o?p=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${s}
        }`:p=`vec4 activation(vec4 x) {
          ${s}
        }`,m="result = activation(result);");const g=n?"result += getBiasAtOutCoords();":"";n&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),o&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${p}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${a};
        int q = d2 - d1 * ${a};
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
        vec4 dotProd = vec4(0.000000000000001);

        ${h}

        vec4 result = dotProd - vec4(0.000000000000001);
        ${g}
        ${m}
        setOutput(result);
      }
    `}}function _Ct(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,filter:o}=e,{strides:a,pad:i,dilations:l,dimRoundingMode:u}=s;let c=l;c==null&&(c=[1,1]),q(ur(a,c),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${a} and dilations '${c}'`);const d=Gs(r.shape,o.shape,a,c,i,u,!0);let f;Be().getBool("WEBGL_PACK_DEPTHWISECONV")&&d.strideWidth<=2&&d.outChannels/d.inChannels===1?f=new vj(d):f=new gj(d);const h=[[d.padInfo.top,d.padInfo.left],[d.strideHeight,d.strideWidth],[d.dilationHeight,d.dilationWidth],[d.inHeight,d.inWidth]];return n.runWebGLProgram(f,[r,o],"float32",h)}const $Ct={kernelName:t1,backendName:"webgl",kernelFunc:_Ct};class xCt{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const n=e.strideHeight,s=e.strideWidth,r=e.padInfo.top,o=e.padInfo.left,a=e.outChannels/e.inChannels;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int dm = coords.w;
        int d2 = d1 * ${a} + dm;

        float dotProd = 0.0;

        // TO DO: Vec4 over the batch size
        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${n} - ${r};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${s} - ${o};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class SCt{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const n=e.filterHeight,s=e.filterWidth,r=e.strideHeight,o=e.strideWidth,a=n-1-e.padInfo.top,i=s-1-e.padInfo.left,l=e.outChannels/e.inChannels;this.userCode=`
      const ivec2 pads = ivec2(${a}, ${i});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];
        ivec2 dyCorner = coords.yz - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        float dotProd = 0.0;

        for (int wR = 0; wR < ${n}; wR++) {
          float dyR = float(dyRCorner + wR) / ${r}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${n} - 1 - wR;

          for (int wC = 0; wC < ${s}; wC++) {
            float dyC = float(dyCCorner + wC) / ${o}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${s} - 1 - wC;

            // TO DO: Vec4 over the channelMul
            for (int dm = 0; dm < ${l}; dm++) {
              int d2 = d1 * ${l} + dm;
              float xValue = getDy(batch, idyR, idyC, d2);
              float wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}function CCt(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,dy:o}=e,{strides:a,dilations:i,pad:l,dimRoundingMode:u,filterShape:c}=s,d=Gs(r.shape,c,a,i,l,u,!0),f=new xCt(d);return n.runWebGLProgram(f,[r,o],"float32")}const kCt={kernelName:Gw,backendName:"webgl",kernelFunc:CCt};function TCt(t){const{inputs:e,backend:n,attrs:s}=t,{dy:r,filter:o}=e,{strides:a,dilations:i,pad:l,dimRoundingMode:u,inputShape:c}=s,d=Gs(c,o.shape,a,i,l,u,!0),f=new SCt(d);return n.runWebGLProgram(f,[r,o],"float32")}const NCt={kernelName:jw,backendName:"webgl",kernelFunc:TCt};class ICt{constructor(e){this.variableNames=["X"],this.outputShape=[e,e],this.userCode=`
      void main() {
          ivec2 coords = getOutputCoords();
          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;
          setOutput(val);
      }
    `}}function ECt(t){const{inputs:e,backend:n}=t,{x:s}=e,r=[...s.shape,...s.shape],o=Ge(s.shape),a=bt({inputs:{x:s},backend:n,attrs:{shape:[o]}}),i=new ICt(o),l=n.runWebGLProgram(i,[a],a.dtype),u=bt({inputs:{x:l},backend:n,attrs:{shape:r}});return n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(l),u}const ACt={kernelName:Kw,backendName:"webgl",kernelFunc:ECt};class OCt{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const{inHeight:n,inWidth:s,padInfo:r,strideHeight:o,strideWidth:a,filterHeight:i,filterWidth:l,dilationHeight:u,dilationWidth:c}=e,{top:d,left:f}=r;this.userCode=`
      const ivec2 strides = ivec2(${o}, ${a});
      const ivec2 pads = ivec2(${d}, ${f});
      const float neg_infinity = -3.4e38;

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.w;
        ivec2 outTopLeftCorner =
            coords.yz * strides - pads;
        int hBeg = outTopLeftCorner.x;
        int wBeg = outTopLeftCorner.y;

        float curVal = neg_infinity;
        for (int h = 0; h < ${i}; h++) {
          int hIn = hBeg + h * ${u};

          if (hIn >= 0 && hIn < ${n}) {
            for (int w = 0; w < ${l}; w++) {
              int wIn = wBeg + w * ${c};

              if (wIn >= 0 && wIn < ${s}) {
                float xVal = getX(batch, hIn, wIn, d1);
                float wVal = getW(h, w, d1);

                float val = xVal + wVal;
                if (val > curVal) {
                  curVal = val;
                }
              }
            }
          }
        }

        float result = curVal;
        setOutput(result);
      }
    `}}function RCt(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,filter:o}=e,{strides:a,pad:i,dilations:l}=s,u=G1(r.shape,o.shape,a,i,"NHWC",l);let c;const d=new OCt(u);c=n.runWebGLProgram(d,[r,o],"float32");const f=bt({inputs:{x:c},backend:n,attrs:{shape:u.outShape}});return n.disposeIntermediateTensorInfo(c),f}const DCt={kernelName:n1,backendName:"webgl",kernelFunc:RCt};function FCt(t){const{inputs:e,backend:n,attrs:s}=t,{equation:r}=s,o=e,{allDims:a,summedDims:i,idDims:l}=AT(r,o.length);RT(a.length,l,o);const{path:u,steps:c}=DT(i,l),d=c.length;let f=null,h=a.length;const p=[];for(let m=0;m<d;++m){for(const g of c[m]){const{permutationIndices:y,expandDims:w}=OT(h,l[g]);let b;FT(y)?b=o[g]:(b=Fr({inputs:{x:o[g]},backend:n,attrs:{perm:y}}),p.push(b));const _=b.shape.slice();for(let $=0;$<w.length;++$)_.splice(w[$],0,1);hn(b.shape,_)||(b=bt({inputs:{x:b},backend:n,attrs:{shape:_}}),p.push(b)),f===null?f=b:(f=RI({inputs:{a:b,b:f},backend:n}),p.push(f))}m<d-1&&(u[m]>=0&&(f=n4({inputs:{x:f},backend:n,attrs:{axis:u[m]-(a.length-h),keepDims:!1}}),p.push(f)),h--)}for(const m of p)m!==f&&n.disposeIntermediateTensorInfo(m);return f}const MCt={kernelName:qw,backendName:"webgl",kernelFunc:FCt};const PCt="return (x >= 0.0) ? x : (exp(x) - 1.0);",LCt=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,zCt=xn({opSnippet:PCt,packedOpSnippet:LCt}),BCt={kernelName:gp,backendName:"webgl",kernelFunc:zCt};const VCt="return (b >= 1.0) ? a : a * (b + 1.0);",HCt=`
  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));
  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));
`,WCt=t=>{const{inputs:e,backend:n}=t,{dy:s,y:r}=e,o=Be().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new T2(HCt,s.shape,r.shape):new Lh(VCt,s.shape,r.shape);return n.runWebGLProgram(o,[s,r],s.dtype)},UCt={kernelName:Xw,backendName:"webgl",kernelFunc:WCt};const GCt=`
  return vec4(equal(a, b));
`,jCt="return float(a == b);",KCt=fr({opSnippet:jCt,packedOpSnippet:GCt,dtype:"bool",cpuKernelImpl:A$t}),qCt={kernelName:s1,backendName:"webgl",kernelFunc:KCt};const XCt=`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  float p = ${ST};
  float a1 = ${CT};
  float a2 = ${kT};
  float a3 = ${TT};
  float a4 = ${NT};
  float a5 = ${IT};

  float sign = sign(x);
  x = abs(x);
  float t = 1.0 / (1.0 + p * x);
  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));
`,YCt=xn({opSnippet:XCt}),ZCt={kernelName:vp,backendName:"webgl",kernelFunc:YCt};const JCt=ym+`
  return exp(x);
`,QCt=`
  vec4 result = exp(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,yj=xn({opSnippet:JCt,packedOpSnippet:QCt,cpuKernelImpl:O$t,dtype:"float32"}),ekt={kernelName:yp,backendName:"webgl",kernelFunc:yj};function tS(t){const{inputs:e,attrs:n,backend:s}=t,{dim:r}=n,{input:o}=e,a=o.shape.length,i=o.shape.slice();let l=r;return r<0&&(q(-(a+1)<=r,()=>`Axis must be in the interval [${-(a+1)}, ${a}]`),l=a+r+1),i.splice(l,0,1),bt({inputs:{x:o},backend:s,attrs:{shape:i}})}const tkt={kernelName:r1,backendName:"webgl",kernelFunc:tS};const d9="return exp(x) - 1.0;",nkt=xn({opSnippet:d9,packedOpSnippet:d9,cpuKernelImpl:R$t}),skt={kernelName:bp,backendName:"webgl",kernelFunc:nkt};class f9{constructor(e,n,s){this.variableNames=["real","imag"];const r=n[1];this.outputShape=n;const o=s?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,a=s?`${r}.0`:"1.0";let i;if(e==="real")i="return real * expR - imag * expI;";else if(e==="imag")i="return real * expI + imag * expR;";else throw new Error(`FFT component must be either "real" or "imag", got ${e}.`);this.userCode=`
      const float exponentMultiplier = ${o};

      float unaryOpComplex(float real, float expR, float imag, float expI) {
        ${i}
      }

      float mulMatDFT(int batch, int index) {
        float indexRatio = float(index) / float(${r});
        float exponentMultiplierTimesIndexRatio =
            exponentMultiplier * indexRatio;

        float result = 0.0;

        for (int i = 0; i < ${r}; i++) {
          // x = (-2|2 * PI / N) * index * i;
          float x = exponentMultiplierTimesIndexRatio * float(i);
          float expR = cos(x);
          float expI = sin(x);
          float real = getReal(batch, i);
          float imag = getImag(batch, i);

          result +=
              unaryOpComplex(real, expR, imag, expI) / ${a};
        }

        return result;
      }

      void main() {
        ivec2 coords = getOutputCoords();
        setOutput(mulMatDFT(coords[0], coords[1]));
      }
    `}}function bj(t,e,n){const s=n.texData.get(t.dataId),r=Ge(t.shape),o=t.shape[t.shape.length-1],a=r/o,i=bt({inputs:{x:t},backend:n,attrs:{shape:[a,o]}}),l=i.shape,u=new f9("real",l,e),c=new f9("imag",l,e),d=[{dataId:s.complexTensorInfos.real.dataId,dtype:s.complexTensorInfos.real.dtype,shape:l},{dataId:s.complexTensorInfos.imag.dataId,dtype:s.complexTensorInfos.imag.dtype,shape:l}],f=n.runWebGLProgram(u,d,"float32"),h=n.runWebGLProgram(c,d,"float32"),p=yc({inputs:{real:f,imag:h},backend:n});n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(h);const m=bt({inputs:{x:p},backend:n,attrs:{shape:t.shape}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(p),m}function rkt(t){const{inputs:e,backend:n}=t,{input:s}=e;return bj(s,!1,n)}const okt={kernelName:Yw,backendName:"webgl",kernelFunc:rkt};class akt{constructor(e,n){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=e,this.userCode=`
      void main() {
        // Input can be obtained from uniform value.
        setOutput(value);
      }
    `}}function I2(t){const{backend:e,attrs:n}=t,{shape:s,value:r}=n;let{dtype:o}=n;if(o=o||np(r),o==="string"){const a=gs(o,Ge(s));return a.fill(r),e.makeTensorInfo(s,o,a)}else{const a=new akt(s,r),i=[[r]];return e.runWebGLProgram(a,[],o,i)}}const ikt={kernelName:Zw,backendName:"webgl",kernelFunc:I2};class lkt{constructor(e){this.variableNames=["Image"],this.outputShape=[];const n=e[2];this.outputShape=e,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];

          int coordX = ${n} - x - 1;
          float outputValue;
          if(coordX >= 0 && coordX < ${n}) {
            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);
          } else {
            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);
          }
          setOutput(outputValue);
        }
    `}}const ukt={kernelName:Jw,backendName:"webgl",kernelFunc:({inputs:t,backend:e})=>{const{image:n}=t,s=e,r=new lkt(n.shape);return s.runWebGLProgram(r,[n],n.dtype)}};const h9="return floor(x);",ckt=xn({opSnippet:h9,packedOpSnippet:h9,cpuKernelImpl:D$t}),dkt={kernelName:wp,backendName:"webgl",kernelFunc:ckt};const fkt=`
  float s = sign(a) * sign(b);
  int ia = round(a);
  int ib = round(b);
  if (ib != 0) {
    // Windows (D3D) wants guaranteed non-zero int division at compile-time.
    return float(idiv(ia, ib, s));
  } else {
    return NAN;
  }
`,hkt=`
  ivec4 ia = round(a);
  ivec4 ib = round(b);
  bvec4 cond = notEqual(ib, ivec4(0));
  ivec4 result = ivec4(0);
  vec4 s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    result[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    result[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    result[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    result[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4(result);
`,pkt=fr({opSnippet:fkt,packedOpSnippet:hkt,dtype:"int32"}),mkt={kernelName:_p,backendName:"webgl",kernelFunc:pkt};class gkt{constructor(e){this.variableNames=["A"];const n=Lr(),[s,r]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}.0, ${s}.0);

        vec4 values = ${n.texture2D}(A, uv);
        float value;
        if (depth == 0) {
          value = values.r;
        } else if (depth == 1) {
          value = values.g;
        } else if (depth == 2) {
          value = values.b;
        } else if (depth == 3) {
          value = values.a;
        }

        setOutput(floor(value * 255.0 + 0.5));
      }
    `}}class vkt{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const n=Lr(),[s,r]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];

        vec4 result = vec4(0.);

        for(int row=0; row<=1; row++) {
          for(int col=0; col<=1; col++) {
            texC = coords[1] + row;
            depth = coords[2] + col;

            vec2 uv = (vec2(texC, texR) + halfCR) /
                       vec2(${r}.0, ${s}.0);
            vec4 values = ${n.texture2D}(A, uv);
            float value;
            if (depth == 0) {
              value = values.r;
            } else if (depth == 1) {
              value = values.g;
            } else if (depth == 2) {
              value = values.b;
            } else if (depth == 3) {
              value = values.a;
            }

            result[row * 2 + col] = floor(value * 255.0 + 0.5);
          }
        }

        ${n.output} = result;
      }
    `}}const ykt={kernelName:Yy,backendName:"webgl",kernelFunc:bkt};let Sf,O$=Be().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");function bkt(t){const{inputs:e,backend:n,attrs:s}=t;let{pixels:r}=e;const{numChannels:o}=s,a=typeof HTMLVideoElement<"u"&&r instanceof HTMLVideoElement,i=typeof HTMLImageElement<"u"&&r instanceof HTMLImageElement,[l,u]=a?[r.videoWidth,r.videoHeight]:[r.width,r.height],c=[u,l],d=[u,l,o];if(i||a){const m=Be().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(Sf==null||m!==O$)&&(O$=m,Sf=document.createElement("canvas").getContext("2d",{willReadFrequently:O$})),Sf.canvas.width=l,Sf.canvas.height=u,Sf.drawImage(r,0,0,l,u),r=Sf.canvas}const f=n.makeTensorInfo(c,"int32");n.texData.get(f.dataId).usage=zo.PIXELS,n.gpgpu.uploadPixelDataToTexture(n.getTexture(f.dataId),r);const h=Be().getBool("WEBGL_PACK")?new vkt(d):new gkt(d),p=n.runWebGLProgram(h,[f],"int32");return n.disposeData(f.dataId),p}function wkt(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,filter:o,bias:a,preluActivationWeights:i}=e,{strides:l,pad:u,dataFormat:c,dilations:d,dimRoundingMode:f,activation:h,leakyreluAlpha:p}=s,m=Yl(c),g=Gs(r.shape,o.shape,l,d,u,f,!1,m);let y;const w=[],b=a!=null,_=i!=null,$=h==="leakyrelu",x=()=>{const C=[r,o],T=(N,M)=>{if(M==="NCHW"&&N.shape.length===1&&N.shape[0]!==1){const R=bt({inputs:{x:N},backend:n,attrs:{shape:[N.shape[0],1,1]}});return w.push(R),R}return N};if(b&&C.push(T(a,c)),_&&C.push(T(i,c)),$){const N=n.makeTensorInfo([],"float32",ql(p,"float32"));C.push(N),w.push(N)}return C};if(g.filterHeight===1&&g.filterWidth===1&&g.dilationHeight===1&&g.dilationWidth===1&&g.strideHeight===1&&g.strideWidth===1&&(g.padInfo.type==="SAME"||g.padInfo.type==="VALID"))y=hj({x:r,filter:o,convInfo:g,backend:n,bias:a,activation:h,preluActivationWeights:i,leakyreluAlpha:p});else if(g.strideWidth<=2&&m==="channelsLast"&&Be().getBool("WEBGL_EXP_CONV")){const C=h?ug(h,!0):null,T=new fj(g,b,C,_,$),N=[[g.padInfo.top,g.padInfo.left],[g.strideHeight,g.strideWidth],[g.dilationHeight,g.dilationWidth],[g.inHeight,g.inWidth]],M=x();y=n.runWebGLProgram(T,M,"float32",N)}else if(Be().getBool("WEBGL_CONV_IM2COL"))y=pj({x:r,filter:o,convInfo:g,backend:n,bias:a,activation:h,preluActivationWeights:i,leakyreluAlpha:p});else{const C=h?ug(h,!1):null,T=new dj(g,b,C,_,$),N=x();y=n.runWebGLProgram(T,N,"float32")}const k=bt({inputs:{x:y},backend:n,attrs:{shape:g.outShape}});return w.push(y),w.forEach(C=>n.disposeIntermediateTensorInfo(C)),k}const _kt={kernelName:Z0,backendName:"webgl",kernelFunc:wkt};function $kt(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,filter:o,bias:a,preluActivationWeights:i}=e,{strides:l,pad:u,dilations:c,dimRoundingMode:d,activation:f,leakyreluAlpha:h}=s,p=[];let m=c;m==null&&(m=[1,1]),q(ur(l,m),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${l} and dilations '${m}'`);const g=Gs(r.shape,o.shape,l,m,u,d,!0),y=Be().getBool("WEBGL_PACK_DEPTHWISECONV")&&g.strideWidth<=2&&g.outChannels/g.inChannels===1,w=f?ug(f,y):null,b=[r,o],_=a!=null,$=i!=null,x=f==="leakyrelu";if(_&&b.push(a),$&&b.push(i),x){const N=n.makeTensorInfo([],"float32",ql(h,"float32"));b.push(N),p.push(N)}let k;y?k=new vj(g,_,w,$,x):k=new gj(g,_,w,$,x);const C=[[g.padInfo.top,g.padInfo.left],[g.strideHeight,g.strideWidth],[g.dilationHeight,g.dilationWidth],[g.inHeight,g.inWidth]],T=n.runWebGLProgram(k,b,"float32",C);return p.forEach(N=>n.disposeIntermediateTensorInfo(N)),T}const xkt={kernelName:J0,backendName:"webgl",kernelFunc:$kt};class Skt{constructor(e,n,s,r){this.sliceDim=e,this.strides=n,this.paramsShape=r,this.variableNames=["x","indices"],this.outputShape=s;const o=jn(s.length);let a=`
    int index;`;for(let i=0;i<this.sliceDim;i++)a+=`
          index = round(getIndices(coords[0], ${i}));
          out_of_bounds = out_of_bounds || index < 0;
          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[i]};
          flattenIndex += index * ${this.strides[i]};`;this.userCode=`
         void main() {
          ${o} coords = getOutputCoords();
          int flattenIndex = 0;
          bool out_of_bounds = false;

          ${a}

          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));
        }
      `}}function Ckt(t){const{inputs:e,backend:n}=t,{params:s,indices:r}=e,o=r.shape,a=o[o.length-1],i=Ge(s.shape),[l,u,c,d]=L_(s,r),f=bt({inputs:{x:r},backend:n,attrs:{shape:[u,a]}}),h=bt({inputs:{x:s},backend:n,attrs:{shape:[Ge(s.shape)/c,c]}});if(n.shouldExecuteOnCPU([s,r])||s.dtype==="string"){const y=n.readSync(r.dataId),w=n.bufferSync(s),b=F$t(y,w,s.dtype,u,a,c,d,s.shape,i);return n.makeTensorInfo(l,s.dtype,b.values)}const p=new Skt(a,d,[u,c],s.shape),m=n.runWebGLProgram(p,[h,f],h.dtype),g=bt({inputs:{x:m},backend:n,attrs:{shape:l}});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(m),g}const kkt={kernelName:Qw,backendName:"webgl",kernelFunc:Ckt};class Tkt{constructor(e,n){this.variableNames=["A","indices"],this.outputShape=n,this.rank=n.length;const s=jn(this.rank),r=Nkt(e);this.userCode=`
      void main() {
        ${s} resRC = getOutputCoords();
        int index = int(getIndices(resRC.x, resRC.z));
        float inBounds = (index >= 0) && (index < ${e[2]}) ? 1.0 : 0.0;
        setOutput(inBounds * getA(${r}));
      }
    `}}function Nkt(t,e){const n=["resRC.x","resRC.y","resRC.z","resRC.w"],s=[];for(let r=0;r<t.length;r++)r===2?s.push("index"):s.push(`${n[r]}`);return s.join()}function wj(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,indices:o}=e,{axis:a,batchDims:i}=s,l=un(a,r.shape)[0];if(Be().get("DEBUG")){const w=n.readSync(o.dataId),b=r.shape[l];for(let _=0;_<w.length;++_){const $=w[_];q($<=b-1&&$>=0,()=>`GatherV2: the index value ${$} is not in [0, ${b-1}]`)}}const u=PT(r,o,l,i),c=Ge(o.shape),d=[],f=bt({inputs:{x:r},backend:n,attrs:{shape:[u.batchSize,u.outerSize,u.dimSize,u.sliceSize]}}),h=bt({inputs:{x:o},backend:n,attrs:{shape:[u.batchSize,c/u.batchSize]}});d.push(f),d.push(h);const p=[u.batchSize,u.outerSize,c/u.batchSize,u.sliceSize];if(n.shouldExecuteOnCPU([r,o])||r.dtype==="string"){const w=n.bufferSync(h),b=n.bufferSync(f),_=M$t(b,w,p);return d.forEach($=>n.disposeIntermediateTensorInfo($)),n.makeTensorInfo(u.outputShape,_.dtype,_.values)}const m=new Tkt(f.shape,p),g=n.runWebGLProgram(m,[f,h],f.dtype);d.push(g);const y=bt({inputs:{x:g},backend:n,attrs:{shape:u.outputShape}});return d.forEach(w=>n.disposeIntermediateTensorInfo(w)),y}const Ikt={kernelName:a1,backendName:"webgl",kernelFunc:wj};const Ekt="return float(a > b);",Akt=`
  return vec4(greaterThan(a, b));
`,Okt=fr({opSnippet:Ekt,packedOpSnippet:Akt,cpuKernelImpl:P$t,dtype:"bool"}),Rkt={kernelName:i1,backendName:"webgl",kernelFunc:Okt};const Dkt="return float(a >= b);",Fkt=`
  return vec4(greaterThanEqual(a, b));
`,Mkt=fr({opSnippet:Dkt,packedOpSnippet:Fkt,dtype:"bool",cpuKernelImpl:L$t}),Pkt={kernelName:$p,backendName:"webgl",kernelFunc:Mkt};function Lkt(t){const{inputs:e,backend:n}=t,{input:s}=e;return bj(s,!0,n)}const zkt={kernelName:e_,backendName:"webgl",kernelFunc:Lkt};const Bkt="return float(!isnan(x) && !isinf(x));",Vkt=xn({opSnippet:Bkt,dtype:"bool"}),Hkt={kernelName:Sp,backendName:"webgl",kernelFunc:Vkt};const Wkt="return float(isinf(x));",Ukt=xn({opSnippet:Wkt,dtype:"bool"}),Gkt={kernelName:Cp,backendName:"webgl",kernelFunc:Ukt};const jkt="return float(isnan(x));",Kkt=xn({opSnippet:jkt,dtype:"bool"}),qkt={kernelName:kp,backendName:"webgl",kernelFunc:Kkt};const Xkt="return float(a < b);",Ykt=`
  return vec4(lessThan(a, b));
`,Zkt=fr({opSnippet:Xkt,packedOpSnippet:Ykt,cpuKernelImpl:z$t,dtype:"bool"}),Jkt={kernelName:u1,backendName:"webgl",kernelFunc:Zkt};const Qkt="return float(a <= b);",e8t=`
  return vec4(lessThanEqual(a, b));
`,t8t=fr({opSnippet:Qkt,packedOpSnippet:e8t,cpuKernelImpl:B$t,dtype:"bool"}),n8t={kernelName:c1,backendName:"webgl",kernelFunc:t8t};function s8t(t){const{backend:e,attrs:n}=t,{start:s,stop:r,num:o}=n,a=V$t(s,r,o);return e.makeTensorInfo([a.length],"float32",a)}const r8t={kernelName:n_,backendName:"webgl",kernelFunc:s8t};const o8t=ym+`
  return x < 0.0 ? 0./0. : log(x);
`,a8t=`
  vec4 result = log(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);
  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);
  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);
  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);
  return result;
`,i8t=xn({opSnippet:o8t,packedOpSnippet:a8t,cpuKernelImpl:H$t}),l8t={kernelName:Tp,backendName:"webgl",kernelFunc:i8t};const u8t=ym+`
  return log(1.0 + x);
`,c8t=xn({opSnippet:u8t}),d8t={kernelName:Np,backendName:"webgl",kernelFunc:c8t};const f8t="return float(a >= 1.0 && b >= 1.0);",h8t=`
  return vec4(
    vec4(greaterThanEqual(a, vec4(1.0))) *
    vec4(greaterThanEqual(b, vec4(1.0))));
`,p8t=fr({opSnippet:f8t,packedOpSnippet:h8t,dtype:"bool"}),m8t={kernelName:d1,backendName:"webgl",kernelFunc:p8t};const g8t="return float(!(x >= 1.0));",v8t=xn({opSnippet:g8t}),y8t={kernelName:f1,backendName:"webgl",kernelFunc:v8t};const b8t="return float(a >= 1.0 || b >= 1.0);",w8t=`
  return min(
    vec4(greaterThanEqual(a, vec4(1.0))) +
    vec4(greaterThanEqual(b, vec4(1.0))),
    vec4(1.0));
`,_8t=fr({opSnippet:b8t,packedOpSnippet:w8t,dtype:"bool"}),$8t={kernelName:h1,backendName:"webgl",kernelFunc:_8t};class x8t{constructor(e,n,s,r,o){this.variableNames=["x"],this.outputShape=[];const a=n,i=e[3]-1;this.outputShape=e;let l;const u=`float(${s}) + float(${r}) * sum`;o===.5?l=`inversesqrt(${u})`:o===1?l=`1.0/(${u})`:l=`exp(log(${u}) * float(-${o}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];
        int d = coords[3];
        float x = getX(b, r, c, d);
        float sum = 0.0;
        for (int j = -${a}; j <= ${a}; j++) {
          int idx = d + j;
          if (idx >= 0 && idx <=  ${i}) {
            float z = getX(b, r, c, idx);
            sum += z * z;
          }
        }
        float val = x * ${l};
        setOutput(val);
      }
    `}}class S8t{constructor(e,n,s,r,o){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const a=n,i=e[3]-1;this.outputShape=e;let l;const u=`float(${s}) + float(${r}) * sum`;o===.5?l=`inversesqrt(${u})`:o===1?l=`1.0/(${u})`:l=`exp(log(${u}) * float(-${o}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords.x;
        int r = coords.y;
        int c = coords.z;
        int d = coords.w;

        bool hasNextCol = d < ${this.outputShape[3]};
        bool hasNextRow = c < ${this.outputShape[2]};

        vec4 sum = vec4(0.);
        vec4 xFragAtOutputCoords = getX(b, r, c, d);

        vec4 xAtOutputCoords = vec4(
          getChannel(xFragAtOutputCoords, vec2(c, d)),
          hasNextCol ?
            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,
          hasNextRow ?
            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,
          (hasNextRow && hasNextCol) ?
            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0
        );

        int firstChannel = d - ${a};
        vec2 cache = vec2(0.);
        if(firstChannel >= 0){
          vec4 firstChannelFrag = getX(b, r, c, firstChannel);
          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));
            if(hasNextRow){
              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));
            }
        }

        ivec2 depth = ivec2(d, d + 1);
        for (int j = - ${a}; j <= ${a}; j++) {
          ivec2 idx = depth + j;
          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));
          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${i}));

          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;
          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;

          if(depthInRange || depthPlusOneInRange){
            vec4 z = vec4(0.);
            vec4 xFragAtCurrentDepth;
            z.xz = cache.xy;
            if(depthPlusOneInRange && hasNextCol){
              xFragAtCurrentDepth = idx.y != d ?
                getX(b, r, c, idx.y) : xFragAtOutputCoords;
              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));
              if(hasNextRow){
                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));
              }
            }
            cache.xy = z.yw;
            sum += z * z;
          }
        }
        vec4 result = xAtOutputCoords * ${l};
        setOutput(result);
      }
    `}}const C8t=t=>{const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{depthRadius:o,bias:a,alpha:i,beta:l}=s,u=Be().getBool("WEBGL_PACK_NORMALIZATION")?new S8t(r.shape,o,a,i,l):new x8t(r.shape,o,a,i,l);return n.runWebGLProgram(u,[r],r.dtype)},k8t={kernelName:p1,backendName:"webgl",kernelFunc:C8t};class T8t{constructor(e,n,s,r,o){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=e,this.depth=e[3],this.depthRadius=n,this.bias=s,this.alpha=r,this.beta=o,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];

        float result = 0.0;
        for (int d = 0; d < ${this.depth}; ++d) {
          int depthBegin = int(max(0.0, float(d - ${n})));
          int depthEnd = int(min(float(${this.depth}),
              float(d + ${n} + 1)));

          const int MIN_DEPTH_BEGIN = 0;
          const int MAX_DEPTH_END = ${this.depth};

          float norm = 0.0;
          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            }
            else {
              break;
            }
          }

          norm = float(${r}) * norm + float(${s});

          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd){
              float dyi = -2.0 * float(${r})
                * float(${o})
                * getInputImage(b ,r ,c, k) * getOutputImage(b, r, c, d)
                / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * ${o});
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            }
            else {
              break;
            }
          }
      }
      setOutput(result);
      }
    `}}const N8t=t=>{const{inputs:e,backend:n,attrs:s}=t,{x:r,y:o,dy:a}=e,{depthRadius:i,bias:l,alpha:u,beta:c}=s,d=new T8t(r.shape,i,l,u,c);return n.runWebGLProgram(d,[r,o,a],r.dtype)},I8t={kernelName:s_,backendName:"webgl",kernelFunc:N8t};function E8t(t,e,n,s){const r=Ge(e),a=Ge(t.shape)/r,i=bt({inputs:{x:t},attrs:{shape:[a,r]},backend:s}),l=mf(i,t.dtype,"max",s),u=bt({inputs:{x:l},attrs:{shape:n},backend:s});return s.disposeIntermediateTensorInfo(i),s.disposeIntermediateTensorInfo(l),u}function _j(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{reductionIndices:o,keepDims:a}=s,i=r.shape.length,l=un(o,r.shape);let u=l;const c=hs(u,i),d=c!=null,f=n.shouldExecuteOnCPU([r]);let h=r;if(d){if(f){const b=n.texData.get(h.dataId).values,_=new Array(i);for(let k=0;k<_.length;k++)_[k]=r.shape[c[k]];const $=AI(b,r.shape,r.dtype,c,_);h=n.makeTensorInfo(_,r.dtype);const x=n.texData.get(h.dataId);x.values=$}else h=t4(r,c,n);u=bs(u.length,i)}cr("max",u,i);const[p,m]=js(h.shape,u);let g=p;a&&(g=ys(p,l));let y;if(f){const b=n.texData.get(h.dataId).values,_=W$t(b,Ge(m),g,r.dtype);y=n.makeTensorInfo(g,r.dtype);const $=n.texData.get(y.dataId);$.values=_}else y=E8t(h,m,g,n);return d&&n.disposeIntermediateTensorInfo(h),y}const A8t={kernelName:m1,backendName:"webgl",kernelFunc:_j};const O8t=OI+`
  return max(a, b);
`,R8t=`
  vec4 result = vec4(max(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+k2+`
  return result;
`,D8t=fr({opSnippet:O8t,packedOpSnippet:R8t,cpuKernelImpl:U$t}),F8t={kernelName:Ip,backendName:"webgl",kernelFunc:D8t};function M8t(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e;S2(r,"maxPool");const{filterSize:o,strides:a,pad:i,dimRoundingMode:l}=s,u=1;q(ur(a,u),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${u}'`);const c=Na(r.shape,o,a,u,i,l);if(c.filterWidth===1&&c.filterHeight===1&&hn(c.inShape,c.outShape))return Co({inputs:{x:r},backend:n});const d=new cg(c,"max",!1);return n.runWebGLProgram(d,[r],r.dtype)}const P8t={kernelName:g1,backendName:"webgl",kernelFunc:M8t};function L8t(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{filterSize:o,strides:a,pad:i,dataFormat:l,dimRoundingMode:u}=s,c=[1,1,1],d=Xl(r.shape,o,a,c,i,u,l),f=new DI(d,"max",!1);return n.runWebGLProgram(f,[r],r.dtype)}const z8t={kernelName:v1,backendName:"webgl",kernelFunc:L8t};class B8t{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const n=e.strideHeight,s=e.strideWidth,r=e.dilationHeight,o=e.effectiveFilterHeight,a=e.effectiveFilterWidth,i=o-1-e.padInfo.top,l=a-1-e.padInfo.left,u=o*a-1;this.userCode=`
      const ivec2 pads = ivec2(${i}, ${l});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${o};
          wR += ${r}) {
          float dyR = float(dyRCorner + wR) / ${n}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${a}; wC++) {
            float dyC = float(dyCCorner + wC) / ${s}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);
            int maxPosValue = ${u} - int(getMaxPos(b, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            int curPosValue = wR * ${a} + wC;
            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

            dotProd += dyValue * mask;
          }
        }
        setOutput(dotProd);
      }
    `}}class V8t{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const n=e.strideDepth,s=e.strideHeight,r=e.strideWidth,o=e.dilationDepth,a=e.dilationHeight,i=e.dilationWidth,l=e.effectiveFilterDepth,u=e.effectiveFilterHeight,c=e.effectiveFilterWidth,d=l-1-e.padInfo.front,f=u-1-e.padInfo.top,h=c-1-e.padInfo.left,p=l*u*c-1;this.userCode=`
      const ivec3 pads = ivec3(${d}, ${f}, ${h});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${l};
           wD += ${o}) {
          float dyD = float(dyDCorner + wD) / ${n}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${u};
              wR += ${a}) {
            float dyR = float(dyRCorner + wR) / ${s}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${c};
                wC += ${i}) {
              float dyC = float(dyCCorner + wC) / ${r}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);
              int maxPosValue = ${p} -
                  int(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              int curPosValue =
                  wD * ${u} * ${c} +
                  wR * ${c} + wC;
              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

              dotProd += dyValue * mask;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}function H8t(t){const{inputs:e,backend:n,attrs:s}=t,{dy:r,input:o}=e,a=o,{filterSize:i,strides:l,pad:u,dimRoundingMode:c}=s,d=[1,1,1],f=Xl(a.shape,i,l,d,u,c),h=new DI(f,"max",!0),p=n.runWebGLProgram(h,[a],a.dtype),m=new V8t(f),g=n.runWebGLProgram(m,[r,p],a.dtype);return n.disposeIntermediateTensorInfo(p),g}const W8t={kernelName:o_,backendName:"webgl",kernelFunc:H8t};function U8t(t){const{inputs:e,backend:n,attrs:s}=t,{dy:r,input:o,output:a}=e,i=o;S2([o,a],"maxPoolGrad");const{filterSize:l,strides:u,pad:c,dimRoundingMode:d}=s,f=Na(i.shape,l,u,1,c,d),h=!0,p=new cg(f,"max",h),m=n.runWebGLProgram(p,[i],i.dtype),g=new B8t(f),y=n.runWebGLProgram(g,[r,m],i.dtype);return n.disposeIntermediateTensorInfo(m),y}const G8t={kernelName:r_,backendName:"webgl",kernelFunc:U8t};function j8t(t,e,n,s){let r=new cg(n,"max",!1);const o=s.runWebGLProgram(r,[t],"float32");r=new cg(n,"max",!0,!0,e);const a=s.runWebGLProgram(r,[t],"float32");return[o,a]}const K8t={kernelName:a_,backendName:"webgl",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{x:s}=t,{filterSize:r,strides:o,pad:a,includeBatchInIndex:i}=e,l=n;q(s.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${s.shape.length}.`);const u=[1,1];q(ur(o,u),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${u}'`);const c=Na(s.shape,r,o,u,a),[d,f]=j8t(s,i,c,l);return[d,f]}};function q8t(t,e,n,s){const r=Ge(e),a=Ge(t.shape)/r,i=bt({inputs:{x:t},attrs:{shape:[a,r]},backend:s}),l=mf(i,"float32","mean",s),u=bt({inputs:{x:l},attrs:{shape:n},backend:s});return s.disposeIntermediateTensorInfo(i),s.disposeIntermediateTensorInfo(l),u}const X8t={kernelName:y1,backendName:"webgl",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{x:s}=t,{keepDims:r,axis:o}=e,a=n,i=s.shape.length,l=un(o,s.shape);let u=l;const c=hs(u,i),d=c!=null,f=a.shouldExecuteOnCPU([s]),h=[];let p=s;if(d){if(f){const _=a.texData.get(p.dataId).values,$=new Array(i);for(let C=0;C<$.length;C++)$[C]=s.shape[c[C]];const x=AI(_,s.shape,s.dtype,c,$);p=a.makeTensorInfo($,s.dtype);const k=a.texData.get(p.dataId);k.values=x}else p=t4(s,c,a);h.push(p),u=bs(u.length,i)}cr("sum",u,i);const[m,g]=js(p.shape,u);let y=m;r&&(y=ys(m,l));const w=q8t(p,g,y,a);for(const b of h)a.disposeIntermediateTensorInfo(b);return w}};function Y8t(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{axis:o,keepDims:a}=s,i=r.shape.length,l=un(o,r.shape);let u=l;const c=hs(u,i);let d=r;c!=null&&(d=Fr({inputs:{x:r},backend:n,attrs:{perm:c}}),u=bs(u.length,r.shape.length)),cr("min",u,i);const[f,h]=js(d.shape,u),p=Ge(h),m=bt({inputs:{x:d},backend:n,attrs:{shape:[-1,p]}}),g=mf(m,m.dtype,"min",n);let y;if(a){const w=ys(f,l);y=bt({inputs:{x:g},backend:n,attrs:{shape:w}})}else y=bt({inputs:{x:g},backend:n,attrs:{shape:f}});return n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),c!=null&&n.disposeIntermediateTensorInfo(d),y}const Z8t={kernelName:b1,backendName:"webgl",kernelFunc:Y8t};const J8t=OI+`
  return min(a, b);
`,Q8t=`
  vec4 result = vec4(min(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+k2+`
  return result;
`,eTt=fr({opSnippet:J8t,packedOpSnippet:Q8t,cpuKernelImpl:G$t}),tTt={kernelName:Ep,backendName:"webgl",kernelFunc:eTt};class nTt{constructor(e,n,s){this.variableNames=["x"],this.outputShape=n.map((c,d)=>c[0]+e[d]+c[1]);const r=e.length,o=jn(r),a=n.map(c=>c[0]).join(","),i=n.map((c,d)=>c[0]+e[d]).join(","),l=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r),u=s==="reflect"?0:1;if(r===1){this.userCode=`
        int start = ${a};
        int end = ${i};

        void main() {
          int outC = getOutputCoords();
          if (outC < start) {
            outC = start * 2 - outC - ${u};
          } else if(outC >= end) {
            outC = (end - 1) * 2 - outC + ${u};
          }
          setOutput(getX(outC - start));
        }
      `;return}this.userCode=`
      ${o} start = ${o}(${a});
      ${o} end = ${o}(${i});

      void main() {
        ${o} outC = getOutputCoords();
        for (int i = 0; i < ${r}; i++) {
          if (outC[i] < start[i]) {
            outC[i] = start[i] * 2 - outC[i] - ${u};
          } else if(outC[i] >= end[i]) {
            outC[i] = (end[i] - 1) * 2 - outC[i] + ${u};
          }
        }
        ${o} coords = outC - start;
        setOutput(getX(${l}));
      }
    `}}class sTt{constructor(e,n,s){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n.map((p,m)=>p[0]+e[m]+p[1]);const r=e.length,o=jn(r),a=n.map(p=>p[0]).join(","),i=n.map((p,m)=>p[0]+e[m]).join(","),l=Ir("rc",r),u=Ir("source",r),c=`${l[r-1]} < ${this.outputShape[r-1]}`,d=r===1?"source":`vec2(${u.slice(-2).join()})`,f=s==="reflect"?0:1;let h="";if(r===1){const p=`
        ${o} source = rc;
        if (source < start) {
          source = start * 2 - source - ${f};
        } else if (source >= end) {
          source = (end - 1) * 2 - source + ${f};
        }
        source -= start;
      `;h=`
        ${o} rc = outputLoc;
        ${p}
        result[0] = getChannel(getX(${u.join()}), ${d});
        ${l[r-1]} += 1;
        if(${c}) {
          ${p}
          result[1] = getChannel(getX(${u.join()}), ${d});
        }
      `}else{const p=`
        ${o} source = rc;
        ${o} lt = ${o}(lessThan(source, start));
        ${o} gte = ${o}(greaterThanEqual(source, end));
        ${o} orig = 1 - (lt + gte);
        source = orig * source +
                lt * (start * 2 - source - ${f}) +
                gte * ((end - 1) * 2 - source + ${f});
        source -= start;
      `;h=`
        ${o} rc = outputLoc;
        ${p}
        result[0] = getChannel(getX(${u.join()}), ${d});
        ${l[r-1]} += 1;
        if(${c}) {
          ${p}
          result[1] = getChannel(getX(${u.join()}), ${d});
        }
        rc = outputLoc;
        ${l[r-2]} += 1;
        if(${l[r-2]} < ${this.outputShape[r-2]}) {
          ${p}
          result[2] = getChannel(getX(${u.join()}), ${d});
          ${l[r-1]} += 1;
          if(${c}) {
            ${p}
            result[3] = getChannel(getX(${u.join()}), ${d});
          }
        }
      `}this.userCode=`
      const ${o} start = ${o}(${a});
      const ${o} end = ${o}(${i});

      void main() {
        ${o} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${h}
        setOutput(result);
      }
    `}}const rTt=({inputs:t,backend:e,attrs:n})=>{const{x:s}=t,{paddings:r,mode:o}=n,a=Be().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new sTt(s.shape,r,o):new nTt(s.shape,r,o);return e.runWebGLProgram(a,[s],s.dtype)},oTt={kernelName:w1,backendName:"webgl",kernelFunc:rTt};const aTt=`if (b == 0.0) return NAN;
  return mod(a, b);`,iTt=`
  vec4 result = mod(a, b);
  bvec4 isNaN = equal(b, vec4(0.0));
  `+k2+`
  return result;
`,lTt=fr({opSnippet:aTt,packedOpSnippet:iTt}),uTt={kernelName:Ap,backendName:"webgl",kernelFunc:lTt};class cTt{constructor(e,n,s){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[e,s],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];

        float r = random(seed);
        float cdf = 0.0;

        for (int i = 0; i < ${n-1}; i++) {
          cdf += getProbs(batch, i);

          if (r < cdf) {
            setOutput(float(i));
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutput(float(${n-1}));
      }
    `}}const dTt=`
if (a == b) {
  return 1.0;
};
return a / b;`,fTt=`
  // vec4 one = vec4(equal(a, b));
  // return one + (vec4(1.0) - one) * a / b;
  vec4 result = a / b;
  if(a.x == b.x) {
    result.x = 1.;
  }
  if(a.y == b.y) {
    result.y = 1.;
  }
  if(a.z == b.z) {
    result.z = 1.;
  }
  if(a.w == b.w) {
    result.w = 1.;
  }

  return result;
`,$j=fr({opSnippet:dTt,packedOpSnippet:fTt,checkOutOfBounds:!0}),hTt={kernelName:mp,backendName:"webgl",kernelFunc:$j};const p9="return a - b;",xj=fr({opSnippet:p9,packedOpSnippet:p9,supportsComplex:!0,cpuKernelImpl:d6t}),pTt={kernelName:Kp,backendName:"webgl",kernelFunc:xj};function Sj(t){const{inputs:e,backend:n,attrs:s}=t,{logits:r}=e,{dim:o}=s,a=un([o],r.shape),i=_j({inputs:{x:r},backend:n,attrs:{reductionIndices:a,keepDims:!1}}),l=ys(i.shape,a),u=bt({inputs:{x:i},backend:n,attrs:{shape:l}}),c=xj({inputs:{a:r,b:u},backend:n}),d=yj({inputs:{x:c},backend:n}),f=n4({inputs:{x:d},backend:n,attrs:{axis:a,keepDims:!1}}),h=bt({inputs:{x:f},backend:n,attrs:{shape:l}}),p=$j({inputs:{a:d,b:h},backend:n});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(h),p}const mTt={kernelName:L1,backendName:"webgl",kernelFunc:Sj};function gTt(t){const{inputs:e,backend:n,attrs:s}=t,{logits:r}=e,{numSamples:o,seed:a,normalized:i}=s,l=i?r:Sj({inputs:{logits:r},backend:n,attrs:{dim:r.shape.length-1}}),u=l.shape[0],c=l.shape[1],d=new cTt(u,c,o),f=[[a]],h=n.runWebGLProgram(d,[l],"int32",f);return i||n.disposeIntermediateTensorInfo(l),h}const vTt={kernelName:i_,backendName:"webgl",kernelFunc:gTt};const yTt=Ea+`
  return -x;
`,bTt=`
  vec4 result = -x;
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;function wTt(t){const{inputs:e,backend:n}=t,{x:s}=e;if(n.shouldExecuteOnCPU([s])){const o=n.texData.get(s.dataId),[a,i]=K$t(o.values,s.shape,s.dtype);return n.makeTensorInfo(i,s.dtype,a)}let r;return Be().getBool("WEBGL_PACK_UNARY_OPERATIONS")?r=new Nu(s.shape,bTt):r=new Ni(s.shape,yTt),n.runWebGLProgram(r,[s],s.dtype)}const _Tt={kernelName:_1,backendName:"webgl",kernelFunc:wTt};const $Tt=y3;function xTt(t){Fo("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:n,attrs:s}=t,{boxes:r,scores:o}=e,{maxOutputSize:a,iouThreshold:i,scoreThreshold:l}=s,u=n.readSync(r.dataId),c=n.readSync(o.dataId),{selectedIndices:d}=$Tt(u,c,a,i,l);return n.makeTensorInfo([d.length],"int32",new Int32Array(d))}const STt={kernelName:l_,backendName:"webgl",kernelFunc:xTt};const CTt=b3;function kTt(t){Fo("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:n,attrs:s}=t,{boxes:r,scores:o}=e,{maxOutputSize:a,iouThreshold:i,scoreThreshold:l,padToMaxOutputSize:u}=s,c=n.readSync(r.dataId),d=n.readSync(o.dataId),{selectedIndices:f,validOutputs:h}=CTt(c,d,a,i,l,u);return[n.makeTensorInfo([f.length],"int32",new Int32Array(f)),n.makeTensorInfo([],"int32",new Int32Array([h]))]}const TTt={kernelName:u_,backendName:"webgl",kernelFunc:kTt};const NTt=w3;function ITt(t){Fo("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:n,attrs:s}=t,{boxes:r,scores:o}=e,{maxOutputSize:a,iouThreshold:i,scoreThreshold:l,softNmsSigma:u}=s,c=n.readSync(r.dataId),d=n.readSync(o.dataId),f=a,h=i,p=l,m=u,{selectedIndices:g,selectedScores:y}=NTt(c,d,f,h,p,m);return[n.makeTensorInfo([g.length],"int32",new Int32Array(g)),n.makeTensorInfo([y.length],"float32",new Float32Array(y))]}const ETt={kernelName:c_,backendName:"webgl",kernelFunc:ITt};class ATt{constructor(e,n,s,r){this.variableNames=["indices"],this.outputShape=[e,n],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int index = round(getIndices(coords.x));
        setOutput(mix(float(${r}), float(${s}),
                      float(index == coords.y)));
      }
    `}}const OTt=t=>{const{inputs:e,backend:n,attrs:s}=t,{indices:r}=e,{dtype:o,depth:a,onValue:i,offValue:l}=s,u=Ge(r.shape),c=new ATt(u,a,i,l),d=bt({inputs:{x:r},backend:n,attrs:{shape:[u]}}),f=n.runWebGLProgram(c,[d],o);n.disposeIntermediateTensorInfo(d);const h=[...r.shape,a],p=bt({inputs:{x:f},backend:n,attrs:{shape:h}});return n.disposeIntermediateTensorInfo(f),p},RTt={kernelName:S1,backendName:"webgl",kernelFunc:OTt};function Cb(t){const{inputs:e,backend:n}=t,{x:s}=e;if(s.dtype==="complex64"){const r=N2({inputs:{input:s},backend:n}),o=Cb({inputs:{x:r},backend:n}),a=s4({inputs:{input:s},backend:n}),i=Cb({inputs:{x:a},backend:n}),l=yc({inputs:{real:o,imag:i},backend:n});return n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(i),l}else return I2({attrs:{shape:s.shape,dtype:s.dtype,value:s.dtype==="string"?"":0},backend:n})}const DTt={kernelName:V1,backendName:"webgl",kernelFunc:Cb};function Cj(t){const{inputs:e,backend:n}=t,{x:s}=e;if(s.dtype==="string")throw new Error("onesLike is not supported under string dtype");if(s.dtype==="complex64"){const r=N2({inputs:{input:s},backend:n}),o=Cj({inputs:{x:r},backend:n}),a=s4({inputs:{input:s},backend:n}),i=Cb({inputs:{x:a},backend:n}),l=yc({inputs:{real:o,imag:i},backend:n});return n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(i),l}else return I2({attrs:{shape:s.shape,dtype:s.dtype,value:1},backend:n})}const FTt={kernelName:x1,backendName:"webgl",kernelFunc:Cj};function MTt(t){const{inputs:e,backend:n,attrs:s}=t,{axis:r}=s;if(e.length===1)return tS({inputs:{input:e[0]},backend:n,attrs:{dim:r}});const o=e[0].shape,a=e[0].dtype;e.forEach(c=>{lr(o,c.shape,"All tensors passed to stack must have matching shapes"),q(a===c.dtype,()=>"All tensors passed to stack must have matching dtypes")});const i=[],l=e.map(c=>{const d=tS({inputs:{input:c},backend:n,attrs:{dim:r}});return i.push(d),d}),u=cj({inputs:l,backend:n,attrs:{axis:r}});return i.forEach(c=>n.disposeIntermediateTensorInfo(c)),u}const PTt={kernelName:C1,backendName:"webgl",kernelFunc:MTt};class LTt{constructor(e,n,s){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=n.map((u,c)=>u[0]+e[c]+u[1]);const r=e.length,o=jn(r),a=n.map(u=>u[0]).join(","),i=n.map((u,c)=>u[0]+e[c]).join(","),l=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r);if(r===1){this.userCode=`
        int start = ${a};
        int end = ${i};

        void main() {
          int outC = getOutputCoords();
          if (outC < start || outC >= end) {
            setOutput(value);
          } else {
            setOutput(getX(outC - start));
          }
        }
      `;return}this.userCode=`
      ${o} start = ${o}(${a});
      ${o} end = ${o}(${i});

      void main() {
        ${o} outC = getOutputCoords();
        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {
          setOutput(value);
        } else {
          ${o} coords = outC - start;
          setOutput(getX(${l}));
        }
      }
    `}}class zTt{constructor(e,n,s){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=n.map((m,g)=>m[0]+e[g]+m[1]);const r=e.length,o=jn(r),a=n.map(m=>m[0]).join(","),i=n.map((m,g)=>m[0]+e[g]).join(","),l=Ir("rc",r),u=Ir("source",r),c=`${l[r-1]} < ${this.outputShape[r-1]}`,d=r===1?"source":`vec2(${u.slice(-2).join()})`,f=[`${o} rc = outputLoc;`,`${l[r-1]} += 1;
       if(${c}) {
      `,r===1?"":`}
       rc = outputLoc;
       ${l[r-2]} += 1;
       if(${l[r-2]} < ${this.outputShape[r-2]}) {`,r===1?"":`  ${l[r-1]} += 1;
         if(${c}) {`],h=r===1?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let p="";for(let m=0,g=r===1?2:4;m<g;m++)p+=`
        ${f[m]}
        if (${h}) {
          result[${m}] = float(value);
        } else {
          ${o} source = rc - start;
          result[${m}] = getChannel(getX(${u.join()}), ${d});
        }
      `;p+=r===1?"} ":"}}",this.userCode=`
      const ${o} start = ${o}(${a});
      const ${o} end = ${o}(${i});

      void main() {
        ${o} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${p}
        setOutput(result);
      }
    `}}const kj=t=>{const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{paddings:o,constantValue:a}=s;if(Ge(r.shape)===0){const u=o.map((c,d)=>c[0]+r.shape[d]+c[1]);return I2({backend:n,attrs:{shape:u,value:a,dtype:r.dtype}})}const i=Be().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new zTt(r.shape,o,a):new LTt(r.shape,o,a),l=[[a]];return n.runWebGLProgram(i,[r],r.dtype,l)},BTt={kernelName:k1,backendName:"webgl",kernelFunc:kj};const VTt=`
  if(a < 0.0 && floor(b) < b){
    return NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  return (round(mod(b, 2.0)) != 1) ?
      pow(abs(a), b) : sign(a) * pow(abs(a), b);
`,HTt=`
  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.
  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));
  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);
  vec4 result = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  bvec4 isExpZero = equal(b, vec4(0.0));
  result.r = isExpZero.r ? 1.0 : result.r;
  result.g = isExpZero.g ? 1.0 : result.g;
  result.b = isExpZero.b ? 1.0 : result.b;
  result.a = isExpZero.a ? 1.0 : result.a;

  bvec4 isNaN1 = lessThan(a, vec4(0.0));
  bvec4 isNaN2 = lessThan(floor(b), b);
  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);
  `+k2+`
  return result;
`,WTt=fr({opSnippet:VTt,packedOpSnippet:HTt}),UTt={kernelName:Rp,backendName:"webgl",kernelFunc:WTt};function GTt(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{axis:o,keepDims:a}=s,i=r.shape.length,l=[],u=un(o,r.shape);let c=u;const d=hs(c,i);let f=r;d!=null&&(f=Fr({inputs:{x:r},backend:n,attrs:{perm:d}}),c=bs(c.length,i),l.push(f)),cr("prod",c,i);let h;if(n.shouldExecuteOnCPU([f])){const p=n.texData.get(f.dataId).values,{outVals:m,outShape:g,outDtype:y}=X$t(f.shape,f.dtype,p,c);h=n.makeTensorInfo(g,y,m)}else{const[p,m]=js(f.shape,c),g=Ge(m),y=bt({inputs:{x:f},backend:n,attrs:{shape:[-1,g]}}),w=F_(r.dtype),b=mf(y,w,"prod",n);h=bt({inputs:{x:b},backend:n,attrs:{shape:p}}),l.push(y),l.push(b)}if(a){l.push(h);const p=ys(h.shape,u);h=bt({inputs:{x:h},backend:n,attrs:{shape:p}})}return l.forEach(p=>n.disposeIntermediateTensorInfo(p)),h}const jTt={kernelName:N1,backendName:"webgl",kernelFunc:GTt};function KTt(t){const{inputs:e,backend:n,attrs:s}=t,{paramsNestedSplits:r,paramsDenseValues:o,indices:a}=e,{outputRaggedRank:i}=s,l=r.map(y=>n.readSync(y.dataId)),u=r.map(y=>y.shape),c=n.readSync(o.dataId),d=n.readSync(a.dataId),[f,h,p]=Y$t(l,u,c,o.shape,o.dtype,d,a.shape,i),m=f.map(y=>n.makeTensorInfo([y.length],"int32",y)),g=n.makeTensorInfo(p,o.dtype,h);return m.concat([g])}const qTt={kernelName:d_,backendName:"webgl",kernelFunc:KTt};function XTt(t){const{inputs:e,backend:n}=t,{starts:s,limits:r,deltas:o}=e,a=n.readSync(s.dataId),i=n.readSync(r.dataId),l=n.readSync(o.dataId),[u,c]=Z$t(a,s.shape,s.dtype,i,r.shape,l,o.shape),d=n.makeTensorInfo([u.length],"int32",u),f=n.makeTensorInfo([c.length],s.dtype,c);return[d,f]}const YTt={kernelName:f_,backendName:"webgl",kernelFunc:XTt};function ZTt(t){const{inputs:e,backend:n,attrs:s}=t,{shape:r,values:o,defaultValue:a,rowPartitionTensors:i}=e,{rowPartitionTypes:l}=s,u=n.readSync(r.dataId),c=n.readSync(o.dataId),d=n.readSync(a.dataId),f=i.map(g=>n.readSync(g.dataId)),h=i.map(g=>g.shape),[p,m]=J$t(u,r.shape,c,o.shape,o.dtype,d,a.shape,f,h,l);return n.makeTensorInfo(p,o.dtype,m)}const JTt={kernelName:h_,backendName:"webgl",kernelFunc:ZTt};const Tj=t=>{const{backend:e,attrs:n}=t,{start:s,stop:r,step:o,dtype:a}=n,i=Q$t(s,r,o,a);return e.makeTensorInfo([i.length],a,i)},QTt={kernelName:p_,backendName:"webgl",kernelFunc:Tj};const eNt="return 1.0 / x;",tNt=xn({opSnippet:eNt}),nNt={kernelName:Dp,backendName:"webgl",kernelFunc:tNt};const sNt=Ea+`
  return (x < 0.0) ? 0.0 : x;
`,rNt=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,oNt=xn({opSnippet:sNt,packedOpSnippet:rNt}),aNt={kernelName:Fp,backendName:"webgl",kernelFunc:oNt};const iNt=Ea+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,lNt=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,uNt=xn({opSnippet:iNt,packedOpSnippet:lNt}),cNt={kernelName:Mp,backendName:"webgl",kernelFunc:uNt};class dNt{constructor(e,n,s,r,o){this.variableNames=["A"],this.outputShape=[];const[a,i,l,u]=e;this.outputShape=[a,n,s,u];const c=[r&&n>1?i-1:i,r&&s>1?l-1:l],d=[r&&n>1?n-1:n,r&&s>1?s-1:s];let f;o?f="(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":f="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${c[0]/d[0]},
          ${c[1]/d[1]});
      const vec2 inputShapeRC = vec2(${i}.0, ${l}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${f};

        // Compute the four integer indices.
        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));
        ivec2 sourceCeilRC = ivec2(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);
        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);
        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);
        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);

        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);

        float top = topLeft + (topRight - topLeft) * fracRC.y;
        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
        float newValue = top + (bottom - top) * fracRC.x;

        setOutput(newValue);
      }
    `}}class fNt{constructor(e,n,s,r,o){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[a,i,l,u]=e;this.outputShape=[a,n,s,u];const c=[r&&n>1?i-1:i,r&&s>1?l-1:l],d=[r&&n>1?n-1:n,r&&s>1?s-1:s];let f;o?f="(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":f="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${c[0]/d[0]},
          ${c[1]/d[1]},
          ${c[1]/d[1]});
      const vec3 inputShapeRC = vec3(${i}.0, ${l}.0,
                                     ${l}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${f};

        // Compute the four integer indices.
        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));
        ivec3 sourceCeilRC = ivec3(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${u-1};
        bool hasNextRow = coords.z < ${s-1};

        // In parallel, construct four corners for all four components in
        // packed 2x2 cell.
        vec4 topLeft = vec4(
          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 bottomLeft = vec4(
          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 topRight = vec4(
          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec4 bottomRight = vec4(
          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);

        vec4 top = mix(topLeft, topRight, fracRC.yyzz);
        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);
        vec4 newValue = mix(top, bottom, fracRC.x);

        setOutput(newValue);
      }
    `}}function hNt(t){const{inputs:e,backend:n,attrs:s}=t,{images:r}=e,{alignCorners:o,halfPixelCenters:a,size:i}=s,[l,u]=i,c=Be().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new fNt(r.shape,l,u,o,a):new dNt(r.shape,l,u,o,a);return n.runWebGLProgram(c,[r],"float32")}const pNt={kernelName:A1,backendName:"webgl",kernelFunc:hNt};class mNt{constructor(e,n,s){this.variableNames=["dy"],this.outputShape=[],this.outputShape=n;const[,r,o]=n,[,a,i]=e,l=[s&&a>1?r-1:r,s&&i>1?o-1:o],u=[s&&a>1?a-1:a,s&&i>1?i-1:i],c=l[0]/u[0],d=l[1]/u[1],f=1/c,h=1/d,p=Math.ceil(f)*2+2,m=Math.ceil(h)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${c});
        const float widthScale = float(${d});

        const float invHeightScale = float(${f});
        const float invWidthScale = float(${h});

        const int winHeight = int(${p});
        const int winWidth = int(${m});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(startRLerp - float(winHeight / 2));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(startCLerp - float(winWidth / 2));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${a}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${i}) {
              continue;
            }

            float dxR = float(dyR) * heightScale;
            int topDxRIndex = int(floor(dxR));
            int bottomDxRIndex = int(min(ceil(dxR), ${r-1}.0));
            float dxRLerp = dxR - float(topDxRIndex);
            float inverseDxRLerp = 1.0 - dxRLerp;

            float dxC = float(dyC) * widthScale;
            int leftDxCIndex = int(floor(dxC));
            int rightDxCIndex = int(min(ceil(dxC), ${o-1}.0));
            float dxCLerp = dxC - float(leftDxCIndex);
            float inverseDxCLerp = 1.0 - dxCLerp;

            if (r == topDxRIndex && c == leftDxCIndex) {
              // topLeft
              accumulator +=
                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
            }

            if (r == topDxRIndex && c == rightDxCIndex) {
              // topRight
              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
            }

            if (r == bottomDxRIndex && c == leftDxCIndex) {
              // bottomLeft
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
            }

            if (r == bottomDxRIndex && c == rightDxCIndex) {
              // bottomRight
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}}function gNt(t){const{inputs:e,backend:n,attrs:s}=t,{images:r,dy:o}=e,{alignCorners:a}=s,i=new mNt(o.shape,r.shape,a);return n.runWebGLProgram(i,[o],o.dtype)}const vNt={kernelName:v_,backendName:"webgl",kernelFunc:gNt};class yNt{constructor(e,n,s,r,o){this.variableNames=["A"],this.outputShape=[];const[a,i,l,u]=e;this.outputShape=[a,n,s,u];const c=[r&&n>1?i-1:i,r&&s>1?l-1:l],d=[r&&n>1?n-1:n,r&&s>1?s-1:s],f=r?"0.5":"0.0";let h;o?h="max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":h="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${c[0]/d[0]},
          ${c[1]/d[1]});
      const vec2 inputShapeRC = vec2(${i}.0, ${l}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${h};

        // Compute the coordinators of nearest neighbor point.
        ivec2 sourceNearestRC = ivec2(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${f})));
        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);

        setOutput(newValue);
      }
    `}}class bNt{constructor(e,n,s,r,o){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[a,i,l,u]=e;this.outputShape=[a,n,s,u];const c=[r&&n>1?i-1:i,r&&s>1?l-1:l],d=[r&&n>1?n-1:n,r&&s>1?s-1:s],f=r?"0.5":"0.0";let h;o?h="max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":h="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${c[0]/d[0]},
          ${c[1]/d[1]},
          ${c[1]/d[1]});
      const vec3 inputShapeRC = vec3(${i}.0, ${l}.0,
                                     ${l}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${h};

        // Compute the coordinators of nearest neighbor point.
        ivec3 sourceNearestRC = ivec3(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${f})));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${u-1};
        bool hasNextRow = coords.z < ${s-1};

        vec4 newValue = vec4(
          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),
          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);

        setOutput(newValue);
      }
    `}}function wNt(t){const{inputs:e,backend:n,attrs:s}=t,{images:r}=e,{alignCorners:o,halfPixelCenters:a,size:i}=s,[l,u]=i,c=Be().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new bNt(r.shape,l,u,o,a):new yNt(r.shape,l,u,o,a);return n.runWebGLProgram(c,[r],r.dtype)}const _Nt={kernelName:E1,backendName:"webgl",kernelFunc:wNt};class $Nt{constructor(e,n,s){this.variableNames=["dy"],this.outputShape=[],this.outputShape=n;const[,r,o]=n,[,a,i]=e,l=[s&&a>1?r-1:r,s&&i>1?o-1:o],u=[s&&a>1?a-1:a,s&&i>1?i-1:i],c=l[0]/u[0],d=l[1]/u[1],f=1/c,h=1/d,p=Math.ceil(f)*2+2,m=Math.ceil(h)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${c});
        const float widthScale = float(${d});

        const float invHeightScale = float(${f});
        const float invWidthScale = float(${h});

        const int winHeight = int(${p});
        const int winWidth = int(${m});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(floor(startRLerp - float(winHeight / 2)));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(floor(startCLerp - float(winWidth / 2)));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${a}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${i}) {
              continue;
            }

            float sourceFracRow =
              float(${l[0]}) *
                (float(dyR) / float(${u[0]}));

            float sourceFracCol =
                float(${l[1]}) *
                  (float(dyC) / float(${u[1]}));

            int sourceNearestRow = int(min(
                float(int(${r}) - 1),
                ${s} ? float(round(sourceFracRow)) :
                                  float(floor(sourceFracRow))));

            int sourceNearestCol = int(min(
                float(int(${o}) - 1),
                ${s} ? float(round(sourceFracCol)) :
                                  float(floor(sourceFracCol))));

            if (r == sourceNearestRow && c == sourceNearestCol) {
              accumulator += getDy(b, dyR, dyC, d);
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}}function xNt(t){const{inputs:e,backend:n,attrs:s}=t,{images:r,dy:o}=e,{alignCorners:a}=s,i=new $Nt(o.shape,r.shape,a);return n.runWebGLProgram(i,[o],o.dtype)}const SNt={kernelName:g_,backendName:"webgl",kernelFunc:xNt};class CNt{constructor(e,n){this.variableNames=["x"];const s=e.length;if(s>4)throw new Error(`WebGL backend: Reverse of rank-${s} tensor is not yet supported`);if(this.outputShape=e,s===1){this.userCode=`
        void main() {
          int coord = getOutputCoords();
          setOutput(getX(${e[0]} - coord - 1));
        }
      `;return}const r=i=>n.indexOf(i)!==-1&&e[i]!==1?`${e[i]} - coords[${i}] - 1`:`coords[${i}]`,o=e.map((i,l)=>r(l)).join(","),a=jn(s);this.userCode=`
      void main() {
        ${a} coords = getOutputCoords();
        setOutput(getX(${o}));
      }
    `}}class kNt{constructor(e,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const s=e.length;if(s>4)throw new Error(`WebGL backend: Reverse of rank-${s} tensor is not yet supported`);this.outputShape=e;const r=Ir("rc",s),o=`${r[s-1]} + 1 < ${this.outputShape[s-1]}`,a=`${r[s-2]} + 1 < ${this.outputShape[s-2]}`,i=jn(s);s===1?this.userCode=`
        void main(){
          int rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = getChannel(getX(${e[0]} - rc - 1),
            ${e[0]} - rc - 1);
          if(${o}){
              result.g = getChannel(getX(${e[0]} - (rc  + 1) - 1),
                ${e[0]} - (rc  + 1) - 1);
          }
          setOutput(result);
        }
      `:this.userCode=`
        void main() {
          ${i} rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = ${l(r.slice())};
          if(${o}){
            result.g = ${u(r.slice())};
          }
          if(${a}) {
            result.b = ${c(r.slice())};
            if(${o}) {
              result.a = ${d(r.slice())};
            }
          }
          setOutput(result);
        }
    `;function l(p){return f(p)}function u(p){return p[s-1]="("+p[s-1]+" + 1)",f(p)}function c(p){return p[s-2]="("+p[s-2]+" + 1)",f(p)}function d(p){return p[s-1]="("+p[s-1]+" + 1)",p[s-2]="("+p[s-2]+" + 1)",f(p)}function f(p){const m=e.map((w,b)=>h(b,p)),g=m.join(","),y=m.slice(-2).join(",");return`getChannel(getX(${g}), vec2(${y}))`}function h(p,m){return n.indexOf(p)!==-1&&e[p]!==1?`${e[p]} - ${m[p]} - 1`:`${m[p]}`}}}function TNt(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{dims:o}=s,a=r.shape.length,i=un(o,r.shape);if(a===0)return Co({inputs:{x:r},backend:n});const l=Be().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new kNt(r.shape,i):new CNt(r.shape,i);return n.runWebGLProgram(l,[r],r.dtype)}const NNt={kernelName:O1,backendName:"webgl",kernelFunc:TNt};class INt{constructor(e,n){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const s=e[1],r=e[2];this.outputShape=e;let o="";typeof n=="number"?o=`float outputValue = ${n.toFixed(2)};`:o=`
        vec3 fill = vec3(${n.join(",")});
        float outputValue = fill[coords[3]];`,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];
          int y = coords[1];
          float coordXFloat = (float(x) - params[0]) * params[3] -
            (float(y) - params[1]) * params[2];
          float coordYFloat = (float(x) - params[0]) * params[2] +
            (float(y) - params[1]) * params[3];
          int coordX = int(round(coordXFloat + params[0]));
          int coordY = int(round(coordYFloat + params[1]));
          ${o}
          if(coordX >= 0 && coordX < ${r} && coordY >= 0 && coordY < ${s}) {
            outputValue = getImage(coords[0], coordY, coordX, coords[3]);
          }
          setOutput(outputValue);
        }
    `}}const ENt={kernelName:R_,backendName:"webgl",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{image:s}=t,{radians:r,fillValue:o,center:a}=e,i=n,l=new INt(s.shape,o),[u,c]=_T(a,s.shape[1],s.shape[2]),d=[[u,c,Math.sin(r),Math.cos(r)]];return i.runWebGLProgram(l,[s],s.dtype,d)}};const ANt=`
  // OpenGL ES does not support round function.
  // The algorithm is based on banker's rounding.
  float base = floor(x);
  if ((x - base) < 0.5) {
    return floor(x);
  } else if ((x - base) > 0.5) {
    return ceil(x);
  } else {
    if (mod(base, 2.0) == 0.0) {
      return base;
    } else {
      return base + 1.0;
    }
  }
`,ONt=xn({opSnippet:ANt}),RNt={kernelName:Pp,backendName:"webgl",kernelFunc:ONt};const DNt="return inversesqrt(x);",FNt=xn({opSnippet:DNt,cpuKernelImpl:e6t}),MNt={kernelName:Lp,backendName:"webgl",kernelFunc:FNt};class Nj{constructor(e,n,s,r,o,a,i=!0){this.variableNames=["updates","indices","defaultValue"],this.outputShape=a;const l=jn(o.length),u=jn(a.length);let c="";s===1?c="i":s===2&&(c="i, j");const d=`getIndices(${c})`;let f="";r===1?f="i":r===2&&(f="i, coords[1]");const h=`getUpdates(${f})`,p=n>1?"strides[j]":"strides";this.userCode=`
        ${l} strides = ${l}(${o});

        void main() {
          ${u} coords = getOutputCoords();
          float sum = 0.0;
          bool found = false;
          for (int i = 0; i < ${e}; i++) {
            int flattenedIndex = 0;
            for (int j = 0; j < ${n}; j++) {
              int index = round(${d});
              flattenedIndex += index * ${p};
            }
            if (flattenedIndex == coords[0]) {
              sum += ${h};
              found = true;
            }
          }
          setOutput(mix(getDefaultValue(), sum, float(found)));
        }
      `}}function PNt(t){const{inputs:e,backend:n,attrs:s}=t,{indices:r,updates:o}=e,{shape:a}=s,{sliceRank:i,numUpdates:l,sliceSize:u,strides:c,outputSize:d}=Jp(o,r,a),f=[d/u,u];if(d===0)return n.makeTensorInfo(a,r.dtype);const h=bt({inputs:{x:r},backend:n,attrs:{shape:[l,i]}}),p=bt({inputs:{x:o},backend:n,attrs:{shape:[l,u]}}),m=n.makeTensorInfo([],"float32",new Float32Array([0])),g=new Nj(l,i,h.shape.length,p.shape.length,c,f),y=n.runWebGLProgram(g,[p,h,m],p.dtype),w=bt({inputs:{x:y},backend:n,attrs:{shape:a}});return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(m),w}const LNt={kernelName:y_,backendName:"webgl",kernelFunc:PNt};class zNt{constructor(e,n,s,r){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[e,s];const o="while (left < right) {",a=`for (int i = 0; i < ${Math.ceil(Math.log2(n+1))}; ++i) { if (left >= right) break;`,i=Be().getNumber("WEBGL_VERSION")===2?o:a,l=r==="left"?"<":"<=";this.userCode=`
       int findBound(int batch, float value) {
         int left = 0;
         int right = numInputs;
         int mid;
         ${i}
           mid = (left + right) / 2;
           if (getSortedSequence(batch, mid) ${l} value) {
             left = mid + 1;
           } else {
             right = mid;
           }
         }
         return right;
       }

       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int valueIndex = coords[1];

         float value = getValues(batch, valueIndex);

         setOutput(float(findBound(batch, value)));
       }
     `}}function BNt(t){const{inputs:e,backend:n,attrs:s}=t,{sortedSequence:r,values:o}=e,{side:a}=s,i=new zNt(r.shape[0],r.shape[1],o.shape[1],a),l=[[r.shape[1]]];return n.runWebGLProgram(i,[r,o],"int32",l)}const VNt={kernelName:b_,backendName:"webgl",kernelFunc:BNt};class HNt{constructor(e,n,s){this.variableNames=["c","a","b"],this.outputShape=n;let r,o;if(s>4)throw Error(`Where for rank ${s} is not yet supported`);if(s===1)o="resRC",r="resRC";else{const i=["resRC.x","resRC.y","resRC.z","resRC.w"],l=[],u=[];for(let c=0;c<n.length;c++)u.push(`${i[c]}`),c<e&&l.push(`${i[c]}`);r=l.join(),o=u.join()}const a=jn(s);this.userCode=`
      void main() {
        ${a} resRC = getOutputCoords();
        float cVal = getC(${r});
        if (cVal >= 1.0) {
          setOutput(getA(${o}));
        } else {
          setOutput(getB(${o}));
        }
      }
    `}}function WNt(t){const{inputs:e,backend:n}=t,{condition:s,t:r,e:o}=e,a=new HNt(s.shape.length,r.shape,r.shape.length);return n.runWebGLProgram(a,[s,r,o],Yr(r.dtype,o.dtype))}const UNt={kernelName:R1,backendName:"webgl",kernelFunc:WNt};const GNt=`
  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.
  // see: https://arxiv.org/abs/1706.02515
  float scaleAlpha = ${N3};
  float scale = ${I3};
  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);
`,jNt=xn({opSnippet:GNt}),KNt={kernelName:zp,backendName:"webgl",kernelFunc:jNt};const qNt=ym+`
  return 1.0 / (1.0 + exp(-1.0 * x));
`,XNt=`
  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,YNt=xn({opSnippet:qNt,packedOpSnippet:XNt,cpuKernelImpl:n6t}),ZNt={kernelName:Wp,backendName:"webgl",kernelFunc:YNt};const JNt=`
  if (isnan(x)) { return 0.0; }
  return sign(x);
`,QNt=xn({opSnippet:JNt}),eIt={kernelName:Hp,backendName:"webgl",kernelFunc:QNt};const tIt=ym+`
  return sin(x);
`,nIt=xn({opSnippet:tIt}),sIt={kernelName:Bp,backendName:"webgl",kernelFunc:nIt};const rIt=`
  float e2x = exp(x);
  return (e2x - 1.0 / e2x) / 2.0;
`,oIt=xn({opSnippet:rIt}),aIt={kernelName:Vp,backendName:"webgl",kernelFunc:oIt};const iIt=`
  float epsilon = 1.1920928955078125e-7;
  float threshold = log(epsilon) + 2.0;

  bool too_large = x > -threshold;
  bool too_small = x < threshold;

  float result;
  float exp_x = exp(x);

  if (too_large){
    result = x;
  }
  else if (too_small){
    result = exp_x;
  }
  else{
    result = log(exp_x + 1.0);
  }
  return result;
`,lIt=xn({opSnippet:iIt}),uIt={kernelName:Up,backendName:"webgl",kernelFunc:lIt};const cIt=t=>{const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{blockShape:o,paddings:a}=s;q(r.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");const i=o.reduce((y,w)=>y*w),l=[[0,0]];l.push(...a);for(let y=1+o.length;y<r.shape.length;++y)l.push([0,0]);const u=[],c=kj({inputs:{x:r},backend:n,attrs:{paddings:l,constantValue:0}}),d=l2(c.shape,o,i,!1),f=u2(d.length,o.length,!1),h=c2(c.shape,o,i,!1),p=bt({inputs:{x:c},backend:n,attrs:{shape:d}}),m=Fr({inputs:{x:p},backend:n,attrs:{perm:f}}),g=bt({inputs:{x:m},backend:n,attrs:{shape:h}});return u.push(c),u.push(p),u.push(m),u.forEach(y=>n.disposeIntermediateTensorInfo(y)),g},dIt={kernelName:M1,backendName:"webgl",kernelFunc:cIt};function fIt(t){const{inputs:e,backend:n}=t,{indices:s,values:r,denseShape:o,defaultValue:a}=e;if(o.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
         ${o.shape}`);if(s.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
         ${s.shape}`);if(r.shape.length!==1)throw new Error(`Values must be a vector, saw:
         ${r.shape}`);if(a.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${a.shape}`);const i=n.readSync(s.dataId),l=n.readSync(r.dataId),u=n.readSync(o.dataId),c=n.readSync(a.dataId)[0],[d,f,h,p,m]=r6t(i,s.shape,s.dtype,l,r.dtype,u,c);return[n.makeTensorInfo(f,s.dtype,d),n.makeTensorInfo([f[0]],r.dtype,h),n.makeTensorInfo([p.length],"bool",new Uint8Array(p.map(g=>Number(g)))),n.makeTensorInfo([m.length],s.dtype,new Int32Array(m))]}const hIt={kernelName:w_,backendName:"webgl",kernelFunc:fIt};function pIt(t){const{inputs:e,backend:n}=t,{inputIndices:s,inputShape:r,newShape:o}=e;if(s.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape ${s.shape}`);if(r.shape.length!==1)throw new Error(`Input shape should be a vector but received shape ${r.shape}`);if(o.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${o.shape}`);const a=Array.from(n.readSync(r.dataId)),i=n.readSync(s.dataId),l=Array.from(n.readSync(o.dataId)),[u,c,d]=o6t(i,s.shape,s.dtype,a,l);return[n.makeTensorInfo(c,s.dtype,u),n.makeTensorInfo([d.length],o.dtype,new Int32Array(d))]}const mIt={kernelName:__,backendName:"webgl",kernelFunc:pIt};function gIt(t){const{inputs:e,backend:n}=t,{data:s,indices:r,segmentIds:o}=e;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.shape.length!==1)throw new Error(`Indices should be a vector but received shape
              ${r.shape}`);if(o.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
              ${o.shape}`);const a=n.readSync(s.dataId),i=n.readSync(r.dataId),l=n.readSync(o.dataId),[u,c]=ZG(a,s.shape,s.dtype,i,l,!0);return n.makeTensorInfo(c,s.dtype,u)}const vIt={kernelName:$_,backendName:"webgl",kernelFunc:gIt};function yIt(t){const{inputs:e,backend:n}=t,{data:s,indices:r,segmentIds:o}=e;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.shape.length!==1)throw new Error(`Indices should be a vector but received shape
             ${r.shape}`);if(o.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
             ${o.shape}`);const a=n.readSync(s.dataId),i=n.readSync(r.dataId),l=n.readSync(o.dataId),[u,c]=ZG(a,s.shape,s.dtype,i,l);return n.makeTensorInfo(c,s.dtype,u)}const bIt={kernelName:x_,backendName:"webgl",kernelFunc:yIt};function wIt(t){const{inputs:e,backend:n,attrs:s}=t,{sparseIndices:r,sparseValues:o,defaultValue:a}=e,{outputShape:i}=s,{sliceRank:l,numUpdates:u,sliceSize:c,strides:d,outputSize:f}=Jp(o,r,i),h=!1;if(o.dtype==="string"){const y=n.bufferSync(r),w=n.bufferSync(o),b=Nl(n.readSync(a.dataId)[0]),_=t6t(y,w,i,f,c,u,l,d,b,h);return n.makeTensorInfo(i,_.dtype,_.values)}const p=new Nj(u,l,r.shape.length,o.shape.length,d,[f,1],h),m=n.runWebGLProgram(p,[o,r,a],o.dtype),g=bt({inputs:{x:m},backend:n,attrs:{shape:i}});return n.disposeIntermediateTensorInfo(m),g}const _It={kernelName:S_,backendName:"webgl",kernelFunc:wIt};function $It(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{numOrSizeSplits:o,axis:a}=s,i=un(a,r.shape)[0],l=MT(r,o,i),u=r.shape.length,c=new Array(u).fill(0),d=r.shape.slice();return l.map(f=>{const h=[...d];h[i]=f;const p=bm({inputs:{x:r},backend:n,attrs:{begin:c,size:h}});return c[i]+=f,p})}const xIt={kernelName:P1,backendName:"webgl",kernelFunc:$It};const m9="return sqrt(x);",SIt=xn({opSnippet:m9,packedOpSnippet:m9,cpuKernelImpl:a6t}),CIt={kernelName:Gp,backendName:"webgl",kernelFunc:SIt};const kIt="return x * x;",TIt=xn({opSnippet:kIt}),NIt={kernelName:C_,backendName:"webgl",kernelFunc:TIt};const g9="return (a - b) * (a - b);",IIt=fr({opSnippet:g9,packedOpSnippet:g9}),EIt={kernelName:jp,backendName:"webgl",kernelFunc:IIt};function AIt({inputs:t,attrs:e,backend:n}){const{x:s}=t,r=Ea+`
    return x > 0.0 ? 1.0 : float(${e.alpha});
  `,o=new Ni(s.shape,r);return n.runWebGLProgram(o,[s],s.dtype)}const OIt={kernelName:Zp,backendName:"webgl",kernelFunc:AIt};class RIt{constructor(e,n,s){this.variableNames=["x"],this.outputShape=s;const r=s.length,o=jn(s.length),a=jn(s.length);let i="";if(r===1)i="coords * strides + begin";else{let l=0;i=s.map((u,c)=>(l++,s.length===1?`coords * strides[${c}] + begin[${c}]`:`coords[${l-1}] * strides[${c}] + begin[${c}]`)).join(",")}this.userCode=`
      ${o} begin = ${o}(${e});
      ${o} strides = ${o}(${n});

      void main() {
        ${a} coords = getOutputCoords();
        setOutput(getX(${i}));
      }
    `}}function DIt(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{begin:o,end:a,strides:i,beginMask:l,endMask:u,ellipsisMask:c,newAxisMask:d,shrinkAxisMask:f}=s,{finalShapeSparse:h,finalShape:p,isIdentity:m,sliceDim0:g,isSimpleSlice:y,begin:w,end:b,strides:_}=p8(r.shape,o,a,i,l,u,c,d,f);let $;if(m)$=bt({inputs:{x:r},backend:n,attrs:{shape:p}});else if(g||y){q(r.shape.length>=1,()=>`Input must have rank at least 1, got: ${r.shape.length}`);const k=d8(w,b,_),C=bm({inputs:{x:r},backend:n,attrs:{begin:w,size:k}});$=bt({inputs:{x:C},backend:n,attrs:{shape:p}}),n.disposeIntermediateTensorInfo(C)}else if(n.shouldExecuteOnCPU([r])){const C=n.readSync(r.dataId),T=tn(r.shape,r.dtype,C),N=i6t(h,T,_,w);$=n.makeTensorInfo(p,r.dtype,N.values)}else{const C=new RIt(w,_,h);$=n.runWebGLProgram(C,[r],r.dtype)}const x=bt({inputs:{x:$},backend:n,attrs:{shape:p}});return n.disposeIntermediateTensorInfo($),x}const FIt={kernelName:k_,backendName:"webgl",kernelFunc:DIt};function MIt(t){const{inputs:e,backend:n,attrs:s}=t,{separator:r,nGramWidths:o,leftPad:a,rightPad:i,padWidth:l,preserveShortSequences:u}=s,{data:c,dataSplits:d}=e,f=n.readSync(c.dataId),h=n.readSync(d.dataId),[p,m]=l6t(f,h,r,o,a,i,l,u);return[n.makeTensorInfo([p.length],"string",p),n.makeTensorInfo(d.shape,"int32",m)]}const PIt={kernelName:T_,backendName:"webgl",kernelFunc:MIt};function LIt(t){const{inputs:e,backend:n,attrs:s}=t,{skipEmpty:r}=s,{input:o,delimiter:a}=e;if(o.dtype!=="string")throw new Error("Input must be of datatype string");if(o.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${o.shape}`);if(a.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${a.shape}`);const i=n.readSync(o.dataId),l=n.readSync(a.dataId)[0],[u,c,d]=u6t(i,l,r),f=c.length;return[n.makeTensorInfo([f,2],"int32",u),n.makeTensorInfo([f],"string",c),n.makeTensorInfo([2],"int32",new Int32Array(d))]}const zIt={kernelName:N_,backendName:"webgl",kernelFunc:LIt};function BIt(t){const{inputs:e,backend:n,attrs:s}=t,{numBuckets:r}=s,{input:o}=e;if(o.dtype!=="string")throw new Error("Input must be of datatype string");if(r<=0)throw new Error("Number of buckets must be at least 1");const a=n.readSync(o.dataId),i=c6t(a,r);return n.makeTensorInfo(o.shape,"int32",i)}const VIt={kernelName:I_,backendName:"webgl",kernelFunc:BIt};const HIt="return tan(x);",WIt=xn({opSnippet:HIt}),UIt={kernelName:qp,backendName:"webgl",kernelFunc:WIt};const GIt=`
  float e2x = exp(-2.0 * abs(x));
  return sign(x) * (1.0 - e2x) / (1.0 + e2x);
`,jIt=xn({opSnippet:GIt}),KIt={kernelName:Xp,backendName:"webgl",kernelFunc:jIt};class qIt{constructor(e,n){this.variableNames=["A"];const s=new Array(e.length);for(let a=0;a<s.length;a++)s[a]=e[a]*n[a];this.outputShape=s,this.rank=s.length;const r=jn(this.rank),o=XIt(e);this.userCode=`
      void main() {
        ${r} resRC = getOutputCoords();
        setOutput(getA(${o}));
      }
    `}}function XIt(t){const e=t.length;if(e>5)throw Error(`Tile for rank ${e} is not yet supported`);if(e===1)return`imod(resRC, ${t[0]})`;const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],s=[];for(let r=0;r<t.length;r++)s.push(`imod(${n[r]}, ${t[r]})`);return s.join()}function Ij(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{reps:o}=s;if(r.dtype==="string"||r.shape.length>5){const l=n.readSync(r.dataId),u=r.dtype==="string"?l.map(f=>Nl(f)):l,c=tn(r.shape,r.dtype,u),d=f6t(c,o);return n.makeTensorInfo(d.shape,d.dtype,d.values)}const a=new qIt(r.shape,o);return n.runWebGLProgram(a,[r],r.dtype)}const YIt={kernelName:Yp,backendName:"webgl",kernelFunc:Ij};class ZIt{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=e,this.userCode=`
       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // We compare elements pair-wise within a group of size 2 * inc.
         // The comparing rule for each group alternates between ascending
         // and descending. Within each group, we compare each pair at
         // positions i and i+inc. To decide whether an element at position i
         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
         // inc, it is in the first half of the group, we denote it as x0,
         // otherwise we denote it as x1.
         // For example, as shown in the Bitonic top K paper referenced above,
         // Figure5(a) shows that element[1] is in the
         // second half of the group when group size is 2, but it is in the
         // first half of the group when group size is 4.

         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;
         int i = isFirstInPair ? elemIdx : elemIdx - inc;

         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));
         float x0 = i0 < n ? getX(batch, i0) : negativeInf;
         float x1 = i1 < n ? getX(batch, i1) : negativeInf;

         // Denotes which direction indices are in (ascending or descending).
         bool reverse = imod(elemIdx, 2 * dir) >= dir;
         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
         if (reverse == isGreater) { // Elements in opposite order of direction
           int iTemp = i0;
           i0 = i1;
           i1 = iTemp;
         }
         if (isFirstInPair) {
            setOutput(float(i0));
         } else {
            setOutput(float(i1));
         }
       }
     `}}class JIt{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=e,this.userCode=`
    void main() {
         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // The output size is half of the previous size.
         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),
         // we only need to output the indices at positions |, the indices at
         // positions _ can be thrown away, see Figure5(b) After Phase 2
         // (Merge phase) in the Bitonic Top K paper referenced above.
         // For example, the paper shows we only need to output the orange bars.
         // The output sequence should look like this | | | | | | | |.
         // Because the sequence is halved, to map the output index back
         // to the previous sequence to find the corresponding value,
         // we need to double the index. When we double the index,
         // we basically interpolate a position, so 2i looks like
         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position
         // of each 2k positions by - elemIdx % k. E.g. for output at
         // index 4,5,6,7, we want to get the corresponding element at
         // original index 8,9,10,11, for output at index 8,9,10,11,
         // we want to get the corresponding element at original index
         // 16,17,18,19, so on and so forth.

         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));
         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));

         float x0 = getX(batch, i0);
         float x1 = i1 < n ? getX(batch, i1) : x0;

         setOutput(x0 >= x1 ? float(i0) : float(i1));
       }
     `}}function Ic(t,e){e!==null&&t.disposeIntermediateTensorInfo(e)}function v9(t){let e=1;for(;e<t;)e*=2;return e}function QIt(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{k:o,sorted:a}=s,i=Be().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),l=Be().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),u=r.shape,c=u[u.length-1];if(n.shouldExecuteOnCPU([r])||c<i||o>l){const N=n.readSync(r.dataId),[M,R]=h6t(N,u,r.dtype,o,a);return[n.makeTensorInfo(M.shape,M.dtype,M.values),n.makeTensorInfo(R.shape,R.dtype,R.values)]}if(o===0)return u[u.length-1]=0,[n.makeTensorInfo(u,r.dtype,[]),n.makeTensorInfo(u,"int32",[])];if(c===1)return[r,I2({attrs:{shape:u,dtype:"int32",value:0},backend:n})];const d=n.texData.get(r.dataId),f=d!==null&&d.isPacked,h=f?n.unpackTensor(r):r,m=Ge(u)/c,g=bt({inputs:{x:h},attrs:{shape:[m,c]},backend:n});f&&Ic(n,h);const y=v9(o),w=v9(c);let b=null;const _=()=>b===null?[g,g]:[g,b],$=(N,M,R)=>{const D=_(),z=new ZIt(R),V=[[c],[b===null?1:0],[Number.NEGATIVE_INFINITY],[N],[M]],O=b;b=n.runWebGLProgram(z,D,"int32",V),Ic(n,O)};for(let N=1;N<y;N*=2){const M=N*2;for(let R=N;R>=1;R/=2)$(M,R,[m,w])}for(let N=w;N>y;N/=2){const M=_(),R=new JIt([m,N/2]),z=[[c],[b===null?1:0],[y]],B=b;b=n.runWebGLProgram(R,M,"int32",z),Ic(n,B);const V=y/2,O=V*2;for(let F=V;F>=1;F/=2)$(O,F,b.shape)}let x=b;b=bm({inputs:{x:b},backend:n,attrs:{begin:0,size:[m,o]}}),Ic(n,x);let k=wj({inputs:{x:g,indices:b},backend:n,attrs:{axis:1,batchDims:1}});Ic(n,g);const C=u.slice(0,-1);C.push(o),x=b,b=bt({inputs:{x:b},attrs:{shape:C},backend:n}),Ic(n,x);const T=k;return k=bt({inputs:{x:k},attrs:{shape:C},backend:n}),Ic(n,T),[k,b]}const eEt={kernelName:E_,backendName:"webgl",kernelFunc:QIt};class tEt{constructor(e,n,s,r,o,a){this.variableNames=["Image","Transforms"],this.outputShape=a;const i=s==="nearest"?1:2;let l;switch(r){case"constant":l=1;break;case"reflect":l=2;break;case"wrap":l=3;break;case"nearest":l=4;break;default:l=1;break}this.userCode=`
            float mapCoord(float outCoord, float len) {
              float inCoord = outCoord;
              if(${l} == 2) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    if (inCoord < sz2) {
                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +
                      inCoord;
                    }
                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    inCoord -= sz2 * float(int(float(inCoord / sz2)));
                    if (inCoord >= len) {
                      inCoord = sz2 - inCoord - 1.0;
                    }
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${l} == 3) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord -= len * float(int(float(inCoord / sz)));
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${l} == 4) {
                return clamp(outCoord, 0.0, len - 1.0);
              } else {
                return outCoord;
              }
            }

            float readWithFillValue(int batch, int coordY, int coordX,
              int channel) {
              float outputValue;
              if (0 <= coordY && coordY < ${e} && 0 <= coordX && coordX < ${n}) {
                  outputValue = getImage(batch, coordY, coordX, channel);
              } else {
                outputValue = float(${o});
              }
              return outputValue;
            }

            void main() {
              ivec4 coords = getOutputCoords();
              float outputValue;
              int batch = coords[0];
              int x = coords[2];
              int y = coords[1];
              int channel = coords[3];
              float xf = float(x);
              float yf = float(y);
              float a1 = getTransforms(batch, 0);
              float a2 = getTransforms(batch, 1);
              float a3 = getTransforms(batch, 2);
              float b1 = getTransforms(batch, 3);
              float b2 = getTransforms(batch, 4);
              float b3 = getTransforms(batch, 5);
              float c1 = getTransforms(batch, 6);
              float c2 = getTransforms(batch, 7);
              float projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = float(${o});
              } else {
                float inX = (a1 * xf + a2 * yf + a3) / projection;
                float inY = (b1 * xf + b2 * yf + b3) / projection;
                float mapX = mapCoord(inX, float(${n}));
                float mapY = mapCoord(inY, float(${e}));

                if (${i} == 1) {
                  int coordY = int(round(mapY));
                  int coordX = int(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  float yFloor = floor(mapY);
                  float xFloor = floor(mapX);
                  float yCeil = yFloor + 1.0;
                  float xCeil = xFloor + 1.0;
                  float valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);
                  float valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutput(outputValue);
            }
        `}}function nEt(t){const{inputs:e,backend:n,attrs:s}=t,{image:r,transforms:o}=e,{interpolation:a,fillMode:i,fillValue:l,outputShape:u}=s,[c,d,f,h]=r.shape,[p,m]=u??[d,f],g=[c,p,m,h],y=new tEt(d,f,a,i,l,g);return n.runWebGLProgram(y,[r,o],"float32")}const sEt={kernelName:A_,backendName:"webgl",kernelFunc:nEt};function rEt(t){const{inputs:e,attrs:n,backend:s}=t,{axis:r}=n,{x:o}=e;S2(o,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const a=s.readSync(o.dataId),{outputValues:i,outputShape:l,indices:u}=p6t(a,r,o.shape,o.dtype);return[s.makeTensorInfo(l,o.dtype,i),s.makeTensorInfo([u.length],"int32",u)]}const oEt={kernelName:O_,backendName:"webgl",kernelFunc:rEt};function aEt(t){const{inputs:e,backend:n,attrs:s}=t,{value:r}=e;let{axis:o}=s;o<0&&(o+=r.shape.length);const a=r,i=a.shape.length,l=r.shape[o],u=new Array(i-1);let c=0;for(let m=0;m<i;m++)m!==o&&(u[c++]=a.shape[m]);const d=[],f=new Array(i).fill(0),h=a.shape.slice();h[o]=1;const p=new Array(l);for(let m=0;m<p.length;m++){f[o]=m;const g=bm({inputs:{x:a},backend:n,attrs:{begin:f,size:h}}),y=bt({inputs:{x:g},backend:n,attrs:{shape:u}});p[m]=y,d.push(g)}return d.forEach(m=>n.disposeIntermediateTensorInfo(m)),p}const iEt={kernelName:z1,backendName:"webgl",kernelFunc:aEt};class lEt{constructor(e,n){this.variableNames=["x","segmentIds"];const s=e.windowSize,r=e.batchSize,o=e.inSize,a=e.numSegments,i=a*Math.ceil(o/s);this.outputShape=[r,i];const l="0.0",u="sumValue",c=Math.floor(s/4)*4,d=s%4,f=`
        sumValue += dot(values, segFilter);
    `;let h="";o%s>0&&(h=`
        if (inIdx < 0 || inIdx >= ${o}) {
          return initializationValue;
        }
      `);let p="";o%s>0&&(p=`
        if (inIdx < 0 || inIdx >= ${o}) {
          return -1.0;
        }
      `),this.userCode=`
      const float initializationValue = ${l};

      float getValue(int batch, int inIdx) {
        ${h}
        return getX(batch, inIdx);
      }

      float getSegmentIdAtIndex(int inIdx) {
        ${p}
        return getSegmentIds(inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = int(floor(float(outIdx) / float(
          ${a})) * float(${s}));
        int currentSeg = int(mod(float(outIdx), float(${a})));

        float sumValue = 0.0;

        for (int i = 0; i < ${c}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0
          );

          ${f}
        }

        int inIdx = inOffset + ${c};
        if (${d===1}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            0,
            0,
            0
          );

          ${f}
        } else if (${d===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
              0,
              0
          );

          ${f}
        } else if (${d===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            0
          );

          ${f}
        }
        setOutput(${u});
      }
    `}}function uEt(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,segmentIds:o}=e,{numSegments:a}=s,i=r.shape.length,l=[];let u=0;const c=hs([u],i);let d=r;c!=null&&(d=Fr({inputs:{x:r},backend:n,attrs:{perm:c}}),l.push(d),u=bs(1,i)[0]);const f=YH(d.shape,u,a),h=Ge([d.shape[u]]),p=bt({inputs:{x:d},backend:n,attrs:{shape:[-1,h]}});l.push(p);const m=F_(r.dtype),g=(_,$,x,k,C)=>{const T=_.shape[0],N=_.shape[1],M=XH(N,C),R={windowSize:M,inSize:N,batchSize:T,numSegments:C},D=new lEt(R,$),z=n.compileAndRun(D,[_,x],k);if(l.push(z),z.shape[1]===C)return z;const B=Tj({backend:n,attrs:{start:0,stop:C,step:1,dtype:"float32"}}),V=Ij({inputs:{x:B},backend:n,attrs:{reps:[N/M]}});return l.push(B),l.push(V),g(z,$,V,k,C)},y=g(p,"unsortedSegmentSum",o,m,a),w=bt({inputs:{x:y},backend:n,attrs:{shape:f}});let b=w;if(c!=null){l.push(w);const _=pc(c);b=Fr({inputs:{x:b},backend:n,attrs:{perm:_}})}return l.forEach(_=>n.disposeIntermediateTensorInfo(_)),b}const cEt={kernelName:B1,backendName:"webgl",kernelFunc:uEt};const dEt=[axt,lxt,dxt,pxt,gxt,bxt,_xt,xxt,Txt,Ixt,Oxt,Fxt,Lxt,Hxt,Gxt,Kxt,Xxt,Qxt,tSt,sSt,iSt,pSt,gSt,ySt,SSt,kSt,ESt,W6t,RSt,LSt,HSt,qSt,YSt,JSt,eCt,nCt,oCt,lCt,dCt,hCt,mCt,vCt,wCt,$Ct,kCt,NCt,ACt,DCt,MCt,BCt,UCt,qCt,ZCt,ekt,tkt,skt,okt,ikt,ukt,dkt,mkt,ykt,_kt,xkt,kkt,Ikt,Rkt,Pkt,H6t,zkt,MSt,Hkt,Gkt,qkt,G6t,Jkt,n8t,r8t,l8t,d8t,m8t,y8t,$8t,k8t,I8t,A8t,F8t,P8t,z8t,W8t,G8t,K8t,X8t,Z8t,tTt,oTt,uTt,vTt,q6t,_Tt,STt,TTt,ETt,wSt,RTt,FTt,PTt,BTt,UTt,K6t,jTt,qTt,YTt,JTt,QTt,_St,hTt,nNt,aNt,cNt,Y6t,pNt,vNt,_Nt,SNt,NNt,ENt,RNt,MNt,LNt,VNt,UNt,KNt,ZNt,eIt,sIt,aIt,fSt,mTt,uIt,dIt,hIt,mIt,vIt,bIt,_It,xIt,CIt,NIt,EIt,OIt,FIt,PIt,zIt,VIt,pTt,sxt,UIt,KIt,YIt,eEt,sEt,rxt,oEt,iEt,cEt,DTt];for(const t of dEt)D_(t);const fEt="4.1.0";const hEt={"tfjs-core":wV,"tfjs-backend-cpu":wvt,"tfjs-backend-webgl":V6t,"tfjs-data":EU,"tfjs-layers":H3,"tfjs-converter":pU,tfjs:fEt},pEt=Object.freeze(Object.defineProperty({__proto__:null,data:f2t,version:hEt,AdadeltaOptimizer:_3,AdagradOptimizer:$3,AdamOptimizer:x3,AdamaxOptimizer:S3,MomentumOptimizer:C3,Optimizer:eu,OptimizerConstructors:pu,RMSPropOptimizer:k3,SGDOptimizer:i2,Tensor:$n,TensorBuffer:Ds,Variable:eg,get Rank(){return fx},sumOutType:F_,upcastType:Yr,get Reduction(){return Tr},customGrad:Hi,grad:xit,grads:Sit,valueAndGrad:Cit,valueAndGrads:kit,variableGrads:EV,Environment:CB,env:Be,get ENV(){return Uk},nextFrame:yT,KernelBackend:Nw,DataStorage:zk,abs:$s,acos:v8,acosh:y8,add:st,addN:_V,all:V_,any:sg,argMax:Od,argMin:b8,asin:w8,asinh:_8,atan:$8,atan2:x8,atanh:S8,avgPool:j1,avgPool3d:k8,basicLSTMCell:$V,batchToSpaceND:K1,batchNorm:Qp,batchNorm2d:T8,batchNorm3d:N8,batchNorm4d:I8,bincount:E8,broadcastArgs:xV,broadcastTo:cd,buffer:tn,cast:ht,ceil:A8,clipByValue:Zr,clone:Ri,complex:El,concat:vs,concat1d:O8,concat2d:R8,concat3d:D8,concat4d:F8,conv1d:H_,conv2d:Al,conv2dTranspose:W_,conv3d:P8,conv3dTranspose:L8,cos:q1,cosh:U_,cumprod:rg,cumsum:G_,denseBincount:ob,depthToSpace:z8,depthwiseConv2d:em,diag:CV,dilation2d:B8,div:Et,divNoNan:V8,dot:H8,einsum:kV,elu:tm,equal:_o,erf:W8,euclideanNorm:G8,exp:$o,expandDims:hr,expm1:j8,eye:j_,fill:of,floor:sm,floorDiv:B_,gather:rm,greater:Pr,greaterEqual:Zl,imag:U1,isFinite:K8,isInf:q8,isNaN:X8,leakyRelu:X1,less:K_,lessEqual:mc,linspace:IV,localResponseNormalization:Y8,log:xo,log1p:Y1,logSigmoid:Z8,logSoftmax:X_,logSumExp:Y_,logicalAnd:Ta,logicalNot:Z1,logicalOr:Z_,logicalXor:J8,lowerBound:AV,matMul:ln,max:Go,maxPool:J1,maxPool3d:Q8,maxPoolWithArgmax:OV,maximum:Zi,mean:us,meshgrid:RV,min:kh,minimum:om,mirrorPad:eT,mod:tT,moments:Q1,mul:Te,multiRNNCell:DV,multinomial:FV,neg:Jn,notEqual:Dd,oneHot:Sh,ones:po,onesLike:So,outerProduct:MV,pad:Jl,pad1d:PV,pad2d:LV,pad3d:zV,pad4d:BV,pool:nT,pow:Ol,prelu:t2,print:n8,prod:sT,raggedGather:VV,raggedRange:HV,raggedTensorToTensor:WV,rand:UV,randomGamma:JV,randomNormal:Q_,randomStandardNormal:QV,randomUniform:am,range:Fd,real:Ch,reciprocal:oT,relu:li,relu6:e3,reshape:Ne,reverse:Xo,reverse1d:eH,reverse2d:tH,reverse3d:nH,reverse4d:sH,round:t3,rsqrt:n3,scalar:Pt,selu:s3,separableConv2d:r3,setdiff1dAsync:rH,sigmoid:qa,sign:aT,sin:o3,sinh:a3,slice:mn,slice1d:n2,slice2d:i3,slice3d:s2,slice4d:Th,softmax:r2,softplus:af,spaceToBatchND:e2,fft:o2,ifft:Nh,irfft:l3,rfft:a2,split:Kr,sqrt:ar,square:Dn,squaredDifference:u3,squeeze:gc,stack:Jr,step:uf,stridedSlice:iT,sub:$t,sum:kt,tan:lT,tanh:Rd,tensor:yo,tensor1d:vr,tensor2d:Mu,tensor3d:i8,tensor4d:oH,tensor5d:aH,tensor6d:iH,tile:Lo,topk:uT,truncatedNormal:c3,unique:cT,unsortedSegmentSum:d3,unstack:Yo,upperBound:lH,variable:dT,where:wr,whereAsync:fT,zeros:xs,zerosLike:yn,op:be,OP_SCOPE_SUFFIX:Yk,booleanMaskAsync:uH,transpose:dn,norm:nm,movingAverage:cH,scatterND:dH,searchSorted:J_,sparseToDense:fH,gatherND:hH,dropout:hT,enclosingPowerOfTwo:pT,cosineWindow:h3,inTopKAsync:pH,image:Ti,linalg:vT,losses:CH,spectral:xH,fused:yH,signal:SH,sparse:kH,string:TH,train:Dc,enableProdMode:Grt,enableDebugMode:jrt,disableDeprecationWarnings:Krt,deprecationWarn:qrt,disposeVariables:Xrt,engine:Ma,memory:sb,profile:Yrt,tidy:Le,dispose:Xt,keep:As,time:Zrt,setBackend:Jrt,ready:Qrt,getBackend:eot,removeBackend:tot,findBackend:not,findBackendFactory:sot,registerBackend:a8,backend:aV,setPlatform:rot,getKernel:Zy,getGradient:ux,getKernelsForBackend:Jy,registerKernel:D_,registerGradient:IB,unregisterKernel:Cst,unregisterGradient:kst,copyRegisteredKernels:Tst,Abs:Vg,Acos:sp,Acosh:rp,Add:nf,AddN:Hg,All:Aw,Any:Ow,ArgMax:Wg,ArgMin:Ug,Asin:op,Asinh:ap,Atan:ip,Atanh:lp,Atan2:up,AvgPool:Gg,AvgPoolGrad:Rw,AvgPool3D:jg,AvgPool3DGrad:Dw,BatchMatMul:Kg,BatchToSpaceND:qg,Bincount:Fw,BroadcastTo:TB,BroadcastArgs:Mw,Cast:cp,Ceil:dp,ClipByValue:fp,Complex:Pw,ComplexAbs:Xg,Concat:Yg,Conv2D:Zg,Conv2DBackpropFilter:Lw,Conv2DBackpropInput:Jg,Conv3D:Qg,Conv3DBackpropFilterV2:zw,Conv3DBackpropInputV2:Bw,Cos:hp,Cosh:pp,Cumprod:Vw,Cumsum:e1,CropAndResize:Hw,DenseBincount:Ww,DepthToSpace:Uw,DepthwiseConv2dNative:t1,DepthwiseConv2dNativeBackpropFilter:Gw,DepthwiseConv2dNativeBackpropInput:jw,Diag:Kw,Dilation2D:n1,Dilation2DBackpropInput:qy,Dilation2DBackpropFilter:Xy,RealDiv:mp,Einsum:qw,Elu:gp,EluGrad:Xw,Erf:vp,Equal:s1,Exp:yp,ExpandDims:r1,Expm1:bp,FFT:Yw,Fill:Zw,FlipLeftRight:Jw,Floor:wp,FloorDiv:_p,FusedBatchNorm:o1,GatherV2:a1,GatherNd:Qw,Greater:i1,GreaterEqual:$p,Identity:xp,IFFT:e_,Imag:t_,IsFinite:Sp,IsInf:Cp,IsNan:kp,LeakyRelu:l1,Less:u1,LessEqual:c1,LinSpace:n_,Log:Tp,Log1p:Np,LogicalAnd:d1,LogicalNot:f1,LogicalOr:h1,LogicalXor:wst,LogSoftmax:NB,LowerBound:_st,LRN:p1,LRNGrad:s_,Max:m1,Maximum:Ip,MaxPool:g1,MaxPoolGrad:r_,MaxPool3D:v1,MaxPool3DGrad:o_,MaxPoolWithArgmax:a_,Mean:y1,Min:b1,Minimum:Ep,MirrorPad:w1,Mod:Ap,Multinomial:i_,Multiply:Op,Neg:_1,NotEqual:$1,NonMaxSuppressionV3:l_,NonMaxSuppressionV4:u_,NonMaxSuppressionV5:c_,OnesLike:x1,OneHot:S1,Pack:C1,PadV2:k1,Pool:$st,Pow:Rp,Prelu:T1,Prod:N1,RaggedGather:d_,RaggedRange:f_,RaggedTensorToTensor:h_,Range:p_,Real:m_,Reciprocal:Dp,Relu:Fp,Reshape:I1,ResizeNearestNeighbor:E1,ResizeNearestNeighborGrad:g_,ResizeBilinear:A1,ResizeBilinearGrad:v_,Relu6:Mp,Reverse:O1,Round:Pp,Rsqrt:Lp,ScatterNd:y_,SearchSorted:b_,Select:R1,Selu:zp,Slice:D1,Sin:Bp,Sinh:Vp,Sign:Hp,Sigmoid:Wp,Softplus:Up,Sqrt:Gp,Sum:F1,SpaceToBatchND:M1,SplitV:P1,Softmax:L1,SparseFillEmptyRows:w_,SparseReshape:__,SparseSegmentMean:$_,SparseSegmentSum:x_,SparseToDense:S_,SquaredDifference:jp,Square:C_,StridedSlice:k_,StringNGrams:T_,StringSplit:N_,StringToHashBucketFast:I_,Sub:Kp,Tan:qp,Tanh:Xp,Tile:Yp,TopK:E_,Transform:A_,Transpose:ld,Unique:O_,Unpack:z1,UnsortedSegmentSum:B1,UpperBound:xst,ZerosLike:V1,Step:Zp,FromPixels:Yy,RotateWithOffset:R_,_FusedMatMul:Y0,FusedConv2D:Z0,FusedDepthwiseConv2D:J0,version_core:wV,browser:bot,io:o8,math:dot,serialization:kot,test_util:Mot,util:Dst,backend_util:JH,broadcast_util:fot,tensor_util:jst,slice_util:vV,gather_util:wot,scatter_util:_ot,device_util:Zst,kernel_impls:tdt,CallbackList:mW,CustomCallback:vW,History:gW,Callback:lU,callbacks:tgt,EarlyStopping:uU,InputSpec:Ss,SymbolicTensor:Ga,LayersModel:yl,input:AW,loadLayersModel:Xpt,model:Jpt,registerCallbackConstructor:emt,sequential:Qpt,RNN:ci,Sequential:Ld,LayerVariable:dW,version_layers:H3,constraints:Ght,initializers:ipt,layers:O0t,metrics:q0t,models:X0t,regularizers:Q0t,GraphModel:hI,loadGraphModel:T1t,loadGraphModelSync:N1t,deregisterOp:rgt,registerOp:sgt,version_converter:pU},Symbol.toStringTag,{value:"Module"})),FI=Mg(pEt);const mEt=1e-7,gEt=1e-4;class vEt{constructor(e,n){this.backend=e,this.dataMover=n,this.data=new WeakMap,this.dataIdsCount=0}get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,n){this.dataIdsCount++,this.data.set(e,n)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}}class Ej{refCount(e){return Ao("refCount")}incRef(e){return Ao("incRef")}timerAvailable(){return!0}time(e){return Ao("time")}read(e){return Ao("read")}readSync(e){return Ao("readSync")}readToGPU(e,n){return Ao("readToGPU")}numDataIds(){return Ao("numDataIds")}disposeData(e,n){return Ao("disposeData")}write(e,n,s){return Ao("write")}move(e,n,s,r,o){return Ao("move")}memory(){return Ao("memory")}floatPrecision(){return Ao("floatPrecision")}epsilon(){return this.floatPrecision()===32?mEt:gEt}dispose(){return Ao("dispose")}}function Ao(t){throw new Error(`'${t}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}function Aj(t){let e=t.length,n=0;for(;e>0;)n=Math.random()*e|0,e--,kb(t,e,n)}function yEt(t,e){if(t.length!==e.length)throw new Error(`Array sizes must match to be shuffled together First array length was ${t.length}Second array length was ${e.length}`);let n=t.length,s=0;for(;n>0;)s=Math.random()*n|0,n--,kb(t,n,s),kb(e,n,s)}function fg(t,e,n){return Math.max(t,Math.min(e,n))}function bEt(t){return t%2===0?t:t+1}function kb(t,e,n){const s=t[e];t[e]=t[n],t[n]=s}function wEt(t){let e=0;for(let n=0;n<t.length;n++)e+=t[n];return e}function _Et(t,e){const n=Math.random();return e*n+(1-n)*t}function $Et(t,e){let n=0;for(let s=0;s<t.length;s++){const r=Number(t[s])-Number(e[s]);n+=r*r}return n}function le(t,e){if(!t)throw new Error(typeof e=="string"?e:e())}function Br(t,e,n=""){le(Ui(t,e),()=>n+` Shapes ${t} and ${e} must match`)}function gf(t){le(t!=null,()=>"The input to the tensor constructor must be a non-null value.")}function Vd(t,e=[],n=!1){if(e==null&&(e=[]),Array.isArray(t)||pr(t)&&!n)for(let s=0;s<t.length;++s)Vd(t[s],e,n);else e.push(t);return e}function Qn(t){if(t.length===0)return 1;let e=t[0];for(let n=1;n<t.length;n++)e*=t[n];return e}function xEt(t){return t.length===0}function Ui(t,e){if(t===e)return!0;if(t==null||e==null||t.length!==e.length)return!1;for(let n=0;n<t.length;n++)if(t[n]!==e[n])return!1;return!0}function zh(t){return t%1===0}function SEt(t){if(Math.tanh!=null)return Math.tanh(t);if(t===1/0)return 1;if(t===-1/0)return-1;{const e=Math.exp(2*t);return(e-1)/(e+1)}}function CEt(t){const e=Math.ceil(Math.sqrt(t));return[e,Math.ceil(t/e)]}function kEt(t){const e=new Uint32Array(t);for(let n=0;n<t;++n)e[n]=n;return Aj(e),e}function g0(t,e){return e<=t.length?t:t+" ".repeat(e-t.length)}function TEt(t,e=r=>0,n,s=setTimeout){return new Promise((r,o)=>{let a=0;const i=()=>{if(t()){r();return}a++;const l=e(a);if(n!=null&&a>=n){o();return}s(i,l)};i()})}function NEt(t,e){let n=1,s=-1;for(let o=0;o<t.length;++o)if(t[o]>=0)n*=t[o];else if(t[o]===-1){if(s!==-1)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${s} and dim ${o}`);s=o}else if(t[o]<0)throw Error(`Shapes can not be < 0. Found ${t[o]} at dim ${o}`);if(s===-1){if(e>0&&e!==n)throw Error(`Size(${e}) must match the product of shape ${t}`);return t}if(n===0)throw Error(`Cannot infer the missing size in [${t}] when there are 0 elements`);if(e%n!==0)throw Error(`The implicit shape can't be a fractional number. Got ${e} / ${n}`);const r=t.slice();return r[s]=e/n,r}function E2(t,e){const n=e.length;return t=t==null?e.map((s,r)=>r):[].concat(t),le(t.every(s=>s>=-n&&s<n),()=>`All values in axis param must be in range [-${n}, ${n}) but got axis ${t}`),le(t.every(s=>zh(s)),()=>`All values in axis param must be integers but got axis ${t}`),t.map(s=>s<0?n+s:s)}function Oj(t,e){const n=[],s=[],r=e!=null&&Array.isArray(e)&&e.length===0,o=e==null||r?null:E2(e,t).sort();let a=0;for(let i=0;i<t.length;++i){if(o!=null){if(o[a]===i&&t[i]!==1)throw new Error(`Can't squeeze axis ${i} since its dim '${t[i]}' is not 1`);(o[a]==null||o[a]>i)&&t[i]===1&&(n.push(t[i]),s.push(i)),o[a]<=i&&a++}t[i]!==1&&(n.push(t[i]),s.push(i))}return{newShape:n,keptDims:s}}function Rj(t,e){let n=null;if(t==null||t==="float32")n=new Float32Array(e);else if(t==="int32")n=new Int32Array(e);else if(t==="bool")n=new Uint8Array(e);else throw new Error(`Unknown data type ${t}`);return n}function Dj(t,e){let n=null;if(t==null||t==="float32")n=new Float32Array(e);else if(t==="int32")n=new Int32Array(e);else if(t==="bool")n=new Uint8Array(e);else if(t==="string")n=new Array(e);else throw new Error(`Unknown data type ${t}`);return n}function Fj(t,e){for(let n=0;n<t.length;n++){const s=t[n];if(isNaN(s)||!isFinite(s))throw Error(`A tensor of type ${e} being uploaded contains ${s}.`)}}function Mj(t){return t==="bool"||t==="complex64"||t==="float32"||t==="int32"||t==="string"}function IEt(t,e){return!(e==="complex64"||e==="float32"&&t!=="complex64"||e==="int32"&&t!=="float32"&&t!=="complex64"||e==="bool"&&t==="bool")}function pr(t){return t instanceof Float32Array||t instanceof Int32Array||t instanceof Uint8Array||t instanceof Uint8ClampedArray}function nS(t){if(t==="float32"||t==="int32")return 4;if(t==="complex64")return 8;if(t==="bool")return 1;throw new Error(`Unknown dtype ${t}`)}function Pj(t){if(t==null)return 0;let e=0;return t.forEach(n=>e+=n.length),e}function Iu(t){return typeof t=="string"||t instanceof String}function Lj(t){return typeof t=="boolean"}function zj(t){return typeof t=="number"}function r4(t){return Array.isArray(t)?r4(t[0]):t instanceof Float32Array?"float32":t instanceof Int32Array||t instanceof Uint8Array||t instanceof Uint8ClampedArray?"int32":zj(t)?"float32":Iu(t)?"string":Lj(t)?"bool":"float32"}function sc(t){return!!(t&&t.constructor&&t.call&&t.apply)}function Tb(t,e){for(let n=e;n<t;++n)if(t%n===0)return n;return t}function wm(t){const e=t.length;if(e<2)return[];const n=new Array(e-1);n[e-2]=t[e-1];for(let s=e-3;s>=0;--s)n[s]=n[s+1]*t[s+1];return n}function Bj(t,e,n,s=!1){const r=new Array;if(e.length===1){const o=e[0]*(s?2:1);for(let a=0;a<o;a++)r[a]=n[t+a]}else{const o=e[0],a=e.slice(1),i=a.reduce((l,u)=>l*u)*(s?2:1);for(let l=0;l<o;l++)r[l]=Bj(t+l*i,a,n,s)}return r}function hd(t,e,n=!1){if(t.length===0)return e[0];const s=t.reduce((r,o)=>r*o)*(n?2:1);if(s===0)return[];if(s!==e.length)throw new Error(`[${t}] does not match the input size ${e.length}${n?" for a complex tensor":""}.`);return Bj(0,t,e,n)}function MI(t,e){const n=o4(t,e);for(let s=0;s<n.length;s++)n[s]=1;return n}function o4(t,e){if(e==null||e==="float32"||e==="complex64")return new Float32Array(t);if(e==="int32")return new Int32Array(t);if(e==="bool")return new Uint8Array(t);throw new Error(`Unknown data type ${e}`)}function EEt(t,e){const n=t.reduce((s,r)=>s*r,1);if(e==null||e==="float32")return hd(t,new Float32Array(n));if(e==="int32")return hd(t,new Int32Array(n));if(e==="bool")return hd(t,new Uint8Array(n));throw new Error(`Unknown data type ${e}`)}function PI(t){t.forEach(e=>{le(Number.isInteger(e)&&e>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${t}].`)})}function AEt(t,e,n){if(e===0)return 0;if(e===1)return t[0];let s=t[t.length-1];for(let r=0;r<t.length-1;++r)s+=n[r]*t[r];return s}function OEt(t,e,n){if(e===0)return[];if(e===1)return[t];const s=new Array(e);for(let r=0;r<s.length-1;++r)s[r]=Math.floor(t/n[r]),t-=s[r]*n[r];return s[s.length-1]=t,s}function Hd(t){return t&&t.then&&typeof t.then=="function"}const y9="tfjsflags";class Vj{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=REt,this.populateURLFlags()}setPlatform(e,n){this.platform!=null&&(en().getBool("IS_TEST")||en().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${e}.`)),this.platformName=e,this.platform=n}registerFlag(e,n,s){if(this.flagRegistry[e]={evaluationFn:n,setHook:s},this.urlFlags[e]!=null){const r=this.urlFlags[e];en().getBool("IS_TEST")||en().getBool("PROD")||console.warn(`Setting feature override from URL ${e}: ${r}.`),this.set(e,r)}}async getAsync(e){return e in this.flags?this.flags[e]:(this.flags[e]=await this.evaluateFlag(e),this.flags[e])}get(e){if(e in this.flags)return this.flags[e];const n=this.evaluateFlag(e);if(Hd(n))throw new Error(`Flag ${e} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[e]=n,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,n){if(this.flagRegistry[e]==null)throw new Error(`Cannot set flag ${e} as it has not been registered.`);this.flags[e]=n,this.flagRegistry[e].setHook!=null&&this.flagRegistry[e].setHook(n)}evaluateFlag(e){if(this.flagRegistry[e]==null)throw new Error(`Cannot evaluate flag '${e}': no evaluation function found.`);return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global>"u"||typeof this.global.location>"u"||typeof this.global.location.search>"u")return;const e=this.getQueryParams(this.global.location.search);y9 in e&&e[y9].split(",").forEach(s=>{const[r,o]=s.split(":");this.urlFlags[r]=FEt(r,o)})}}function REt(t){const e={};return t.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(n,...s)=>(DEt(e,s[0],s[1]),s.join("="))),e}function DEt(t,e,n){t[decodeURIComponent(e)]=decodeURIComponent(n||"")}function FEt(t,e){if(e=e.toLowerCase(),e==="true"||e==="false")return e==="true";if(`${+e}`===e)return+e;throw new Error(`Could not parse value flag value ${e} for flag ${t}.`)}function en(){return LI}let LI=null;function MEt(t){LI=t}let R$;function Hj(){if(R$==null){let t;if(typeof window<"u")t=window;else if(typeof global<"u")t=global;else if(typeof process<"u")t=process;else if(typeof self<"u")t=self;else throw new Error("Could not find a global object");R$=t}return R$}function PEt(){const t=Hj();return t._tfGlobals==null&&(t._tfGlobals=new Map),t._tfGlobals}function zI(t,e){const n=PEt();if(n.has(t))return n.get(t);{const s=e();return n.set(t,s),n.get(t)}}const Wj="Abs",Uj="Acos",Gj="Acosh",BI="Add",jj="AddN",Kj="All",qj="Any",Xj="ArgMax",Yj="ArgMin",Zj="Asin",Jj="Asinh",Qj="Atan",eK="Atanh",tK="Atan2",nK="AvgPool",LEt="AvgPoolGrad",sK="AvgPool3D",zEt="AvgPool3DGrad",rK="BatchMatMul",oK="BatchToSpaceND",aK="Bincount",BEt="BroadcastTo",iK="BroadcastArgs",VI="Cast",lK="Ceil",uK="ClipByValue",cK="Complex",dK="ComplexAbs",fK="Concat",hK="Conv2D",pK="Conv2DBackpropFilter",mK="Conv2DBackpropInput",gK="Conv3D",VEt="Conv3DBackpropFilterV2",vK="Conv3DBackpropInputV2",yK="Cos",bK="Cosh",wK="Cumprod",_K="Cumsum",$K="CropAndResize",xK="DenseBincount",SK="DepthToSpace",CK="DepthwiseConv2dNative",kK="DepthwiseConv2dNativeBackpropFilter",TK="DepthwiseConv2dNativeBackpropInput",NK="Diag",IK="Dilation2D",HEt="Dilation2DBackpropInput",WEt="Dilation2DBackpropFilter",EK="RealDiv",AK="Einsum",OK="Elu",UEt="EluGrad",RK="Erf",DK="Equal",FK="Exp",MK="ExpandDims",PK="Expm1",LK="FFT",zK="Fill",BK="FlipLeftRight",VK="Floor",HK="FloorDiv",WK="FusedBatchNorm",UK="GatherV2",GK="GatherNd",jK="Greater",KK="GreaterEqual",HI="Identity",qK="IFFT",XK="Imag",YK="IsFinite",ZK="IsInf",JK="IsNan",QK="LeakyRelu",eq="Less",tq="LessEqual",nq="LinSpace",sq="Log",rq="Log1p",oq="LogicalAnd",aq="LogicalNot",iq="LogicalOr",GEt="LogicalXor",jEt="LogSoftmax",KEt="LowerBound",lq="LRN",qEt="LRNGrad",uq="Max",cq="Maximum",dq="MaxPool",XEt="MaxPoolGrad",fq="MaxPool3D",YEt="MaxPool3DGrad",hq="MaxPoolWithArgmax",pq="Mean",mq="Min",gq="Minimum",vq="MirrorPad",yq="Mod",bq="Multinomial",wq="Multiply",_q="Neg",$q="NotEqual",xq="NonMaxSuppressionV3",Sq="NonMaxSuppressionV4",Cq="NonMaxSuppressionV5",kq="OnesLike",Tq="OneHot",Nq="Pack",Iq="PadV2",ZEt="Pool",Eq="Pow",Aq="Prelu",Oq="Prod",Rq="RaggedGather",Dq="RaggedTensorToTensor",Fq="Range",Mq="Real",Pq="Reciprocal",Lq="Relu",zq="Reshape",Bq="ResizeNearestNeighbor",JEt="ResizeNearestNeighborGrad",Vq="ResizeBilinear",QEt="ResizeBilinearGrad",Hq="Relu6",Wq="Reverse",Uq="Round",Gq="Rsqrt",jq="ScatterNd",Kq="SearchSorted",qq="Select",Xq="Selu",Yq="Slice",Zq="Sin",Jq="Sinh",Qq="Sign",eX="Sigmoid",tX="Softplus",nX="Sqrt",sX="Sum",rX="SpaceToBatchND",oX="SplitV",aX="Softmax",iX="SparseFillEmptyRows",lX="SparseReshape",uX="SparseSegmentMean",cX="SparseSegmentSum",dX="SparseToDense",fX="SquaredDifference",e5t="Square",hX="StridedSlice",pX="StringNGrams",mX="StringSplit",gX="StringToHashBucketFast",vX="Sub",yX="Tan",bX="Tanh",WI="Tile",wX="TopK",_X="Transform",my="Transpose",$X="Unique",xX="Unpack",SX="UnsortedSegmentSum",t5t="UpperBound",CX="ZerosLike",kX="Step",sS="FromPixels",TX="RotateWithOffset",rS="_FusedMatMul",oS="FusedConv2D",aS="FusedDepthwiseConv2D";function _u(...t){en().getBool("IS_TEST")||en().getBool("PROD")||console.warn(...t)}function n5t(...t){en().getBool("IS_TEST")||en().getBool("PROD")||console.log(...t)}const Bh=zI("kernelRegistry",()=>new Map),hg=zI("gradRegistry",()=>new Map);function Nb(t,e){const n=UI(t,e);return Bh.get(n)}function iS(t){return hg.get(t)}function Ib(t){const e=Bh.entries(),n=[];for(;;){const{done:s,value:r}=e.next();if(s)break;const[o,a]=r,[i]=o.split("_");i===t&&n.push(a)}return n}function NX(t){const{kernelName:e,backendName:n}=t,s=UI(e,n);Bh.has(s)&&_u(`The kernel '${e}' for backend '${n}' is already registered`),Bh.set(s,t)}function s5t(t){const{kernelName:e}=t;hg.has(e)&&en().getBool("DEBUG")&&_u(`Overriding the gradient for '${e}'`),hg.set(e,t)}function r5t(t,e){const n=UI(t,e);if(!Bh.has(n))throw new Error(`The kernel '${t}' for backend '${e}' is not registered`);Bh.delete(n)}function o5t(t){if(!hg.has(t))throw new Error(`The gradient '${t}' for backend is not registered`);hg.delete(t)}function a5t(t,e){Ib(t).forEach(s=>{const r=Object.assign({},s,{backendName:e});NX(r)})}function UI(t,e){return`${e}_${t}`}const Uc=Qy||DB;function A2(t){return Uc.fromString(t,!0,16)}const IX=A2("c3a5c85c97cb3127"),Fc=A2("b492b66fbe98f273"),Cr=A2("9ae16a3b2f90404f");function lS(t){return t.xor(t.shru(47))}function EX(t,e,n){const s=t.slice(e,e+n);return Uc.fromBytes(Array.from(s),!0,!0)}function Hn(t,e){return EX(t,e,8)}function b9(t,e){return EX(t,e,4)}function Vs(t,e){return e===0?t:t.shru(e).or(t.shl(64-e))}function zu(t,e,n=A2("9ddfea08eb382d69")){let s=t.xor(e).mul(n);s=s.xor(s.shru(47));let r=e.xor(s).mul(n);return r=r.xor(r.shru(47)),r=r.mul(n),r}function i5t(t,e,n,s,r,o){r=r.add(t),o=Vs(o.add(r).add(s),21);const a=r;return r=r.add(e),r=r.add(n),o=o.add(Vs(r,44)),[r.add(s),o.add(a)]}function Av(t,e,n,s){return i5t(Hn(t,e),Hn(t,e+8),Hn(t,e+16),Hn(t,e+24),n,s)}function l5t(t,e=t.length){if(e>=8){const n=Cr.add(e*2),s=Hn(t,0).add(Cr),r=Hn(t,e-8),o=Vs(r,37).mul(n).add(s),a=Vs(s,25).add(r).mul(n);return zu(o,a,n)}if(e>=4){const n=Cr.add(e*2),s=b9(t,0);return zu(s.shl(3).add(e),b9(t,e-4),n)}if(e>0){const n=t[0],s=t[e>>1],r=t[e-1],o=n+(s<<8),a=e+(r<<2);return lS(Cr.mul(o).xor(IX.mul(a))).mul(Cr)}return Cr}function u5t(t,e=t.length){const n=Cr.add(e*2),s=Hn(t,0).mul(Fc),r=Hn(t,8),o=Hn(t,e-8).mul(n),a=Hn(t,e-16).mul(Cr);return zu(Vs(s.add(r),43).add(Vs(o,30)).add(a),s.add(Vs(r.add(Cr),18)).add(o),n)}function c5t(t,e=t.length){const n=Cr.add(e*2),s=Hn(t,0).mul(Cr),r=Hn(t,8),o=Hn(t,e-8).mul(n),a=Hn(t,e-16).mul(Cr),i=Vs(s.add(r),43).add(Vs(o,30)).add(a),l=zu(i,s.add(Vs(r.add(Cr),18)).add(o),n),u=Hn(t,16).mul(n),c=Hn(t,24),d=i.add(Hn(t,e-32)).mul(n),f=l.add(Hn(t,e-24)).mul(n);return zu(Vs(u.add(c),43).add(Vs(d,30)).add(f),u.add(Vs(c.add(s),18)).add(d),n)}function d5t(t,e=t.length){const n=Uc.fromNumber(81,!0);if(e<=32)return e<=16?l5t(t,e):u5t(t,e);if(e<=64)return c5t(t,e);let s=n,r=n.mul(Fc).add(113),o=lS(r.mul(Cr).add(113)).mul(Cr),a=[Uc.UZERO,Uc.UZERO],i=[Uc.UZERO,Uc.UZERO];s=s.mul(Cr).add(Hn(t,0));let l=0;const u=(e-1>>6)*64,c=u+(e-1&63)-63;do s=Vs(s.add(r).add(a[0]).add(Hn(t,l+8)),37).mul(Fc),r=Vs(r.add(a[1]).add(Hn(t,l+48)),42).mul(Fc),s=s.xor(i[1]),r=r.add(a[0]).add(Hn(t,l+40)),o=Vs(o.add(i[0]),33).mul(Fc),a=Av(t,l,a[1].mul(Fc),s.add(i[0])),i=Av(t,l+32,o.add(i[1]),r.add(Hn(t,l+16))),[o,s]=[s,o],l+=64;while(l!==u);const d=Fc.add(o.and(255).shl(1));return l=c,i[0]=i[0].add(e-1&63),a[0]=a[0].add(i[0]),i[0]=i[0].add(a[0]),s=Vs(s.add(r).add(a[0]).add(Hn(t,l+8)),37).mul(d),r=Vs(r.add(a[1]).add(Hn(t,l+48)),42).mul(d),s=s.xor(i[1].mul(9)),r=r.add(a[0].mul(9).add(Hn(t,l+40))),o=Vs(o.add(i[0]),33).mul(d),a=Av(t,l,a[1].mul(d),s.add(i[0])),i=Av(t,l+32,o.add(i[1]),r.add(Hn(t,l+16))),[o,s]=[s,o],zu(zu(a[0],i[0],d).add(lS(r).mul(IX)).add(o),zu(a[1],i[1],d).add(s),d)}function f5t(t,e){return e==="string"?O2(t):a4([t],e)}function h5t(t,e){return t instanceof Float32Array&&e==="float32"||t instanceof Int32Array&&e==="int32"||t instanceof Uint8Array&&e==="bool"}function a4(t,e){if(e==="string")throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(t)&&(t=Vd(t)),en().getBool("DEBUG")&&Fj(t,e),h5t(t,e))return t;if(e==null||e==="float32"||e==="complex64")return new Float32Array(t);if(e==="int32")return new Int32Array(t);if(e==="bool"){const n=new Uint8Array(t.length);for(let s=0;s<n.length;++s)Math.round(t[s])!==0&&(n[s]=1);return n}else throw new Error(`Unknown data type ${e}`)}function pg(){return en().platform.now()}function p5t(t,e){return en().platform.fetch(t,e)}function O2(t,e="utf-8"){return e=e||"utf-8",en().platform.encode(t,e)}function Eb(t,e="utf-8"){return e=e||"utf-8",en().platform.decode(t,e)}const m5t=Object.freeze(Object.defineProperty({__proto__:null,createScalarValue:f5t,toTypedArray:a4,now:pg,fetch:p5t,encodeString:O2,decodeString:Eb,shuffle:Aj,shuffleCombo:yEt,clamp:fg,nearestLargerEven:bEt,swap:kb,sum:wEt,randUniform:_Et,distSquared:$Et,assert:le,assertShapesMatch:Br,assertNonNull:gf,flatten:Vd,sizeFromShape:Qn,isScalarShape:xEt,arraysEqual:Ui,isInt:zh,tanh:SEt,sizeToSquarishShape:CEt,createShuffledIndices:kEt,rightPad:g0,repeatedTry:TEt,inferFromImplicitShape:NEt,parseAxisParam:E2,squeezeShape:Oj,getTypedArrayFromDType:Rj,getArrayFromDType:Dj,checkConversionForErrors:Fj,isValidDtype:Mj,hasEncodingLoss:IEt,isTypedArray:pr,bytesPerElement:nS,bytesFromStringArray:Pj,isString:Iu,isBoolean:Lj,isNumber:zj,inferDtype:r4,isFunction:sc,nearestDivisor:Tb,computeStrides:wm,toNestedArray:hd,makeOnesTypedArray:MI,makeZerosTypedArray:o4,makeZerosNestedTypedArray:EEt,assertNonNegativeIntegerDimensions:PI,locToIndex:AEt,indexToLoc:OEt,isPromise:Hd,hexToLong:A2,fingerPrint64:d5t},Symbol.toStringTag,{value:"Module"}));class g5t{constructor(e,n){this.backendTimer=e,this.logger=n,n==null&&(this.logger=new y5t)}profileKernel(e,n,s){let r;const o=()=>{r=s()};let a;const i=pg();if(this.backendTimer.timerAvailable())a=this.backendTimer.time(o);else{o();for(const u of r)u.dataSync();a=Promise.resolve({kernelMs:pg()-i})}if(en().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let u=0;u<r.length;u++){const c=r[u];c.data().then(d=>{v5t(d,c.dtype,e)})}return{kernelName:e,outputs:r,inputs:n,timeMs:a.then(u=>u.kernelMs),extraInfo:a.then(u=>u.getExtraProfileInfo!=null?u.getExtraProfileInfo():"")}}logKernelProfile(e){const{kernelName:n,outputs:s,timeMs:r,inputs:o,extraInfo:a}=e;s.forEach(i=>{Promise.all([i.data(),r,a]).then(l=>{this.logger.logKernelProfile(n,i,l[0],l[1],o,l[2])})})}}function v5t(t,e,n){if(e!=="float32")return!1;for(let s=0;s<t.length;s++){const r=t[s];if(isNaN(r)||!isFinite(r))return console.warn(`Found ${r} in the result of '${n}'`),!0}return!1}class y5t{logKernelProfile(e,n,s,r,o,a){const i=typeof r=="number"?g0(`${r}ms`,9):r.error,l=g0(e,25),u=n.rank,c=n.size,d=g0(n.shape.toString(),14);let f="";for(const h in o){const p=o[h];if(p!=null){const m=p.shape||n.shape,g=m.length;f+=`${h}: ${g}D ${g>0?m:""} `}}console.log(`%c${l}	%c${i}	%c${u}D ${d}	%c${c}	%c${f}	%c${a}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}function b5t(t,e,n){const s={},r={};for(let l=0;l<e.length;l++)s[e[l].id]=!0;for(let l=0;l<t.length;l++){const u=t[l],c=u.inputs;for(const d in c){const f=c[d];let h=!1;for(let p=0;p<e.length;p++)if(s[f.id]){u.outputs.forEach(m=>s[m.id]=!0),h=!0,r[u.id]=!0;break}if(h)break}}const o={};o[n.id]=!0;const a={};for(let l=t.length-1;l>=0;l--){const u=t[l],c=u.inputs;for(let d=0;d<u.outputs.length;d++)if(o[u.outputs[d].id]){for(const f in c)o[c[f].id]=!0,a[u.id]=!0;break}}const i=[];for(let l=0;l<t.length;l++){const u=t[l];if(r[u.id]&&a[u.id]){const c={};for(const f in u.inputs){const h=u.inputs[f];s[h.id]&&(c[f]=h)}const d=Object.assign({},u);d.inputs=c,d.outputs=u.outputs,i.push(d)}}return i}function w5t(t,e,n,s){for(let r=e.length-1;r>=0;r--){const o=e[r],a=[];if(o.outputs.forEach(l=>{const u=t[l.id];u!=null?a.push(u):a.push(null)}),o.gradient==null)throw new Error(`Cannot compute gradient: gradient function not found for ${o.kernelName}.`);const i=o.gradient(a);for(const l in o.inputs){if(!(l in i))throw new Error(`Cannot backprop through input ${l}. Available gradients found: ${Object.keys(i)}.`);const u=n(()=>i[l]());if(u.dtype!=="float32")throw new Error(`Error in gradient for op ${o.kernelName}. The gradient of input ${l} must have 'float32' dtype, but has '${u.dtype}'`);const c=o.inputs[l];if(!Ui(u.shape,c.shape))throw new Error(`Error in gradient for op ${o.kernelName}. The gradient of input '${l}' has shape '${u.shape}', which does not match the shape of the input '${c.shape}'`);if(t[c.id]==null)t[c.id]=u;else{const d=t[c.id];t[c.id]=s(d,u),d.dispose()}}}}const w9=20,zm=3,D$=7;function _5t(t,e,n,s){const r=wm(e),o=$5t(t,e,n,r),a=e.length,i=gy(t,e,n,r,o),l=["Tensor"];return s&&(l.push(`  dtype: ${n}`),l.push(`  rank: ${a}`),l.push(`  shape: [${e}]`),l.push("  values:")),l.push(i.map(u=>"    "+u).join(`
`)),l.join(`
`)}function $5t(t,e,n,s){const r=Qn(e),o=s[s.length-1],a=new Array(o).fill(0),i=e.length,l=n==="complex64"?Jm(t):t;if(i>1)for(let u=0;u<r/o;u++){const c=u*o;for(let d=0;d<o;d++)a[d]=Math.max(a[d],Zm(l[c+d],0,n).length)}return a}function Zm(t,e,n){let s;return Array.isArray(t)?s=`${parseFloat(t[0].toFixed(D$))} + ${parseFloat(t[1].toFixed(D$))}j`:Iu(t)?s=`'${t}'`:n==="bool"?s=AX(t):s=parseFloat(t.toFixed(D$)).toString(),g0(s,e)}function AX(t){return t===0?"false":"true"}function gy(t,e,n,s,r,o=!0){const a=n==="complex64"?2:1,i=e[0],l=e.length;if(l===0){if(n==="complex64"){const m=Jm(t);return[Zm(m[0],0,n)]}return n==="bool"?[AX(t[0])]:[t[0].toString()]}if(l===1){if(i>w9){const g=zm*a;let y=Array.from(t.slice(0,g)),w=Array.from(t.slice((i-zm)*a,i*a));return n==="complex64"&&(y=Jm(y),w=Jm(w)),["["+y.map((b,_)=>Zm(b,r[_],n)).join(", ")+", ..., "+w.map((b,_)=>Zm(b,r[i-zm+_],n)).join(", ")+"]"]}return["["+(n==="complex64"?Jm(t):Array.from(t)).map((g,y)=>Zm(g,r[y],n)).join(", ")+"]"]}const u=e.slice(1),c=s.slice(1),d=s[0]*a,f=[];if(i>w9){for(let m=0;m<zm;m++){const g=m*d,y=g+d;f.push(...gy(t.slice(g,y),u,n,c,r,!1))}f.push("...");for(let m=i-zm;m<i;m++){const g=m*d,y=g+d;f.push(...gy(t.slice(g,y),u,n,c,r,m===i-1))}}else for(let m=0;m<i;m++){const g=m*d,y=g+d;f.push(...gy(t.slice(g,y),u,n,c,r,m===i-1))}const h=l===2?",":"";f[0]="["+f[0]+h;for(let m=1;m<f.length-1;m++)f[m]=" "+f[m]+h;let p=`,
`;for(let m=2;m<l;m++)p+=`
`;return f[f.length-1]=" "+f[f.length-1]+"]"+(o?"":p),f}function Jm(t){const e=[];for(let n=0;n<t.length;n+=2)e.push([t[n],t[n+1]]);return e}class Ab{constructor(e,n,s){if(this.dtype=n,this.shape=e.slice(),this.size=Qn(e),s!=null){const r=s.length;le(r===this.size,()=>`Length of values '${r}' does not match the size inferred by the shape '${this.size}'.`)}if(n==="complex64")throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=s||Dj(n,this.size),this.strides=wm(e)}set(e,...n){n.length===0&&(n=[0]),le(n.length===this.rank,()=>`The number of provided coordinates (${n.length}) must match the rank (${this.rank})`);const s=this.locToIndex(n);this.values[s]=e}get(...e){e.length===0&&(e=[0]);let n=0;for(const r of e){if(r<0||r>=this.shape[n]){const o=`Requested out of range element at ${e}.   Buffer shape=${this.shape}`;throw new Error(o)}n++}let s=e[e.length-1];for(let r=0;r<e.length-1;++r)s+=this.strides[r]*e[r];return this.values[s]}locToIndex(e){if(this.rank===0)return 0;if(this.rank===1)return e[0];let n=e[e.length-1];for(let s=0;s<e.length-1;++s)n+=this.strides[s]*e[s];return n}indexToLoc(e){if(this.rank===0)return[];if(this.rank===1)return[e];const n=new Array(this.shape.length);for(let s=0;s<n.length-1;++s)n[s]=Math.floor(e/this.strides[s]),e-=n[s]*this.strides[s];return n[n.length-1]=e,n}get rank(){return this.shape.length}toTensor(){return Ba().makeTensor(this.values,this.shape,this.dtype)}}let Ba=null,Of=null;function x5t(t){Ba=t}function S5t(t){Of=t}class os{constructor(e,n,s,r){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=n||"float32",this.size=Qn(e),this.strides=wm(e),this.dataId=s,this.id=r,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const e=await this.data();return Of.buffer(this.shape,this.dtype,e)}bufferSync(){return Of.buffer(this.shape,this.dtype,this.dataSync())}async array(){const e=await this.data();return hd(this.shape,e,this.dtype==="complex64")}arraySync(){return hd(this.shape,this.dataSync(),this.dtype==="complex64")}async data(){this.throwIfDisposed();const e=Ba().read(this.dataId);if(this.dtype==="string"){const n=await e;try{return n.map(s=>Eb(s))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e}dataToGPU(e){return this.throwIfDisposed(),Ba().readToGPU(this.dataId,e)}dataSync(){this.throwIfDisposed();const e=Ba().readSync(this.dataId);if(this.dtype==="string")try{return e.map(n=>Eb(n))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}async bytes(){this.throwIfDisposed();const e=await Ba().read(this.dataId);return this.dtype==="string"?e:new Uint8Array(e.buffer)}dispose(){this.isDisposed||(Ba().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(e=!1){return Of.print(this,e)}clone(){return this.throwIfDisposed(),Of.clone(this)}toString(e=!1){const n=this.dataSync();return _5t(n,this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),Of.cast(this,e)}variable(e=!0,n,s){return this.throwIfDisposed(),Ba().makeVariable(this,e,n,s)}}Object.defineProperty(os,Symbol.hasInstance,{value:t=>!!t&&t.data!=null&&t.dataSync!=null&&t.throwIfDisposed!=null});function C5t(){return zI("Tensor",()=>os)}C5t();class mg extends os{constructor(e,n,s,r){super(e.shape,e.dtype,e.dataId,r),this.trainable=n,this.name=s}assign(e){if(e.dtype!==this.dtype)throw new Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);if(!Ui(e.shape,this.shape))throw new Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);Ba().disposeTensor(this),this.dataId=e.dataId,Ba().incRef(this,null)}dispose(){Ba().disposeVariable(this),this.isDisposedInternal=!0}}Object.defineProperty(mg,Symbol.hasInstance,{value:t=>t instanceof os&&t.assign!=null&&t.assign instanceof Function});var uS;(function(t){t.R0="R0",t.R1="R1",t.R2="R2",t.R3="R3",t.R4="R4",t.R5="R5",t.R6="R6"})(uS||(uS={}));var cS;(function(t){t.float32="float32",t.int32="int32",t.bool="int32",t.complex64="complex64"})(cS||(cS={}));var dS;(function(t){t.float32="float32",t.int32="int32",t.bool="bool",t.complex64="complex64"})(dS||(dS={}));var fS;(function(t){t.float32="float32",t.int32="float32",t.bool="float32",t.complex64="complex64"})(fS||(fS={}));var hS;(function(t){t.float32="complex64",t.int32="complex64",t.bool="complex64",t.complex64="complex64"})(hS||(hS={}));const k5t={float32:fS,int32:cS,bool:dS,complex64:hS};function i4(t,e){if(t==="string"||e==="string"){if(t==="string"&&e==="string")return"string";throw new Error(`Can not upcast ${t} with ${e}`)}return k5t[t][e]}function T5t(t){return i4(t,"int32")}function fs(t,e){if(t.dtype===e.dtype)return[t,e];const n=i4(t.dtype,e.dtype);return[t.cast(n),e.cast(n)]}function OX(t,e){le(t.dtype===e.dtype,()=>`The dtypes of the first(${t.dtype}) and second(${e.dtype}) input must match`)}function N5t(t,e){return e.some(n=>n.id===t.id)}function GI(t){const e=[];return RX(t,e,new Set),e}function RX(t,e,n){if(t==null)return;if(t instanceof os){e.push(t);return}if(!I5t(t))return;const s=t;for(const r in s){const o=s[r];n.has(o)||(n.add(o),RX(o,e,n))}}function I5t(t){return Array.isArray(t)||typeof t=="object"}const E5t=Object.freeze(Object.defineProperty({__proto__:null,makeTypesMatch:fs,assertTypesMatch:OX,isTensorInList:N5t,getTensorsInContainer:GI},Symbol.toStringTag,{value:"Module"}));function F$(t){return t.kernelName!=null}class _9{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(e=>e.name)))}}}dispose(){for(const e in this.registeredVariables)this.registeredVariables[e].dispose()}}class Vh{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new _9}async ready(){if(this.pendingBackendInit!=null)return this.pendingBackendInit.then(()=>{});if(this.backendInstance!=null)return;const e=this.getSortedBackends();for(let n=0;n<e.length;n++){const s=e[n];if(await this.initializeBackend(s).success){await this.setBackend(s);return}}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(this.pendingBackendInit!=null)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(this.backendInstance==null){const{name:e,asyncInit:n}=this.initializeBackendsAndReturnBest();if(n)throw new Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry))if(e in this.registryFactory){const{asyncInit:n}=this.initializeBackend(e);if(n)return null}else return null;return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,n,s=1){return e in this.registryFactory?(_u(`${e} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[e]={factory:n,priority:s},!0)}async setBackend(e){if(this.registryFactory[e]==null)throw new Error(`Backend name '${e}' not found in registry`);if(this.backendName=e,this.registry[e]==null){this.backendInstance=null;const{success:n,asyncInit:s}=this.initializeBackend(e);if(!(s?await n:n))return!1}return this.backendInstance=this.registry[e],this.setupRegisteredKernels(),this.profiler=new g5t(this.backendInstance),!0}setupRegisteredKernels(){Ib(this.backendName).forEach(n=>{n.setupFunc!=null&&n.setupFunc(this.backendInstance)})}disposeRegisteredKernels(e){Ib(e).forEach(s=>{s.disposeFunc!=null&&s.disposeFunc(this.registry[e])})}initializeBackend(e){const n=this.registryFactory[e];if(n==null)throw new Error(`Cannot initialize backend ${e}, no registration found.`);try{const s=n.factory();if(s&&!(s instanceof Ej)&&typeof s.then=="function"){const r=++this.pendingBackendInitId,o=s.then(a=>r<this.pendingBackendInitId?!1:(this.registry[e]=a,this.pendingBackendInit=null,!0)).catch(a=>(r<this.pendingBackendInitId||(this.pendingBackendInit=null,_u(`Initialization of backend ${e} failed`),_u(a.stack||a.message)),!1));return this.pendingBackendInit=o,{success:o,asyncInit:!0}}else return this.registry[e]=s,{success:!0,asyncInit:!1}}catch(s){return _u(`Initialization of backend ${e} failed`),_u(s.stack||s.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error(`${e} backend not found in registry`);this.backendName===e&&this.pendingBackendInit!=null&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(Object.keys(this.registryFactory).length===0)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((e,n)=>this.registryFactory[n].priority-this.registryFactory[e].priority)}initializeBackendsAndReturnBest(){const e=this.getSortedBackends();for(let n=0;n<e.length;n++){const s=e[n],{success:r,asyncInit:o}=this.initializeBackend(s);if(o||r)return{name:s,asyncInit:o}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,n){const s=this.state.tensorInfo.get(n),r=s.backend,o=this.readSync(n),a=r.refCount(n);r.disposeData(n,!0),s.backend=e,e.move(n,o,s.shape,s.dtype,a),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,n){let s=null;if(n==null){if(typeof e!="function")throw new Error("Please provide a function to tidy()");n=e}else{if(typeof e!="string"&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if(typeof n!="function")throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");s=e}let r;return this.scopedRun(()=>this.startScope(s),()=>this.endScope(r),()=>(r=n(),r instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),r))}scopedRun(e,n,s){e();try{const r=s();return n(),r}catch(r){throw n(),r}}nextTensorId(){return Vh.nextTensorId++}nextVariableId(){return Vh.nextVariableId++}clone(e){const n=ke.runKernel(HI,{x:e}),s={x:e},r=a=>({x:()=>{const i="float32",l={x:a},u={dtype:i};return ke.runKernel(VI,l,u)}}),o=[];return this.addTapeNode(this.state.activeScope.name,s,[n],r,o,{}),n}runKernel(e,n,s){if(this.backendName==null&&this.backend,!(Nb(e,this.backendName)!=null))throw new Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:e,inputs:n,attrs:s})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,n,s){const r=this.backend.numDataIds();let o=0;s.forEach(l=>{o+=l.dtype==="complex64"?3:1});const a=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],i=r-n-o-a;if(i>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${i} data ids) after running '${e}'`)}runKernelFunc(e){let n,s=[];const r=this.isTapeOn(),o=this.state.numBytes,a=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);let i;this.backendName==null&&this.backend;let l;const u=F$(e)?e.kernelName:this.state.activeScope!=null?this.state.activeScope.name:"";if(F$(e)){const{kernelName:p,inputs:m,attrs:g}=e;this.backendName==null&&this.backend;const y=Nb(p,this.backendName);le(y!=null,()=>`Cannot find registered kernel '${p}' for backend '${this.backendName}'`),i=()=>{const w=this.backend.numDataIds();l=y.kernelFunc({inputs:m,attrs:g,backend:this.backend});const b=Array.isArray(l)?l:[l];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(p,w,b);const _=b.map($=>$.rank!=null?$:this.makeTensorFromTensorInfo($));if(r){const $=this.getTensorsForGradient(p,m,_);s=this.saveTensorsForBackwardMode($)}return _}}else{const{forwardFunc:p}=e,m=g=>{!r||(s=g.map(y=>this.keep(this.clone(y))))};i=()=>{const g=this.backend.numDataIds();l=this.tidy(()=>p(this.backend,m));const y=Array.isArray(l)?l:[l];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(u,g,y),y}}const{inputs:c,attrs:d}=e,f=F$(e)?null:e.backwardsFunc;let h;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{!this.ENV.getBool("DEBUG")&&!this.state.profiling?n=i():(h=this.profiler.profileKernel(u,c,()=>i()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(h),n=h.outputs)}),r&&this.addTapeNode(u,c,n,f,s,d),this.state.profiling&&this.state.activeProfile.kernels.push({name:u,bytesAdded:this.state.numBytes-o,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-a,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(c).map(p=>c[p]!=null?c[p].shape:null),outputShapes:n.map(p=>p.shape),kernelTimeMs:h.timeMs,extraInfo:h.extraInfo}),Array.isArray(l)?n:n[0]}saveTensorsForBackwardMode(e){return e.map(s=>this.keep(this.clone(s)))}getTensorsForGradient(e,n,s){const r=iS(e);if(r!=null){const o=r.inputsToSave||[],a=r.outputsToSave||[];let i;r.saveAllInputs?(le(Array.isArray(n),()=>"saveAllInputs is true, expected inputs to be an array."),i=Object.keys(n).map(u=>n[u])):i=o.map(u=>n[u]);const l=s.filter((u,c)=>a[c]);return i.concat(l)}return[]}makeTensor(e,n,s,r){if(e==null)throw new Error("Values passed to engine.makeTensor() are null");s=s||"float32",r=r||this.backend;let o=e;s==="string"&&Iu(e[0])&&(o=e.map(l=>O2(l)));const a=r.write(o,n,s),i=new os(n,s,a,this.nextTensorId());if(this.trackTensor(i,r),s==="string"){const l=this.state.tensorInfo.get(a),u=Pj(o);this.state.numBytes+=u-l.bytes,l.bytes=u}return i}makeTensorFromDataId(e,n,s,r){s=s||"float32";const o={dataId:e,shape:n,dtype:s};return this.makeTensorFromTensorInfo(o,r)}makeTensorFromTensorInfo(e,n){const{dataId:s,shape:r,dtype:o}=e,a=new os(r,o,s,this.nextTensorId());return this.trackTensor(a,n),a}makeVariable(e,n=!0,s,r){s=s||this.nextVariableId().toString(),r!=null&&r!==e.dtype&&(e=e.cast(r));const o=new mg(e,n,s,this.nextTensorId());if(this.state.registeredVariables[o.name]!=null)throw new Error(`Variable with name ${o.name} was already registered`);return this.state.registeredVariables[o.name]=o,this.incRef(o,this.backend),o}trackTensor(e,n){this.state.numTensors++,e.dtype==="string"&&this.state.numStringTensors++;let s=0;e.dtype!=="complex64"&&e.dtype!=="string"&&(s=e.size*nS(e.dtype)),this.state.numBytes+=s,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:n||this.backend,dtype:e.dtype,shape:e.shape,bytes:s})),e instanceof mg||this.track(e)}incRef(e,n){this.trackTensor(e,n),this.backend.incRef(e.dataId)}removeDataId(e,n){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===n&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;const n=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,e.dtype==="string"&&(this.state.numStringTensors--,this.state.numBytes-=n.bytes),e.dtype!=="complex64"&&e.dtype!=="string"){const s=e.size*nS(e.dtype);this.state.numBytes-=s}n.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,n.backend)}disposeVariables(){for(const e in this.state.registeredVariables){const n=this.state.registeredVariables[e];this.disposeVariable(n)}}disposeVariable(e){this.disposeTensor(e),this.state.registeredVariables[e.name]!=null&&delete this.state.registeredVariables[e.name]}memory(){const e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,e.reasons==null&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}async profile(e){this.state.profiling=!0;const n=this.state.numBytes,s=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await e(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(r=>r.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-n,this.state.activeProfile.newTensors=this.state.numTensors-s;for(const r of this.state.activeProfile.kernels)r.kernelTimeMs=await r.kernelTimeMs,r.extraInfo=await r.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(e,n,s,r,o,a){const i={id:this.state.nextTapeNodeId++,kernelName:e,inputs:n,outputs:s,saved:o},l=iS(e);l!=null&&(r=l.gradFunc),r!=null&&(i.gradient=u=>(u=u.map((c,d)=>{if(c==null){const f=s[d],h=o4(f.size,f.dtype);return this.makeTensor(h,f.shape,f.dtype)}return c}),r(u.length>1?u:u[0],o,a))),this.state.activeTape.push(i)}keep(e){return e.kept=!0,e}startTape(){this.state.gradientDepth===0&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){const n={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(n.name=e),this.state.scopeStack.push(n),this.state.activeScope=n}endScope(e){const n=GI(e),s=new Set(n.map(o=>o.id));for(let o=0;o<this.state.activeScope.track.length;o++){const a=this.state.activeScope.track[o];!a.kept&&!s.has(a.id)&&a.dispose()}const r=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1],n.forEach(o=>{!o.kept&&o.scopeId===r.id&&this.track(o)})}gradients(e,n,s,r=!1){if(le(n.length>0,()=>"gradients() received an empty list of xs."),s!=null&&s.dtype!=="float32")throw new Error(`dy must have 'float32' dtype, but has '${s.dtype}'`);const o=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",e));le(o instanceof os,()=>"The result y returned by f() must be a tensor.");const a=b5t(this.state.activeTape,n,o);if(!r&&a.length===0&&n.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{const i={};i[o.id]=s??A5t(o.shape),w5t(i,a,u=>this.tidy(u),O5t);const l=n.map(u=>i[u.id]);return this.state.gradientDepth===0&&(this.state.activeTape.forEach(u=>{for(const c of u.saved)c.dispose()}),this.state.activeTape=null),{value:o,grads:l}})}customGrad(e){return le(sc(e),()=>"The f passed in customGrad(f) must be a function."),(...n)=>{le(n.every(i=>i instanceof os),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");let s;const r={};n.forEach((i,l)=>{r[l]=i});const o=(i,l)=>(s=e(...n,l),le(s.value instanceof os,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),le(sc(s.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),s.value),a=(i,l)=>{const u=s.gradFunc(i,l),c=Array.isArray(u)?u:[u];le(c.length===n.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),le(c.every(f=>f instanceof os),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const d={};return c.forEach((f,h)=>{d[h]=()=>f}),d};return this.runKernelFunc({forwardFunc:o,backwardsFunc:a,inputs:r})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}readToGPU(e,n){return this.state.tensorInfo.get(e).backend.readToGPU(e,n)}async time(e){const n=pg(),s=await this.backend.time(e);return s.wallMs=pg()-n,s}track(e){return this.state.activeScope!=null&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new _9;for(const e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}Vh.nextTensorId=0;Vh.nextVariableId=0;function A5t(t){const e=MI(Qn(t),"float32");return ke.makeTensor(e,t,"float32")}function DX(){const t=Hj();if(t._tfengine==null){const e=new Vj(t);t._tfengine=new Vh(e)}return MEt(t._tfengine.ENV),x5t(()=>t._tfengine),t._tfengine}const ke=DX();function O5t(t,e){const n={a:t,b:e};return ke.runKernel(BI,n)}function R5t(){return typeof navigator<"u"&&navigator!=null}let pS;function D5t(t){pS=t}function F5t(t){if(pS!==void 0)return pS;if(t||R5t()){if(t||(t=navigator),t.product==="ReactNative")return!0;const e=t.userAgent||t.vendor||(typeof window<"u"?window.opera:"");if(!e){const n=t;return n.userAgentData&&n.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(e)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(e.substr(0,4))}return!1}function FX(){return typeof window<"u"&&window.document!=null||typeof WorkerGlobalScope<"u"}const M5t=Object.freeze(Object.defineProperty({__proto__:null,mockIsMobile:D5t,isMobile:F5t,isBrowser:FX},Symbol.toStringTag,{value:"Module"}));const ko=en();ko.registerFlag("DEBUG",()=>!1,t=>{t&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")});ko.registerFlag("IS_BROWSER",()=>FX());ko.registerFlag("IS_NODE",()=>typeof process<"u"&&typeof process.versions<"u"&&typeof process.versions.node<"u");ko.registerFlag("IS_CHROME",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor));ko.registerFlag("PROD",()=>!1);ko.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>ko.getBool("DEBUG"));ko.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0);ko.registerFlag("IS_TEST",()=>!1);ko.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>!0);ko.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1);ko.registerFlag("ENGINE_COMPILE_ONLY",()=>!1);ko.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>!1);ko.registerFlag("USE_SETTIMEOUTCUSTOM",()=>!1);function Gi(t,e){let n=t;if(pr(t))return e==="string"?[]:[t.length];if(!Array.isArray(t))return[];const s=[];for(;Array.isArray(n)||pr(n)&&e!=="string";)s.push(n.length),n=n[0];return Array.isArray(t)&&en().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&MX(t,s,[]),s}function MX(t,e,n){if(n=n||[],!Array.isArray(t)&&!pr(t)){le(e.length===0,()=>`Element arr[${n.join("][")}] is a primitive, but should be an array/TypedArray of ${e[0]} elements`);return}le(e.length>0,()=>`Element arr[${n.join("][")}] should be a primitive, but is an array of ${t.length} elements`),le(t.length===e[0],()=>`Element arr[${n.join("][")}] should have ${e[0]} elements, but has ${t.length} elements`);const s=e.slice(1);for(let r=0;r<t.length;++r)MX(t[r],s,n.concat(r))}function $9(t,e,n,s){if(t!=="string_or_numeric"){if(t==null)throw new Error("Expected dtype cannot be null.");if(t!=="numeric"&&t!==e||t==="numeric"&&e==="string")throw new Error(`Argument '${n}' passed to '${s}' must be ${t} tensor, but got ${e} tensor`)}}function ne(t,e,n,s="numeric"){if(t instanceof os)return $9(s,t.dtype,e,n),t;let r=r4(t);if(r!=="string"&&["bool","int32","float32"].indexOf(s)>=0&&(r=s),$9(s,r,e,n),t==null||!pr(t)&&!Array.isArray(t)&&typeof t!="number"&&typeof t!="boolean"&&typeof t!="string"){const l=t==null?"null":t.constructor.name;throw new Error(`Argument '${e}' passed to '${n}' must be a Tensor or TensorLike, but got '${l}'`)}const o=Gi(t,r);!pr(t)&&!Array.isArray(t)&&(t=[t]);const i=r!=="string"?a4(t,r):Vd(t,[],!0);return ke.makeTensor(i,o,r)}function gg(t,e,n,s="numeric"){if(!Array.isArray(t))throw new Error(`Argument ${e} passed to ${n} must be a \`Tensor[]\` or \`TensorLike[]\``);return t.map((o,a)=>ne(o,`${e}[${a}]`,n,s))}const jI="__op";function Ce(t){const e=Object.keys(t);if(e.length!==1)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${e.length} keys.`);let n=e[0];const s=t[n];n.endsWith("_")&&(n=n.substring(0,n.length-1)),n=n+jI;const r=(...o)=>{ke.startScope(n);try{const a=s(...o);return Hd(a)&&console.error("Cannot return a Promise inside of tidy."),ke.endScope(a),a}catch(a){throw ke.endScope(null),a}};return Object.defineProperty(r,"name",{value:n,configurable:!0}),r}function P5t(t,e){const n=ne(t,"real","complex"),s=ne(e,"imag","complex");Br(n.shape,s.shape,`real and imag shapes, ${n.shape} and ${s.shape}, must match in call to tf.complex().`);const r={real:n,imag:s};return ke.runKernel(cK,r)}const Dl=Ce({complex_:P5t});function bc(t,e,n,s){if(s==null&&(s=r4(t)),s==="complex64")throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(!pr(t)&&!Array.isArray(t)&&typeof t!="number"&&typeof t!="boolean"&&typeof t!="string")throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(e!=null){PI(e);const r=Qn(e),o=Qn(n);le(r===o,()=>`Based on the provided shape, [${e}], the tensor should have ${r} values but has ${o}`);for(let a=0;a<n.length;++a){const i=n[a],l=a===n.length-1?i!==Qn(e.slice(a)):!0;le(n[a]===e[a]||!l,()=>`Error creating a new Tensor. Inferred shape (${n}) does not match the provided shape (${e}). `)}}return!pr(t)&&!Array.isArray(t)&&(t=[t]),e=e||n,t=s!=="string"?a4(t,s):Vd(t,[],!0),ke.makeTensor(t,e,s)}function Za(t,e,n){const s=Gi(t,n);return bc(t,e,s,n)}const mS={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};const Ob=4;async function L5t(t,e){const n=[],s=[],r=Array.isArray(t)?t.map(a=>a.name):Object.keys(t);for(let a=0;a<r.length;++a){const i=r[a],l=Array.isArray(t)?t[a].tensor:t[i];if(l.dtype!=="float32"&&l.dtype!=="int32"&&l.dtype!=="bool"&&l.dtype!=="string"&&l.dtype!=="complex64")throw new Error(`Unsupported dtype in weight '${i}': ${l.dtype}`);const u={name:i,shape:l.shape,dtype:l.dtype};if(l.dtype==="string"){const c=new Promise(async d=>{const f=await l.bytes(),h=f.reduce((g,y)=>g+y.length,0)+Ob*f.length,p=new Uint8Array(h);let m=0;for(let g=0;g<f.length;g++){const y=f[g],w=new Uint8Array(new Uint32Array([y.length]).buffer);p.set(w,m),m+=Ob,p.set(y,m),m+=y.length}d(p)});s.push(c)}else s.push(l.data());e!=null&&(u.group=e),n.push(u)}const o=await Promise.all(s);return{data:z5t(o),specs:n}}function PX(t,e){const n={};let s,r=0;for(const o of e){const a=o.name,i=o.dtype,l=o.shape,u=Qn(l);let c;if("quantization"in o){const d=o.quantization;if(d.dtype==="uint8"||d.dtype==="uint16"){if(!("min"in d&&"scale"in d))throw new Error(`Weight ${o.name} with quantization ${d.dtype} doesn't have corresponding metadata min and scale.`)}else if(d.dtype==="float16"){if(i!=="float32")throw new Error(`Weight ${o.name} is quantized with ${d.dtype} which only supports weights of type float32 not ${i}.`)}else throw new Error(`Weight ${o.name} has unknown quantization dtype ${d.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);const f=mS[d.dtype],h=t.slice(r,r+u*f),p=d.dtype==="uint8"?new Uint8Array(h):new Uint16Array(h);if(i==="float32")if(d.dtype==="uint8"||d.dtype==="uint16"){c=new Float32Array(p.length);for(let m=0;m<p.length;m++){const g=p[m];c[m]=g*d.scale+d.min}}else if(d.dtype==="float16")s===void 0&&(s=G5t()),c=s(p);else throw new Error(`Unsupported quantization type ${d.dtype} for weight type float32.`);else if(i==="int32"){if(d.dtype!=="uint8"&&d.dtype!=="uint16")throw new Error(`Unsupported quantization type ${d.dtype} for weight type int32.`);c=new Int32Array(p.length);for(let m=0;m<p.length;m++){const g=p[m];c[m]=Math.round(g*d.scale+d.min)}}else throw new Error(`Unsupported dtype in weight '${a}': ${i}`);r+=u*f}else if(i==="string"){const d=Qn(o.shape);c=[];for(let f=0;f<d;f++){const h=new Uint32Array(t.slice(r,r+Ob))[0];r+=Ob;const p=new Uint8Array(t.slice(r,r+h));c.push(p),r+=h}}else{const d=mS[i],f=t.slice(r,r+u*d);if(i==="float32")c=new Float32Array(f);else if(i==="int32")c=new Int32Array(f);else if(i==="bool")c=new Uint8Array(f);else if(i==="complex64"){c=new Float32Array(f);const h=new Float32Array(c.length/2),p=new Float32Array(c.length/2);for(let y=0;y<h.length;y++)h[y]=c[y*2],p[y]=c[y*2+1];const m=Za(h,l,"float32"),g=Za(p,l,"float32");n[a]=Dl(m,g),m.dispose(),g.dispose()}else throw new Error(`Unsupported dtype in weight '${a}': ${i}`);r+=u*d}i!=="complex64"&&(n[a]=Za(c,l,i))}return n}function z5t(t){if(t===null)throw new Error(`Invalid input value: ${JSON.stringify(t)}`);let e=0;const n=[];t.forEach(o=>{if(e+=o.byteLength,n.push(o.byteLength===o.buffer.byteLength?o:new o.constructor(o)),!(o instanceof Float32Array||o instanceof Int32Array||o instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${o.constructor.name}`)});const s=new Uint8Array(e);let r=0;return n.forEach(o=>{s.set(new Uint8Array(o.buffer),r),r+=o.byteLength}),s.buffer}const KI=typeof Buffer<"u"&&(typeof Blob>"u"||typeof atob>"u"||typeof btoa>"u");function x9(t){return KI?Buffer.byteLength(t):new Blob([t]).size}function B5t(t){if(KI)return Buffer.from(t).toString("base64");const e=new Uint8Array(t);let n="";for(let s=0,r=e.length;s<r;s++)n+=String.fromCharCode(e[s]);return btoa(n)}function V5t(t){if(KI){const s=Buffer.from(t,"base64");return s.buffer.slice(s.byteOffset,s.byteOffset+s.byteLength)}const e=atob(t),n=new Uint8Array(e.length);for(let s=0;s<e.length;++s)n.set([e.charCodeAt(s)],s);return n.buffer}function qI(t){if(t.length===1)return t[0];let e=0;t.forEach(r=>{e+=r.byteLength});const n=new Uint8Array(e);let s=0;return t.forEach(r=>{n.set(new Uint8Array(r),s),s+=r.byteLength}),n.buffer}function S9(t){const e="/";for(t=t.trim();t.endsWith(e);)t=t.slice(0,t.length-1);const n=t.split(e);return n[n.length-1]}function LX(t,e){const n={modelTopology:t.modelTopology,format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy,weightsManifest:e};return t.signature!=null&&(n.signature=t.signature),t.userDefinedMetadata!=null&&(n.userDefinedMetadata=t.userDefinedMetadata),t.modelInitializer!=null&&(n.modelInitializer=t.modelInitializer),t.trainingConfig!=null&&(n.trainingConfig=t.trainingConfig),n}function zX(t,e,n){const s={modelTopology:t.modelTopology,format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy};if(t.trainingConfig!=null&&(s.trainingConfig=t.trainingConfig),t.weightsManifest!=null){if(!e)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!n)throw new Error("modelJSON has weightsManifest but weightData is null");s.weightSpecs=e,s.weightData=n}return t.signature!=null&&(s.signature=t.signature),t.userDefinedMetadata!=null&&(s.userDefinedMetadata=t.userDefinedMetadata),t.modelInitializer!=null&&(s.modelInitializer=t.modelInitializer),s}async function XI(t,e){let n,s;return t.weightsManifest!=null&&([n,s]=await e(t.weightsManifest)),zX(t,n,s)}function R2(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:t.modelTopology==null?0:x9(JSON.stringify(t.modelTopology)),weightSpecsBytes:t.weightSpecs==null?0:x9(JSON.stringify(t.weightSpecs)),weightDataBytes:t.weightData==null?0:t.weightData.byteLength}}function BX(t){const e=[];for(const n of t)e.push(...n.weights);return e}function H5t(){const t=n=>{let s=n<<13,r=0;for(;(s&8388608)===0;)r-=8388608,s<<=1;return s&=-8388609,r+=947912704,s|r},e=new Uint32Array(2048);e[0]=0;for(let n=1;n<1024;n++)e[n]=t(n);for(let n=1024;n<2048;n++)e[n]=939524096+(n-1024<<13);return e}function W5t(){const t=new Uint32Array(64);t[0]=0,t[31]=1199570944,t[32]=2147483648,t[63]=3347054592;for(let e=1;e<31;e++)t[e]=e<<23;for(let e=33;e<63;e++)t[e]=2147483648+(e-32<<23);return t}function U5t(){const t=new Uint32Array(64);for(let e=0;e<64;e++)t[e]=1024;return t[0]=t[32]=0,t}function G5t(){const t=H5t(),e=W5t(),n=U5t();return s=>{const r=new ArrayBuffer(4*s.length),o=new Uint32Array(r);for(let a=0;a<s.length;a++){const i=s[a],l=t[n[i>>10]+(i&1023)]+e[i>>10];o[a]=l}return new Float32Array(r)}}class ls{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return ls.instance==null&&(ls.instance=new ls),ls.instance}static registerSaveRouter(e){ls.getInstance().saveRouters.push(e)}static registerLoadRouter(e){ls.getInstance().loadRouters.push(e)}static getSaveHandlers(e){return ls.getHandlers(e,"save")}static getLoadHandlers(e,n){return ls.getHandlers(e,"load",n)}static getHandlers(e,n,s){const r=[];return(n==="load"?ls.getInstance().loadRouters:ls.getInstance().saveRouters).forEach(a=>{const i=a(e,s);i!==null&&r.push(i)}),r}}const j5t=t=>ls.registerSaveRouter(t),K5t=t=>ls.registerLoadRouter(t),q5t=t=>ls.getSaveHandlers(t),X5t=(t,e)=>ls.getLoadHandlers(t,e);const gS="tensorflowjs",vS=1,ed="models_store",Eu="model_info_store";function VX(){if(!en().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const t=typeof window>"u"?self:window,e=t.indexedDB||t.mozIndexedDB||t.webkitIndexedDB||t.msIndexedDB||t.shimIndexedDB;if(e==null)throw new Error("The current browser does not appear to support IndexedDB.");return e}function yS(t){const e=t.result;e.createObjectStore(ed,{keyPath:"modelPath"}),e.createObjectStore(Eu,{keyPath:"modelPath"})}class Wd{constructor(e){if(this.indexedDB=VX(),e==null||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,e)}async load(){return this.databaseAction(this.modelPath)}databaseAction(e,n){return new Promise((s,r)=>{const o=this.indexedDB.open(gS,vS);o.onupgradeneeded=()=>yS(o),o.onsuccess=()=>{const a=o.result;if(n==null){const i=a.transaction(ed,"readonly"),u=i.objectStore(ed).get(this.modelPath);u.onsuccess=()=>{if(u.result==null)return a.close(),r(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));s(u.result.modelArtifacts)},u.onerror=c=>(a.close(),r(u.error)),i.oncomplete=()=>a.close()}else{const i=R2(n),l=a.transaction(Eu,"readwrite");let u=l.objectStore(Eu);const c=u.put({modelPath:this.modelPath,modelArtifactsInfo:i});let d;c.onsuccess=()=>{d=a.transaction(ed,"readwrite");const h=d.objectStore(ed).put({modelPath:this.modelPath,modelArtifacts:n,modelArtifactsInfo:i});h.onsuccess=()=>s({modelArtifactsInfo:i}),h.onerror=p=>{u=l.objectStore(Eu);const m=u.delete(this.modelPath);m.onsuccess=()=>(a.close(),r(h.error)),m.onerror=g=>(a.close(),r(h.error))}},c.onerror=f=>(a.close(),r(c.error)),l.oncomplete=()=>{d==null?a.close():d.oncomplete=()=>a.close()}}},o.onerror=a=>r(o.error)})}}Wd.URL_SCHEME="indexeddb://";const HX=t=>en().getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(Wd.URL_SCHEME)?Y5t(t.slice(Wd.URL_SCHEME.length)):null;ls.registerSaveRouter(HX);ls.registerLoadRouter(HX);function Y5t(t){return new Wd(t)}function Z5t(t){return t.startsWith(Wd.URL_SCHEME)?t.slice(Wd.URL_SCHEME.length):t}class J5t{constructor(){this.indexedDB=VX()}async listModels(){return new Promise((e,n)=>{const s=this.indexedDB.open(gS,vS);s.onupgradeneeded=()=>yS(s),s.onsuccess=()=>{const r=s.result,o=r.transaction(Eu,"readonly"),i=o.objectStore(Eu).getAll();i.onsuccess=()=>{const l={};for(const u of i.result)l[u.modelPath]=u.modelArtifactsInfo;e(l)},i.onerror=l=>(r.close(),n(i.error)),o.oncomplete=()=>r.close()},s.onerror=r=>n(s.error)})}async removeModel(e){return e=Z5t(e),new Promise((n,s)=>{const r=this.indexedDB.open(gS,vS);r.onupgradeneeded=()=>yS(r),r.onsuccess=()=>{const o=r.result,a=o.transaction(Eu,"readwrite"),i=a.objectStore(Eu),l=i.get(e);let u;l.onsuccess=()=>{if(l.result==null)return o.close(),s(new Error(`Cannot find model with path '${e}' in IndexedDB.`));{const c=i.delete(e),d=()=>{u=o.transaction(ed,"readwrite");const h=u.objectStore(ed).delete(e);h.onsuccess=()=>n(l.result.modelArtifactsInfo),h.onerror=p=>s(l.error)};c.onsuccess=d,c.onerror=f=>(d(),o.close(),s(l.error))}},l.onerror=c=>(o.close(),s(l.error)),a.oncomplete=()=>{u==null?o.close():u.oncomplete=()=>o.close()}},r.onerror=o=>s(r.error)})}}const ml="/",Rf="tensorflowjs_models",WX="info",Q5t="model_topology",eAt="weight_specs",tAt="weight_data",nAt="model_metadata";function UX(t){return{info:[Rf,t,WX].join(ml),topology:[Rf,t,Q5t].join(ml),weightSpecs:[Rf,t,eAt].join(ml),weightData:[Rf,t,tAt].join(ml),modelMetadata:[Rf,t,nAt].join(ml)}}function GX(t){for(const e of Object.values(t))window.localStorage.removeItem(e)}function sAt(t){const e=t.split(ml);if(e.length<3)throw new Error(`Invalid key format: ${t}`);return e.slice(1,e.length-1).join(ml)}function rAt(t){return t.startsWith(Ud.URL_SCHEME)?t.slice(Ud.URL_SCHEME.length):t}class Ud{constructor(e){if(!en().getBool("IS_BROWSER")||typeof window>"u"||typeof window.localStorage>"u")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,e==null||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=UX(this.modelPath)}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const n=JSON.stringify(e.modelTopology),s=JSON.stringify(e.weightSpecs),r=R2(e);try{this.LS.setItem(this.keys.info,JSON.stringify(r)),this.LS.setItem(this.keys.topology,n),this.LS.setItem(this.keys.weightSpecs,s),this.LS.setItem(this.keys.weightData,B5t(e.weightData));const o={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:e.signature!=null?e.signature:void 0,userDefinedMetadata:e.userDefinedMetadata!=null?e.userDefinedMetadata:void 0,modelInitializer:e.modelInitializer!=null?e.modelInitializer:void 0,trainingConfig:e.trainingConfig!=null?e.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(o)),{modelArtifactsInfo:r}}catch{throw GX(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${r.modelTopologyBytes}, weightSpecsBytes=${r.weightSpecsBytes}, weightDataBytes=${r.weightDataBytes}.`)}}}async load(){const e=JSON.parse(this.LS.getItem(this.keys.info));if(e==null)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if(e.modelTopologyType!=="JSON")throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const n={},s=JSON.parse(this.LS.getItem(this.keys.topology));if(s==null)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);n.modelTopology=s;const r=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(r==null)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);n.weightSpecs=r;const o=this.LS.getItem(this.keys.modelMetadata);if(o!=null){const i=JSON.parse(o);n.format=i.format,n.generatedBy=i.generatedBy,n.convertedBy=i.convertedBy,i.signature!=null&&(n.signature=i.signature),i.userDefinedMetadata!=null&&(n.userDefinedMetadata=i.userDefinedMetadata),i.modelInitializer!=null&&(n.modelInitializer=i.modelInitializer),i.trainingConfig!=null&&(n.trainingConfig=i.trainingConfig)}const a=this.LS.getItem(this.keys.weightData);if(a==null)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return n.weightData=V5t(a),n}}Ud.URL_SCHEME="localstorage://";const jX=t=>en().getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(Ud.URL_SCHEME)?oAt(t.slice(Ud.URL_SCHEME.length)):null;ls.registerSaveRouter(jX);ls.registerLoadRouter(jX);function oAt(t){return new Ud(t)}class aAt{constructor(){le(en().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),le(typeof window>"u"||typeof window.localStorage<"u",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){const e={},n=Rf+ml,s=ml+WX;for(let r=0;r<this.LS.length;++r){const o=this.LS.key(r);if(o.startsWith(n)&&o.endsWith(s)){const a=sAt(o);e[a]=JSON.parse(this.LS.getItem(o))}}return e}async removeModel(e){e=rAt(e);const n=UX(e);if(this.LS.getItem(n.info)==null)throw new Error(`Cannot find model at path '${e}'`);const s=JSON.parse(this.LS.getItem(n.info));return GX(n),s}}const Qf="://";class xr{constructor(){this.managers={}}static getInstance(){return xr.instance==null&&(xr.instance=new xr),xr.instance}static registerManager(e,n){le(e!=null,()=>"scheme must not be undefined or null."),e.endsWith(Qf)&&(e=e.slice(0,e.indexOf(Qf))),le(e.length>0,()=>"scheme must not be an empty string.");const s=xr.getInstance();le(s.managers[e]==null,()=>`A model store manager is already registered for scheme '${e}'.`),s.managers[e]=n}static getManager(e){const n=xr.getInstance().managers[e];if(n==null)throw new Error(`Cannot find model manager for scheme '${e}'`);return n}static getSchemes(){return Object.keys(xr.getInstance().managers)}}function vy(t){if(t.indexOf(Qf)===-1)throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${xr.getSchemes().join(",")}`);return{scheme:t.split(Qf)[0],path:t.split(Qf)[1]}}async function KX(t,e,n=!1){le(t!==e,()=>`Old path and new path are the same: '${t}'`);const s=ls.getLoadHandlers(t);le(s.length>0,()=>`Copying failed because no load handler is found for source URL ${t}.`),le(s.length<2,()=>`Copying failed because more than one (${s.length}) load handlers for source URL ${t}.`);const r=s[0],o=ls.getSaveHandlers(e);le(o.length>0,()=>`Copying failed because no save handler is found for destination URL ${e}.`),le(o.length<2,()=>`Copying failed because more than one (${s.length}) save handlers for destination URL ${e}.`);const a=o[0],i=vy(t).scheme,l=vy(t).path,u=i===vy(t).scheme,c=await r.load();n&&u&&await xr.getManager(i).removeModel(l);const d=await a.save(c);return n&&!u&&await xr.getManager(i).removeModel(l),d.modelArtifactsInfo}async function iAt(){const t=xr.getSchemes(),e={};for(const n of t){const s=await xr.getManager(n).listModels();for(const r in s){const o=n+Qf+r;e[o]=s[r]}}return e}async function lAt(t){const e=vy(t);return xr.getManager(e.scheme).removeModel(e.path)}async function uAt(t,e){return KX(t,e,!1)}async function cAt(t,e){return KX(t,e,!0)}class dAt{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(e,n){return fetch(e,n)}now(){return performance.now()}encode(e,n){if(n!=="utf-8"&&n!=="utf8")throw new Error(`Browser's encoder only supports utf-8, but got ${n}`);return this.textEncoder==null&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,n){return new TextDecoder(n).decode(e)}setTimeoutCustom(e,n){if(!window||!en().getBool("USE_SETTIMEOUTCUSTOM")){setTimeout(e,n);return}this.functionRefs.push(e),setTimeout(()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")},n),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",s=>{if(s.source===window&&s.data.name===this.messageName){s.stopPropagation();const r=this.functionRefs[s.data.index];r(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0)}},!0))}}if(en().get("IS_BROWSER")){en().setPlatform("browser",new dAt);try{xr.registerManager(Ud.URL_SCHEME,new aAt)}catch{}try{xr.registerManager(Wd.URL_SCHEME,new J5t)}catch{}}const fAt={importFetch:()=>require("node-fetch")};let M$;class hAt{constructor(){this.util=require("util"),this.textEncoder=new this.util.TextEncoder}fetch(e,n){return en().global.fetch!=null?en().global.fetch(e,n):(M$==null&&(M$=fAt.importFetch()),M$(e,n))}now(){const e=process.hrtime();return e[0]*1e3+e[1]/1e6}encode(e,n){if(n!=="utf-8"&&n!=="utf8")throw new Error(`Node built-in encoder only supports utf-8, but got ${n}`);return this.textEncoder.encode(e)}decode(e,n){return e.length===0?"":new this.util.TextDecoder(n).decode(e)}}en().get("IS_NODE")&&!en().get("IS_BROWSER")&&en().setPlatform("node",new hAt);function ji(t,e="float32",n){return e=e||"float32",PI(t),new Ab(t,e,n)}function pAt(t,e){const n=ne(t,"x","cast");if(!Mj(e))throw new Error(`Failed to cast to unknown dtype ${e}`);if(e==="string"&&n.dtype!=="string"||e!=="string"&&n.dtype==="string")throw new Error("Only strings can be casted to strings");const s={x:n},r={dtype:e};return ke.runKernel(VI,s,r)}const es=Ce({cast_:pAt});function mAt(t){const n={x:ne(t,"x","clone","string_or_numeric")};return ke.runKernel(HI,n)}const bl=Ce({clone_:mAt});function YI(t,e=!1){console.log(t.toString(e))}DX();const gAt={buffer:ji,cast:es,clone:bl,print:YI};S5t(gAt);const vAt="model",yAt=".json",bAt=".weights.bin";function C9(t){return new Promise(e=>setTimeout(e)).then(t)}class Gd{constructor(e){if(!en().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");e.startsWith(Gd.URL_SCHEME)&&(e=e.slice(Gd.URL_SCHEME.length)),(e==null||e.length===0)&&(e=vAt),this.modelJsonFileName=e+yAt,this.weightDataFileName=e+bAt}async save(e){if(typeof document>"u")throw new Error("Browser downloads are not supported in this environment since `document` is not present");const n=window.URL.createObjectURL(new Blob([e.weightData],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const s=[{paths:["./"+this.weightDataFileName],weights:e.weightSpecs}],r=LX(e,s),o=window.URL.createObjectURL(new Blob([JSON.stringify(r)],{type:"application/json"})),a=this.modelJsonAnchor==null?document.createElement("a"):this.modelJsonAnchor;if(a.download=this.modelJsonFileName,a.href=o,await C9(()=>a.dispatchEvent(new MouseEvent("click"))),e.weightData!=null){const i=this.weightDataAnchor==null?document.createElement("a"):this.weightDataAnchor;i.download=this.weightDataFileName,i.href=n,await C9(()=>i.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:R2(e)}}}}Gd.URL_SCHEME="downloads://";class wAt{constructor(e){if(e==null||e.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${e}`);this.jsonFile=e[0],this.weightsFiles=e.slice(1)}async load(){return new Promise((e,n)=>{const s=new FileReader;s.onload=r=>{const o=JSON.parse(r.target.result),a=o.modelTopology;if(a==null){n(new Error(`modelTopology field is missing from file ${this.jsonFile.name}`));return}if(o.weightsManifest==null){n(new Error(`weightManifest field is missing from file ${this.jsonFile.name}`));return}if(this.weightsFiles.length===0){e({modelTopology:a});return}const l=XI(o,u=>this.loadWeights(u));e(l)},s.onerror=r=>n(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),s.readAsText(this.jsonFile)})}loadWeights(e){const n=[],s=[];for(const a of e)n.push(...a.weights),s.push(...a.paths);const r=this.checkManifestAndWeightFiles(e),o=s.map(a=>this.loadWeightsFile(a,r[a]));return Promise.all(o).then(a=>[n,qI(a)])}loadWeightsFile(e,n){return new Promise((s,r)=>{const o=new FileReader;o.onload=a=>{const i=a.target.result;s(i)},o.onerror=a=>r(`Failed to weights data from file of path '${e}'.`),o.readAsArrayBuffer(n)})}checkManifestAndWeightFiles(e){const n=[],s=this.weightsFiles.map(o=>S9(o.name)),r={};for(const o of e)o.paths.forEach(a=>{const i=S9(a);if(n.indexOf(i)!==-1)throw new Error(`Duplicate file basename found in weights manifest: '${i}'`);if(n.push(i),s.indexOf(i)===-1)throw new Error(`Weight file with basename '${i}' is not provided.`);r[a]=this.weightsFiles[s.indexOf(i)]});if(n.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${n.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return r}}const _At=t=>en().getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(Gd.URL_SCHEME)?$At(t.slice(Gd.URL_SCHEME.length)):null;ls.registerSaveRouter(_At);function $At(t="model"){return new Gd(t)}function xAt(t){return new wAt(t)}function k9(t,e,n,s){a(t),n=n??0,s=s??1,i(n,s);let r=0;const o=l=>(l.then(u=>{const c=n+ ++r/t.length*(s-n);return e(c),u}),l);function a(l){le(l!=null&&Array.isArray(l)&&l.length>0,()=>"promises must be a none empty array")}function i(l,u){le(l>=0&&l<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${l}`),le(u>=0&&u<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${u}`),le(u>=l,()=>`startFraction must be no more than endFraction, but got startFraction ${l} and endFraction ${u}`)}return Promise.all(t.map(o))}async function qX(t,e){e==null&&(e={});const n=e.fetchFunc==null?en().platform.fetch:e.fetchFunc,s=t.map(d=>n(d,e.requestInit,{isBinary:!0})),r=0,o=.5,i=(e.onProgress==null?await Promise.all(s):await k9(s,e.onProgress,r,o)).map(d=>d.arrayBuffer()),l=.5,u=1;return e.onProgress==null?await Promise.all(i):await k9(i,e.onProgress,l,u)}async function SAt(t,e="",n,s){return XX(a=>qX(a,{requestInit:s}))(t,e,n)}function XX(t){return async(e,n="",s)=>{const r=e.map(()=>!1),o={},a=s!=null?s.map(()=>!1):[],i=[];if(e.forEach((h,p)=>{let m=0;h.weights.forEach(g=>{const y="quantization"in g?g.quantization.dtype:g.dtype,w=mS[y]*Qn(g.shape),b=()=>{r[p]=!0,o[p]==null&&(o[p]=[]),o[p].push({manifestEntry:g,groupOffset:m,sizeBytes:w})};s!=null?s.forEach((_,$)=>{_===g.name&&(b(),a[$]=!0)}):b(),i.push(g.name),m+=w})}),!a.every(h=>h)){const h=s.filter((p,m)=>!a[m]);throw new Error(`Could not find weights in manifest with names: ${h.join(", ")}. 
Manifest JSON has weights with names: ${i.join(", ")}.`)}const l=r.reduce((h,p,m)=>(p&&h.push(m),h),[]),u=[];l.forEach(h=>{e[h].paths.forEach(p=>{const m=n+(n.endsWith("/")?"":"/")+p;u.push(m)})});const c=await t(u),d={};let f=0;return l.forEach(h=>{const p=e[h].paths.length;let m=0;for(let _=0;_<p;_++)m+=c[f+_].byteLength;const g=new ArrayBuffer(m),y=new Uint8Array(g);let w=0;for(let _=0;_<p;_++){const $=new Uint8Array(c[f+_]);y.set($,w),w+=$.byteLength}o[h].forEach(_=>{const $=g.slice(_.groupOffset,_.groupOffset+_.sizeBytes),x=PX($,[_.manifestEntry]);for(const k in x)d[k]=x[k]}),f+=p}),d}}const CAt="application/octet-stream",kAt="application/json";class ZI{constructor(e,n){if(this.DEFAULT_METHOD="POST",n==null&&(n={}),this.weightPathPrefix=n.weightPathPrefix,this.onProgress=n.onProgress,this.weightUrlConverter=n.weightUrlConverter,n.fetchFunc!=null?(le(typeof n.fetchFunc=="function",()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=n.fetchFunc):this.fetch=en().platform.fetch,le(e!=null&&e.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(e)&&le(e.length===2,()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`),this.path=e,n.requestInit!=null&&n.requestInit.body!=null)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=n.requestInit||{}}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const n=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);n.body=new FormData;const s=[{paths:["./model.weights.bin"],weights:e.weightSpecs}],r=LX(e,s);n.body.append("model.json",new Blob([JSON.stringify(r)],{type:kAt}),"model.json"),e.weightData!=null&&n.body.append("model.weights.bin",new Blob([e.weightData],{type:CAt}),"model.weights.bin");const o=await this.fetch(this.path,n);if(o.ok)return{modelArtifactsInfo:R2(e),responses:[o]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${o.status}.`)}async load(){const e=await this.fetch(this.path,this.requestInit);if(!e.ok)throw new Error(`Request to ${this.path} failed with status code ${e.status}. Please verify this URL points to the model JSON of the model to load.`);let n;try{n=await e.json()}catch{let a=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?a+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":a+=" Please make sure the server is serving valid JSON for this request.",new Error(a)}const s=n.modelTopology,r=n.weightsManifest;if(s==null&&r==null)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return XI(n,o=>this.loadWeights(o))}async loadWeights(e){const n=Array.isArray(this.path)?this.path[1]:this.path,[s,r]=TAt(n),o=this.weightPathPrefix||s,a=BX(e),i=[],l=[];for(const c of e)for(const d of c.paths)this.weightUrlConverter!=null?l.push(this.weightUrlConverter(d)):i.push(o+d+r);this.weightUrlConverter&&i.push(...await Promise.all(l));const u=await qX(i,{requestInit:this.requestInit,fetchFunc:this.fetch,onProgress:this.onProgress});return[a,qI(u)]}}ZI.URL_SCHEME_REGEX=/^https?:\/\//;function TAt(t){const e=t.lastIndexOf("/"),n=t.lastIndexOf("?"),s=t.substring(0,e),r=n>e?t.substring(n):"";return[s+"/",r]}function bS(t){return t.match(ZI.URL_SCHEME_REGEX)!=null}const YX=(t,e)=>{if(typeof fetch>"u"&&(e==null||e.fetchFunc==null))return null;{let n=!0;if(Array.isArray(t)?n=t.every(s=>bS(s)):n=bS(t),n)return JI(t,e)}return null};ls.registerSaveRouter(YX);ls.registerLoadRouter(YX);function JI(t,e){return new ZI(t,e)}function NAt(t,e){return JI(t,e)}class P${constructor(e){this.modelArtifacts=e}load(){return this.modelArtifacts}}class ZX{constructor(e){this.saveHandler=e}save(e){return this.saveHandler(e)}}class IAt{constructor(e){e.load&&(this.load=()=>Promise.resolve(e.load())),e.save&&(this.save=n=>Promise.resolve(e.save(n)))}}function EAt(t,e,n,s){const r=arguments;return new IAt(JX(...r))}function JX(t,e,n,s){return arguments.length===1?t.modelTopology!=null||t.weightSpecs!=null?new P$(t):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new P$({modelTopology:t})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new P$({modelTopology:t,weightSpecs:e,weightData:n,trainingConfig:s}))}function AAt(t){return new ZX(t)}function OAt(t){return new ZX(t)}const QI=Object.freeze(Object.defineProperty({__proto__:null,browserFiles:xAt,browserHTTPRequest:NAt,concatenateArrayBuffers:qI,decodeWeights:PX,encodeWeights:L5t,fromMemory:EAt,fromMemorySync:JX,getLoadHandlers:X5t,getModelArtifactsForJSON:XI,getModelArtifactsForJSONSync:zX,getModelArtifactsInfoForJSON:R2,getSaveHandlers:q5t,getWeightSpecs:BX,http:JI,isHTTPScheme:bS,loadWeights:SAt,registerLoadRouter:K5t,registerSaveRouter:j5t,weightsLoaderFactory:XX,withSaveHandler:AAt,withSaveHandlerSync:OAt,copyModel:uAt,listModels:iAt,moveModel:cAt,removeModel:lAt},Symbol.toStringTag,{value:"Module"}));function RAt(t,e,n=!1,s=!1){let r=ne(t,"a","matMul"),o=ne(e,"b","matMul");[r,o]=fs(r,o);const a={a:r,b:o},i={transposeA:n,transposeB:s};return ke.runKernel(rK,a,i)}const Tn=Ce({matMul_:RAt});function DAt(t,e,n=1,s=0,r="int32"){if(e<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${e}`);const a={indices:ne(t,"indices","oneHot","int32")},i={dtype:r,depth:e,onValue:n,offValue:s};return ke.runKernel(Tq,a,i)}const Rb=Ce({oneHot_:DAt});function FAt(){en().set("PROD",!0)}function MAt(){en().set("DEBUG",!0)}function PAt(){en().set("DEPRECATION_WARNINGS_ENABLED",!1),console.warn("TensorFlow.js deprecation warnings have been disabled.")}function LAt(t){en().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(t+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")}function zAt(){ke.disposeVariables()}function BAt(){return ke}function VAt(){return ke.memory()}function HAt(t){return ke.profile(t)}function vn(t,e){return ke.tidy(t,e)}function qr(t){GI(t).forEach(n=>n.dispose())}function Ii(t){return ke.keep(t)}function WAt(t){return ke.time(t)}function UAt(t){return ke.setBackend(t)}function GAt(){return ke.ready()}function jAt(){return ke.backendName}function KAt(t){ke.removeBackend(t)}function qAt(t){return ke.findBackend(t)}function XAt(t){return ke.findBackendFactory(t)}function YAt(t,e,n=1){return ke.registerBackend(t,e,n)}function ZAt(){return ke.backend}function JAt(t,e){en().setPlatform(t,e)}function QAt(t){const n={input:ne(t,"input","imag")};return ke.runKernel(XK,n)}const D2=Ce({imag_:QAt});function eOt(t){const n={x:ne(t,"x","neg")};return ke.runKernel(_q,n)}const Pi=Ce({neg_:eOt});function tOt(t){const n={input:ne(t,"input","real")};return ke.runKernel(Mq,n)}const Hh=Ce({real_:tOt});function nOt(t,e,n){const s=ne(t,"x","transpose");if(e==null&&(e=s.shape.map((a,i)=>i).reverse()),le(s.rank===e.length,()=>`Error in transpose: rank of input ${s.rank} must match length of perm ${e}.`),e.forEach(a=>{le(a>=0&&a<s.rank,()=>`All entries in 'perm' must be between 0 and ${s.rank-1} but got ${e}`)}),s.rank<=1)return s.clone();const r={x:s},o={perm:e};return s.dtype==="complex64"?vn(()=>{let a=Hh(s),i=D2(s);return a=ke.runKernel(my,{x:a},o),i=ke.runKernel(my,{x:i},o),n&&(i=Pi(i)),Dl(a,i)}):ke.runKernel(my,r,o)}const vg=Ce({transpose_:nOt});function sOt(t,e,n){const s=ne(t,"labels","confusionMatrix"),r=ne(e,"predictions","confusionMatrix");le(n==null||n>0&&Number.isInteger(n),()=>`If provided, numClasses must be a positive integer, but got ${n}`),le(s.rank===1,()=>`Expected the rank of labels to be 1, but got ${s.rank}`),le(r.rank===1,()=>`Expected the rank of predictions to be 1, but got ${r.rank}`),le(s.shape[0]===r.shape[0],()=>`Mismatch in the number of examples: ${s.shape[0]} vs. ${r.shape[0]}. Labels and predictions should have the same number of elements.`),le(n>0&&Number.isInteger(n),()=>`numClasses is required to be a positive integer, but got ${n}`);const o=Rb(es(s,"int32"),n),a=Rb(es(r,"int32"),n),i=vg(o),l=Tn(i,a);return es(l,"int32")}const rOt=Ce({confusionMatrix_:sOt});const oOt=Object.freeze(Object.defineProperty({__proto__:null,confusionMatrix:rOt},Symbol.toStringTag,{value:"Module"}));function QX(t,e){const n=t.length,s=[];for(let r=0;r<n;r++){const o=n-1-r,a=t[o]||1;(e[e.length-1-r]||1)>1&&a===1&&s.unshift(o)}return s}function eE(t,e){const n=[];for(let s=0;s<e.length;s++){const r=t[t.length-s-1],o=e.length-s-1,a=e[o];(r==null||r===1&&a>1)&&n.unshift(o)}return n}function Ns(t,e){const n=[],s=Math.max(t.length,e.length);for(let r=0;r<s;r++){let o=t[t.length-r-1];o==null&&(o=1);let a=e[e.length-r-1];if(a==null&&(a=1),o===1)n.unshift(a);else if(a===1)n.unshift(o);else if(o!==a){const i=`Operands could not be broadcast together with shapes ${t} and ${e}.`;throw Error(i)}else n.unshift(o)}return n}const aOt=Object.freeze(Object.defineProperty({__proto__:null,getBroadcastDims:QX,getReductionAxes:eE,assertAndGetBroadcastShape:Ns},Symbol.toStringTag,{value:"Module"}));function tE(t,e,n){if(gf(t),e!=null&&e.length!==3)throw new Error("tensor3d() requires shape to have three numbers");const s=Gi(t,n);if(s.length!==3&&s.length!==1)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(s.length===1&&e==null)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return bc(t,e,s,n)}let Ec;function eY(t,e=3){if(e>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(t==null)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let n=!1,s=!1,r=!1,o=!1,a=!1,i=!1;if(t.data instanceof Uint8Array)n=!0;else if(typeof ImageData<"u"&&t instanceof ImageData)s=!0;else if(typeof HTMLVideoElement<"u"&&t instanceof HTMLVideoElement)r=!0;else if(typeof HTMLImageElement<"u"&&t instanceof HTMLImageElement)o=!0;else if(t.getContext!=null)a=!0;else if(typeof ImageBitmap<"u"&&t instanceof ImageBitmap)i=!0;else throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${t.constructor.name}`);if(Nb(sS,ke.backendName)!=null){const p={pixels:t},m={numChannels:e};return ke.runKernel(sS,p,m)}const[u,c]=r?[t.videoWidth,t.videoHeight]:[t.width,t.height];let d;if(a)d=t.getContext("2d").getImageData(0,0,u,c).data;else if(s||n)d=t.data;else if(o||r||i){if(Ec==null)if(typeof document>"u")if(typeof OffscreenCanvas<"u"&&typeof OffscreenCanvasRenderingContext2D<"u")Ec=new OffscreenCanvas(1,1).getContext("2d");else throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");else Ec=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});Ec.canvas.width=u,Ec.canvas.height=c,Ec.drawImage(t,0,0,u,c),d=Ec.getImageData(0,0,u,c).data}let f;if(e===4)f=new Int32Array(d);else{const p=u*c;f=new Int32Array(p*e);for(let m=0;m<p;m++)for(let g=0;g<e;++g)f[m*e+g]=d[m*4+g]}return tE(f,[c,u,e],"int32")}function iOt(t){return t!=null&&t.data instanceof Uint8Array}function lOt(){return typeof window<"u"&&typeof ImageBitmap<"u"&&window.hasOwnProperty("createImageBitmap")}function uOt(t){return t!=null&&t.width!==0&&t.height!==0}function cOt(t){return lOt()&&!(t instanceof ImageBitmap)&&uOt(t)&&!iOt(t)}async function dOt(t,e=3){let n=null;if(en().getBool("WRAP_TO_IMAGEBITMAP")&&cOt(t)){let s;try{s=await createImageBitmap(t,{premultiplyAlpha:"none"})}catch{s=null}s!=null&&s.width===t.width&&s.height===t.height?n=s:n=t}else n=t;return eY(n,e)}async function fOt(t,e){let n=ne(t,"img","toPixels");if(!(t instanceof os)){const u=n;n=es(u,"int32"),u.dispose()}if(n.rank!==2&&n.rank!==3)throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${n.rank}.`);const[s,r]=n.shape.slice(0,2),o=n.rank===2?1:n.shape[2];if(o>4||o===2)throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${o}`);if(n.dtype!=="float32"&&n.dtype!=="int32")throw new Error(`Unsupported type for toPixels: ${n.dtype}. Please use float32 or int32 tensors.`);const a=await n.data(),i=n.dtype==="float32"?255:1,l=new Uint8ClampedArray(r*s*4);for(let u=0;u<s*r;++u){const c=[0,0,0,255];for(let f=0;f<o;f++){const h=a[u*o+f];if(n.dtype==="float32"){if(h<0||h>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${h}.`)}else if(n.dtype==="int32"&&(h<0||h>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${h}.`);o===1?(c[0]=h*i,c[1]=h*i,c[2]=h*i):c[f]=h*i}const d=u*4;l[d+0]=Math.round(c[0]),l[d+1]=Math.round(c[1]),l[d+2]=Math.round(c[2]),l[d+3]=Math.round(c[3])}if(e!=null){e.width=r,e.height=s;const u=e.getContext("2d"),c=new ImageData(l,r,s);u.putImageData(c,0,0)}return n!==t&&n.dispose(),l}const tY=Ce({fromPixels_:eY}),hOt=Object.freeze(Object.defineProperty({__proto__:null,fromPixelsAsync:dOt,toPixels:fOt,fromPixels:tY},Symbol.toStringTag,{value:"Module"}));function nY(t,e){const n=t.shape.length,s=e.shape.length;if(n<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${n}.`);if(s<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${s}.`);if(e.dtype!=="int32")throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.shape[s-1]>n)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${e.shape[s-1]} vs. ${n}`);if(Qn(t.shape)===0)throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${t.shape}.`);const r=e.shape,o=r[r.length-1];let a=1;for(let d=0;d<r.length-1;++d)a*=r[d];const i=t.shape,l=r.slice();l.pop();let u=1;for(let d=o;d<n;++d)u*=i[d],l.push(i[d]);const c=[...wm(t.shape).map(d=>d/u),1].slice(0,o);return[l,a,u,c]}const pOt=Object.freeze(Object.defineProperty({__proto__:null,prepareAndValidate:nY},Symbol.toStringTag,{value:"Module"}));function nE(t,e,n){const s=e.rank>1?e.shape[e.rank-1]:1,r=e.rank>1?e.rank-1:1,o=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${n.shape}, indices.shape: ${e.shape}, shape: ${t}, sliceDim: ${s}, and batchDim: ${r}.`;if(n.rank<r)throw new Error(o+` update.rank < ${r}. `);if(t.length<s+(n.rank-r))throw new Error(o+` Output shape length < ${s+(n.rank-r)}`);if(n.rank!==r+t.length-s)throw new Error(o+` update.rank != ${r+t.length-s}`);for(let a=0;a<r;++a)if(n.shape[a]!==e.shape[a])throw new Error(o+` updates.shape[${a}] (${n.shape[a]}) != indices.shape[${a}] (${e.shape[a]}).`);for(let a=0;a<n.rank-r;++a)if(n.shape[a+r]!==t[a+s])throw new Error(o+` updates.shape[${a+r}] (${n.shape[a+r]}) != shape[${a+r}] (${t[a+r]})`)}function sE(t,e,n){if(e.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${e.rank}.`);if(t.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${t.rank}.`);if(e.dtype!=="int32")throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${e.dtype}`);if(n.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${n}`);if(n.length===0){if(e.size===0)throw new Error(`Indices specified for empty output. indices shape: ${e.shape}`);if(t.size===0)throw new Error(`Updates specified for empty output. updates shape: ${t.shape}`)}nE(n,e,t)}function sY(t,e,n){const s=e.shape.length,r=s>1?e.shape[s-1]:1,o=n.length;let a=1;for(let d=r;d<o;++d)a*=n[d];const i=r<1?1:r,l=Qn(e.shape)/i,u=[...wm(n.slice(0,r)),1],c=Qn(n);return{sliceRank:r,numUpdates:l,sliceSize:a,strides:u,outputSize:c}}const mOt=Object.freeze(Object.defineProperty({__proto__:null,validateUpdateShape:nE,validateInput:sE,calculateShapes:sY},Symbol.toStringTag,{value:"Module"}));const wS=-2,gOt=-1;function vOt(t,e,n){const s=t.shape.length;le(s===e.length,()=>`Error in slice${s}D: Length of begin ${e} must match the rank of the array (${s}).`),le(s===n.length,()=>`Error in slice${s}D: Length of size ${n} must match the rank of the array (${s}).`);for(let r=0;r<s;++r)le(e[r]+n[r]<=t.shape[r],()=>`Error in slice${s}D: begin[${r}] + size[${r}] (${e[r]+n[r]}) would overflow input.shape[${r}] (${t.shape[r]})`)}function yOt(t){const e=[];let n=0;for(;t>0;)t&1&&e.push(n),t/=2,n++;return e}function bOt(t,e,n){const s=[];for(let r=0;r<t.length;r++)s[r]=Math.ceil((e[r]-t[r])/n[r]);return s}function rY(t,e,n,s){const r=[...t];for(let o=r.length;o<s.length;o++)r.push(1);for(let o=0;o<n;o++)o===0?r[e]=1:(r.splice(e,0,1),r.pop());return r}function oY(t,e,n){return n<=t?n:n-(e-1)}function aY(t,e){const n=[];for(let s=0;s<t;s++)n.push(e+s);return n}function wOt(t,e,n,s,r,o,a,i,l){const u=t.length;let c=new Array(u),d=new Array(u),f=new Array(u);if(e.length&&n>0){const h=e[0],p=n+1;c=iY(a,h,p,s,t),d=lY(i,h,p,r,t),f=rY(o,h,p,t)}else for(let h=0;h<u;h++)c[h]=cY(a,s,o,t,h,l),d[h]=dY(i,r,o,t,h,l),f[h]=uY(o,h,l);return{begin:c,end:d,strides:f}}function iY(t,e,n,s,r){const o=[...r],a=aY(n,e);for(let i=0;i<o.length;i++)if(a.indexOf(i)>-1)o[i]=0;else{const l=oY(e,n,i);let u=s[l];t&1<<l&&(u=0),o[i]=u}return o}function lY(t,e,n,s,r){const o=[...r],a=aY(n,e);for(let i=0;i<o.length;i++)if(a.indexOf(i)>-1)o[i]=Number.MAX_SAFE_INTEGER;else{const l=oY(e,n,i);let u=s[l];t&1<<l&&(u=Number.MAX_SAFE_INTEGER),o[i]=u}for(let i=0;i<o.length;i++){const l=r[i];o[i]<0&&(o[i]+=l),o[i]=fg(0,o[i],r[i])}return o}function uY(t,e,n){let s=t[e];return(n&1<<e||s==null)&&(s=1),s}function cY(t,e,n,s,r,o){let a=e[r];const i=n[r]||1;(t&1<<r||o&1<<r||a==null)&&(i>0?a=Number.MIN_SAFE_INTEGER:a=Number.MAX_SAFE_INTEGER);const l=s[r];return a<0&&(a+=l),a=fg(0,a,l-1),a}function dY(t,e,n,s,r,o){let a=e[r];const i=n[r]||1;(t&1<<r||o&1<<r||a==null)&&(i>0?a=Number.MAX_SAFE_INTEGER:a=Number.MIN_SAFE_INTEGER);const l=s[r];return a<0&&(a+=l),i>0?a=fg(0,a,l):a=fg(-1,a,l-1),a}function _Ot(t,e,n){let s=n.length;for(let r=0;r<n.length;r++)if(n[r]>1){s=r;break}for(let r=s+1;r<n.length;r++)if(e[r]>0||n[r]!==t[r])return!1;return!0}function $Ot(t,e){let n=t.length>0?t[t.length-1]:1;for(let s=0;s<t.length-1;s++)n+=t[s]*e[s];return n}function xOt(t,e,n){let s;const r=t.shape.length;typeof e=="number"?s=[e,...new Array(r-1).fill(0)]:e.length<r?s=e.concat(new Array(r-e.length).fill(0)):s=e.slice(),s.forEach(a=>{le(a!==-1,()=>"slice() does not support negative begin indexing.")});let o;return n==null?o=new Array(r).fill(-1):typeof n=="number"?o=[n,...new Array(r-1).fill(-1)]:n.length<r?o=n.concat(new Array(r-n.length).fill(-1)):o=n,o=o.map((a,i)=>a>=0?a:(le(a===-1,()=>`Negative size values should be exactly -1 but got ${a} for the slice() size at index ${i}.`),t.shape[i]-s[i])),[s,o]}function SOt(t,e,n,s,r,o,a,i,l){let u;if(s==null?(u=new Array(e.length),u.fill(1)):u=s,a!=null&&(a&a-1)!==0)throw new Error("Multiple ellipses in slice is not allowed.");let c=!1;const d={dims:u.length,numAddAxisAfterEllipsis:0,begin:e.slice(),end:n.slice(),strides:u.slice(),beginMask:r,endMask:o,ellipsisMask:a,newAxisMask:i,shrinkAxisMask:l};for(let b=0;b<d.dims;b++)c&&(1<<b&i)!==0&&d.numAddAxisAfterEllipsis++,1<<b&a&&(c=!0);c||(d.ellipsisMask|=1<<d.dims,d.dims++);const f={dims:t.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};COt(d,f);let h=!0,p=!0,m=!0;const g=[],y=[];for(let b=0;b<t.length;++b){if(f.strides[b]===0)throw Error(`strides[${b}] must be non-zero`);const _=!!(f.shrinkAxisMask&1<<b),$=t[b];if($===-1){g.push(_?1:-1);continue}const x=[f.beginMask&1<<b,f.endMask&1<<b],k=[f.strides[b]>0?0:-1,f.strides[b]>0?$:$-1];if(_&&f.strides[b]<=0)throw Error("only stride 1 allowed on non-range indexing.");m=m&&f.strides[b]===1;const C=!!(f.beginMask&1<<b&&f.endMask&1<<b);if(f.beginValid&&f.endValid){if(_){const R=f.begin[b]<0?$+f.begin[b]:f.begin[b];if(f.begin[b]=R,f.end[b]=f.begin[b]+1,R<0||R>=$)throw Error(`slice index ${f.begin[b]} of dimension ${b} out of bounds.`)}else f.begin[b]=T9(f.begin[b],0,f.strides[b],$,x,k),f.end[b]=T9(f.end[b],1,f.strides[b],$,x,k);const M=f.strides[b]===1&&f.begin[b]===0&&f.end[b]===$;h=h&&M,p=p&&(b===0&&f.strides[b]===1||M)}else h=h&&f.strides[b]===1&&C,p=p&&(b===0&&f.strides[b]===1||C);let T,N=!1;if(f.beginValid&&f.endValid?(T=f.end[b]-f.begin[b],N=!0):_?(T=1,N=!0):C&&$>=0&&(f.strides[b]<0?T=-$:T=$,N=!0),N){let M;T===0||T<0!=f.strides[b]<0?M=0:M=Math.trunc(T/f.strides[b])+(T%f.strides[b]!==0?1:0),g.push(M)}else g.push(-1)}for(let b=0;b<f.finalShapeGatherIndices.length;++b){const _=f.finalShapeGatherIndices[b];_>=0?y.push(g[_]):_===wS&&y.push(1)}return{finalShapeSparse:y.filter((b,_)=>f.finalShapeGatherIndices[_]!==wS),finalShape:y,isIdentity:h,sliceDim0:p,isSimpleSlice:m,begin:f.begin,end:f.end,strides:f.strides}}function COt(t,e){e.beginMask=0,e.endMask=0,e.shrinkAxisMask=0;let n=0;e.beginValid=t.begin!=null,e.endValid=t.end!=null,e.begin=new Array(e.dims),e.end=new Array(e.dims),e.strides=new Array(e.dims),e.finalShapeGatherIndices=[],e.finalShapeGatherIndicesSparse=[],e.inputShapeGatherIndicesSparse=new Array(e.dims);for(let s=0;s<t.dims;s++)if(1<<s&t.ellipsisMask){const r=Math.min(e.dims-(t.dims-s)+1+t.numAddAxisAfterEllipsis,e.dims);for(;n<r;n++)e.begin[n]=0,e.end[n]=0,e.strides[n]=1,e.beginMask|=1<<n,e.endMask|=1<<n,e.finalShapeGatherIndices.push(n),e.finalShapeGatherIndicesSparse.push(-1),e.inputShapeGatherIndicesSparse[n]=s}else if(1<<s&t.newAxisMask)e.finalShapeGatherIndices.push(wS),e.finalShapeGatherIndicesSparse.push(-1);else{if(n===e.begin.length)throw Error(`Index out of range using input dim ${n}; input has only ${e.dims} dims, ${e.begin.length}.`);t.begin!=null&&(e.begin[n]=t.begin[s]),t.end!=null&&(e.end[n]=t.end[s]),e.strides[n]=t.strides[s],t.beginMask&1<<s&&(e.beginMask|=1<<n),t.endMask&1<<s&&(e.endMask|=1<<n),t.shrinkAxisMask&1<<s?(e.finalShapeGatherIndices.push(gOt),e.finalShapeGatherIndicesSparse.push(-1),e.shrinkAxisMask|=1<<n):(e.finalShapeGatherIndices.push(n),e.finalShapeGatherIndicesSparse.push(s)),e.inputShapeGatherIndicesSparse[n]=s,n++}}function T9(t,e,n,s,r,o){if(r[e])return n>0?o[e]:o[e+1&1];{const a=t<0?s+t:t;return a<o[0]?o[0]:a>o[1]?o[1]:a}}const fY=Object.freeze(Object.defineProperty({__proto__:null,assertParamsValid:vOt,maskToAxes:yOt,computeOutShape:bOt,stridesWithElidedDims:rY,getNormalizedAxes:wOt,startIndicesWithElidedDims:iY,stopIndicesWithElidedDims:lY,stridesForAxis:uY,startForAxis:cY,stopForAxis:dY,isSliceContinous:_Ot,computeFlatOffset:$Ot,parseSliceParams:xOt,sliceInfo:SOt},Symbol.toStringTag,{value:"Module"}));class hY{getClassName(){return this.constructor.className}static fromConfig(e,n){return new e(n)}}class $u{constructor(){this.classNameMap={}}static getMap(){return $u.instance==null&&($u.instance=new $u),$u.instance}static register(e){$u.getMap().classNameMap[e.className]=[e,e.fromConfig]}}function wc(t){le(t.className!=null,()=>"Class being registered does not have the static className property defined."),le(typeof t.className=="string",()=>"className is required to be a string, but got type "+typeof t.className),le(t.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),$u.register(t)}const kOt=Object.freeze(Object.defineProperty({__proto__:null,Serializable:hY,SerializationMap:$u,registerClass:wc},Symbol.toStringTag,{value:"Module"}));const TOt=.001,pY=.1;function NOt(t,e,n){return n==null&&(n=rE()),_S(t,e,(s,r)=>oE(s,r,n))}function rE(){return ke.backend.floatPrecision()===32?TOt:pY}function _S(t,e,n){let s=!0;if((pr(t)||pr(e))&&(s=!1),pr(t)&&pr(e)&&(s=!0),s){const a=t.constructor.name,i=e.constructor.name;if(a!==i)throw new Error(`Arrays are of different type. Actual: ${a}. Expected: ${i}`)}if(Array.isArray(t)&&Array.isArray(e)){const a=Gi(t),i=Gi(e);if(!Ui(a,i))throw new Error(`Arrays have different shapes. Actual: [${a}]. Expected: [${i}]`)}const r=pr(t)?t:Vd(t),o=pr(e)?e:Vd(e);if(r.length!==o.length)throw new Error(`Arrays have different lengths actual: ${r.length} vs expected: ${o.length}.
Actual:   ${r}.
Expected: ${o}.`);for(let a=0;a<o.length;++a){const i=r[a],l=o[a];if(!n(i,l))throw new Error(`Arrays differ: actual[${a}] = ${i}, expected[${a}] = ${l}.
Actual:   ${r}.
Expected: ${o}.`)}typeof expect<"u"&&expect().nothing()}function IOt(t,e){t().then(()=>e.fail(),()=>e()),typeof expect<"u"&&expect().nothing()}function EOt(t,e){const n=typeof e=="string"||typeof e=="number"||typeof e=="boolean"?[e]:e;return Iu(t)||Iu(t[0])||Iu(e)||Iu(e[0])?_S(t,n,(s,r)=>s==r):_S(t,e,(s,r)=>oE(s,r,0))}function AOt(t,e,n){if(n==null&&(n=rE()),!oE(t,e,n))throw new Error(`Numbers differ: actual === ${t}, expected === ${e}`);typeof expect<"u"&&expect().nothing()}function oE(t,e,n){return!isFinite(t)&&!isFinite(e)?!0:!(isNaN(t)||isNaN(e)||Math.abs(t-e)>n)}function OOt(t,e,n){for(let s=0;s<t.length;s++)if(t[s]<e||t[s]>n)throw new Error(`Value out of range:${t[s]} low: ${e}, high: ${n}`)}function ROt(t,e){const n=new Float32Array(t),s=new Float32Array(e);if(n.length!==s.length)throw new Error(`Expected ArrayBuffer to be of length ${s.length}, but it was ${n.length}`);for(let r=0;r<s.length;r++)if(n[r]!==s[r])throw new Error(`Expected ArrayBuffer value at ${r} to be ${s[r]} but got ${n[r]} instead`)}function mY(t){for(let e=0;e<t.length;e++){const n=t[e];Array.isArray(n)?mY(n):t[e]=O2(n)}return t}function DOt(t){const e=document.createElement("video");return"playsInline"in e&&(e.playsInline=!0),e.muted=!0,e.loop=!0,e.style.position="fixed",e.style.left="0px",e.style.top="0px",e.preload="auto",e.appendChild(t),new Promise(n=>{e.addEventListener("loadeddata",s=>n(e)),e.load()})}async function FOt(t){await t.play(),"requestVideoFrameCallback"in t&&await new Promise(e=>{t.requestVideoFrameCallback(e)})}const MOt=Object.freeze(Object.defineProperty({__proto__:null,TEST_EPSILON_FLOAT16:pY,expectArraysClose:NOt,testEpsilon:rE,expectPromiseToFail:IOt,expectArraysEqual:EOt,expectNumbersClose:AOt,expectValuesInRange:OOt,expectArrayBuffersEqual:ROt,encodeStrings:mY,createVideoElement:DOt,play:FOt},Symbol.toStringTag,{value:"Module"}));const POt="3.21.0";function LOt(t,e){let n=ne(t,"a","add"),s=ne(e,"b","add");[n,s]=fs(n,s);const r={a:n,b:s};return ke.runKernel(BI,r)}const Wt=Ce({add_:LOt});function zOt(t,e){let n=ne(t,"a","floorDiv"),s=ne(e,"b","floorDiv");[n,s]=fs(n,s);const r={a:n,b:s};return ke.runKernel(HK,r)}const aE=Ce({floorDiv_:zOt});function BOt(t,e){let n=ne(t,"a","div"),s=ne(e,"b","div");if([n,s]=fs(n,s),n.dtype==="int32"&&s.dtype==="int32")return aE(n,s);const r={a:n,b:s},o={};return ke.runKernel(EK,r,o)}const En=Ce({div_:BOt});function VOt(t,e){let n=ne(t,"a","mul"),s=ne(e,"b","mul");[n,s]=fs(n,s);const r={a:n,b:s};return ke.runKernel(wq,r)}const gt=Ce({mul_:VOt});function HOt(t){const e=ne(t,"x","abs");if(e.dtype==="complex64"){const n={x:e};return ke.runKernel(dK,n)}else{const n={x:e};return ke.runKernel(Wj,n)}}const co=Ce({abs_:HOt});function WOt(t){const n={x:ne(t,"x","acos")};return ke.runKernel(Uj,n)}const gY=Ce({acos_:WOt});function UOt(t){const n={x:ne(t,"x","acosh")};return ke.runKernel(Gj,n)}const vY=Ce({acosh_:UOt});function GOt(t){le(Array.isArray(t),()=>"The argument passed to tf.addN() must be a list of tensors"),le(t.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${t.length}`);const e=t.map((r,o)=>ne(r,`tensors${o}`,"addN")),n=e[0];e.forEach(r=>{if(r.dtype!==n.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),e.forEach(r=>{if(!Ui(r.shape,n.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")});const s=e;return ke.runKernel(jj,s)}const yY=Ce({addN_:GOt});function jOt(t,e=null,n=!1){const r={x:ne(t,"x","all","bool")},o={axis:e,keepDims:n};return ke.runKernel(Kj,r,o)}const bY=Ce({all_:jOt});function KOt(t,e=null,n=!1){const r={x:ne(t,"x","any","bool")},o={axis:e,keepDims:n};return ke.runKernel(qj,r,o)}const wY=Ce({any_:KOt});function qOt(t,e=0){const s={x:ne(t,"x","argMax")},r={axis:e};return ke.runKernel(Xj,s,r)}const iE=Ce({argMax_:qOt});function XOt(t,e=0){const s={x:ne(t,"x","argMin")},r={axis:e};return ke.runKernel(Yj,s,r)}const _Y=Ce({argMin_:XOt});function YOt(t){const n={x:ne(t,"x","asin")};return ke.runKernel(Zj,n)}const $Y=Ce({asin_:YOt});function ZOt(t){const n={x:ne(t,"x","asinh")};return ke.runKernel(Jj,n)}const xY=Ce({asinh_:ZOt});function JOt(t){const n={x:ne(t,"x","atan")};return ke.runKernel(Qj,n)}const SY=Ce({atan_:JOt});function QOt(t,e){let n=ne(t,"a","atan2"),s=ne(e,"b","atan2");[n,s]=fs(n,s);const r={a:n,b:s};return ke.runKernel(tK,r)}const CY=Ce({atan2_:QOt});function eRt(t){const n={x:ne(t,"x","atanh")};return ke.runKernel(eK,n)}const kY=Ce({atanh_:eRt});function tRt(t,e,n,s,r="NHWC",o){const a=t[3],i=[...e,a],l=IY(r);return F2(t,i,n,o,s,null,null,l)}function TY(t,e,n,s,r,o,a="channelsLast"){const[i,l]=Db(e);let u;if(a==="channelsLast")u=[i,l,t[3],t[3]];else if(a==="channelsFirst")u=[i,l,t[1],t[1]];else throw new Error(`Unknown dataFormat ${a}`);return F2(t,u,n,s,r,o,!1,a)}function nRt(t,e,n,s,r,o,a="NDHWC"){const[i,l,u]=$S(e);let c,d;if(a==="NDHWC")d="channelsLast",c=[i,l,u,t[4],t[4]];else if(a==="NCDHW")d="channelsFirst",c=[i,l,u,t[1],t[1]];else throw new Error(`Unknown dataFormat ${a}`);return NY(t,c,n,s,r,!1,d,o)}function F2(t,e,n,s,r,o,a=!1,i="channelsLast"){let[l,u,c,d]=[-1,-1,-1,-1];if(i==="channelsLast")[l,u,c,d]=t;else if(i==="channelsFirst")[l,d,u,c]=t;else throw new Error(`Unknown dataFormat ${i}`);const[f,h,,p]=e,[m,g]=Db(n),[y,w]=Db(s),b=eh(f,y),_=eh(h,w),{padInfo:$,outHeight:x,outWidth:k}=oRt(r,u,c,m,g,b,_,o,i),C=a?p*d:p;let T;return i==="channelsFirst"?T=[l,C,x,k]:i==="channelsLast"&&(T=[l,x,k,C]),{batchSize:l,dataFormat:i,inHeight:u,inWidth:c,inChannels:d,outHeight:x,outWidth:k,outChannels:C,padInfo:$,strideHeight:m,strideWidth:g,filterHeight:f,filterWidth:h,effectiveFilterHeight:b,effectiveFilterWidth:_,dilationHeight:y,dilationWidth:w,inShape:t,outShape:T,filterShape:e}}function NY(t,e,n,s,r,o=!1,a="channelsLast",i){let[l,u,c,d,f]=[-1,-1,-1,-1,-1];if(a==="channelsLast")[l,u,c,d,f]=t;else if(a==="channelsFirst")[l,f,u,c,d]=t;else throw new Error(`Unknown dataFormat ${a}`);const[h,p,m,,g]=e,[y,w,b]=$S(n),[_,$,x]=$S(s),k=eh(h,_),C=eh(p,$),T=eh(m,x),{padInfo:N,outDepth:M,outHeight:R,outWidth:D}=aRt(r,u,c,d,y,w,b,k,C,T,i),z=o?g*f:g;let B;return a==="channelsFirst"?B=[l,z,M,R,D]:a==="channelsLast"&&(B=[l,M,R,D,z]),{batchSize:l,dataFormat:a,inDepth:u,inHeight:c,inWidth:d,inChannels:f,outDepth:M,outHeight:R,outWidth:D,outChannels:z,padInfo:N,strideDepth:y,strideHeight:w,strideWidth:b,filterDepth:h,filterHeight:p,filterWidth:m,effectiveFilterDepth:k,effectiveFilterHeight:C,effectiveFilterWidth:T,dilationDepth:_,dilationHeight:$,dilationWidth:x,inShape:t,outShape:B,filterShape:e}}function sRt(t,e,n,s,r){s==null&&(s=lE(t,e,n));const o=t[0],a=t[1],i=pd((o-e+2*s)/n+1,r),l=pd((a-e+2*s)/n+1,r);return[i,l]}function rRt(t,e,n,s,r,o){r==null&&(r=lE(t,e,s));const a=t[0],i=t[1],l=t[2],u=pd((a-e+2*r)/s+1,o),c=pd((i-e+2*r)/s+1,o),d=pd((l-e+2*r)/s+1,o);return[u,c,d,n]}function lE(t,e,n,s=1){const r=eh(e,s);return Math.floor((t[0]*(n-1)-n+r)/2)}function Db(t){return typeof t=="number"?[t,t,t]:t.length===2?[t[0],t[1],1]:t}function $S(t){return typeof t=="number"?[t,t,t]:t}function eh(t,e){return e<=1?t:t+(t-1)*(e-1)}function oRt(t,e,n,s,r,o,a,i,l){let u,c,d;if(typeof t=="number"){u={top:t,bottom:t,left:t,right:t,type:t===0?"VALID":"NUMBER"};const h=sRt([e,n],o,s,t,i);c=h[0],d=h[1]}else if(t==="same"){c=Math.ceil(e/s),d=Math.ceil(n/r);const f=Math.max(0,(c-1)*s+o-e),h=Math.max(0,(d-1)*r+a-n),p=Math.floor(f/2),m=f-p,g=Math.floor(h/2),y=h-g;u={top:p,bottom:m,left:g,right:y,type:"SAME"}}else if(t==="valid")u={top:0,bottom:0,left:0,right:0,type:"VALID"},c=Math.ceil((e-o+1)/s),d=Math.ceil((n-a+1)/r);else if(typeof t=="object"){const f=l==="channelsLast"?t[1][0]:t[2][0],h=l==="channelsLast"?t[1][1]:t[2][1],p=l==="channelsLast"?t[2][0]:t[3][0],m=l==="channelsLast"?t[2][1]:t[3][1];u={top:f,bottom:h,left:p,right:m,type:f===0&&h===0&&p===0&&m===0?"VALID":"EXPLICIT"},c=pd((e-o+f+h)/s+1,i),d=pd((n-a+p+m)/r+1,i)}else throw Error(`Unknown padding parameter: ${t}`);return{padInfo:u,outHeight:c,outWidth:d}}function aRt(t,e,n,s,r,o,a,i,l,u,c){let d,f,h,p;if(typeof t=="number"){d={top:t,bottom:t,left:t,right:t,front:t,back:t,type:t===0?"VALID":"NUMBER"};const g=rRt([e,n,s,1],i,1,r,t,c);f=g[0],h=g[1],p=g[2]}else if(t==="same"){f=Math.ceil(e/r),h=Math.ceil(n/o),p=Math.ceil(s/a);const m=(f-1)*r+i-e,g=(h-1)*o+l-n,y=(p-1)*a+u-s,w=Math.floor(m/2),b=m-w,_=Math.floor(g/2),$=g-_,x=Math.floor(y/2),k=y-x;d={top:_,bottom:$,left:x,right:k,front:w,back:b,type:"SAME"}}else if(t==="valid")d={top:0,bottom:0,left:0,right:0,front:0,back:0,type:"VALID"},f=Math.ceil((e-i+1)/r),h=Math.ceil((n-l+1)/o),p=Math.ceil((s-u+1)/a);else throw Error(`Unknown padding parameter: ${t}`);return{padInfo:d,outDepth:f,outHeight:h,outWidth:p}}function pd(t,e){if(!e)return Math.trunc(t);switch(e){case"round":return Math.round(t);case"ceil":return Math.ceil(t);case"floor":return Math.floor(t);default:throw new Error(`Unknown roundingMode ${e}`)}}function yg(t){const[e,n,s]=Db(t);return e===1&&n===1&&s===1}function nu(t,e){return yg(t)||yg(e)}function IY(t){if(t==="NHWC")return"channelsLast";if(t==="NCHW")return"channelsFirst";throw new Error(`Unknown dataFormat ${t}`)}function Aa(t,e,n){if(n!=null){if(typeof e=="string")throw Error(`Error in ${t}: pad must be an integer when using dimRoundingMode ${n} but got pad ${e}.`);if(typeof e=="number")le(zh(e),()=>`Error in ${t}: pad must be an integer when using dimRoundingMode ${n} but got pad ${e}.`);else if(typeof e=="object")e.forEach(s=>{s.forEach(r=>{le(zh(r),()=>`Error in ${t}: pad must be an integer when using dimRoundingMode ${n} but got pad ${r}.`)})});else throw Error(`Error in ${t}: Unknown padding parameter: ${e}`)}}function iRt(t,e){const s={x:ne(t,"x","reshape","string_or_numeric")},r={shape:e};return ke.runKernel(zq,s,r)}const Ze=Ce({reshape_:iRt});function lRt(t,e,n,s,r){const o=ne(t,"x","avgPool","float32"),a=1;le(nu(n,a),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${n} and dilations '${a}'`);let i=o,l=!1;o.rank===3&&(l=!0,i=Ze(o,[1,o.shape[0],o.shape[1],o.shape[2]])),le(i.rank===4,()=>`Error in avgPool: x must be rank 4 but got rank ${i.rank}.`),Aa("avgPool",s,r);const u={x:i},c={filterSize:e,strides:n,pad:s,dimRoundingMode:r};let d=ke.runKernel(nK,u,c);return d=es(d,o.dtype),l?Ze(d,[d.shape[1],d.shape[2],d.shape[3]]):d}const uE=Ce({avgPool_:lRt});function uRt(t,e,n,s,r,o="NDHWC"){const a=ne(t,"x","avgPool3d","float32");let i=a,l=!1;a.rank===4&&(l=!0,i=Ze(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),le(i.rank===5,()=>`Error in avgPool3d: x must be rank 5 but got rank ${i.rank}.`),le(o==="NDHWC",()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${o}`),Aa("avgPool3d",s,r);const u={x:i},c={filterSize:e,strides:n,pad:s,dimRoundingMode:r,dataFormat:o};let d=ke.runKernel(sK,u,c);return d=es(d,i.dtype),l?Ze(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}const EY=Ce({avgPool3d_:uRt});function cRt(t,e=0){le(t.length>=1,()=>"Pass at least one tensor to concat");const n=gg(t,"tensors","concat","string_or_numeric");if(n[0].dtype==="complex64"&&n.forEach(o=>{if(o.dtype!=="complex64")throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${o.dtype}. `)}),n.length===1)return bl(n[0]);const s=n,r={axis:e};return ke.runKernel(fK,s,r)}const sr=Ce({concat_:cRt});function dRt(t){const n={x:ne(t,"x","sigmoid","float32")};return ke.runKernel(eX,n)}const Bu=Ce({sigmoid_:dRt});function fRt(t,e,n){const s=ne(t,"x","slice","string_or_numeric");if(s.rank===0)throw new Error("Slicing scalar is not possible");const r={x:s},o={begin:e,size:n};return ke.runKernel(Yq,r,o)}const Mn=Ce({slice_:fRt});function hRt(t){const n={x:ne(t,"x","tanh","float32")};return ke.runKernel(bX,n)}const Fb=Ce({tanh_:hRt});function pRt(t,e,n,s,r,o){const a=ne(t,"forgetBias","basicLSTMCell"),i=ne(e,"lstmKernel","basicLSTMCell"),l=ne(n,"lstmBias","basicLSTMCell"),u=ne(s,"data","basicLSTMCell"),c=ne(r,"c","basicLSTMCell"),d=ne(o,"h","basicLSTMCell"),f=sr([u,d],1),h=Tn(f,i),p=Wt(h,l),m=p.shape[0],g=p.shape[1]/4,y=[m,g],w=Mn(p,[0,0],y),b=Mn(p,[0,g],y),_=Mn(p,[0,g*2],y),$=Mn(p,[0,g*3],y),x=Wt(gt(Bu(w),Fb(b)),gt(c,Bu(Wt(a,_)))),k=gt(Fb(x),Bu($));return[x,k]}const AY=Ce({basicLSTMCell_:pRt});function mRt(t,e,n){const s=ne(t,"x","batchToSpaceND"),r=e.reduce((i,l)=>i*l);le(s.rank>=1+e.length,()=>`input rank is ${s.rank} but should be > than blockShape.length ${e.length}`),le(n.length===e.length,()=>`crops.length is ${n.length} but should be equal to blockShape.length  ${e.length}`),le(s.shape[0]%r===0,()=>`input tensor batch is ${s.shape[0]} but is not divisible by the product of the elements of blockShape ${e.join(" * ")} === ${r}`);const o={x:s},a={blockShape:e,crops:n};return ke.runKernel(oK,o,a)}const cE=Ce({batchToSpaceND_:mRt});function gRt(t){let e;return t.rank===0||t.rank===1?e=Ze(t,[1,1,1,t.size]):t.rank===2?e=Ze(t,[1,1,t.shape[0],t.shape[1]]):t.rank===3?e=Ze(t,[1,t.shape[0],t.shape[1],t.shape[2]]):e=t,e}function vRt(t,e,n,s,r,o){o==null&&(o=.001);const a=ne(t,"x","batchNorm"),i=ne(e,"mean","batchNorm"),l=ne(n,"variance","batchNorm");let u;r!=null&&(u=ne(r,"scale","batchNorm"));let c;s!=null&&(c=ne(s,"offset","batchNorm")),le(i.rank===l.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),le(c==null||i.rank===c.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),le(u==null||i.rank===u.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");const f={x:gRt(a),scale:u,offset:c,mean:i,variance:l},h={varianceEpsilon:o},p=ke.runKernel(WK,f,h);return Ze(p,a.shape)}const M2=Ce({batchNorm_:vRt});function yRt(t,e,n,s,r,o){const a=ne(t,"x","batchNorm"),i=ne(e,"mean","batchNorm"),l=ne(n,"variance","batchNorm");let u;r!=null&&(u=ne(r,"scale","batchNorm"));let c;return s!=null&&(c=ne(s,"offset","batchNorm")),le(a.rank===2,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${a.rank}.`),le(i.rank===2||i.rank===1,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${i.rank}.`),le(l.rank===2||l.rank===1,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${l.rank}.`),u!=null&&le(u.rank===2||u.rank===1,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${u.rank}.`),c!=null&&le(c.rank===2||c.rank===1,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${c.rank}.`),M2(a,i,l,c,u,o)}const OY=Ce({batchNorm2d_:yRt});function bRt(t,e,n,s,r,o){const a=ne(t,"x","batchNorm"),i=ne(e,"mean","batchNorm"),l=ne(n,"variance","batchNorm");let u;r!=null&&(u=ne(r,"scale","batchNorm"));let c;return s!=null&&(c=ne(s,"offset","batchNorm")),le(a.rank===3,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${a.rank}.`),le(i.rank===3||i.rank===1,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${i.rank}.`),le(l.rank===3||l.rank===1,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${l.rank}.`),u!=null&&le(u.rank===3||u.rank===1,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${u.rank}.`),c!=null&&le(c.rank===3||c.rank===1,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${c.rank}.`),M2(a,i,l,c,u,o)}const RY=Ce({batchNorm3d_:bRt});function wRt(t,e,n,s,r,o){const a=ne(t,"x","batchNorm"),i=ne(e,"mean","batchNorm"),l=ne(n,"variance","batchNorm");let u;r!=null&&(u=ne(r,"scale","batchNorm"));let c;return s!=null&&(c=ne(s,"offset","batchNorm")),le(a.rank===4,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${a.rank}.`),le(i.rank===4||i.rank===1,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${i.rank}.`),le(l.rank===4||l.rank===1,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${l.rank}.`),u!=null&&le(u.rank===4||u.rank===1,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${u.rank}.`),c!=null&&le(c.rank===4||c.rank===1,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${c.rank}.`),M2(a,i,l,c,u,o)}const DY=Ce({batchNorm4d_:wRt});function _Rt(t,e,n){const s=ne(t,"x","bincount"),r=ne(e,"weights","bincount");le(s.dtype==="int32",()=>`Error in bincount: input dtype must be int32, but got ${s.dtype}`),le(n>=0,()=>`size must be non-negative, but got ${n}.`),le(r.size===s.size||r.size===0,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${s.shape}, weights shape: ${r.shape}.`);const o={x:s,weights:r},a={size:n};return ke.runKernel(aK,o,a)}const dE=Ce({bincount_:_Rt});function $Rt(t,e){const n=ne(t,"s0","broadcastArgs","int32"),s=ne(e,"s1","broadcastArgs","int32");if(n.rank!==1)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${n.rank}`);if(s.rank!==1)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${s.rank}`);const r={s0:n,s1:s};return ke.runKernel(iK,r)}const FY=Ce({broadcastArgs_:$Rt});function xRt(t,e){let n=ne(t,"broadcastTo","x");const s=n.shape;if(e.some(u=>!(u>0)||u%1!==0))throw new Error(`broadcastTo(): Invalid broadcast shape [${e}].`);if(e.length<n.rank)throw new Error(`broadcastTo(): shape.length=${e.length} < input.rank=${n.rank}.`);if(e.length>n.rank){const u=n.shape.slice();for(;u.length<e.length;)u.unshift(1);n=Ze(n,u)}const r=n.shape,o=Array.from(e);for(let u=e.length-1;u>=0;u--)if(r[u]===e[u])o[u]=1;else if(n.shape[u]!==1)throw new Error(`broadcastTo(): [${s}] cannot be broadcast to [${e}].`);if(o.map((u,c)=>u>1?c:-1).filter(u=>u>=0).length===0)return bl(n);const i={x:n},l={reps:o};return ke.runKernel(WI,i,l)}const v0=Ce({broadcastTo_:xRt});function SRt(t){const n={x:ne(t,"x","ceil","float32")};return ke.runKernel(lK,n)}const MY=Ce({ceil_:SRt});function _m(t,e,n){const s={shape:t,value:e,dtype:n};return ke.runKernel(zK,{},s)}function CRt(t,e,n){const s=ne(t,"x","clipByValue");if(le(e<=n,()=>`Error in clip: min (${e}) must be less than or equal to max (${n}).`),e===n)return _m(s.shape,e,s.dtype);const r={x:s},o={clipValueMin:e,clipValueMax:n};return ke.runKernel(uK,r,o)}const PY=Ce({clipByValue_:CRt});function kRt(t){return sr(t,0)}const LY=Ce({concat1d_:kRt});function TRt(t,e){return sr(t,e)}const zY=Ce({concat2d_:TRt});function NRt(t,e){return sr(t,e)}const BY=Ce({concat3d_:NRt});function IRt(t,e){return sr(t,e)}const VY=Ce({concat4d_:IRt});function ERt(t,e,n,s,r="NHWC",o=[1,1],a){const i=ne(t,"x","conv2d","float32"),l=ne(e,"filter","conv2d","float32");let u=i,c=!1;i.rank===3&&(c=!0,u=Ze(i,[1,i.shape[0],i.shape[1],i.shape[2]])),le(u.rank===4,()=>`Error in conv2d: input must be rank 4, but got rank ${u.rank}.`),le(l.rank===4,()=>`Error in conv2d: filter must be rank 4, but got rank ${l.rank}.`),Aa("conv2d",s,a);const d=r==="NHWC"?u.shape[3]:u.shape[1];le(d===l.shape[2],()=>`Error in conv2d: depth of input (${d}) must match input depth for filter ${l.shape[2]}.`),le(nu(n,o),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${o}'`);const f={x:u,filter:l},h={strides:n,pad:s,dataFormat:r,dilations:o,dimRoundingMode:a},p=ke.runKernel(hK,f,h);return c?Ze(p,[p.shape[1],p.shape[2],p.shape[3]]):p}const P2=Ce({conv2d_:ERt});function ARt(t,e,n,s,r="NWC",o=1,a){const i=ne(t,"x","conv1d"),l=ne(e,"filter","conv1d");let u=i,c=!1;i.rank===2&&(c=!0,u=Ze(i,[1,i.shape[0],i.shape[1]])),le(u.rank===3,()=>`Error in conv1d: input must be rank 3, but got rank ${u.rank}.`),le(l.rank===3,()=>`Error in conv1d: filter must be rank 3, but got rank ${l.rank}.`),Aa("conv1d",s,a),le(u.shape[2]===l.shape[1],()=>`Error in conv1d: depth of input (${u.shape[2]}) must match input depth for filter ${l.shape[1]}.`),le(nu(n,o),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${n} and dilation '${o}'`),le(r==="NWC",()=>`Error in conv1d: got dataFormat of ${r} but only NWC is currently supported.`);const d=Ze(l,[1,l.shape[0],l.shape[1],l.shape[2]]),f=Ze(u,[u.shape[0],1,u.shape[1],u.shape[2]]),g=P2(f,d,[1,n],s,"NHWC",[1,o],a);return c?Ze(g,[g.shape[2],g.shape[3]]):Ze(g,[g.shape[0],g.shape[2],g.shape[3]])}const HY=Ce({conv1d_:ARt});function ORt(t,e,n,s,r,o="NHWC",a){le(t.length===e.rank,()=>`Length of inShape (${t.length}) and rank of dy (${e.rank}) must match`);let i=t,l=e,u=!1;e.rank===3&&(u=!0,l=Ze(e,[1,e.shape[0],e.shape[1],e.shape[2]]),i=[1,t[0],t[1],t[2]]),le(i.length===4,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${i.length}.`),le(l.rank===4,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${l.rank}`),le(n.rank===4,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${n.rank}`);const c=o==="NHWC"?i[3]:i[1],d=o==="NHWC"?l.shape[3]:l.shape[1];le(c===n.shape[2],()=>`Error in conv2dDerInput: depth of input (${c}) must match input depth for filter ${n.shape[2]}.`),le(d===n.shape[3],()=>`Error in conv2dDerInput: depth of output (${d}) must match output depth for filter ${n.shape[3]}.`),Aa("conv2dDerInput",r,a);const f={dy:l,filter:n},h={strides:s,pad:r,dataFormat:o,dimRoundingMode:a,inputShape:i},p=ke.runKernel(mK,f,h);return u?Ze(p,[p.shape[1],p.shape[2],p.shape[3]]):p}const WY=Ce({conv2DBackpropInput_:ORt});function RRt(t,e,n,s,r,o){const a=ne(t,"x","conv2dTranspose"),i=ne(e,"filter","conv2dTranspose");return WY(n,a,i,s,r,"NHWC",o)}const UY=Ce({conv2dTranspose_:RRt});function DRt(t,e,n,s,r="NDHWC",o=[1,1,1]){const a=ne(t,"x","conv3d"),i=ne(e,"filter","conv3d");let l=a,u=!1;a.rank===4&&(u=!0,l=Ze(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),le(l.rank===5,()=>`Error in conv3d: input must be rank 5, but got rank ${l.rank}.`),le(i.rank===5,()=>`Error in conv3d: filter must be rank 5, but got rank ${i.rank}.`),le(l.shape[4]===i.shape[3],()=>`Error in conv3d: depth of input (${l.shape[4]}) must match input depth for filter ${i.shape[3]}.`),le(nu(n,o),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${n} and dilations '${o}'`),le(r==="NDHWC",()=>`Error in conv3d: got dataFormat of ${r} but only NDHWC is currently supported.`);const c={x:l,filter:i},d={strides:n,pad:s,dataFormat:r,dilations:o},f=ke.runKernel(gK,c,d);return u?Ze(f,[f.shape[1],f.shape[2],f.shape[3],f.shape[4]]):f}const GY=Ce({conv3d_:DRt});function FRt(t,e,n,s,r){le(t.length===e.rank,()=>`Length of inShape (${t.length}) and rank of dy (${e.rank}) must match`);let o=t,a=e,i=!1;e.rank===4&&(i=!0,a=Ze(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]),o=[1,t[0],t[1],t[2],t[3]]);const l=o[4],u=a.shape[4];le(o.length===5,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${o.length}.`),le(a.rank===5,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${a.rank}`),le(n.rank===5,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${n.rank}`),le(l===n.shape[3],()=>`Error in conv3dDerInput: depth of input (${l}) must match input depth for filter ${n.shape[3]}.`),le(u===n.shape[4],()=>`Error in conv3dDerInput: depth of output (${u}) must match output depth for filter ${n.shape[4]}.`);const c={dy:a,filter:n},d={pad:r,strides:s,inputShape:o},f=ke.runKernel(vK,c,d);return i?Ze(f,[f.shape[1],f.shape[2],f.shape[3],f.shape[4]]):f}const MRt=Ce({conv3DBackpropInput_:FRt});function PRt(t,e,n,s,r){const o=ne(t,"x","conv3dTranspose"),a=ne(e,"filter","conv3dTranspose");return MRt(n,o,a,s,r)}const jY=Ce({conv3dTranspose_:PRt});function LRt(t){const n={x:ne(t,"x","cos","float32")};return ke.runKernel(yK,n)}const KY=Ce({cos_:LRt});function zRt(t){const n={x:ne(t,"x","cosh","float32")};return ke.runKernel(bK,n)}const qY=Ce({cosh_:zRt});function BRt(t,e=0,n=!1,s=!1){const o={x:ne(t,"x","cumprod")},a={axis:e,exclusive:n,reverse:s};return ke.runKernel(wK,o,a)}const XY=Ce({cumprod_:BRt});function VRt(t,e=0,n=!1,s=!1){const o={x:ne(t,"x","cumsum")},a={axis:e,exclusive:n,reverse:s};return ke.runKernel(_K,o,a)}const YY=Ce({cumsum_:VRt});function HRt(t,e,n,s=!1){const r=ne(t,"x","denseBincount"),o=ne(e,"weights","denseBincount");le(r.dtype==="int32",()=>`Error in denseBincount: input dtype must be int32, but got ${r.dtype}`),le(r.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${r.rank}.`),le(n>=0,()=>`size must be non-negative, but got ${n}.`),le(o.size===r.size||o.size===0,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${r.shape}, weights shape: ${o.shape}.`);const a={x:r,weights:o},i={size:n,binaryOutput:s};return ke.runKernel(xK,a,i)}const ZY=Ce({denseBincount_:HRt});function WRt(t,e,n="NHWC"){const s=ne(t,"x","depthToSpace","float32"),r=n==="NHWC"?s.shape[1]:s.shape[2],o=n==="NHWC"?s.shape[2]:s.shape[3],a=n==="NHWC"?s.shape[3]:s.shape[1];le(e>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${e}`),le(r*e>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${r} and ${e}  for depthToSpace with input shape
    ${s.shape}`),le(o*e>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${o} and ${e} for depthToSpace with input shape
        ${s.shape}`),le(a%(e*e)===0,()=>`Dimension size must be evenly divisible by ${e*e} but is ${a} for depthToSpace with input shape ${s.shape}`);const i={x:s},l={blockSize:e,dataFormat:n};return ke.runKernel(SK,i,l)}const JY=Ce({depthToSpace_:WRt});function URt(t,e,n,s,r="NHWC",o=[1,1],a){const i=ne(t,"x","depthwiseConv2d","float32"),l=ne(e,"filter","depthwiseConv2d","float32");let u=i,c=!1;i.rank===3&&(c=!0,u=Ze(i,[1,i.shape[0],i.shape[1],i.shape[2]])),le(u.rank===4,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${u.rank}.`),le(l.rank===4,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${l.rank}.`);const d=r==="NHWC"?u.shape[3]:u.shape[1];le(d===l.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${d}) must match the inChannels dimension in filter ${l.shape[2]}.`),Aa("depthwiseConv2d",s,a);const f={x:u,filter:l},h={strides:n,pad:s,dataFormat:r,dilations:o,dimRoundingMode:a},p=ke.runKernel(CK,f,h);return c?Ze(p,[p.shape[1],p.shape[2],p.shape[3]]):p}const l4=Ce({depthwiseConv2d_:URt});function GRt(t){const n={x:ne(t,"x","diag")};return ke.runKernel(NK,n)}const QY=Ce({diag_:GRt});function jRt(t,e,n,s,r=[1,1],o="NHWC"){const a=ne(t,"x","dilation2d"),i=ne(e,"filter","dilation2d");le(a.rank===3||a.rank===4,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${a.rank}.`),le(i.rank===3,()=>`Error in dilation2d: filter must be rank 3, but got rank ${i.rank}.`),le(o==="NHWC",()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${o}`);let l=a,u=!1;a.rank===3&&(l=Ze(a,[1,a.shape[0],a.shape[1],a.shape[2]]),u=!0);const c={x:l,filter:i},d={strides:n,pad:s,dilations:r},f=ke.runKernel(IK,c,d);return u?Ze(f,[f.shape[1],f.shape[2],f.shape[3]]):f}const eZ=Ce({dilation2d_:jRt});function KRt(t,e){let n=ne(t,"a","equal","string_or_numeric"),s=ne(e,"b","equal","string_or_numeric");[n,s]=fs(n,s),Ns(n.shape,s.shape);const r={a:n,b:s};return ke.runKernel(DK,r)}const fE=Ce({equal_:KRt});function qRt(t,e,n){const s=ne(e,"a","where"),r=ne(n,"b","where"),o=ne(t,"condition","where","bool"),a=Ns(Ns(o.shape,s.shape),r.shape),i=v0(o,a),l=v0(s,a),u=v0(r,a),c={condition:i,t:l,e:u};return ke.runKernel(qq,c)}const jd=Ce({where_:qRt});function XRt(t){const n={x:ne(t,"x","zerosLike")};return ke.runKernel(CX,n)}const bo=Ce({zerosLike_:XRt});function YRt(t,e){let n=ne(t,"a","div"),s=ne(e,"b","div");[n,s]=fs(n,s);const r=En(n,s),o=bo(r),a=fE(s,o);return jd(a,o,r)}const tZ=Ce({divNoNan_:YRt});function ZRt(t,e){const n=ne(t,"t1","dot"),s=ne(e,"t2","dot");le((n.rank===1||n.rank===2)&&(s.rank===1||s.rank===2),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${n.rank} and ${s.rank}.`);const r=n.rank===1?n.size:n.shape[1],o=s.rank===1?s.size:s.shape[0];if(le(r===o,()=>`Error in dot: inner dimensions of inputs must match, but got ${r} and ${o}.`),n.rank===1&&s.rank===1){const a=Ze(n,[1,-1]),i=Ze(s,[-1,1]),l=Tn(a,i);return Ze(l,[])}else if(n.rank===1&&s.rank===2){const a=Ze(n,[1,-1]),i=Ze(s,[s.shape[0],s.shape[1]]),l=Tn(a,i);return Ze(l,[l.size])}else if(n.rank===2&&s.rank===1){const a=Ze(s,[-1,1]),i=Tn(n,a);return Ze(i,[i.size])}else{const a=Ze(s,[s.shape[0],s.shape[1]]);return Tn(n,a)}}const nZ=Ce({dot_:ZRt});function JRt(t,...e){const n=e.map((r,o)=>ne(r,`tensors${o}`,"einsum")),s={equation:t};return ke.runKernel(AK,n,s)}const sZ=Ce({einsum_:JRt});function QRt(t){const n={x:ne(t,"x","elu","float32")};return ke.runKernel(OK,n)}const hE=Ce({elu_:QRt});function eDt(t){let e=ne(t,"x","erf");le(e.dtype==="int32"||e.dtype==="float32",()=>"Input dtype must be `int32` or `float32`."),e.dtype==="int32"&&(e=es(e,"float32"));const n={x:e};return ke.runKernel(RK,n)}const rZ=Ce({erf_:eDt});function pE(t,e){for(let n=0;n<t.length;++n)if(t[t.length-n-1]!==e-1-n)return!1;return!0}function oZ(t,e,n){const s=t.length+e.length,r=[];let o=0,a=0;for(let i=0;i<s;i++)n.indexOf(i)===-1?r.push(t[o++]):r.push(e[a++]);return r}function tDt(t,e){const n=[],s=t.length;for(let o=0;o<s;o++)e.indexOf(o)===-1&&n.push(t[o]);const r=e.map(o=>t[o]);return[n,r]}function L2(t,e){const n=e.map(s=>1);return oZ(t,n,e)}function nDt(t,e,n){le(pE(e,n),()=>`${t} supports only inner-most axes for now. Got axes ${e} and rank-${n} input.`)}function sDt(t,e){if(pE(t,e))return null;const n=[];for(let s=0;s<e;++s)t.indexOf(s)===-1&&n.push(s);return t.forEach(s=>n.push(s)),n}function rDt(t){return t.map((e,n)=>[n,e]).sort((e,n)=>e[1]-n[1]).map(e=>e[0])}function oDt(t,e){const n=[];for(let s=e-t;s<e;++s)n.push(s);return n}function aDt(t,e=null,n=!1){const r={x:ne(t,"x","max")},o={reductionIndices:e,keepDims:n};return ke.runKernel(uq,r,o)}const md=Ce({max_:aDt});function iDt(t,e=null,n=!1){const r={x:ne(t,"x","min")},o={axis:e,keepDims:n};return ke.runKernel(mq,r,o)}const Mb=Ce({min_:iDt});function lDt(t,e){let n=ne(t,"base","pow"),s=ne(e,"exp","pow");[n,s]=fs(n,s);const r={a:n,b:s};return ke.runKernel(Eq,r)}const Wh=Ce({pow_:lDt});function an(t,e){if((pr(t)&&e!=="string"||Array.isArray(t))&&e!=="complex64")throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if(e==="string"&&pr(t)&&!(t instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return bc(t,[],[],e)}function uDt(t){const n={x:ne(t,"x","sqrt","float32")};return ke.runKernel(nX,n)}const Ki=Ce({sqrt_:uDt});function cDt(t){const e=ne(t,"x","square"),n={};return ke.runKernel("Square",{x:e},n)}const ba=Ce({square_:cDt});function dDt(t,e=null,n=!1){let s=ne(t,"x","sum");s.dtype==="bool"&&(s=es(s,"int32"));const r={x:s},o={axis:e,keepDims:n};return ke.runKernel(sX,r,o)}const Wn=Ce({sum_:dDt});function fDt(t,e="euclidean",n=null,s=!1){t=ne(t,"x","norm");const r=aZ(t,e,n);let o=r.shape;if(s){const a=E2(n,t.shape);o=L2(r.shape,a)}return Ze(r,o)}function aZ(t,e,n=null){if(t.rank===0)return co(t);if(t.rank!==1&&n===null)return aZ(Ze(t,[-1]),e,n);if(t.rank===1||typeof n=="number"||Array.isArray(n)&&n.length===1){if(e===1)return Wn(co(t),n);if(e===1/0)return md(co(t),n);if(e===-1/0)return Mb(co(t),n);if(e==="euclidean"||e===2)return Ki(Wn(Wh(co(t),an(2,"int32")),n));throw new Error(`Error in norm: invalid ord value: ${e}`)}if(Array.isArray(n)&&n.length===2){if(e===1)return md(Wn(co(t),n[0]),n[1]-1);if(e===1/0)return md(Wn(co(t),n[1]),n[0]);if(e===-1/0)return Mb(Wn(co(t),n[1]),n[0]);if(e==="fro"||e==="euclidean")return Ki(Wn(ba(t),n));throw new Error(`Error in norm: invalid ord value: ${e}`)}throw new Error(`Error in norm: invalid axis: ${n}`)}const z2=Ce({norm_:fDt});function hDt(t,e=null,n=!1){return z2(t,"euclidean",e,n)}const iZ=Ce({euclideanNorm_:hDt});function pDt(t){const n={x:ne(t,"x","exp")};return ke.runKernel(FK,n)}const rc=Ce({exp_:pDt});function mDt(t,e=0){const n=ne(t,"x","expandDims","string_or_numeric");le(e<=n.rank,()=>"Axis must be <= rank of the tensor");const s={input:n},r={dim:e};return ke.runKernel(MK,s,r)}const Va=Ce({expandDims_:mDt});function gDt(t){const n={x:ne(t,"x","expm1")};return ke.runKernel(PK,n)}const lZ=Ce({expm1_:gDt});function vDt(t,e){const n=ne(t,"x","tile","string_or_numeric");le(n.rank===e.length,()=>`Error in transpose: rank of input ${n.rank} must match length of reps ${e}.`);const s={x:n},r={reps:e};return ke.runKernel(WI,s,r)}const th=Ce({tile_:vDt});function yDt(t,e,n,s="float32"){e==null&&(e=t);const r=ji([t,e],s),o=t<=e?t:e;for(let i=0;i<o;++i)r.set(1,i,i);const a=Ze(r.toTensor(),[t,e]);if(n==null)return a;if(n.length===1)return th(Va(a,0),[n[0],1,1]);if(n.length===2)return th(Va(Va(a,0),0),[n[0],n[1],1,1]);if(n.length===3)return th(Va(Va(Va(a,0),0),0),[n[0],n[1],n[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${n.length}D.`)}const mE=Ce({eye_:yDt});function bDt(t){const n={x:ne(t,"x","floor","float32")};return ke.runKernel(VK,n)}const gE=Ce({floor_:bDt});function wDt(t,e,n=0,s=0){const r=ne(t,"x","gather"),o=ne(e,"indices","gather","int32"),a={x:r,indices:o},i={axis:n,batchDims:s};return ke.runKernel(UK,a,i)}const vE=Ce({gather_:wDt});function _Dt(t,e){let n=ne(t,"a","greater","string_or_numeric"),s=ne(e,"b","greater","string_or_numeric");[n,s]=fs(n,s),Ns(n.shape,s.shape);const r={a:n,b:s};return ke.runKernel(jK,r)}const B2=Ce({greater_:_Dt});function $Dt(t,e){let n=ne(t,"a","greaterEqual","string_or_numeric"),s=ne(e,"b","greaterEqual","string_or_numeric");[n,s]=fs(n,s),Ns(n.shape,s.shape);const r={a:n,b:s};return ke.runKernel(KK,r)}const yE=Ce({greaterEqual_:$Dt});function xDt(t){const n={x:ne(t,"x","isFinite")};return ke.runKernel(YK,n)}const uZ=Ce({isFinite_:xDt});function SDt(t){const n={x:ne(t,"x","isInf")};return ke.runKernel(ZK,n)}const cZ=Ce({isInf_:SDt});function CDt(t){const n={x:ne(t,"x","isNaN")};return ke.runKernel(JK,n)}const dZ=Ce({isNaN_:CDt});function kDt(t,e=.2){const s={x:ne(t,"x","leakyRelu")},r={alpha:e};return ke.runKernel(QK,s,r)}const bE=Ce({leakyRelu_:kDt});function TDt(t,e){let n=ne(t,"a","less","string_or_numeric"),s=ne(e,"b","less","string_or_numeric");[n,s]=fs(n,s),Ns(n.shape,s.shape);const r={a:n,b:s};return ke.runKernel(eq,r)}const fZ=Ce({less_:TDt});function NDt(t,e){let n=ne(t,"a","lessEqual","string_or_numeric"),s=ne(e,"b","lessEqual","string_or_numeric");[n,s]=fs(n,s),Ns(n.shape,s.shape);const r={a:n,b:s};return ke.runKernel(tq,r)}const u4=Ce({lessEqual_:NDt});function hZ(t,e,n){if(n<=0)throw new Error("The number of values should be positive.");const s={start:t,stop:e,num:n};return ke.runKernel(nq,{},s)}function IDt(t,e=5,n=1,s=1,r=.5){const o=ne(t,"x","localResponseNormalization");le(o.rank===4||o.rank===3,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${o.rank}.`),le(zh(e),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${e}.`);let a=o,i=!1;o.rank===3&&(i=!0,a=Ze(o,[1,o.shape[0],o.shape[1],o.shape[2]]));const l={x:a},u={depthRadius:e,bias:n,alpha:s,beta:r},c=ke.runKernel(lq,l,u);return i?Ze(c,[c.shape[1],c.shape[2],c.shape[3]]):c}const pZ=Ce({localResponseNormalization_:IDt});function EDt(t){const n={x:ne(t,"x","log","float32")};return ke.runKernel(sq,n)}const Uh=Ce({log_:EDt});function ADt(t){const n={x:ne(t,"x","log1p")};return ke.runKernel(rq,n)}const wE=Ce({log1p_:ADt});function ODt(t){return le(sc(t),()=>"The f passed in grad(f) must be a function"),(e,n)=>{const s=ne(e,"x","tf.grad","string_or_numeric"),r=n!=null?ne(n,"dy","tf.grad"):null;return ke.tidy(()=>{const{value:o,grads:a}=ke.gradients(()=>t(s),[s],r);return r!=null&&Br(o.shape,r.shape,"The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)"),c4(a),a[0]})}}function RDt(t){return le(sc(t),()=>"The f passed in grads(f) must be a function"),(e,n)=>{le(Array.isArray(e),()=>"The args passed in grads(f)(args) must be an array of `Tensor`s or `TensorLike`s");const s=gg(e,"args","tf.grads","string_or_numeric"),r=n!=null?ne(n,"dy","tf.grads"):null;return ke.tidy(()=>{const{value:o,grads:a}=ke.gradients(()=>t(...s),s,r);return r!=null&&Br(o.shape,r.shape,"The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),c4(a),a})}}function DDt(t){return le(sc(t),()=>"The f passed in valueAndGrad(f) must be a function"),(e,n)=>{le(e instanceof os,()=>"The x passed in valueAndGrad(f)(x) must be a tensor"),le(n==null||n instanceof os,()=>"The dy passed in valueAndGrad(f)(x, dy) must be a tensor");const{grads:s,value:r}=ke.gradients(()=>t(e),[e],n);return c4(s),{grad:s[0],value:r}}}function FDt(t){return le(sc(t),()=>"The f passed in valueAndGrads(f) must be a function"),(e,n)=>{le(Array.isArray(e)&&e.every(r=>r instanceof os),()=>"The args passed in valueAndGrads(f)(args) must be array of tensors"),le(n==null||n instanceof os,()=>"The dy passed in valueAndGrads(f)(args, dy) must be a tensor");const s=ke.gradients(()=>t(...e),e,n);return n!=null&&Br(s.value.shape,n.shape,"The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),c4(s.grads),s}}function mZ(t,e){le(sc(t),()=>"The f passed in variableGrads(f) must be a function"),le(e==null||Array.isArray(e)&&e.every(u=>u instanceof mg),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");const n=e!=null;if(!n){e=[];for(const u in ke.registeredVariables)e.push(ke.registeredVariables[u])}const s=n?e.filter(u=>!u.trainable):null,r=e.length;e=e.filter(u=>u.trainable),le(e.length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${r} variables is trainable.`);const o=!0,{value:a,grads:i}=ke.gradients(t,e,null,o);le(i.some(u=>u!=null),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),le(a.rank===0,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${a.rank} tensor`);const l={};return e.forEach((u,c)=>{i[c]!=null&&(l[u.name]=i[c])}),s!=null&&s.forEach(u=>l[u.name]=null),{value:a,grads:l}}function qi(t){return ke.customGrad(t)}function c4(t){if(t.filter(n=>n==null).length>0)throw new Error(`Cannot compute gradient of y=f(x) with respect to x. Make sure that
    the f you passed encloses all operations that lead from x to y.`)}function MDt(t){const n={x:ne(t,"x","softplus")};return ke.runKernel(tX,n)}const _E=Ce({softplus_:MDt});function PDt(t){const e=ne(t,"x","logSigmoid");return qi(s=>({value:Pi(_E(Pi(s))),gradFunc:a=>gt(a,Bu(Pi(s)))}))(e)}const gZ=Ce({logSigmoid_:PDt});function LDt(t,e){let n=ne(t,"a","sub"),s=ne(e,"b","sub");[n,s]=fs(n,s);const r={a:n,b:s};return ke.runKernel(vX,r)}const rn=Ce({sub_:LDt});function zDt(t,e=-1){const n=ne(t,"logits","logSoftmax");if(e===-1&&(e=n.rank-1),e!==n.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and axis was ${e}`);return qi((r,o)=>{const i=md(r,e,!0),l=rn(r,i),u=rn(es(l,"float32"),Uh(Wn(rc(l),e,!0)));return o([u]),{value:u,gradFunc:(d,f)=>{const[h]=f,p=!0,m=rc(h);return rn(d,gt(Wn(d,e,p),m))}}})(n)}const vZ=Ce({logSoftmax_:zDt});function BDt(t,e=null,n=!1){const s=ne(t,"x","logSumExp"),r=E2(e,s.shape),o=md(s,r,!0),a=rn(s,o),i=rc(a),l=Wn(i,r),u=Uh(l),c=Wt(Ze(o,u.shape),u);if(n){const d=L2(c.shape,r);return Ze(c,d)}return c}const $E=Ce({logSumExp_:BDt});function VDt(t,e){const n=ne(t,"a","logicalAnd","bool"),s=ne(e,"b","logicalAnd","bool");Ns(n.shape,s.shape);const r={a:n,b:s};return ke.runKernel(oq,r)}const bg=Ce({logicalAnd_:VDt});function HDt(t){const n={x:ne(t,"x","logicalNot","bool")};return ke.runKernel(aq,n)}const xE=Ce({logicalNot_:HDt});function WDt(t,e){const n=ne(t,"a","logicalOr","bool"),s=ne(e,"b","logicalOr","bool");Ns(n.shape,s.shape);const r={a:n,b:s};return ke.runKernel(iq,r)}const SE=Ce({logicalOr_:WDt});function UDt(t,e){const n=ne(t,"a","logicalXor","bool"),s=ne(e,"b","logicalXor","bool");return Ns(n.shape,s.shape),bg(SE(t,e),xE(bg(t,e)))}const yZ=Ce({logicalXor_:UDt});const Ov=2147483648;function GDt(t,e,n="left"){const s=ne(t,"sortedSequence","searchSorted"),r=ne(e,"values","searchSorted"),o=s.shape[s.shape.length-1],a=r.shape[r.shape.length-1],i=Ze(s,[-1,o]),l=Ze(r,[-1,a]);if(i.rank<2)throw new Error("Sorted input argument must be at least 2-dimensional");if(i.shape[0]!==l.shape[0])throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");if(Qn(l.shape)>=Ov)throw new Error(`values tensor size must less than ${Ov}`);if(i.shape[1]>=Ov)throw new Error(`trailing dim_size must less than ${Ov} for int32 output type, was ${i.shape[1]}`);const u={sortedSequence:i,values:l},c={side:n};return ke.runKernel(Kq,u,c)}const d4=Ce({searchSorted_:GDt});function bZ(t,e){return d4(t,e,"left")}function jDt(t,e,n,s,r){const o=ne(t,"x","maxPool"),a=1;let i=o,l=!1;o.rank===3&&(l=!0,i=Ze(o,[1,o.shape[0],o.shape[1],o.shape[2]])),le(i.rank===4,()=>`Error in maxPool: input must be rank 4 but got rank ${i.rank}.`),le(nu(n,a),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${n} and dilations '${a}'`),Aa("maxPool",s,r);const u={x:i},c={filterSize:e,strides:n,pad:s,dimRoundingMode:r},d=ke.runKernel(dq,u,c);return l?Ze(d,[d.shape[1],d.shape[2],d.shape[3]]):d}const CE=Ce({maxPool_:jDt});function KDt(t,e=[1,1,1],n,s,r,o="NDHWC"){const a=ne(t,"x","maxPool3d");let i=a,l=!1;a.rank===4&&(l=!0,i=Ze(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),le(i.rank===5,()=>`Error in maxPool3d: x must be rank 5 but got rank ${i.rank}.`),le(o==="NDHWC",()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${o}`),Aa("maxPool3d",s,r);const u={x:i},c={filterSize:e,strides:n,pad:s,dimRoundingMode:r,dataFormat:o},d=ke.runKernel(fq,u,c);return l?Ze(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}const wZ=Ce({maxPool3d_:KDt});function qDt(t,e,n,s,r=!1){const a={x:ne(t,"x","maxPoolWithArgmax")},i={filterSize:e,strides:n,pad:s,includeBatchInIndex:r},l=ke.runKernel(hq,a,i);return{result:l[0],indexes:l[1]}}const _Z=Ce({maxPoolWithArgmax_:qDt});function XDt(t,e){let n=ne(t,"a","maximum"),s=ne(e,"b","maximum");[n,s]=fs(n,s),n.dtype==="bool"&&(n=es(n,"int32"),s=es(s,"int32")),Ns(n.shape,s.shape);const r={a:n,b:s};return ke.runKernel(cq,r)}const kE=Ce({maximum_:XDt});function YDt(t,e=null,n=!1){const r={x:ne(t,"x","mean")},o={axis:e,keepDims:n};return ke.runKernel(pq,r,o)}const wg=Ce({mean_:YDt});function Kd(t,e="float32"){if(e==="complex64"){const s=Kd(t,"float32"),r=Kd(t,"float32");return Dl(s,r)}const n=o4(Qn(t),e);return ke.makeTensor(n,t,e)}function Au(t,e="float32"){if(e==="complex64"){const s=Au(t,"float32"),r=Kd(t,"float32");return Dl(s,r)}const n=MI(Qn(t),e);return ke.makeTensor(n,t,e)}function $Z(t,e,{indexing:n="xy"}={}){if(n!=="xy"&&n!=="ij")throw new TypeError(`${n} is not a valid third argument to meshgrid`);if(t===void 0)return[];let s=ne(t,"x","meshgrid",t instanceof os?t.dtype:"float32");if(e===void 0)return[s];let r=ne(e,"y","meshgrid",e instanceof os?e.dtype:"float32");const o=Qn(s.shape),a=Qn(r.shape);return n==="xy"?(s=Ze(s,[1,-1]),r=Ze(r,[-1,1]),[Tn(Au([a,1],s.dtype),s),Tn(r,Au([1,o],r.dtype))]):(s=Ze(s,[-1,1]),r=Ze(r,[1,-1]),[Tn(s,Au([1,a],s.dtype)),Tn(Au([o,1],r.dtype),r)])}function ZDt(t,e){let n=ne(t,"a","minimum"),s=ne(e,"b","minimum");[n,s]=fs(n,s),n.dtype==="bool"&&(n=es(n,"int32"),s=es(s,"int32")),Ns(n.shape,s.shape);const r={a:n,b:s};return ke.runKernel(gq,r)}const TE=Ce({minimum_:ZDt});function JDt(t,e,n){le(n==="reflect"||n==="symmetric",()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${n}.`);const s=ne(t,"x","mirrorPad");if(s.rank===0)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");le(e.length===s.rank,()=>`Padding doesn't match input. Must be ${s.rank}. Got ${e.length}.`);const r=n==="reflect"?1:0;for(let i=0;i<s.rank;i++)le(e[i].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),le(e[i][0]>=0&&e[i][0]<=s.shape[i]-r&&e[i][1]>=0&&e[i][1]<=s.shape[i]-r,()=>`Padding in dimension ${i} cannot be greater than or equal to ${s.shape[i]-r} or less than 0 for input of shape ${s.shape}`);const o={paddings:e,mode:n},a={x:s};return ke.runKernel(vq,a,o)}const xZ=Ce({mirrorPad_:JDt});function QDt(t,e){let n=ne(t,"a","mod"),s=ne(e,"b","mod");[n,s]=fs(n,s);const r={a:n,b:s};return ke.runKernel(yq,r)}const SZ=Ce({mod_:QDt});function e9t(t,e=null,n=!1){t=ne(t,"x","moments");const s=E2(e,t.shape),r=wg(t,s,n);let o=r.shape;n||(o=L2(r.shape,s));const a=ba(rn(es(t,"float32"),Ze(r,o))),i=wg(a,s,n);return{mean:r,variance:i}}const CZ=Ce({moments_:e9t});function t9t(t,e,n,s){const r=ne(e,"data","multiRNNCell"),o=gg(n,"c","multiRNNCell"),a=gg(s,"h","multiRNNCell");let i=r;const l=[];for(let d=0;d<t.length;d++){const f=t[d](i,o[d],a[d]);l.push(f[0]),l.push(f[1]),i=f[1]}const u=[],c=[];for(let d=0;d<l.length;d+=2)u.push(l[d]),c.push(l[d+1]);return[u,c]}const kZ=Ce({multiRNNCell_:t9t});function n9t(t,e,n,s=!1){const r=ne(t,"logits","multinomial"),o=r.size,a=r.rank;if(o<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${o}.`);if(a>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${a}`);n=n||Math.random();const l={logits:a===1?Ze(r,[1,-1]):r},u={numSamples:e,seed:n,normalized:s},c=ke.runKernel(bq,l,u);return a===1?Ze(c,[c.size]):c}const TZ=Ce({multinomial_:n9t});function s9t(t,e){let n=ne(t,"a","notEqual","string_or_numeric"),s=ne(e,"b","notEqual","string_or_numeric");[n,s]=fs(n,s),Ns(n.shape,s.shape);const r={a:n,b:s};return ke.runKernel($q,r)}const NE=Ce({notEqual_:s9t});function r9t(t){const n={x:ne(t,"x","onesLike")};return ke.runKernel(kq,n)}const NZ=Ce({onesLike_:r9t});function o9t(t,e){const n=ne(t,"v1","outerProduct"),s=ne(e,"v2","outerProduct");le(n.rank===1&&s.rank===1,()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${n.rank} and ${s.rank}.`);const r=Ze(n,[-1,1]),o=Ze(s,[1,-1]);return Tn(r,o)}const IZ=Ce({outerProduct_:o9t});function a9t(t,e,n=0){const s=ne(t,"x","pad");if(s.rank===0)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const r={paddings:e,constantValue:n},o={x:s};return ke.runKernel(Iq,o,r)}const $m=Ce({pad_:a9t});function i9t(t,e,n=0){return le(e.length===2,()=>"Invalid number of paddings. Must be length of 2."),$m(t,[e],n)}const EZ=Ce({pad1d_:i9t});function l9t(t,e,n=0){return le(e.length===2&&e[0].length===2&&e[1].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),$m(t,e,n)}const AZ=Ce({pad2d_:l9t});function u9t(t,e,n=0){return le(e.length===3&&e[0].length===2&&e[1].length===2&&e[2].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),$m(t,e,n)}const IE=Ce({pad3d_:u9t});function c9t(t,e,n=0){return le(e.length===4&&e[0].length===2&&e[1].length===2&&e[2].length===2&&e[3].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),$m(t,e,n)}const OZ=Ce({pad4d_:c9t});function d9t(t,e,n){const s=ne(t,"x","spaceToBatchND");le(s.rank>=1+e.length,()=>`input rank ${s.rank} should be > than [blockShape] ${e.length}`),le(n.length===e.length,()=>`paddings.shape[0] ${n.length} must be equal to [blockShape] ${e.length}`),le(s.shape.reduce((a,i,l)=>l>0&&l<=e.length?a&&(i+n[l-1][0]+n[l-1][1])%e[l-1]===0:a,!0),()=>`input spatial dimensions ${s.shape.slice(1)} with paddings ${n.toString()} must be divisible by blockShapes ${e.toString()}`);const r={x:s},o={blockShape:e,paddings:n};return ke.runKernel(rX,r,o)}const EE=Ce({spaceToBatchND_:d9t});function f9t(t,e,n,s,r,o,a){r==null&&(r=[1,1]),o==null&&(o=1),s===0&&(s="valid");const i=ne(t,"x","maxPool");let l=i,u=!1;i.rank===3&&(u=!0,l=Ze(i,[1,i.shape[0],i.shape[1],i.shape[2]])),le(nu(o,r),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${o} and dilations '${r}'`);const c=TY(l.shape,e,o,r,s),d=[c.dilationHeight,c.dilationWidth];let f;s==="same"?f=p9t([c.filterHeight,c.filterWidth],d):f=[[0,0],[0,0]];const h=d[0]===1&&d[1]===1,[p,m]=h9t([c.inHeight,c.inWidth],d,f),g=h?s:"valid",y=h?l:EE(l,d,p),b=(n==="avg"?()=>uE(y,e,o,g,a):()=>CE(y,e,o,g,a))(),_=h?b:cE(b,d,m);return u?Ze(_,[_.shape[1],_.shape[2],_.shape[3]]):_}function h9t(t,e,n){const s=n.map(c=>c[0]),r=n.map(c=>c[1]),o=t.concat(s,r),a=e.map((c,d)=>(c-o[d]%c)%c),i=r.map((c,d)=>c+a[d]),l=e.map((c,d)=>[s[d],i[d]]),u=e.map((c,d)=>[0,a[d]]);return[l,u]}function p9t(t,e){const s=t.map((a,i)=>a+(a-1)*(e[i]-1)).map(a=>a-1),r=s.map(a=>Math.floor(a/2)),o=s.map((a,i)=>a-r[i]);return s.map((a,i)=>[r[i],o[i]])}const RZ=Ce({pool_:f9t});function m9t(t,e){const n=ne(t,"x","prelu"),s=ne(e,"alpha","prelu"),r={x:n,alpha:s};return ke.runKernel(Aq,r)}const AE=Ce({prelu_:m9t});function g9t(t,e=null,n=!1){let s=ne(t,"x","prod");s.dtype==="bool"&&(s=es(s,"int32"));const r={x:s},o={axis:e,keepDims:n};return ke.runKernel(Oq,r,o)}const DZ=Ce({prod_:g9t});function v9t(t,e,n,s){const r=t.map((c,d)=>ne(c,`tensors${d}`,"raggedGather","int32")),o=ne(e,"paramsDenseValues","raggedGather"),a=ne(n,"indices","raggedGather","int32"),i={paramsNestedSplits:r,paramsDenseValues:o,indices:a},l={outputRaggedRank:s},u=ke.runKernel(Rq,i,l);return{outputNestedSplits:u.slice(0,u.length-1),outputDenseValues:u[u.length-1]}}const FZ=Ce({raggedGather_:v9t});function y9t(t,e,n,s,r){const o=ne(t,"shape","raggedTensorToTensor","int32"),a=ne(e,"values","raggedTensorToTensor"),i=ne(n,"defaultValue","raggedTensorToTensor",a.dtype),l=s.map((d,f)=>ne(d,`tensors${f}`,"raggedTensorToTensor","int32")),u={shape:o,values:a,defaultValue:i,rowPartitionTensors:l},c={rowPartitionTypes:r};return ke.runKernel(Dq,u,c)}const MZ=Ce({raggedTensorToTensor_:y9t});function b9t(t,e,n){const s=Qn(t);let r=null;if(n==null||n==="float32")r=new Float32Array(s);else if(n==="int32")r=new Int32Array(s);else if(n==="bool")r=new Uint8Array(s);else throw new Error(`Unknown data type ${n}`);for(let o=0;o<s;o++)r[o]=e();return ke.makeTensor(r,t,n)}const PZ=Ce({rand_:b9t});class OE{constructor(e,n,s,r,o){this.mean=e,this.stdDev=n,this.dtype=s,this.nextVal=NaN,this.truncated=r,this.truncated&&(this.upper=this.mean+this.stdDev*2,this.lower=this.mean-this.stdDev*2);const a=o||Math.random();this.random=Ji.alea(a.toString())}nextValue(){if(!isNaN(this.nextVal)){const r=this.nextVal;return this.nextVal=NaN,r}let e,n,s=!1;for(;!s;){let r,o,a;do r=2*this.random()-1,o=2*this.random()-1,a=r*r+o*o;while(a>=1||a===0);const i=Math.sqrt(-2*Math.log(a)/a);e=this.mean+this.stdDev*r*i,n=this.mean+this.stdDev*o*i,(!this.truncated||this.isValidTruncated(e))&&(s=!0)}return(!this.truncated||this.isValidTruncated(n))&&(this.nextVal=this.convertValue(n)),this.convertValue(e)}convertValue(e){return this.dtype==null||this.dtype==="float32"?e:Math.round(e)}isValidTruncated(e){return e<=this.upper&&e>=this.lower}}class w9t{constructor(e,n,s,r){this.alpha=e,this.beta=1/n,this.dtype=s;const o=r||Math.random();this.randu=Ji.alea(o.toString()),this.randn=new OE(0,1,s,!1,this.randu()),e<1?this.d=e+2/3:this.d=e-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let e,n,s,r,o,a;for(;;){do r=this.randn.nextValue(),a=1+this.c*r;while(a<=0);if(a*=a*a,e=r*r,n=1-.331*e*e,s=.5*e+this.d*(1-a+Math.log(a)),o=this.randu(),o<n||Math.log(o)<s)break}return a=1/this.beta*this.d*a,this.alpha<1&&(a*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(a)}convertValue(e){return this.dtype==="float32"?e:Math.round(e)}}class _9t{constructor(e=0,n=1,s,r){if(this.canReturnFloat=()=>this.dtype==null||this.dtype==="float32",this.min=e,this.range=n-e,this.dtype=s,r==null&&(r=Math.random()),typeof r=="number"&&(r=r.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${e} - ${n} <= 1 and dtype is not float`);this.random=Ji.alea(r)}convertValue(e){return this.canReturnFloat()?e:Math.round(e)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}function $9t(t,e,n=1,s="float32",r){if(n==null&&(n=1),s==null&&(s="float32"),s!=="float32"&&s!=="int32")throw new Error(`Unsupported data type ${s}`);const o=new w9t(e,n,s,r),a=ji(t,s);for(let i=0;i<a.values.length;i++)a.values[i]=o.nextValue();return a.toTensor()}const LZ=Ce({randomGamma_:$9t});function x9t(t,e=0,n=1,s,r){if(s!=null&&s==="bool")throw new Error(`Unsupported data type ${s}`);const o=new OE(e,n,s,!1,r),a=ji(t,s);for(let i=0;i<a.values.length;i++)a.values[i]=o.nextValue();return a.toTensor()}const RE=Ce({randomNormal_:x9t});function S9t(t,e,n){if(e!=null&&e==="bool")throw new Error(`Unsupported data type ${e}`);return RE(t,0,1,e,n)}const zZ=Ce({randomStandardNormal_:S9t});function C9t(t,e=0,n=1,s="float32",r){const o=ji(t,s),a=new _9t(e,n,null,r);for(let i=0;i<o.values.length;i++)o.values[i]=a.nextValue();return o.toTensor()}const DE=Ce({randomUniform_:C9t});function Gh(t,e,n=1,s="float32"){if(n===0)throw new Error("Cannot have a step of zero");const r={start:t,stop:e,step:n,dtype:s};return ke.runKernel(Fq,{},r)}function k9t(t){const n={x:ne(t,"x","reciprocal")};return ke.runKernel(Pq,n)}const BZ=Ce({reciprocal_:k9t});function T9t(t){const n={x:ne(t,"x","relu")};return ke.runKernel(Lq,n)}const V2=Ce({relu_:T9t});function N9t(t){const n={x:ne(t,"x","relu6")};return ke.runKernel(Hq,n)}const FE=Ce({relu6_:N9t});function I9t(t,e){const s={x:ne(t,"x","reverse")},r={dims:e};return ke.runKernel(Wq,s,r)}const oc=Ce({reverse_:I9t});function E9t(t){const e=ne(t,"x","reverse");return le(e.rank===1,()=>`Error in reverse1D: x must be rank 1 but got rank ${e.rank}.`),oc(e,0)}const VZ=Ce({reverse1d_:E9t});function A9t(t,e){const n=ne(t,"x","reverse");return le(n.rank===2,()=>`Error in reverse2D: x must be rank 2 but got rank ${n.rank}.`),oc(n,e)}const HZ=Ce({reverse2d_:A9t});function O9t(t,e){const n=ne(t,"x","reverse");return le(n.rank===3,()=>`Error in reverse3D: x must be rank 3 but got rank ${n.rank}.`),oc(n,e)}const WZ=Ce({reverse3d_:O9t});function R9t(t,e){const n=ne(t,"x","reverse");return le(n.rank===4,()=>`Error in reverse4D: x must be rank 4 but got rank ${n.rank}.`),oc(n,e)}const UZ=Ce({reverse4d_:R9t});function D9t(t){const n={x:ne(t,"x","round")};return ke.runKernel(Uq,n)}const ME=Ce({round_:D9t});function F9t(t){const n={x:ne(t,"x","rsqrt","float32")};return ke.runKernel(Gq,n)}const GZ=Ce({rsqrt_:F9t});function M9t(t){const n={x:ne(t,"x","selu")};return ke.runKernel(Xq,n)}const jZ=Ce({selu_:M9t});function P9t(t,e,n,s,r,o=[1,1],a="NHWC"){const i=ne(t,"x","separableConv2d"),l=ne(e,"depthwiseFilter","separableConv2d"),u=ne(n,"pointwiseFilter","separableConv2d");let c=i,d=!1;if(i.rank===3&&(d=!0,c=Ze(i,[1,i.shape[0],i.shape[1],i.shape[2]])),a==="NCHW")throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");le(c.rank===4,()=>`Error in separableConv2d: input must be rank 4, but got rank ${c.rank}.`),le(l.rank===4,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${l.rank}.`),le(u.rank===4,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${l.rank}.`),le(u.shape[0]===1,()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${u.shape[0]}.`),le(u.shape[1]===1,()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${u.shape[1]}.`);const f=l.shape[2],h=l.shape[3];le(u.shape[2]===f*h,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${f*h}, but got ${u.shape[2]}.`);const p=l4(c,l,s,r,a,o),g=P2(p,u,1,"valid",a);return d?Ze(g,[g.shape[1],g.shape[2],g.shape[3]]):g}const KZ=Ce({separableConv2d_:P9t});async function L9t(t,e){const n=ne(t,"x","setdiff1d"),s=ne(e,"y","setdiff1d");le(n.dtype===s.dtype,()=>`x and y should have the same dtype, but got x (${n.dtype}) and y (${s.dtype}).`),le(n.rank===1,()=>`x should be 1D tensor, but got x (${n.shape}).`),le(s.rank===1,()=>`y should be 1D tensor, but got y (${s.shape}).`);const r=await n.data(),o=await s.data(),a=new Set(o);let i=0;for(let c=0;c<r.length;c++)a.has(r[c])||i++;const l=new Ab([i],n.dtype),u=new Ab([i],"int32");for(let c=0,d=0;c<r.length;c++)a.has(r[c])||(l.values[d]=r[c],u.values[d]=c,d++);return[l.toTensor(),u.toTensor()]}const qZ=L9t;function z9t(t){const n={x:ne(t,"x","sign")};return ke.runKernel(Qq,n)}const XZ=Ce({sign_:z9t});function B9t(t){const n={x:ne(t,"x","sin","float32")};return ke.runKernel(Zq,n)}const YZ=Ce({sin_:B9t});function V9t(t){const n={x:ne(t,"x","sinh")};return ke.runKernel(Jq,n)}const ZZ=Ce({sinh_:V9t});function H9t(t,e,n){const s=ne(t,"x","slice1d");return le(s.rank===1,()=>`slice1d expects a rank-1 tensor, but got a rank-${s.rank} tensor`),Mn(s,[e],[n])}const JZ=Ce({slice1d_:H9t});function W9t(t,e,n){const s=ne(t,"x","slice2d");return le(s.rank===2,()=>`slice2d expects a rank-2 tensor, but got a rank-${s.rank} tensor`),Mn(s,e,n)}const QZ=Ce({slice2d_:W9t});function U9t(t,e,n){const s=ne(t,"x","slice3d");return le(s.rank===3,()=>`slice3d expects a rank-3 tensor, but got a rank-${s.rank} tensor`),Mn(s,e,n)}const eJ=Ce({slice3d_:U9t});function G9t(t,e,n){const s=ne(t,"x","slice4d");return le(s.rank===4,()=>`slice4d expects a rank-4 tensor, but got a rank-${s.rank} tensor`),Mn(s,e,n)}const tJ=Ce({slice4d_:G9t});function j9t(t,e=-1){const n=ne(t,"logits","softmax","float32");if(e===-1&&(e=n.rank-1),e!==n.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and dim was ${e}`);const s={logits:n},r={dim:e};return ke.runKernel(aX,s,r)}const nJ=Ce({softmax_:j9t});function K9t(t){le(t.dtype==="complex64",()=>`The dtype for tf.spectral.fft() must be complex64 but got ${t.dtype}.`);const e={input:t};return ke.runKernel(LK,e)}const f4=Ce({fft_:K9t});function q9t(t){le(t.dtype==="complex64",()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${t.dtype}.`);const e={input:t};return ke.runKernel(qK,e)}const _g=Ce({ifft_:q9t});function X9t(t){const e=t.shape[t.shape.length-1],n=t.size/e;let s;if(e<=2){const r=Ze(t,[n,e]);s=_g(r)}else{const r=[n,2*(e-1)],o=Ze(Hh(t),[n,e]),a=Ze(D2(t),[n,e]),i=oc(Mn(o,[0,1],[n,e-2]),1),l=gt(oc(Mn(a,[0,1],[n,e-2]),1),an(-1)),u=sr([o,i],1),c=sr([a,l],1),d=Ze(Dl(u,c),[r[0],r[1]]);s=_g(d)}if(s=Hh(s),t.rank===3&&t.shape[0]!==0){const r=s,o=t.shape[0];s=Ze(s,[o,s.shape[0]/o,s.shape[1]]),r.dispose()}return s}const PE=Ce({irfft_:X9t});function Y9t(t,e,n=0){const r={x:ne(t,"x","split")},o={numOrSizeSplits:e,axis:n};return ke.runKernel(oX,r,o)}const jh=Ce({split_:Y9t});function Z9t(t,e){le(t.dtype==="float32",()=>`The dtype for rfft() must be real value but got ${t.dtype}`);let n=t.shape[t.shape.length-1];const s=t.size/n;let r;if(e!=null&&e<n){const p=t.shape.map(g=>0),m=t.shape.map(g=>g);m[t.shape.length-1]=e,r=Mn(t,p,m),n=e}else if(e!=null&&e>n){const p=t.shape.map(m=>m);p[t.shape.length-1]=e-n,r=sr([t,Kd(p)],t.shape.length-1),n=e}else r=t;const o=bo(r),a=Ze(Dl(r,o),[s,n]),i=f4(a),l=Math.floor(n/2)+1,u=Hh(i),c=D2(i),d=jh(u,[l,n-l],u.shape.length-1),f=jh(c,[l,n-l],c.shape.length-1),h=r.shape.slice();return h[r.shape.length-1]=l,Ze(Dl(d[0],f[0]),h)}const h4=Ce({rfft_:Z9t});function J9t(t,e){let n=ne(t,"a","squaredDifference"),s=ne(e,"b","squaredDifference");[n,s]=fs(n,s),Ns(n.shape,s.shape);const r={a:n,b:s},o={};return ke.runKernel(fX,r,o)}const LE=Ce({squaredDifference_:J9t});function Q9t(t,e){const n=ne(t,"x","squeeze","string_or_numeric");return Ze(n,Oj(n.shape,e).newShape)}const H2=Ce({squeeze_:Q9t});function eFt(t,e=0){const n=gg(t,"tensors","stack","string_or_numeric");le(n.length>=1,()=>"Pass at least one tensor to tf.stack"),n.length>0&&le(e<=n[0].rank,()=>"Axis must be <= rank of the tensor");const s=n,r={axis:e};return ke.runKernel(Nq,s,r)}const Xi=Ce({stack_:eFt});function tFt(t,e=0){const s={x:ne(t,"x","step")},r={alpha:e};return ke.runKernel(kX,s,r)}const zE=Ce({step_:tFt});function nFt(t,e,n,s,r=0,o=0,a=0,i=0,l=0){const c={x:ne(t,"x","stridedSlice","string_or_numeric")},d={begin:e,end:n,strides:s,beginMask:r,endMask:o,ellipsisMask:a,newAxisMask:i,shrinkAxisMask:l};return ke.runKernel(hX,c,d)}const sJ=Ce({stridedSlice_:nFt});function sFt(t){const n={x:ne(t,"x","tan","float32")};return ke.runKernel(yX,n)}const rJ=Ce({tan_:sFt});function ga(t,e){gf(t);const n=Gi(t,e);if(n.length!==1)throw new Error("tensor1d() requires values to be a flat/TypedArray");return bc(t,null,n,e)}function gd(t,e,n){if(gf(t),e!=null&&e.length!==2)throw new Error("tensor2d() requires shape to have two numbers");const s=Gi(t,n);if(s.length!==2&&s.length!==1)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(s.length===1&&e==null)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return bc(t,e,s,n)}function oJ(t,e,n){if(gf(t),e!=null&&e.length!==4)throw new Error("tensor4d() requires shape to have four numbers");const s=Gi(t,n);if(s.length!==4&&s.length!==1)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(s.length===1&&e==null)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return bc(t,e,s,n)}function aJ(t,e,n){if(gf(t),e!=null&&e.length!==5)throw new Error("tensor5d() requires shape to have five numbers");const s=Gi(t,n);if(s.length!==5&&s.length!==1)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(s.length===1&&e==null)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return bc(t,e,s,n)}function iJ(t,e,n){if(gf(t),e!=null&&e.length!==6)throw new Error("tensor6d() requires shape to have six numbers");const s=Gi(t,n);if(s.length!==6&&s.length!==1)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(s.length===1&&e==null)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return e=e||s,bc(t,e,s,n)}function rFt(t,e=1,n=!0){const s=ne(t,"x","topk");if(s.rank===0)throw new Error("topk() expects the input to be of rank 1 or higher");const r=s.shape[s.shape.length-1];if(e<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${e}`);if(e>r)throw new Error(`'k' passed to topk() must be <= the last dimension (${r}) but got ${e}`);const o={x:s},a={k:e,sorted:n},[i,l]=ke.runKernel(wX,o,a);return{values:i,indices:l}}const lJ=Ce({topk_:rFt});function oFt(t,e=0,n=1,s,r){if(s!=null&&s==="bool")throw new Error("Unsupported data type $ { dtype }");const o=new OE(e,n,s,!0,r),a=ji(t,s);for(let i=0;i<a.values.length;i++)a.values[i]=o.nextValue();return a.toTensor()}const uJ=Ce({truncatedNormal_:oFt});function aFt(t,e=0){const n=ne(t,"x","unique","string_or_numeric");le(n.rank>0,()=>"The input tensor must be at least 1D");const s={x:n},r={axis:e},[o,a]=ke.runKernel($X,s,r);return{values:o,indices:a}}const cJ=Ce({unique_:aFt});function iFt(t,e,n){const s=ne(t,"x","unsortedSegmentSum"),r=ne(e,"segmentIds","unsortedSegmentSum","int32");le(zh(n),()=>"numSegments must be of dtype int");const o={x:s,segmentIds:r},a={numSegments:n};return ke.runKernel(SX,o,a)}const dJ=Ce({unsortedSegmentSum_:iFt});function lFt(t,e=0){const n=ne(t,"x","unstack","string_or_numeric");le(e>=-n.shape.length&&e<n.shape.length,()=>`Axis = ${e} is not in [-${n.shape.length}, ${n.shape.length})`);const s={value:n},r={axis:e};return ke.runKernel(xX,s,r)}const _c=Ce({unstack_:lFt});function fJ(t,e){return d4(t,e,"right")}function hJ(t,e=!0,n,s){return ke.makeVariable(t,e,n,s)}function pJ(t,e){const n=[];for(let o=0;o<e.length;o++)e[o]&&n.push(o);const s=ji(t,"int32"),r=ji([n.length,t.length],"int32");for(let o=0;o<n.length;o++){const a=s.indexToLoc(n[o]),i=o*t.length;r.values.set(a,i)}return r.toTensor()}async function uFt(t){const e=ne(t,"condition","whereAsync","bool"),n=await e.data(),s=pJ(e.shape,n);return t!==e&&e.dispose(),s}const BE=uFt;async function cFt(t,e,n){const s=ne(t,"tensor","boolMask"),r=ne(e,"mask","boolMask","bool"),o=n??0,a=r.rank,i=s.shape;le(a>0,()=>"mask cannot be scalar"),Br(i.slice(o,o+a),r.shape,"mask's shape must match the first K dimensions of tensor's shape,");let l=1;for(let m=o;m<o+a;m++)l*=i[m];const u=i.slice(0,o).concat([l],i.slice(o+a)),c=Ze(s,u),d=Ze(r,[-1]),f=await BE(d),h=H2(f,[1]),p=vE(c,h,o);return t!==s&&s.dispose(),e!==r&&r.dispose(),h.dispose(),c.dispose(),d.dispose(),f.dispose(),p}const mJ=cFt;function dFt(t,e,n,s,r=!0){const o=ne(t,"v","movingAverage"),a=ne(e,"x","movingAverage"),i=ne(n,"decay","movingAverage");OX(o,a),le(Ui(o.shape,a.shape),()=>"Shape mismatch in v and x");const l=an(1),u=rn(l,i);let c=gt(rn(a,o),u);if(r){le(s!=null,()=>"When using zeroDebias: true, step is required.");const d=ne(s,"step","movingAverage");c=En(c,rn(l,Wh(i,d)))}return Wt(o,c)}const gJ=Ce({movingAverage_:dFt});function fFt(t,e,n){const s=ne(t,"indices","scatterND","int32"),r=ne(e,"updates","scatterND");sE(r,s,n);const o={indices:s,updates:r},a={shape:n};return ke.runKernel(jq,o,a)}const vJ=Ce({scatterND_:fFt});function hFt(t,e,n,s){if(t.dtype!=="int32")throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);if(t.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${t.shape}.`);const r=t.rank>0?t.shape[0]:1,o=t.rank>1?t.shape[1]:1;if(n.length!==o)throw new Error(`outputShape has incorrect number of elements:, ${n.length}, should be: ${o}.`);const a=e.size;if(!(e.rank===0||e.rank===1&&a===r))throw new Error(`sparseValues has incorrect shape ${e.shape}, should be [] or [${r}]`);if(e.dtype!==s.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}function pFt(t,e,n,s=0){const r=ne(t,"sparseIndices","sparseToDense","int32"),o=ne(e,"sparseValues","sparseToDense","string_or_numeric"),a=ne(s,"defaultValue","sparseToDense",o.dtype);hFt(r,o,n,a);const i={sparseIndices:r,sparseValues:o,defaultValue:a},l={outputShape:n};return ke.runKernel(dX,i,l)}const yJ=Ce({sparseToDense_:pFt});function mFt(t,e){const n=ne(e,"indices","gatherND","int32"),r={params:ne(t,"x","gatherND","string_or_numeric"),indices:n};return ke.runKernel(GK,r)}const bJ=Ce({gatherND_:mFt});function gFt(t,e){if(e==null)return t.shape.slice();if(Ui(t.shape,e))return e;if(t.shape.length===e.length){const n=[];for(let s=0;s<t.shape.length;s++)e[s]==null&&t.shape[s]!=null?n.push(t.shape[s]):n.push(e[s]);return n}return e}function vFt(t,e,n,s){const r=ne(t,"x","dropout");if(le(r.dtype==="float32",()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${r.dtype} tensor instead.`),le(e>=0&&e<1,()=>`rate must be a float in the range [0, 1), but got ${e}.`),e===0)return t instanceof os?r.clone():r;const o=gFt(r,n),a=1-e,i=En(gE(Wt(DE(o,0,1,"float32",s),a)),a);return gt(r,i)}const wJ=Ce({dropout_:vFt});function VE(t){return Math.floor(Math.pow(2,Math.ceil(Math.log(t)/Math.log(2))))}function p4(t,e,n){const s=1-t%2,r=new Float32Array(t);for(let o=0;o<t;++o){const a=2*Math.PI*o/(t+s-1);r[o]=e-n*Math.cos(a)}return ga(r,"float32")}async function yFt(t,e,n=1){const s=ne(t,"predictions","inTopK"),r=ne(e,"targets","inTopK");le(s.rank>1,()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${s.rank}`),le(s.rank-1===r.rank,()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${s.rank} and targets rank ${r.rank}`),Br(s.shape.slice(0,s.shape.length-1),r.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");const o=s.shape[s.shape.length-1];le(n>0&&n<=o,()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${o}), but got ${n}`);const a=await s.data(),i=await r.data(),[l,u]=[a.length/o,o],c=Rj("bool",l);for(let d=0;d<l;d++){const f=d*u,h=a.subarray(f,f+u),p=[];for(let m=0;m<h.length;m++)p.push({value:h[m],index:m});p.sort((m,g)=>g.value-m.value),c[d]=0;for(let m=0;m<n;m++)if(p[m].index===i[d]){c[d]=1;break}}return t!==s&&s.dispose(),e!==r&&r.dispose(),Za(c,r.shape,"bool")}const _J=yFt;function bFt(t,e,n,s,r,o="NHWC",a){let i=t;t.rank===3&&(i=Ze(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let l=e;l.rank===3&&(l=Ze(e,[1,e.shape[0],e.shape[1],e.shape[2]])),le(i.rank===4,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${i.shape}.`),le(l.rank===4,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${l.shape}.`),le(n.length===4,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${n}.`);const u=o==="NHWC"?i.shape[3]:i.shape[1],c=o==="NHWC"?l.shape[3]:l.shape[1];le(u===n[2],()=>`Error in conv2dDerFilter: depth of input ${u}) must match input depth in filter (${n[2]}.`),le(c===n[3],()=>`Error in conv2dDerFilter: depth of dy (${c}) must match output depth for filter (${n[3]}).`),Aa("conv2dDerFilter",r,a);const d={x:i,dy:l},f={strides:s,pad:r,dataFormat:o,dimRoundingMode:a,filterShape:n};return ke.runKernel(pK,d,f)}const wFt=Ce({conv2DBackpropFilter_:bFt});function m4(t,e,n){if(n==null||n==="linear")return t;if(n==="relu")return gt(t,zE(e));throw new Error(`Cannot compute gradient for fused activation ${n}.`)}function g4(t,e){let n=e;const s=eE(t.shape,e.shape);return s.length>0&&(n=Wn(n,s)),Ze(n,t.shape)}function v4(t,e,n,s){if(e==="linear")return t;if(e==="relu")return V2(t);if(e==="elu")return hE(t);if(e==="relu6")return FE(t);if(e==="prelu")return AE(t,n);if(e==="leakyrelu")return bE(t,s);if(e==="sigmoid")return Bu(t);throw new Error(`Unknown fused activation ${e}.`)}const y4=(t,e)=>!(t>0)||e==="linear";function _Ft({x:t,filter:e,strides:n,pad:s,dataFormat:r="NHWC",dilations:o=[1,1],dimRoundingMode:a,bias:i,activation:l="linear",preluActivationWeights:u,leakyreluAlpha:c}){if(l=l||"linear",y4(ke.state.gradientDepth,l)===!1){le(r==="NHWC",()=>`Error in fused conv2d: got dataFormat of ${r} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);let x=P2(t,e,n,s,r,o,a);return i!=null&&(x=Wt(x,i)),v4(x,l,u,c)}const d=ne(t,"x","conv2d","float32"),f=ne(e,"filter","conv2d","float32");let h=d,p=!1;d.rank===3&&(p=!0,h=Ze(d,[1,d.shape[0],d.shape[1],d.shape[2]])),le(h.rank===4,()=>`Error in fused conv2d: input must be rank 4, but got rank ${h.rank}.`),le(f.rank===4,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${f.rank}.`),Aa("fused conv2d",s,a);const m=r==="NHWC"?h.shape[3]:h.shape[1];le(f.shape[2]===m,()=>`Error in conv2d: depth of input (${m}) must match input depth for filter ${f.shape[2]}.`),le(nu(n,o),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${o}'`);const g=F2(h.shape,f.shape,n,o,s,a);let y;i!=null&&(y=ne(i,"bias","fused conv2d"),[y]=fs(y,d),r==="NHWC"?Ns(g.outShape,y.shape):(le(y.shape.length<=1,()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${y.shape.length}.`),le(y.shape.length===0||y.shape[0]===g.outChannels||y.shape[0]===1,()=>`Error in fused conv2d: bias shape (${y.shape}) is not compatible with the number of output channels (${g.outChannels})`)));let w;if(u!=null){const x=u.shape;if(le(x.length<=1||x.length===3,()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${x.length}.`),x.length===1)le(x[0]===1||x[0]===g.outChannels,()=>`Error in fused conv2d: PReLU activation weights (${x}) is not compatible with the number of output channels (${g.outChannels}).`);else if(x.length===3)try{Ns(x,g.outShape)}catch{const C=`Error in fused conv2d: PReLU activation weights (${x}) is not compatible with the output shape of the conv2d (${g.outShape}).`;throw Error(C)}w=ne(u,"prelu weights","fused conv2d")}const b=(x,k)=>{le(r==="NHWC",()=>`Error in gradient of fused conv2D: got dataFormat of ${r} but only NHWC is currently supported.`);const[C,T,N,M]=k,R=m4(x,N,l);le(yg(o),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${o}'`);const D=WY(T.shape,R,C,n,s),z=wFt(T,R,C.shape,n,s),B=[D,z];if(M!=null){const V=g4(M,R);B.push(V)}return B},_={x:h,filter:f,bias:y,preluActivationWeights:w},$={strides:n,pad:s,dataFormat:r,dilations:o,dimRoundingMode:a,activation:l,leakyreluAlpha:c};return i==null?qi((k,C,T)=>{let N=ke.runKernel(oS,_,$);return T([C,k,N]),p&&(N=Ze(N,[N.shape[1],N.shape[2],N.shape[3]])),{value:N,gradFunc:b}})(h,f):qi((k,C,T,N)=>{let M=ke.runKernel(oS,_,$);return N([C,k,M,T]),p&&(M=Ze(M,[M.shape[1],M.shape[2],M.shape[3]])),{value:M,gradFunc:b}})(h,f,y)}const $Ft=Ce({fusedConv2d_:_Ft});function xFt(t,e,n,s,r,o=[1,1],a){let i=t;t.rank===3&&(i=Ze(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let l=e;l.rank===3&&(l=Ze(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const u={x:i,dy:l},c={strides:s,pad:r,dimRoundingMode:a,dilations:o,filterShape:n};return ke.runKernel(kK,u,c)}const SFt=Ce({depthwiseConv2dNativeBackpropFilter_:xFt});function CFt(t,e,n,s,r,o=[1,1],a){let i=e,l=!1;e.rank===3&&(l=!0,i=Ze(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const u={dy:i,filter:n},c={strides:s,pad:r,dimRoundingMode:a,dilations:o,inputShape:t},d=ke.runKernel(TK,u,c);return l?Ze(d,[d.shape[1],d.shape[2],d.shape[3]]):d}const kFt=Ce({depthwiseConv2dNativeBackpropInput_:CFt});function TFt({x:t,filter:e,strides:n,pad:s,dataFormat:r="NHWC",dilations:o=[1,1],dimRoundingMode:a,bias:i,activation:l="linear",preluActivationWeights:u,leakyreluAlpha:c}){if(y4(ke.state.gradientDepth,l)===!1){let $=l4(t,e,n,s,r,o,a);return i!=null&&($=Wt($,i)),v4($,l,u,c)}const d=ne(t,"x","depthwiseConv2d","float32"),f=ne(e,"filter","depthwiseConv2d","float32");let h=d,p=!1;d.rank===3&&(p=!0,h=Ze(d,[1,d.shape[0],d.shape[1],d.shape[2]])),le(h.rank===4,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${h.rank}.`),le(f.rank===4,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${f.rank}.`),le(h.shape[3]===f.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${h.shape[3]}) must match the inChannels dimension in filter ${f.shape[2]}.`),o==null&&(o=[1,1]),le(nu(n,o),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${n} and dilations '${o}'`),Aa("fused depthwiseConv2d",s,a);const m=F2(h.shape,f.shape,n,o,s,a,!0);let g;i!=null&&(g=ne(i,"bias","fused conv2d"),[g]=fs(g,d),Ns(m.outShape,g.shape));let y;u!=null&&(y=ne(u,"prelu weights","fused depthwiseConv2d"));const w=($,x)=>{le(yg(o),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${o}'`);const[k,C,T,N]=x,M=m4($,T,l),R=kFt(C.shape,M,k,n,s,o,a),D=SFt(C,M,k.shape,n,s,o,a);if(N!=null){const z=g4(g,M);return[R,D,z]}return[R,D]},b={x:h,filter:f,bias:g,preluActivationWeights:y},_={strides:n,pad:s,dataFormat:r,dilations:o,dimRoundingMode:a,activation:l,leakyreluAlpha:c};return i==null?qi((x,k,C)=>{let T=ke.runKernel(aS,b,_);return C([k,x,T]),p&&(T=Ze(T,[T.shape[1],T.shape[2],T.shape[3]])),{value:T,gradFunc:w}})(h,f):qi((x,k,C,T)=>{let N=ke.runKernel(aS,b,_);return T([k,x,N,C]),p&&(N=Ze(N,[N.shape[1],N.shape[2],N.shape[3]])),{value:N,gradFunc:w}})(h,f,g)}const NFt=Ce({fusedDepthwiseConv2d_:TFt});function IFt({a:t,b:e,transposeA:n=!1,transposeB:s=!1,bias:r,activation:o="linear",preluActivationWeights:a,leakyreluAlpha:i=.2}){if(y4(ke.state.gradientDepth,o)===!1){let M=Tn(t,e,n,s);return r!=null&&(M=Wt(M,r)),v4(M,o,a,i)}let l=ne(t,"a","fused matMul"),u=ne(e,"b","fused matMul");[l,u]=fs(l,u);const c=n?l.shape[l.rank-2]:l.shape[l.rank-1],d=s?u.shape[u.rank-1]:u.shape[u.rank-2],f=n?l.shape[l.rank-1]:l.shape[l.rank-2],h=s?u.shape[u.rank-2]:u.shape[u.rank-1],p=l.shape.slice(0,-2),m=u.shape.slice(0,-2),g=Qn(p),y=Qn(m);le(c===d,()=>`Error in fused matMul: inner shapes (${c}) and (${d}) of Tensors with shapes ${l.shape} and ${u.shape} and transposeA=${n} and transposeB=${s} must match.`);const b=Ns(l.shape.slice(0,-2),u.shape.slice(0,-2)).concat([f,h]),_=n?Ze(l,[g,c,f]):Ze(l,[g,f,c]),$=s?Ze(u,[y,h,d]):Ze(u,[y,d,h]);let x;r!=null&&(x=ne(r,"bias","fused matMul"),[x]=fs(x,l),Ns(b,x.shape));let k;a!=null&&(k=ne(a,"prelu weights","fused matMul"));const C=(M,R)=>{const[D,z,B,V]=R,O=m4(Ze(M,B.shape),B,o);let F,L;if(!n&&!s?(F=Tn(O,z,!1,!0),L=Tn(D,O,!0,!1)):!n&&s?(F=Tn(O,z,!1,!1),L=Tn(O,D,!0,!1)):n&&!s?(F=Tn(z,O,!1,!0),L=Tn(D,O,!1,!1)):(F=Tn(z,O,!0,!0),L=Tn(O,D,!0,!0)),r!=null){const G=g4(V,O);return[F,L,G]}else return[F,L]},T={a:_,b:$,bias:x,preluActivationWeights:k},N={transposeA:n,transposeB:s,activation:o,leakyreluAlpha:i};return r==null?qi((R,D,z)=>{const B=ke.runKernel(rS,T,N);return z([R,D,B]),{value:Ze(B,b),gradFunc:C}})(_,$):qi((R,D,z,B)=>{const V=ke.runKernel(rS,T,N);return B([R,D,V,z]),{value:Ze(V,b),gradFunc:C}})(_,$,x)}const EFt=Ce({fusedMatMul_:IFt});const $J=Object.freeze(Object.defineProperty({__proto__:null,conv2d:$Ft,depthwiseConv2d:NFt,matMul:EFt},Symbol.toStringTag,{value:"Module"}));function AFt(t){return p4(t,.54,.46)}const OFt=Ce({hammingWindow_:AFt});function RFt(t){return p4(t,.5,.5)}const xJ=Ce({hannWindow_:RFt});function DFt(t,e,n,s=!1,r=0){let o=0;const a=[];for(;o+e<=t.size;)a.push(Mn(t,o,e)),o+=n;if(s)for(;o<t.size;){const i=o+e-t.size,l=sr([Mn(t,o,e-i),_m([i],r)]);a.push(l),o+=n}return a.length===0?gd([],[0,e]):Ze(sr(a),[a.length,e])}const SJ=Ce({frame_:DFt});function FFt(t,e,n,s,r=xJ){s==null&&(s=VE(e));const o=SJ(t,e,n),a=gt(o,r(e));return h4(a,s)}const MFt=Ce({stft_:FFt});function PFt(t,e,n,s,r="bilinear",o=0){const a=ne(t,"image","cropAndResize"),i=ne(e,"boxes","cropAndResize","float32"),l=ne(n,"boxInd","cropAndResize","int32"),u=i.shape[0];le(a.rank===4,()=>`Error in cropAndResize: image must be rank 4,but got rank ${a.rank}.`),le(i.rank===2&&i.shape[1]===4,()=>`Error in cropAndResize: boxes must be have size [${u},4] but had shape ${i.shape}.`),le(l.rank===1&&l.shape[0]===u,()=>`Error in cropAndResize: boxInd must be have size [${u}] but had shape ${i.shape}.`),le(s.length===2,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${s.length}.`),le(s[0]>=1&&s[1]>=1,()=>`cropSize must be atleast [1,1], but was ${s}`),le(r==="bilinear"||r==="nearest",()=>`method must be bilinear or nearest, but was ${r}`);const c={image:a,boxes:i,boxInd:l},d={method:r,extrapolationValue:o,cropSize:s};return ke.runKernel($K,c,d)}const LFt=Ce({cropAndResize_:PFt});function zFt(t){const e=ne(t,"image","flipLeftRight","float32");le(e.rank===4,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${e.rank}.`);const n={image:e};return ke.runKernel(BK,n,{})}const BFt=Ce({flipLeftRight_:zFt});function VFt(t){const e=ne(t,"image","grayscaleToRGB"),n=e.rank-1,s=e.shape[n];le(e.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${e.rank}.`),le(s===1,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${s}.`);const r=new Array(e.rank);return r.fill(1,0,n),r[n]=3,th(e,r)}const HFt=Ce({grayscaleToRGB_:VFt});function WFt(t,e,n=0,s=.5){const r=ne(t,"image","rotateWithOffset","float32");le(r.rank===4,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${r.rank}.`);const o={image:r},a={radians:e,fillValue:n,center:s};return ke.runKernel(TX,o,a)}const UFt=Ce({rotateWithOffset_:WFt});function xm(t,e,n,s,r,o){s==null&&(s=.5),r==null&&(r=Number.NEGATIVE_INFINITY),o==null&&(o=0);const a=t.shape[0];return n=Math.min(n,a),le(0<=s&&s<=1,()=>`iouThreshold must be in [0, 1], but was '${s}'`),le(t.rank===2,()=>`boxes must be a 2D tensor, but was of rank '${t.rank}'`),le(t.shape[1]===4,()=>`boxes must have 4 columns, but 2nd dimension was ${t.shape[1]}`),le(e.rank===1,()=>"scores must be a 1D tensor"),le(e.shape[0]===a,()=>`scores has incompatible shape with boxes. Expected ${a}, but was ${e.shape[0]}`),le(0<=o&&o<=1,()=>`softNmsSigma must be in [0, 1], but was '${o}'`),{maxOutputSize:n,iouThreshold:s,scoreThreshold:r,softNmsSigma:o}}function GFt(t,e,n,s=.5,r=Number.NEGATIVE_INFINITY){const o=ne(t,"boxes","nonMaxSuppression","float32"),a=ne(e,"scores","nonMaxSuppression","float32"),i=xm(o,a,n,s,r);n=i.maxOutputSize,s=i.iouThreshold,r=i.scoreThreshold;const l={maxOutputSize:n,iouThreshold:s,scoreThreshold:r};return ke.runKernel(xq,{boxes:o,scores:a},l)}const jFt=Ce({nonMaxSuppression_:GFt});function KFt(t,e,n){const s=qFt(t,e,n),r=s<0?-(s+1):s;t.splice(r,0,e)}function qFt(t,e,n){return YFt(t,e,n||XFt)}function XFt(t,e){return t>e?1:t<e?-1:0}function YFt(t,e,n){let s=0,r=t.length,o=0,a=!1;for(;s<r;){o=s+(r-s>>>1);const i=n(e,t[o]);i>0?s=o+1:(r=o,a=!i)}return a?s:-s-1}function CJ(t,e,n,s,r){return HE(t,e,n,s,r,0)}function kJ(t,e,n,s,r,o){return HE(t,e,n,s,r,0,!1,o,!0)}function TJ(t,e,n,s,r,o){return HE(t,e,n,s,r,o,!0)}function HE(t,e,n,s,r,o,a=!1,i=!1,l=!1){const u=[];for(let g=0;g<e.length;g++)e[g]>r&&u.push({score:e[g],boxIndex:g,suppressBeginIndex:0});u.sort(N9);const c=o>0?-.5/o:0,d=[],f=[];for(;d.length<n&&u.length>0;){const g=u.pop(),{score:y,boxIndex:w,suppressBeginIndex:b}=g;if(y<r)break;let _=!1;for(let $=d.length-1;$>=b;--$){const x=ZFt(t,w,d[$]);if(x>=s){_=!0;break}if(g.score=g.score*JFt(s,c,x),g.score<=r)break}g.suppressBeginIndex=d.length,_||(g.score===y?(d.push(w),f.push(g.score)):g.score>r&&KFt(u,g,N9))}const h=d.length,p=n-h;i&&p>0&&(d.push(...new Array(p).fill(0)),f.push(...new Array(p).fill(0)));const m={selectedIndices:d};return a&&(m.selectedScores=f),l&&(m.validOutputs=h),m}function ZFt(t,e,n){const s=t.subarray(e*4,e*4+4),r=t.subarray(n*4,n*4+4),o=Math.min(s[0],s[2]),a=Math.min(s[1],s[3]),i=Math.max(s[0],s[2]),l=Math.max(s[1],s[3]),u=Math.min(r[0],r[2]),c=Math.min(r[1],r[3]),d=Math.max(r[0],r[2]),f=Math.max(r[1],r[3]),h=(i-o)*(l-a),p=(d-u)*(f-c);if(h<=0||p<=0)return 0;const m=Math.max(o,u),g=Math.max(a,c),y=Math.min(i,d),w=Math.min(l,f),b=Math.max(y-m,0)*Math.max(w-g,0);return b/(h+p-b)}function JFt(t,e,n){const s=Math.exp(e*n*n);return n<=t?s:0}function N9(t,e){return t.score-e.score||t.score===e.score&&e.boxIndex-t.boxIndex}async function QFt(t,e,n,s=.5,r=Number.NEGATIVE_INFINITY){const o=ne(t,"boxes","nonMaxSuppressionAsync"),a=ne(e,"scores","nonMaxSuppressionAsync"),i=xm(o,a,n,s,r);n=i.maxOutputSize,s=i.iouThreshold,r=i.scoreThreshold;const l=await Promise.all([o.data(),a.data()]),u=l[0],c=l[1],{selectedIndices:d}=CJ(u,c,n,s,r);return o!==t&&o.dispose(),a!==e&&a.dispose(),ga(d,"int32")}const eMt=QFt;function tMt(t,e,n,s=.5,r=Number.NEGATIVE_INFINITY,o=0){const a=ne(t,"boxes","nonMaxSuppression"),i=ne(e,"scores","nonMaxSuppression"),l=xm(a,i,n,s,r,o);n=l.maxOutputSize,s=l.iouThreshold,r=l.scoreThreshold,o=l.softNmsSigma;const u={boxes:a,scores:i},c={maxOutputSize:n,iouThreshold:s,scoreThreshold:r,softNmsSigma:o},d=ke.runKernel(Cq,u,c);return{selectedIndices:d[0],selectedScores:d[1]}}const nMt=Ce({nonMaxSuppressionWithScore_:tMt});async function sMt(t,e,n,s=.5,r=Number.NEGATIVE_INFINITY,o=0){const a=ne(t,"boxes","nonMaxSuppressionAsync"),i=ne(e,"scores","nonMaxSuppressionAsync"),l=xm(a,i,n,s,r,o);n=l.maxOutputSize,s=l.iouThreshold,r=l.scoreThreshold,o=l.softNmsSigma;const u=await Promise.all([a.data(),i.data()]),c=u[0],d=u[1],{selectedIndices:f,selectedScores:h}=TJ(c,d,n,s,r,o);return a!==t&&a.dispose(),i!==e&&i.dispose(),{selectedIndices:ga(f,"int32"),selectedScores:ga(h)}}const rMt=sMt;function oMt(t,e,n,s=.5,r=Number.NEGATIVE_INFINITY,o=!1){const a=ne(t,"boxes","nonMaxSuppression"),i=ne(e,"scores","nonMaxSuppression"),l=xm(a,i,n,s,r,null),u=l.maxOutputSize,c=l.iouThreshold,d=l.scoreThreshold,f={boxes:a,scores:i},h={maxOutputSize:u,iouThreshold:c,scoreThreshold:d,padToMaxOutputSize:o},p=ke.runKernel(Sq,f,h);return{selectedIndices:p[0],validOutputs:p[1]}}const aMt=Ce({nonMaxSuppressionPadded_:oMt});async function iMt(t,e,n,s=.5,r=Number.NEGATIVE_INFINITY,o=!1){const a=ne(t,"boxes","nonMaxSuppressionAsync"),i=ne(e,"scores","nonMaxSuppressionAsync"),l=xm(a,i,n,s,r,null),u=l.maxOutputSize,c=l.iouThreshold,d=l.scoreThreshold,[f,h]=await Promise.all([a.data(),i.data()]),{selectedIndices:p,validOutputs:m}=kJ(f,h,u,c,d,o);return a!==t&&a.dispose(),i!==e&&i.dispose(),{selectedIndices:ga(p,"int32"),validOutputs:an(m,"int32")}}const lMt=iMt;function uMt(t,e,n=!1,s=!1){const r=ne(t,"images","resizeBilinear");le(r.rank===3||r.rank===4,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${r.rank}.`),le(e.length===2,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${e}.`),le(s===!1||n===!1,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let o=r,a=!1;r.rank===3&&(a=!0,o=Ze(r,[1,r.shape[0],r.shape[1],r.shape[2]]));const i={images:o},l={alignCorners:n,halfPixelCenters:s,size:e},u=ke.runKernel(Vq,i,l);return a?Ze(u,[u.shape[1],u.shape[2],u.shape[3]]):u}const cMt=Ce({resizeBilinear_:uMt});function dMt(t,e,n=!1,s=!1){const r=ne(t,"images","resizeNearestNeighbor");le(r.rank===3||r.rank===4,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${r.rank}.`),le(e.length===2,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${e}.`),le(r.dtype==="float32"||r.dtype==="int32",()=>"`images` must have `int32` or `float32` as dtype"),le(s===!1||n===!1,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let o=r,a=!1;r.rank===3&&(a=!0,o=Ze(r,[1,r.shape[0],r.shape[1],r.shape[2]]));const i={images:o},l={alignCorners:n,halfPixelCenters:s,size:e},u=ke.runKernel(Bq,i,l);return a?Ze(u,[u.shape[1],u.shape[2],u.shape[3]]):u}const fMt=Ce({resizeNearestNeighbor_:dMt});function hMt(t,e="binary",n=!1,s=.5){const r=ne(t,"image","threshold"),o=.2989,a=.587,i=.114,l=r.shape[0]*r.shape[1];let u=gt(ga([s]),255),c,d,f,h;if(le(r.rank===3,()=>`Error in threshold: image must be rank 3,but got rank ${r.rank}.`),le(r.shape[2]===3||r.shape[2]===1,()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${r.shape[2]}.`),le(r.dtype==="int32"||r.dtype==="float32",()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${r.dtype}.`),le(e==="otsu"||e==="binary",()=>`Method must be binary or otsu, but was ${e}`),r.shape[2]===3){[c,d,f]=jh(r,[1,1,1],-1);const g=gt(c,o),y=gt(d,a),w=gt(f,i);h=Wt(Wt(g,y),w)}else h=t;if(e==="otsu"){const g=dE(es(ME(h),"int32"),Za([]),256);u=pMt(g,l)}const p=n?u4(h,u):B2(h,u);return es(gt(p,255),"int32")}function pMt(t,e){let n=ga([-1]),s=ga([0]),r=ga([0]),o,a,i,l,u,c;for(let d=0;d<t.size-1;d++){o=Mn(t,0,d+1),a=Mn(t,d+1),u=En(Wn(o),e),c=En(Wn(a),e);const f=Wn(gt(o,Gh(0,o.size)));i=En(f,Wn(o));const h=_m(a.shape,o.size),p=Wt(Gh(0,a.size),h),m=gt(a,p);l=En(Wn(m),Wn(a));const g=rn(i,l),y=rn(i,l),w=gt(u,c);r=gt(gt(w,g),y);const b=B2(r,s);s=jd(b,r,s),n=jd(b,ga([d]),n)}return n}const mMt=Ce({threshold_:hMt});function gMt(t,e,n="nearest",s="constant",r=0,o){const a=ne(t,"image","transform","float32"),i=ne(e,"transforms","transform","float32");le(a.rank===4,()=>`Error in transform: image must be rank 4,but got rank ${a.rank}.`),le(i.rank===2&&(i.shape[0]===a.shape[0]||i.shape[0]===1)&&i.shape[1]===8,()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),le(o==null||o.length===2,()=>`Error in transform: outputShape must be [height, width] or null, but got ${o}.`);const l={image:a,transforms:i},u={interpolation:n,fillMode:s,fillValue:r,outputShape:o};return ke.runKernel(_X,l,u)}const vMt=Ce({transform_:gMt});function yMt(t,e,n){le(e%1===0,()=>`bandPart(): numLower must be an integer, got ${e}.`),le(n%1===0,()=>`bandPart(): numUpper must be an integer, got ${n}.`);const s=ne(t,"a","bandPart");le(s.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${s.rank}.`);const r=s.shape,[o,a]=s.shape.slice(-2);if(!(e<=o))throw new Error(`bandPart(): numLower (${e}) must not be greater than the number of rows (${o}).`);if(!(n<=a))throw new Error(`bandPart(): numUpper (${n}) must not be greater than the number of columns (${a}).`);e<0&&(e=o),n<0&&(n=a);const i=Ze(Gh(0,o,1,"int32"),[-1,1]),l=Gh(0,a,1,"int32"),u=rn(i,l),c=bg(u4(u,an(+e,"int32")),yE(u,an(-n,"int32"))),d=Kd([o,a],s.dtype);return Ze(Xi(_c(Ze(s,[-1,o,a])).map(f=>jd(c,f,d))),r)}const bMt=Ce({bandPart_:yMt});function wMt(t){let e;if(Array.isArray(t)){e=!1,le(t!=null&&t.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");const r=t[0].shape[0];for(let o=1;o<t.length;++o)le(t[o].shape[0]===r,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${t[o].shape[0]} vs. ${r})`)}else e=!0,t=jh(t,t.shape[0],0).map(r=>H2(r,[0]));le(t.length<=t[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${t.length}) exceeds number of dimensions (${t[0].shape[0]}).`);const n=[],s=t;for(let r=0;r<t.length;++r)n.push(ke.tidy(()=>{let o=s[r];if(r>0)for(let a=0;a<r;++a){const i=gt(Wn(gt(n[a],o)),n[a]);o=rn(o,i)}return En(o,z2(o,"euclidean"))}));return e?Xi(n,0):n}const _Mt=Ce({gramSchmidt_:wMt});function $Mt(t,e=!1){if(le(t.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${t.rank}`),t.rank===2)return I9(t,e);{const n=t.shape.slice(0,t.shape.length-2).reduce((l,u)=>l*u),s=_c(Ze(t,[n,t.shape[t.shape.length-2],t.shape[t.shape.length-1]]),0),r=[],o=[];s.forEach(l=>{const[u,c]=I9(l,e);r.push(u),o.push(c)});const a=Ze(Xi(r,0),t.shape),i=Ze(Xi(o,0),t.shape);return[a,i]}}function I9(t,e=!1){return ke.tidy(()=>{le(t.shape.length===2,()=>`qr2d() requires a 2D Tensor, but got a ${t.shape.length}D Tensor.`);const n=t.shape[0],s=t.shape[1];let r=mE(n),o=bl(t);const a=gd([[1]],[1,1]);let i=bl(a);const l=n>=s?s:n;for(let u=0;u<l;++u){const c=o,d=i,f=r;[i,o,r]=ke.tidy(()=>{const h=Mn(o,[u,u],[n-u,1]),p=z2(h),m=Mn(o,[u,u],[1,1]),g=jd(B2(m,0),gd([[-1]]),gd([[1]])),y=rn(m,gt(g,p)),w=En(h,y);w.shape[0]===1?i=bl(a):i=sr([a,Mn(w,[1,0],[w.shape[0]-1,w.shape[1]])],0);const b=Pi(En(Tn(g,y),p)),_=Mn(o,[u,0],[n-u,s]),$=gt(b,i),x=vg(i);if(u===0)o=rn(_,Tn($,Tn(x,_)));else{const T=rn(_,Tn($,Tn(x,_)));o=sr([Mn(o,[0,0],[u,s]),T],0)}const k=vg($),C=Mn(r,[0,u],[n,r.shape[1]-u]);if(u===0)r=rn(C,Tn(Tn(C,i),k));else{const T=rn(C,Tn(Tn(C,i),k));r=sr([Mn(r,[0,0],[n,u]),T],1)}return[i,o,r]}),qr([c,d,f])}return!e&&n>s&&(r=Mn(r,[0,0],[n,s]),o=Mn(o,[0,0],[s,s])),[r,o]})}const xMt=Ce({qr_:$Mt});var Er;(function(t){t[t.NONE=0]="NONE",t[t.MEAN=1]="MEAN",t[t.SUM=2]="SUM",t[t.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"})(Er||(Er={}));function SMt(t,e,n=Er.SUM_BY_NONZERO_WEIGHTS){const s=ne(t,"losses","computeWeightedLoss");let r=null;e!=null&&(r=ne(e,"weights","computeWeightedLoss"));const o=r==null?s:gt(s,r);if(n===Er.NONE)return o;if(n===Er.SUM)return Wn(o);if(n===Er.MEAN){if(r==null)return wg(o);{const a=s.size/r.size,i=En(Wn(o),Wn(r));return a>1?En(i,an(a)):i}}if(n===Er.SUM_BY_NONZERO_WEIGHTS){if(r==null)return En(Wn(o),an(s.size));{const a=gt(r,Au(s.shape)),i=es(Wn(NE(a,an(0))),"float32");return En(Wn(o),i)}}throw Error(`Unknown reduction: ${n}`)}const su=Ce({computeWeightedLoss_:SMt});function CMt(t,e,n,s=Er.SUM_BY_NONZERO_WEIGHTS){const r=ne(t,"labels","absoluteDifference"),o=ne(e,"predictions","absoluteDifference");let a=null;n!=null&&(a=ne(n,"weights","absoluteDifference")),Br(r.shape,o.shape,"Error in absoluteDifference: ");const i=co(rn(r,o));return su(i,a,s)}const kMt=Ce({absoluteDifference_:CMt});function TMt(t,e,n,s,r=Er.SUM_BY_NONZERO_WEIGHTS){const o=ne(t,"labels","cosineDistance"),a=ne(e,"predictions","cosineDistance");let i=null;s!=null&&(i=ne(s,"weights","cosineDistance")),Br(o.shape,a.shape,"Error in cosineDistance: ");const l=an(1),u=rn(l,Wn(gt(o,a),n,!0));return su(u,i,r)}const NMt=Ce({cosineDistance_:TMt});function IMt(t,e,n,s=Er.SUM_BY_NONZERO_WEIGHTS){let r=ne(t,"labels","hingeLoss");const o=ne(e,"predictions","hingeLoss");let a=null;n!=null&&(a=ne(n,"weights","hingeLoss")),Br(r.shape,o.shape,"Error in hingeLoss: ");const i=an(1);r=rn(gt(an(2),r),i);const l=V2(rn(i,gt(r,o)));return su(l,a,s)}const EMt=Ce({hingeLoss_:IMt});function AMt(t,e,n,s=1,r=Er.SUM_BY_NONZERO_WEIGHTS){const o=ne(t,"labels","huberLoss"),a=ne(e,"predictions","huberLoss");let i=null;n!=null&&(i=ne(n,"weights","huberLoss")),Br(o.shape,a.shape,"Error in huberLoss: ");const l=an(s),u=co(rn(a,o)),c=TE(u,l),d=rn(u,c),f=Wt(gt(an(.5),ba(c)),gt(l,d));return su(f,i,r)}const OMt=Ce({huberLoss_:AMt});function RMt(t,e,n,s=1e-7,r=Er.SUM_BY_NONZERO_WEIGHTS){const o=ne(t,"labels","logLoss"),a=ne(e,"predictions","logLoss");let i=null;n!=null&&(i=ne(n,"weights","logLoss")),Br(o.shape,a.shape,"Error in logLoss: ");const l=an(1),u=an(s),c=Pi(gt(o,Uh(Wt(a,u)))),d=gt(rn(l,o),Uh(Wt(rn(l,a),u))),f=rn(c,d);return su(f,i,r)}const DMt=Ce({logLoss_:RMt});function FMt(t,e,n,s=Er.SUM_BY_NONZERO_WEIGHTS){const r=ne(t,"labels","meanSquaredError"),o=ne(e,"predictions","meanSquaredError");let a=null;n!=null&&(a=ne(n,"weights","meanSquaredError")),Br(r.shape,o.shape,"Error in meanSquaredError: ");const i=LE(r,o);return su(i,a,s)}const MMt=Ce({meanSquaredError_:FMt});function PMt(t,e){const n=ne(t,"labels","sigmoidCrossEntropyWithLogits"),s=ne(e,"logits","sigmoidCrossEntropyWithLogits");Br(n.shape,s.shape,"Error in sigmoidCrossEntropyWithLogits: ");const r=V2(s),o=gt(s,n),a=wE(rc(Pi(co(s))));return Wt(rn(r,o),a)}function LMt(t,e,n,s=0,r=Er.SUM_BY_NONZERO_WEIGHTS){let o=ne(t,"multiClassLabels","sigmoidCrossEntropy");const a=ne(e,"logits","sigmoidCrossEntropy");let i=null;if(n!=null&&(i=ne(n,"weights","sigmoidCrossEntropy")),Br(o.shape,a.shape,"Error in sigmoidCrossEntropy: "),s>0){const u=an(s),c=an(1),d=an(.5);o=Wt(gt(o,rn(c,u)),gt(d,u))}const l=PMt(o,a);return su(l,i,r)}const zMt=Ce({sigmoidCrossEntropy_:LMt});function BMt(t,e,n=-1){if(n===-1&&(n=e.rank-1),n!==e.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${e.rank} and dim was ${n}`);return qi((r,o,a)=>{const l=$E(o,[n],!0),u=rn(es(o,"float32"),l);a([r,u]);const c=Pi(gt(u,r));return{value:Wn(c,[n]),gradFunc:(h,p)=>{const[m,g]=p,y=L2(h.shape,[n]);return[gt(Ze(h,y),rn(es(m,"float32"),rc(g))),gt(Ze(h,y),rn(rc(g),es(m,"float32")))]}}})(t,e)}function VMt(t,e,n,s=0,r=Er.SUM_BY_NONZERO_WEIGHTS){let o=ne(t,"onehotLabels","softmaxCrossEntropy");const a=ne(e,"logits","softmaxCrossEntropy");let i=null;if(n!=null&&(i=ne(n,"weights","softmaxCrossEntropy")),Br(o.shape,a.shape,"Error in softmaxCrossEntropy: "),s>0){const u=an(s),c=an(1),d=an(o.shape[1]);o=Wt(gt(o,rn(c,u)),En(u,d))}const l=BMt(o,a);return su(l,i,r)}const HMt=Ce({softmaxCrossEntropy_:VMt});function WMt(t,e,n,s){const r=ne(t,"indices","sparseFillEmptyRows","int32"),o=ne(e,"values","sparseFillEmptyRows"),a=ne(n,"denseShape","sparseFillEmptyRows","int32"),i=ne(s,"defaultValue","sparseFillEmptyRows",o.dtype);if(r.rank!==2)throw new Error(`Indices should be Tensor2D but received shape
        ${r.shape}`);if(o.rank!==1)throw new Error(`Values should be Tensor1D but received shape ${o.shape}`);if(a.rank!==1)throw new Error(`Dense shape should be Tensor1D but received shape ${a.shape}`);if(i.rank!==0)throw new Error(`Default value should be a scalar but received shape ${i.shape}`);const l={indices:r,values:o,denseShape:a,defaultValue:i},u=ke.runKernel(iX,l);return{outputIndices:u[0],outputValues:u[1],emptyRowIndicator:u[2],reverseIndexMap:u[3]}}const UMt=Ce({sparseFillEmptyRows_:WMt});function GMt(t,e,n){const s=ne(t,"inputIndices","sparseReshape","int32"),r=ne(e,"inputShape","sparseReshape","int32"),o=ne(n,"newShape","sparseReshape","int32");if(s.rank!==2)throw new Error(`Input indices should be Tensor2D but received shape
        ${s.shape}`);if(r.rank!==1)throw new Error(`Input shape should be Tensor1D but received shape ${r.shape}`);if(o.rank!==1)throw new Error(`New shape should be Tensor1D but received shape ${o.shape}`);const a={inputIndices:s,inputShape:r,newShape:o},i=ke.runKernel(lX,a);return{outputIndices:i[0],outputShape:i[1]}}const jMt=Ce({sparseReshape_:GMt});function KMt(t,e,n){const s=ne(t,"data","sparseSegmentMean"),r=ne(e,"indices","sparseSegmentMean","int32"),o=ne(n,"segmentIds","sparseSegmentMean","int32");if(s.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
          ${r.shape}`);if(o.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
          ${o.shape}`);const a={data:s,indices:r,segmentIds:o};return ke.runKernel(uX,a)}const qMt=Ce({sparseSegmentMean_:KMt});function XMt(t,e,n){const s=ne(t,"data","sparseSegmentSum"),r=ne(e,"indices","sparseSegmentSum","int32"),o=ne(n,"segmentIds","sparseSegmentSum","int32");if(s.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
         ${r.shape}`);if(o.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
         ${o.shape}`);const a={data:s,indices:r,segmentIds:o};return ke.runKernel(cX,a)}const YMt=Ce({sparseSegmentSum_:XMt});function ZMt(t,e,n,s,r,o,a,i){const l=ne(t,"data","stringNGrams","string");if(l.dtype!=="string")throw new Error("Data must be of datatype string");if(l.shape.length!==1)throw new Error(`Data must be a vector, saw: ${l.shape}`);const u=ne(e,"dataSplits","stringNGrams");if(u.dtype!=="int32")throw new Error("Data splits must be of datatype int32");const c={separator:n,nGramWidths:s,leftPad:r,rightPad:o,padWidth:a,preserveShortSequences:i},d={data:l,dataSplits:u},f=ke.runKernel(pX,d,c);return{nGrams:f[0],nGramsSplits:f[1]}}const JMt=Ce({stringNGrams_:ZMt});function QMt(t,e,n=!0){const s=ne(t,"input","stringSplit","string"),r=ne(e,"delimiter","stringSplit","string");if(s.rank!==1)throw new Error(`Input should be Tensor1D but received shape ${s.shape}`);if(r.rank!==0)throw new Error(`Delimiter should be a scalar but received shape ${r.shape}`);const o={skipEmpty:n},a={input:s,delimiter:r},i=ke.runKernel(mX,a,o);return{indices:i[0],values:i[1],shape:i[2]}}const ePt=Ce({stringSplit_:QMt});function tPt(t,e){const n=ne(t,"input","stringToHashBucketFast","string"),s={numBuckets:e};if(e<=0)throw new Error("Number of buckets must be at least 1");const r={input:n};return ke.runKernel(gX,r,s)}const nPt=Ce({stringToHashBucketFast_:tPt});const NJ={fft:f4,ifft:_g,rfft:h4,irfft:PE},IJ={hammingWindow:OFt,hannWindow:xJ,frame:SJ,stft:MFt},WE={flipLeftRight:BFt,grayscaleToRGB:HFt,resizeNearestNeighbor:fMt,resizeBilinear:cMt,rotateWithOffset:UFt,cropAndResize:LFt,nonMaxSuppression:jFt,nonMaxSuppressionAsync:eMt,nonMaxSuppressionWithScore:nMt,nonMaxSuppressionWithScoreAsync:rMt,nonMaxSuppressionPadded:aMt,nonMaxSuppressionPaddedAsync:lMt,threshold:mMt,transform:vMt},EJ={bandPart:bMt,gramSchmidt:_Mt,qr:xMt},AJ={absoluteDifference:kMt,computeWeightedLoss:su,cosineDistance:NMt,hingeLoss:EMt,huberLoss:OMt,logLoss:DMt,meanSquaredError:MMt,sigmoidCrossEntropy:zMt,softmaxCrossEntropy:HMt},OJ={sparseFillEmptyRows:UMt,sparseReshape:jMt,sparseSegmentMean:qMt,sparseSegmentSum:YMt},RJ={stringNGrams:JMt,stringSplit:ePt,stringToHashBucketFast:nPt};class $c extends hY{minimize(e,n=!1,s){const{value:r,grads:o}=this.computeGradients(e,s);if(s!=null){const a=s.map(i=>({name:i.name,tensor:o[i.name]}));this.applyGradients(a)}else this.applyGradients(o);return qr(o),n?r:(r.dispose(),null)}get iterations(){return this.iterations_==null&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(e,n){return mZ(e,n)}dispose(){this.iterations_!=null&&qr(this.iterations_)}async saveIterations(){return this.iterations_==null&&(this.iterations_=0),{name:"iter",tensor:an(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(e){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(e){return this.iterations_=(await e[0].tensor.data())[0],e.slice(1)}}Object.defineProperty($c,Symbol.hasInstance,{value:t=>t.minimize!=null&&t.computeGradients!=null&&t.applyGradients!=null});class b4 extends $c{constructor(e,n,s=null){super(),this.learningRate=e,this.rho=n,this.epsilon=s,this.accumulatedGrads=[],this.accumulatedUpdates=[],s==null&&(this.epsilon=ke.backend.epsilon())}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,r)=>{const o=ke.registeredVariables[s],a=!1;this.accumulatedGrads[r]==null&&(this.accumulatedGrads[r]={originalName:`${s}/accum_grad`,variable:vn(()=>bo(o).variable(a))}),this.accumulatedUpdates[r]==null&&(this.accumulatedUpdates[r]={originalName:`${s}/accum_var`,variable:vn(()=>bo(o).variable(a))});const i=Array.isArray(e)?e[r].tensor:e[s];if(i==null)return;const l=this.accumulatedGrads[r].variable,u=this.accumulatedUpdates[r].variable;vn(()=>{const c=Wt(gt(l,this.rho),gt(ba(i),1-this.rho)),d=gt(En(Ki(Wt(u,this.epsilon)),Ki(Wt(l,this.epsilon))),i),f=Wt(gt(u,this.rho),gt(ba(d),1-this.rho));l.assign(c),u.assign(f);const h=Wt(gt(d,-this.learningRate),o);o.assign(h)})}),this.incrementIterations()}dispose(){this.accumulatedUpdates!=null&&(qr(this.accumulatedGrads.map(e=>e.variable)),qr(this.accumulatedUpdates.map(e=>e.variable)))}async getWeights(){const e=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(e.map(n=>({name:n.originalName,tensor:n.variable})))}async setWeights(e){e=await this.extractIterations(e);const n=e.length/2,s=!1;this.accumulatedGrads=e.slice(0,n).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})),this.accumulatedUpdates=e.slice(n,n*2).map(r=>({originalName:r.name,variable:r.tensor.variable(s)}))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(e,n){return new e(n.learningRate,n.rho,n.epsilon)}}b4.className="Adadelta";wc(b4);class w4 extends $c{constructor(e,n=.1){super(),this.learningRate=e,this.initialAccumulatorValue=n,this.accumulatedGrads=[]}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,r)=>{const o=ke.registeredVariables[s];this.accumulatedGrads[r]==null&&(this.accumulatedGrads[r]={originalName:`${s}/accumulator`,variable:vn(()=>_m(o.shape,this.initialAccumulatorValue).variable(!1))});const a=Array.isArray(e)?e[r].tensor:e[s];if(a==null)return;const i=this.accumulatedGrads[r].variable;vn(()=>{const l=Wt(i,ba(a));i.assign(l);const u=Wt(gt(En(a,Ki(Wt(l,ke.backend.epsilon()))),-this.learningRate),o);o.assign(u)})}),this.incrementIterations()}dispose(){this.accumulatedGrads!=null&&qr(this.accumulatedGrads.map(e=>e.variable))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);const n=!1;this.accumulatedGrads=e.map(s=>({originalName:s.name,variable:s.tensor.variable(n)}))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(e,n){return new e(n.learningRate,n.initialAccumulatorValue)}}w4.className="Adagrad";wc(w4);class _4 extends $c{constructor(e,n,s,r=null){super(),this.learningRate=e,this.beta1=n,this.beta2=s,this.epsilon=r,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],vn(()=>{this.accBeta1=an(n).variable(),this.accBeta2=an(s).variable()}),r==null&&(this.epsilon=ke.backend.epsilon())}applyGradients(e){const n=Array.isArray(e)?e.map(s=>s.name):Object.keys(e);vn(()=>{const s=rn(1,this.accBeta1),r=rn(1,this.accBeta2);n.forEach((o,a)=>{const i=ke.registeredVariables[o],l=!1;this.accumulatedFirstMoment[a]==null&&(this.accumulatedFirstMoment[a]={originalName:`${o}/m`,variable:vn(()=>bo(i).variable(l))}),this.accumulatedSecondMoment[a]==null&&(this.accumulatedSecondMoment[a]={originalName:`${o}/v`,variable:vn(()=>bo(i).variable(l))});const u=Array.isArray(e)?e[a].tensor:e[o];if(u==null)return;const c=this.accumulatedFirstMoment[a].variable,d=this.accumulatedSecondMoment[a].variable,f=Wt(gt(c,this.beta1),gt(u,1-this.beta1)),h=Wt(gt(d,this.beta2),gt(ba(u),1-this.beta2)),p=En(f,s),m=En(h,r);c.assign(f),d.assign(h);const g=Wt(gt(En(p,Wt(Ki(m),this.epsilon)),-this.learningRate),i);i.assign(g)}),this.accBeta1.assign(gt(this.accBeta1,this.beta1)),this.accBeta2.assign(gt(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),this.accumulatedFirstMoment!=null&&qr(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedSecondMoment!=null&&qr(this.accumulatedSecondMoment.map(e=>e.variable))}async getWeights(){const e=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(e.map(n=>({name:n.originalName,tensor:n.variable})))}async setWeights(e){e=await this.extractIterations(e),vn(()=>{this.accBeta1.assign(Wh(this.beta1,this.iterations_+1)),this.accBeta2.assign(Wh(this.beta2,this.iterations_+1))});const n=e.length/2,s=!1;this.accumulatedFirstMoment=e.slice(0,n).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})),this.accumulatedSecondMoment=e.slice(n,n*2).map(r=>({originalName:r.name,variable:r.tensor.variable(s)}))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(e,n){return new e(n.learningRate,n.beta1,n.beta2,n.epsilon)}}_4.className="Adam";wc(_4);class $4 extends $c{constructor(e,n,s,r=null,o=0){super(),this.learningRate=e,this.beta1=n,this.beta2=s,this.epsilon=r,this.decay=o,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],vn(()=>{this.iteration=an(0).variable(),this.accBeta1=an(n).variable()}),r==null&&(this.epsilon=ke.backend.epsilon())}applyGradients(e){const n=Array.isArray(e)?e.map(s=>s.name):Object.keys(e);vn(()=>{const s=rn(1,this.accBeta1),r=En(-this.learningRate,Wt(gt(this.iteration,this.decay),1));n.forEach((o,a)=>{const i=ke.registeredVariables[o],l=!1;this.accumulatedFirstMoment[a]==null&&(this.accumulatedFirstMoment[a]={originalName:`${o}/m`,variable:bo(i).variable(l)}),this.accumulatedWeightedInfNorm[a]==null&&(this.accumulatedWeightedInfNorm[a]={originalName:`${o}/v`,variable:bo(i).variable(l)});const u=Array.isArray(e)?e[a].tensor:e[o];if(u==null)return;const c=this.accumulatedFirstMoment[a].variable,d=this.accumulatedWeightedInfNorm[a].variable,f=Wt(gt(c,this.beta1),gt(u,1-this.beta1)),h=gt(d,this.beta2),p=co(u),m=kE(h,p);c.assign(f),d.assign(m);const g=Wt(gt(En(r,s),En(f,Wt(m,this.epsilon))),i);i.assign(g)}),this.iteration.assign(Wt(this.iteration,1)),this.accBeta1.assign(gt(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),this.accumulatedFirstMoment!=null&&qr(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedWeightedInfNorm!=null&&qr(this.accumulatedWeightedInfNorm.map(e=>e.variable))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(e){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(e,n){return new e(n.learningRate,n.beta1,n.beta2,n.epsilon,n.decay)}}$4.className="Adamax";wc($4);class W2 extends $c{constructor(e){super(),this.learningRate=e,this.setLearningRate(e)}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,r)=>{const o=Array.isArray(e)?e[r].tensor:e[s];if(o==null)return;const a=ke.registeredVariables[s];vn(()=>{const i=Wt(gt(this.c,o),a);a.assign(i)})}),this.incrementIterations()}setLearningRate(e){this.learningRate=e,this.c!=null&&this.c.dispose(),this.c=Ii(an(-e))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(e){if(e=await this.extractIterations(e),e.length!==0)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(e,n){return new e(n.learningRate)}}W2.className="SGD";wc(W2);class x4 extends W2{constructor(e,n,s=!1){super(e),this.learningRate=e,this.momentum=n,this.useNesterov=s,this.accumulations=[],this.m=an(this.momentum)}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,r)=>{const o=ke.registeredVariables[s];this.accumulations[r]==null&&(this.accumulations[r]={originalName:`${s}/momentum`,variable:vn(()=>bo(o).variable(!1))});const a=this.accumulations[r].variable,i=Array.isArray(e)?e[r].tensor:e[s];i!=null&&vn(()=>{let l;const u=Wt(gt(this.m,a),i);this.useNesterov?l=Wt(gt(this.c,Wt(i,gt(u,this.m))),o):l=Wt(gt(this.c,u),o),a.assign(u),o.assign(l)})}),this.incrementIterations()}dispose(){this.m.dispose(),this.accumulations!=null&&qr(this.accumulations.map(e=>e.variable))}setMomentum(e){this.momentum=e}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);const n=!1;this.accumulations=e.map(s=>({originalName:s.name,variable:s.tensor.variable(n)}))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(e,n){return new e(n.learningRate,n.momentum,n.useNesterov)}}x4.className="Momentum";wc(x4);class S4 extends $c{constructor(e,n=.9,s=0,r=null,o=!1){if(super(),this.learningRate=e,this.decay=n,this.momentum=s,this.epsilon=r,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=o,r==null&&(this.epsilon=ke.backend.epsilon()),e==null)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,r)=>{const o=ke.registeredVariables[s],a=!1;this.accumulatedMeanSquares[r]==null&&(this.accumulatedMeanSquares[r]={originalName:`${s}/rms`,variable:vn(()=>bo(o).variable(a))}),this.accumulatedMoments[r]==null&&(this.accumulatedMoments[r]={originalName:`${s}/momentum`,variable:vn(()=>bo(o).variable(a))}),this.accumulatedMeanGrads[r]==null&&this.centered&&(this.accumulatedMeanGrads[r]={originalName:`${s}/mg`,variable:vn(()=>bo(o).variable(a))});const i=Array.isArray(e)?e[r].tensor:e[s];if(i==null)return;const l=this.accumulatedMeanSquares[r].variable,u=this.accumulatedMoments[r].variable;vn(()=>{const c=Wt(gt(l,this.decay),gt(ba(i),1-this.decay));if(this.centered){const d=this.accumulatedMeanGrads[r].variable,f=Wt(gt(d,this.decay),gt(i,1-this.decay)),h=En(gt(i,this.learningRate),Ki(rn(c,Wt(ba(f),this.epsilon)))),p=Wt(gt(u,this.momentum),h);l.assign(c),d.assign(f),u.assign(p);const m=rn(o,p);o.assign(m)}else{const d=Wt(gt(l,this.decay),gt(ba(i),1-this.decay)),f=Wt(gt(u,this.momentum),En(gt(i,this.learningRate),Ki(Wt(d,this.epsilon))));l.assign(d),u.assign(f);const h=rn(o,f);o.assign(h)}})}),this.incrementIterations()}dispose(){this.accumulatedMeanSquares!=null&&qr(this.accumulatedMeanSquares.map(e=>e.variable)),this.accumulatedMeanGrads!=null&&this.centered&&qr(this.accumulatedMeanGrads.map(e=>e.variable)),this.accumulatedMoments!=null&&qr(this.accumulatedMoments.map(e=>e.variable))}async getWeights(){const e=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&e.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(e.map(n=>({name:n.originalName,tensor:n.variable})))}async setWeights(e){e=await this.extractIterations(e);const n=this.centered?e.length/3:e.length/2,s=!1;this.accumulatedMeanSquares=e.slice(0,n).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})),this.accumulatedMoments=e.slice(n,n*2).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})),this.centered&&(this.accumulatedMeanGrads=e.slice(n*2,n*3).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(e,n){return new e(n.learningRate,n.decay,n.momentum,n.epsilon,n.centered)}}S4.className="RMSProp";wc(S4);class gu{static sgd(e){return new W2(e)}static momentum(e,n,s=!1){return new x4(e,n,s)}static rmsprop(e,n=.9,s=0,r=null,o=!1){return new S4(e,n,s,r,o)}static adam(e=.001,n=.9,s=.999,r=null){return new _4(e,n,s,r)}static adadelta(e=.001,n=.95,s=null){return new b4(e,n,s)}static adamax(e=.002,n=.9,s=.999,r=null,o=0){return new $4(e,n,s,r,o)}static adagrad(e,n=.1){return new w4(e,n)}}const sPt={sgd:gu.sgd,momentum:gu.momentum,adadelta:gu.adadelta,adagrad:gu.adagrad,rmsprop:gu.rmsprop,adamax:gu.adamax,adam:gu.adam};const rPt=(()=>typeof requestAnimationFrame<"u"?requestAnimationFrame:typeof setImmediate<"u"?setImmediate:t=>t())();function oPt(){return new Promise(t=>rPt(()=>t()))}function aPt(t,e){const n=t[0].length;t.forEach((r,o)=>{le(r.length===n,()=>`Error in concat${n}D: rank of tensors[${o}] must be the same as the rank of the rest (${n})`)}),le(e>=0&&e<n,()=>`Error in concat${n}D: axis must be between 0 and ${n-1}.`);const s=t[0];t.forEach((r,o)=>{for(let a=0;a<n;a++)le(a===e||r[a]===s[a],()=>`Error in concat${n}D: Shape of tensors[${o}] (${r}) does not match the shape of the rest (${s}) along the non-concatenated axis ${o}.`)})}function iPt(t,e){const n=t[0].slice();for(let s=1;s<t.length;s++)n[e]+=t[s][e];return n}var yi;(function(t){t[t.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",t[t.VALUE_ROWIDS=1]="VALUE_ROWIDS",t[t.ROW_LENGTHS=2]="ROW_LENGTHS",t[t.ROW_SPLITS=3]="ROW_SPLITS",t[t.ROW_LIMITS=4]="ROW_LIMITS",t[t.ROW_STARTS=5]="ROW_STARTS"})(yi||(yi={}));function lPt(t,e,n){let s=new Array;if(n==null&&e==null)return s;if(e==null)for(;s.length<t+n.length;)s.push(-1);else s=e.slice();if(n==null)return s;if(t+n.length!==s.length)throw new Error(`rt input.shape and shape=${e} are incompatible: rt input.rank = ${t+n.length}, but shape.rank = ${s.length}`);for(let r=1;r<n.length;++r){const o=n[r],a=s[s.length-n.length+r],i=s[a];if(o>=0)if(i>=0){if(i!==o)throw new Error(`rt input.shape and shape=${e} are incompatible: rt input.shape[${r+t}] = ${o} but shape[${r+t}] = ${i}`)}else s[a]=o}return s}function uPt(t){const e={FIRST_DIM_SIZE:yi.FIRST_DIM_SIZE,VALUE_ROWIDS:yi.VALUE_ROWIDS,ROW_LENGTHS:yi.ROW_LENGTHS,ROW_SPLITS:yi.ROW_SPLITS,ROW_LIMITS:yi.ROW_LIMITS,ROW_STARTS:yi.ROW_STARTS},n=[];for(const s of t)if(s in e)n.push(e[s]);else break;return n}function cPt(t){return t.length===0?0:t[0]===yi.FIRST_DIM_SIZE?t.length-1:t.length}function dPt(t,e){if(t==null||e==null)return;const n=t.length,s=e.length;if(n>=s)throw new Error(`defaultValue.shape=${t} and ragged tensor flatValues.shape=${e}, are incompatible: defaultValue.rank = ${n} must be less than ragged tensor input flatValues.rank = ${s})`);for(let r=0;r<Math.min(n,s-1);++r){const o=t[r],a=e[r+1];if(o>=0&&a>=0&&o!==1&&o!==a)throw new Error(`defaultValue.shape=${t}, and ragged tensor input flatValues.shape=${e} are incompatible: defaultValue.shape[${r-t.length}] = ${o} but ragged tensor input.flatValues.shape[${r-t.length}] = ${a}`)}}const UE=30;function fPt(t){return t<=UE?t:Tb(t,Math.floor(Math.sqrt(t)))}function hPt(t,e,n){const s=n*(typeof t=="number"?t:t[0]),r=e*(typeof t=="number"?t:t[1]);return[s,r]}function pPt(t,e,n,s=!0){let r=[];if(s)r=r.concat(e.slice(0)),r.push(t[0]/n),r=r.concat(t.slice(1));else{r=r.concat(t[0]);const o=e.length;for(let a=0;a<o;++a)r=r.concat([t[a+1]/e[a],e[a]]);r=r.concat(t.slice(o+1))}return r}function mPt(t,e,n=!0){const s=[];if(n){s.push(e);for(let r=e+1;r<t;++r)r<=2*e?(s.push(r),s.push(r-(e+1))):s.push(r)}else{const r=[],o=[];for(let a=1;a<t;++a)a>=e*2+1||a%2===1?o.push(a):r.push(a);s.push(...r),s.push(0),s.push(...o)}return s}function gPt(t,e,n,s=!0){const r=[];s?r.push(t[0]/n):r.push(t[0]*n);for(let o=1;o<t.length;++o)o<=e.length?s?r.push(e[o-1]*t[o]):r.push(t[o]/e[o-1]):r.push(t[o]);return r}function vPt(t,e){const n=[0];for(let s=0;s<e;++s)n.push(t[s][0]);return n}function yPt(t,e,n){const s=t.slice(0,1);for(let r=0;r<n;++r)s.push(t[r+1]-e[r][0]-e[r][1]);return s}const bPt=1.7580993408473768,wPt=1.0507009873554805;const _Pt=.3275911,$Pt=.254829592,xPt=-.284496736,SPt=1.421413741,CPt=-1.453152027,kPt=1.061405429;function TPt(t,e){if(t.length!==e.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${t.length}, imag: ${e.length}.`);const n=new Float32Array(t.length*2);for(let s=0;s<n.length;s+=2)n[s]=t[s/2],n[s+1]=e[s/2];return n}function NPt(t){const e=new Float32Array(t.length/2),n=new Float32Array(t.length/2);for(let s=0;s<t.length;s+=2)e[s/2]=t[s],n[s/2]=t[s+1];return{real:e,imag:n}}function IPt(t){const e=Math.ceil(t.length/4),n=new Float32Array(e),s=new Float32Array(e);for(let r=0;r<t.length;r+=4)n[Math.floor(r/4)]=t[r],s[Math.floor(r/4)]=t[r+1];return{real:n,imag:s}}function EPt(t){const e=Math.floor(t.length/4),n=new Float32Array(e),s=new Float32Array(e);for(let r=2;r<t.length;r+=4)n[Math.floor(r/4)]=t[r],s[Math.floor(r/4)]=t[r+1];return{real:n,imag:s}}function APt(t,e){const n=t[e*2],s=t[e*2+1];return{real:n,imag:s}}function OPt(t,e,n,s){t[s*2]=e,t[s*2+1]=n}function RPt(t,e){const n=new Float32Array(t/2),s=new Float32Array(t/2);for(let r=0;r<Math.ceil(t/2);r++){const o=(e?2:-2)*Math.PI*(r/t);n[r]=Math.cos(o),s[r]=Math.sin(o)}return{real:n,imag:s}}function DPt(t,e,n){const s=(n?2:-2)*Math.PI*(t/e),r=Math.cos(s),o=Math.sin(s);return{real:r,imag:o}}const L$="->",FPt=/->/g,E9=",",A9="...";function MPt(t,e){t=t.replace(/\s/g,"");const n=(t.length-t.replace(FPt,"").length)/L$.length;if(n<1)throw new Error("Equations without an arrow are not supported.");if(n>1)throw new Error(`Equation must contain exactly one arrow ("${L$}").`);const[s,r]=t.split(L$);le(s.indexOf(A9)===-1,()=>`The ellipsis notation ("${A9}") is not supported yet.`);const o=s.split(E9),a=o.length;if(e!==a)throw new Error(`Expected ${a} input tensors, received ${e}`);if(a>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const i=[];for(let f=0;f<r.length;++f){const h=r[f];if(!o.some(p=>p.indexOf(h)!==-1))throw new Error(`Output subscripts contain the label ${h} not present in the input subscripts.`);i.indexOf(h)===-1&&i.push(h)}for(let f=0;f<s.length;++f){const h=s[f];i.indexOf(h)===-1&&h!==E9&&i.push(h)}const l=new Array(o.length);for(let f=0;f<a;++f){if(new Set(o[f].split("")).size!==o[f].length)throw new Error(`Found duplicate axes in input component ${o[f]}. Support for duplicate axes in input is not implemented yet.`);l[f]=[];for(let h=0;h<o[f].length;++h)l[f].push(i.indexOf(o[f][h]))}const u=i.length,c=r.length,d=[];for(let f=c;f<u;++f)d.push(f);return{allDims:i,summedDims:d,idDims:l}}function PPt(t,e){let n=new Array(t);n.fill(-1);for(let r=0;r<e.length;++r)n[e[r]]=r;const s=[];for(let r=0;r<t;++r)n[r]===-1&&s.push(r);return n=n.filter(r=>r!==-1),{permutationIndices:n,expandDims:s}}function LPt(t,e,n){const s=new Array(t);for(let r=0;r<n.length;++r){const o=n[r].shape;for(let a=0;a<e[r].length;++a)s[e[r][a]]===void 0?s[e[r][a]]=o[a]:le(s[e[r][a]]===o[a],()=>`Expected dimension ${s[e[r][a]]} at axis ${a} of input shaped ${JSON.stringify(o)}, but got dimension ${o[a]}`)}}function zPt(t,e){const n=t,s=[];let r=0;t.length===0&&n.push(-1),r=t.length+1;for(let a=0;a<r;++a)s.push([]);const o=[];for(let a=0;a<n.length;++a){const i=n[a],l=VPt(e,i);for(const u of l)o.indexOf(u)===-1&&(s[a].push(u),o.push(u))}return{path:n,steps:s}}function BPt(t){return t.every((e,n)=>e===n)}function VPt(t,e){const n=[];for(let s=0;s<t.length;++s)(t[s].length===0||t[s].indexOf(e)!==-1||e===-1)&&n.push(s);return n}function HPt(t,e,n=0){let s=[];if(typeof e=="number")le(t.shape[n]%e===0,()=>"Number of splits must evenly divide the axis."),s=new Array(e).fill(t.shape[n]/e);else{const r=e.reduce((a,i)=>(i===-1&&(a+=1),a),0);le(r<=1,()=>"There should be only one negative value in split array.");const o=e.indexOf(-1);if(o!==-1){const a=e.reduce((i,l)=>l>0?i+l:i);e[o]=t.shape[n]-a}le(t.shape[n]===e.reduce((a,i)=>a+i),()=>"The sum of sizes must match the size of the axis dimension."),s=e}return s}function WPt(t){return`Received SparseTensor with denseShape[0] = 0 but
  indices.shape[0] = ${t}`}function UPt(t,e){return`indices(${t}, 0) is invalid: ${e} < 0`}function GPt(t,e,n){return`indices(${t}, 0) is invalid: ${e} >= ${n}`}function jPt(t,e){return`only one output dimension may be -1, not both ${t} and ${e}`}function KPt(t,e){return`size ${t} must be non-negative, not ${e}`}function qPt(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function XPt(t,e){const n=Qn(t),s=Qn(e);return`Input to reshape is a SparseTensor with ${n}
  dense values, but the requested shape requires a multiple of ${s}. inputShape=${t} outputShape= ${e}`}function YPt(t,e){const n=Qn(t),s=Qn(e);return`Input to reshape is a tensor with ${n} dense values, but the requested shape has ${s}. inputShape=${t} outputShape=${e}`}function ZPt(){return"segment ids must be >= 0"}function JPt(){return"segment ids are not increasing"}function QPt(t,e){return`Segment id ${t} out of range [0, ${e}), possibly because segmentIds input is not sorted.`}function eLt(t,e,n){return`Bad: indices[${t}] == ${e} out of range [0, ${n})`}function tLt(t,e){let n=!1,s;for(t<=UE?(s=t,n=!0):s=Tb(t,Math.floor(Math.sqrt(t)));!n;)s>e||s===t?n=!0:s=Tb(t,s+1);return s}function nLt(t,e,n){const s=[],r=t.length;for(let o=0;o<r;o++)o!==e?s.push(t[o]):s.push(n);return s}function sLt(t,e,n,s){const r=e.shape.length,o=t.shape.length;if(s!==0&&(s<-r||s>r))throw new Error(`Expect batchDims in the range of [-${r}, ${r}], but got ${s}`);if(s<0&&(s+=r),s>o)throw new Error(`batchDims (${s}) must be less than rank(x) (
    ${o}).`);if(n<s)throw new Error(`batchDims (${s}) must be less than or equal to axis (${n}).`);for(let d=0;d<s;++d)if(t.shape[d]!==e.shape[d])throw new Error(`x.shape[${d}]: ${t.shape[d]} should be equal to indices.shape[${d}]: ${e.shape[d]}.`);const a=t.shape[n],i=[];let l=1,u=1,c=1;for(let d=0;d<s;++d)i.push(t.shape[d]),l*=t.shape[d];for(let d=s;d<n;d++)i.push(t.shape[d]),u*=t.shape[d];for(let d=s;d<r;d++)i.push(e.shape[d]);for(let d=n+1;d<o;d++)i.push(t.shape[d]),c*=t.shape[d];return{batchSize:l,sliceSize:c,outerSize:u,dimSize:a,outputShape:i}}const rLt=Object.freeze(Object.defineProperty({__proto__:null,segOpComputeOptimalWindowSize:tLt,computeOutShape:nLt,collectGatherOpShapeInfo:sLt},Symbol.toStringTag,{value:"Module"}));function oLt(t){try{return t.map(e=>Eb(e))}catch(e){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${e}`)}}function aLt(t){return t.map(e=>O2(e))}const iLt=Object.freeze(Object.defineProperty({__proto__:null,slice_util:fY,segment_util:rLt,fromUint8ToStringArray:oLt,fromStringArrayToUint8:aLt,upcastType:i4,axesAreInnerMostDims:pE,combineLocations:oZ,computeOutAndReduceShapes:tDt,expandShapeToKeepDim:L2,assertAxesAreInnerMostDims:nDt,getAxesPermutation:sDt,getUndoAxesPermutation:rDt,getInnerMostAxes:oDt,getBroadcastDims:QX,getReductionAxes:eE,assertAndGetBroadcastShape:Ns,assertParamsConsistent:aPt,computeOutShape:iPt,computeDilation2DInfo:tRt,computePool2DInfo:TY,computePool3DInfo:nRt,computeConv2DInfo:F2,computeConv3DInfo:NY,computeDefaultPad:lE,tupleValuesAreOne:yg,eitherStridesOrDilationsAreOne:nu,convertConv2DDataFormat:IY,checkPadOnDimRoundingMode:Aa,getFusedDyActivation:m4,getFusedBiasGradient:g4,applyActivation:v4,shouldFuse:y4,get RowPartitionType(){return yi},combineRaggedTensorToTensorShapes:lPt,getRowPartitionTypesHelper:uPt,getRaggedRank:cPt,validateDefaultValueShape:dPt,PARALLELIZE_THRESHOLD:UE,computeOptimalWindowSize:fPt,getImageCenter:hPt,getReshaped:pPt,getPermuted:mPt,getReshapedPermuted:gPt,getSliceBeginCoords:vPt,getSliceSize:yPt,prepareAndValidate:nY,validateUpdateShape:nE,validateInput:sE,calculateShapes:sY,SELU_SCALEALPHA:bPt,SELU_SCALE:wPt,ERF_P:_Pt,ERF_A1:$Pt,ERF_A2:xPt,ERF_A3:SPt,ERF_A4:CPt,ERF_A5:kPt,warn:_u,log:n5t,mergeRealAndImagArrays:TPt,splitRealAndImagArrays:NPt,complexWithEvenIndex:IPt,complexWithOddIndex:EPt,getComplexWithIndex:APt,assignToTypedArray:OPt,exponents:RPt,exponent:DPt,decodeEinsumEquation:MPt,getEinsumPermutation:PPt,checkEinsumDimSizes:LPt,getEinsumComputePath:zPt,isIdentityPermutation:BPt,prepareSplitSize:HPt,getSparseFillEmptyRowsIndicesDenseShapeMismatch:WPt,getSparseFillEmptyRowsNegativeIndexErrorMessage:UPt,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:GPt,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:jPt,getSparseReshapeNegativeOutputDimErrorMessage:KPt,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:qPt,getSparseReshapeInputOutputMultipleErrorMessage:XPt,getSparseReshapeInputOutputMismatchErrorMessage:YPt,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:ZPt,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:JPt,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:QPt,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:eLt},Symbol.toStringTag,{value:"Module"}));const lLt=Object.freeze(Object.defineProperty({__proto__:null,nonMaxSuppressionV3Impl:CJ,nonMaxSuppressionV4Impl:kJ,nonMaxSuppressionV5Impl:TJ,whereImpl:pJ},Symbol.toStringTag,{value:"Module"}));const GE=Object.freeze(Object.defineProperty({__proto__:null,AdadeltaOptimizer:b4,AdagradOptimizer:w4,AdamOptimizer:_4,AdamaxOptimizer:$4,MomentumOptimizer:x4,Optimizer:$c,OptimizerConstructors:gu,RMSPropOptimizer:S4,SGDOptimizer:W2,Tensor:os,TensorBuffer:Ab,Variable:mg,get Rank(){return uS},sumOutType:T5t,upcastType:i4,get Reduction(){return Er},customGrad:qi,grad:ODt,grads:RDt,valueAndGrad:DDt,valueAndGrads:FDt,variableGrads:mZ,Environment:Vj,env:en,get ENV(){return LI},nextFrame:oPt,KernelBackend:Ej,DataStorage:vEt,abs:co,acos:gY,acosh:vY,add:Wt,addN:yY,all:bY,any:wY,argMax:iE,argMin:_Y,asin:$Y,asinh:xY,atan:SY,atan2:CY,atanh:kY,avgPool:uE,avgPool3d:EY,basicLSTMCell:AY,batchToSpaceND:cE,batchNorm:M2,batchNorm2d:OY,batchNorm3d:RY,batchNorm4d:DY,bincount:dE,broadcastArgs:FY,broadcastTo:v0,buffer:ji,cast:es,ceil:MY,clipByValue:PY,clone:bl,complex:Dl,concat:sr,concat1d:LY,concat2d:zY,concat3d:BY,concat4d:VY,conv1d:HY,conv2d:P2,conv2dTranspose:UY,conv3d:GY,conv3dTranspose:jY,cos:KY,cosh:qY,cumprod:XY,cumsum:YY,denseBincount:ZY,depthToSpace:JY,depthwiseConv2d:l4,diag:QY,dilation2d:eZ,div:En,divNoNan:tZ,dot:nZ,einsum:sZ,elu:hE,equal:fE,erf:rZ,euclideanNorm:iZ,exp:rc,expandDims:Va,expm1:lZ,eye:mE,fill:_m,floor:gE,floorDiv:aE,gather:vE,greater:B2,greaterEqual:yE,imag:D2,isFinite:uZ,isInf:cZ,isNaN:dZ,leakyRelu:bE,less:fZ,lessEqual:u4,linspace:hZ,localResponseNormalization:pZ,log:Uh,log1p:wE,logSigmoid:gZ,logSoftmax:vZ,logSumExp:$E,logicalAnd:bg,logicalNot:xE,logicalOr:SE,logicalXor:yZ,lowerBound:bZ,matMul:Tn,max:md,maxPool:CE,maxPool3d:wZ,maxPoolWithArgmax:_Z,maximum:kE,mean:wg,meshgrid:$Z,min:Mb,minimum:TE,mirrorPad:xZ,mod:SZ,moments:CZ,mul:gt,multiRNNCell:kZ,multinomial:TZ,neg:Pi,notEqual:NE,oneHot:Rb,ones:Au,onesLike:NZ,outerProduct:IZ,pad:$m,pad1d:EZ,pad2d:AZ,pad3d:IE,pad4d:OZ,pool:RZ,pow:Wh,prelu:AE,print:YI,prod:DZ,raggedGather:FZ,raggedTensorToTensor:MZ,rand:PZ,randomGamma:LZ,randomNormal:RE,randomStandardNormal:zZ,randomUniform:DE,range:Gh,real:Hh,reciprocal:BZ,relu:V2,relu6:FE,reshape:Ze,reverse:oc,reverse1d:VZ,reverse2d:HZ,reverse3d:WZ,reverse4d:UZ,round:ME,rsqrt:GZ,scalar:an,selu:jZ,separableConv2d:KZ,setdiff1dAsync:qZ,sigmoid:Bu,sign:XZ,sin:YZ,sinh:ZZ,slice:Mn,slice1d:JZ,slice2d:QZ,slice3d:eJ,slice4d:tJ,softmax:nJ,softplus:_E,spaceToBatchND:EE,fft:f4,ifft:_g,irfft:PE,rfft:h4,split:jh,sqrt:Ki,square:ba,squaredDifference:LE,squeeze:H2,stack:Xi,step:zE,stridedSlice:sJ,sub:rn,sum:Wn,tan:rJ,tanh:Fb,tensor:Za,tensor1d:ga,tensor2d:gd,tensor3d:tE,tensor4d:oJ,tensor5d:aJ,tensor6d:iJ,tile:th,topk:lJ,truncatedNormal:uJ,unique:cJ,unsortedSegmentSum:dJ,unstack:_c,upperBound:fJ,variable:hJ,where:jd,whereAsync:BE,zeros:Kd,zerosLike:bo,op:Ce,OP_SCOPE_SUFFIX:jI,booleanMaskAsync:mJ,transpose:vg,norm:z2,movingAverage:gJ,scatterND:vJ,searchSorted:d4,sparseToDense:yJ,gatherND:bJ,dropout:wJ,enclosingPowerOfTwo:VE,cosineWindow:p4,inTopKAsync:_J,image:WE,linalg:EJ,losses:AJ,spectral:NJ,fused:$J,signal:IJ,sparse:OJ,string:RJ,train:sPt,enableProdMode:FAt,enableDebugMode:MAt,disableDeprecationWarnings:PAt,deprecationWarn:LAt,disposeVariables:zAt,engine:BAt,memory:VAt,profile:HAt,tidy:vn,dispose:qr,keep:Ii,time:WAt,setBackend:UAt,ready:GAt,getBackend:jAt,removeBackend:KAt,findBackend:qAt,findBackendFactory:XAt,registerBackend:YAt,backend:ZAt,setPlatform:JAt,getKernel:Nb,getGradient:iS,getKernelsForBackend:Ib,registerKernel:NX,registerGradient:s5t,unregisterKernel:r5t,unregisterGradient:o5t,copyRegisteredKernels:a5t,Abs:Wj,Acos:Uj,Acosh:Gj,Add:BI,AddN:jj,All:Kj,Any:qj,ArgMax:Xj,ArgMin:Yj,Asin:Zj,Asinh:Jj,Atan:Qj,Atanh:eK,Atan2:tK,AvgPool:nK,AvgPoolGrad:LEt,AvgPool3D:sK,AvgPool3DGrad:zEt,BatchMatMul:rK,BatchToSpaceND:oK,Bincount:aK,BroadcastTo:BEt,BroadcastArgs:iK,Cast:VI,Ceil:lK,ClipByValue:uK,Complex:cK,ComplexAbs:dK,Concat:fK,Conv2D:hK,Conv2DBackpropFilter:pK,Conv2DBackpropInput:mK,Conv3D:gK,Conv3DBackpropFilterV2:VEt,Conv3DBackpropInputV2:vK,Cos:yK,Cosh:bK,Cumprod:wK,Cumsum:_K,CropAndResize:$K,DenseBincount:xK,DepthToSpace:SK,DepthwiseConv2dNative:CK,DepthwiseConv2dNativeBackpropFilter:kK,DepthwiseConv2dNativeBackpropInput:TK,Diag:NK,Dilation2D:IK,Dilation2DBackpropInput:HEt,Dilation2DBackpropFilter:WEt,RealDiv:EK,Einsum:AK,Elu:OK,EluGrad:UEt,Erf:RK,Equal:DK,Exp:FK,ExpandDims:MK,Expm1:PK,FFT:LK,Fill:zK,FlipLeftRight:BK,Floor:VK,FloorDiv:HK,FusedBatchNorm:WK,GatherV2:UK,GatherNd:GK,Greater:jK,GreaterEqual:KK,Identity:HI,IFFT:qK,Imag:XK,IsFinite:YK,IsInf:ZK,IsNan:JK,LeakyRelu:QK,Less:eq,LessEqual:tq,LinSpace:nq,Log:sq,Log1p:rq,LogicalAnd:oq,LogicalNot:aq,LogicalOr:iq,LogicalXor:GEt,LogSoftmax:jEt,LowerBound:KEt,LRN:lq,LRNGrad:qEt,Max:uq,Maximum:cq,MaxPool:dq,MaxPoolGrad:XEt,MaxPool3D:fq,MaxPool3DGrad:YEt,MaxPoolWithArgmax:hq,Mean:pq,Min:mq,Minimum:gq,MirrorPad:vq,Mod:yq,Multinomial:bq,Multiply:wq,Neg:_q,NotEqual:$q,NonMaxSuppressionV3:xq,NonMaxSuppressionV4:Sq,NonMaxSuppressionV5:Cq,OnesLike:kq,OneHot:Tq,Pack:Nq,PadV2:Iq,Pool:ZEt,Pow:Eq,Prelu:Aq,Prod:Oq,RaggedGather:Rq,RaggedTensorToTensor:Dq,Range:Fq,Real:Mq,Reciprocal:Pq,Relu:Lq,Reshape:zq,ResizeNearestNeighbor:Bq,ResizeNearestNeighborGrad:JEt,ResizeBilinear:Vq,ResizeBilinearGrad:QEt,Relu6:Hq,Reverse:Wq,Round:Uq,Rsqrt:Gq,ScatterNd:jq,SearchSorted:Kq,Select:qq,Selu:Xq,Slice:Yq,Sin:Zq,Sinh:Jq,Sign:Qq,Sigmoid:eX,Softplus:tX,Sqrt:nX,Sum:sX,SpaceToBatchND:rX,SplitV:oX,Softmax:aX,SparseFillEmptyRows:iX,SparseReshape:lX,SparseSegmentMean:uX,SparseSegmentSum:cX,SparseToDense:dX,SquaredDifference:fX,Square:e5t,StridedSlice:hX,StringNGrams:pX,StringSplit:mX,StringToHashBucketFast:gX,Sub:vX,Tan:yX,Tanh:bX,Tile:WI,TopK:wX,Transform:_X,Transpose:my,Unique:$X,Unpack:xX,UnsortedSegmentSum:SX,UpperBound:t5t,ZerosLike:CX,Step:kX,FromPixels:sS,RotateWithOffset:TX,_FusedMatMul:rS,FusedConv2D:oS,FusedDepthwiseConv2D:aS,version_core:POt,browser:hOt,io:QI,math:oOt,serialization:kOt,test_util:MOt,util:m5t,backend_util:iLt,broadcast_util:aOt,tensor_util:E5t,slice_util:fY,gather_util:pOt,scatter_util:mOt,device_util:M5t,kernel_impls:lLt},Symbol.toStringTag,{value:"Module"}));const uLt=en();uLt.registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,t=>{t&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")});var sa;(function(t){t[t.DT_INVALID=0]="DT_INVALID",t[t.DT_FLOAT=1]="DT_FLOAT",t[t.DT_DOUBLE=2]="DT_DOUBLE",t[t.DT_INT32=3]="DT_INT32",t[t.DT_UINT8=4]="DT_UINT8",t[t.DT_INT16=5]="DT_INT16",t[t.DT_INT8=6]="DT_INT8",t[t.DT_STRING=7]="DT_STRING",t[t.DT_COMPLEX64=8]="DT_COMPLEX64",t[t.DT_INT64=9]="DT_INT64",t[t.DT_BOOL=10]="DT_BOOL",t[t.DT_QINT8=11]="DT_QINT8",t[t.DT_QUINT8=12]="DT_QUINT8",t[t.DT_QINT32=13]="DT_QINT32",t[t.DT_BFLOAT16=14]="DT_BFLOAT16",t[t.DT_QINT16=15]="DT_QINT16",t[t.DT_QUINT16=16]="DT_QUINT16",t[t.DT_UINT16=17]="DT_UINT16",t[t.DT_COMPLEX128=18]="DT_COMPLEX128",t[t.DT_HALF=19]="DT_HALF",t[t.DT_RESOURCE=20]="DT_RESOURCE",t[t.DT_VARIANT=21]="DT_VARIANT",t[t.DT_UINT32=22]="DT_UINT32",t[t.DT_UINT64=23]="DT_UINT64",t[t.DT_FLOAT_REF=101]="DT_FLOAT_REF",t[t.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",t[t.DT_INT32_REF=103]="DT_INT32_REF",t[t.DT_UINT8_REF=104]="DT_UINT8_REF",t[t.DT_INT16_REF=105]="DT_INT16_REF",t[t.DT_INT8_REF=106]="DT_INT8_REF",t[t.DT_STRING_REF=107]="DT_STRING_REF",t[t.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",t[t.DT_INT64_REF=109]="DT_INT64_REF",t[t.DT_BOOL_REF=110]="DT_BOOL_REF",t[t.DT_QINT8_REF=111]="DT_QINT8_REF",t[t.DT_QUINT8_REF=112]="DT_QUINT8_REF",t[t.DT_QINT32_REF=113]="DT_QINT32_REF",t[t.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",t[t.DT_QINT16_REF=115]="DT_QINT16_REF",t[t.DT_QUINT16_REF=116]="DT_QUINT16_REF",t[t.DT_UINT16_REF=117]="DT_UINT16_REF",t[t.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",t[t.DT_HALF_REF=119]="DT_HALF_REF",t[t.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",t[t.DT_VARIANT_REF=121]="DT_VARIANT_REF",t[t.DT_UINT32_REF=122]="DT_UINT32_REF",t[t.DT_UINT64_REF=123]="DT_UINT64_REF"})(sa||(sa={}));var O9;(function(t){(function(e){e[e.LEGACY=0]="LEGACY",e[e.V1=1]="V1",e[e.V2=2]="V2"})(t.CheckpointFormatVersion||(t.CheckpointFormatVersion={}))})(O9||(O9={}));const cLt={};function DJ(t){return cLt[t]}function W(t,e,n,s,r){const o=e.inputParams[t];if(o&&o.inputIndexStart!==void 0){const i=o.inputIndexStart,l=o.inputIndexEnd===0?void 0:o.inputIndexEnd===void 0?i+1:o.inputIndexEnd;if(o.type==="tensor")return Ar(e.inputNames[o.inputIndexStart],n,s,r);if(o.type==="tensors")return e.inputNames.slice(i,l).map(f=>Ar(f,n,s,r));const u=Ar(e.inputNames.slice(i)[0],n,s,r),c=u.dataSync();return o.type==="number"?c[0]:hd(u.shape,c)}const a=e.attrParams[t];return a&&a.value}function Ar(t,e,n,s){const[r,o]=uo(t);if(s!=null){const i=s.getHashTableHandleByName(r);if(i!=null)return i}const a=n.currentContextIds.find(i=>!!e[Pb(r,i)]);return a!==void 0?e[Pb(r,a)][o]:void 0}function dLt(t,e,n){return e[Pb(t,n.currentContextId)]}function bi(t,e){const[n,s,r]=uo(t);return[Pb(n,e&&e.currentContextId),s,r]}function Pb(t,e){return e?`${t}-${e}`:t}function uo(t){const e=t.split(":");if(e.length===1)return[t,0,void 0];const n=e[0],s=e.length===3?e[1]:void 0,r=Number(e[e.length-1]);return[n,r,s]}function yy(t,e,n){let s=W("pad",t,e,n);if(s==="explicit"){s=W("explicitPaddings",t,e,n);const r=[[0,0],[0,0],[0,0],[0,0]];for(let o=0;o<4;o++)r[o][0]=s[o*2],r[o][1]=s[o*2+1];return r}return s}function cl(t){return t.kept?t:bl(t)}const fLt=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],hLt=Object.freeze(Object.defineProperty({__proto__:null,json:fLt},Symbol.toStringTag,{value:"Module"}));const pLt=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Prod",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axes",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],mLt=Object.freeze(Object.defineProperty({__proto__:null,json:pLt},Symbol.toStringTag,{value:"Module"}));const gLt=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}],vLt=Object.freeze(Object.defineProperty({__proto__:null,json:gLt},Symbol.toStringTag,{value:"Module"}));const yLt=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}],bLt=Object.freeze(Object.defineProperty({__proto__:null,json:yLt},Symbol.toStringTag,{value:"Module"}));const wLt=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomStandardNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}],_Lt=Object.freeze(Object.defineProperty({__proto__:null,json:wLt},Symbol.toStringTag,{value:"Module"}));const $Lt=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],xLt=Object.freeze(Object.defineProperty({__proto__:null,json:$Lt},Symbol.toStringTag,{value:"Module"}));const SLt=[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}],CLt=Object.freeze(Object.defineProperty({__proto__:null,json:SLt},Symbol.toStringTag,{value:"Module"}));const kLt=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],TLt=Object.freeze(Object.defineProperty({__proto__:null,json:kLt},Symbol.toStringTag,{value:"Module"}));const NLt=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]}],ILt=Object.freeze(Object.defineProperty({__proto__:null,json:NLt},Symbol.toStringTag,{value:"Module"}));const ELt=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}],ALt=Object.freeze(Object.defineProperty({__proto__:null,json:ELt},Symbol.toStringTag,{value:"Module"}));const OLt=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],RLt=Object.freeze(Object.defineProperty({__proto__:null,json:OLt},Symbol.toStringTag,{value:"Module"}));const DLt=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]}],FLt=Object.freeze(Object.defineProperty({__proto__:null,json:DLt},Symbol.toStringTag,{value:"Module"}));const MLt=[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"SparseToDense",category:"normalization",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!0,notSupported:!0}]}],PLt=Object.freeze(Object.defineProperty({__proto__:null,json:MLt},Symbol.toStringTag,{value:"Module"}));const LLt=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}],zLt=Object.freeze(Object.defineProperty({__proto__:null,json:LLt},Symbol.toStringTag,{value:"Module"}));const BLt=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]}],VLt=Object.freeze(Object.defineProperty({__proto__:null,json:BLt},Symbol.toStringTag,{value:"Module"}));const HLt=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}],WLt=Object.freeze(Object.defineProperty({__proto__:null,json:HLt},Symbol.toStringTag,{value:"Module"}));const ULt=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],GLt=Object.freeze(Object.defineProperty({__proto__:null,json:ULt},Symbol.toStringTag,{value:"Module"}));const jLt=[{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}],KLt=Object.freeze(Object.defineProperty({__proto__:null,json:jLt},Symbol.toStringTag,{value:"Module"}));const qLt=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}],XLt=Object.freeze(Object.defineProperty({__proto__:null,json:qLt},Symbol.toStringTag,{value:"Module"}));class R9{static get Instance(){return this._instance||(this._instance=new this)}constructor(){const e=[hLt,mLt,vLt,bLt,_Lt,xLt,CLt,TLt,ILt,ALt,RLt,FLt,PLt,zLt,VLt,WLt,GLt,KLt,XLt],n=[].concat(...e.map(s=>s.json));this.opMappers=n.reduce((s,r)=>(s[r.tfOpName]=r,s),{})}transformGraph(e,n={}){const s=e.node,r=[],o=[],a=[],i=s.reduce((m,g)=>(m[g.name]=this.mapNode(g),g.op.startsWith("Placeholder")?r.push(m[g.name]):g.op==="Const"?o.push(m[g.name]):(g.input==null||g.input.length===0)&&a.push(m[g.name]),m),{});let l=[];const u=[];let c={},d={};n!=null&&(c=this.mapSignatureEntries(n.inputs),d=this.mapSignatureEntries(n.outputs));const f=Object.keys(i);f.forEach(m=>{const g=i[m];g.inputNames.forEach((y,w)=>{const[b,,_]=bi(y),$=i[b];if($.outputs!=null){const x=$.outputs.indexOf(_);if(x!==-1){const k=`${b}:${x}`;g.inputNames[w]=k}}g.inputs.push($),$.children.push(g)})}),Object.keys(d).length===0?f.forEach(m=>{const g=i[m];g.children.length===0&&u.push(g)}):Object.keys(d).forEach(m=>{const[g]=bi(m),y=i[g];y!=null&&(y.signatureKey=d[m],u.push(y))}),Object.keys(c).length>0?Object.keys(c).forEach(m=>{const[g]=bi(m),y=i[g];y&&(y.signatureKey=c[m],l.push(y))}):l=r;let h={};e.library!=null&&e.library.function!=null&&(h=e.library.function.reduce((m,g)=>(m[g.signature.name]=this.mapFunction(g),m),{}));const p={nodes:i,inputs:l,outputs:u,weights:o,placeholders:r,signature:n,functions:h};return a.length>0&&(p.initNodes=a),p}mapSignatureEntries(e){return Object.keys(e||{}).reduce((n,s)=>(n[e[s].name]=s,n),{})}mapNode(e){const n=DJ(e.op)||this.opMappers[e.op]||{};e.attr==null&&(e.attr={});const s={name:e.name,op:e.op,category:n.category,inputNames:(e.input||[]).map(r=>r.startsWith("^")?r.slice(1):r),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:e.attr,outputs:n.outputs};return n.inputs!=null&&(s.inputParams=n.inputs.reduce((r,o)=>(r[o.name]={type:o.type,inputIndexStart:o.start,inputIndexEnd:o.end},r),{})),n.attrs!=null&&(s.attrParams=n.attrs.reduce((r,o)=>{const a=o.type;let i;switch(o.type){case"string":i=xS(e.attr,o.tfName,o.defaultValue),i===void 0&&!!o.tfDeprecatedName&&(i=xS(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"string[]":i=ES(e.attr,o.tfName,o.defaultValue),i===void 0&&!!o.tfDeprecatedName&&(i=ES(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"number":i=CS(e.attr,o.tfName,o.defaultValue||0),i===void 0&&!!o.tfDeprecatedName&&(i=CS(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"number[]":i=IS(e.attr,o.tfName,o.defaultValue),i===void 0&&!!o.tfDeprecatedName&&(i=IS(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"bool":i=SS(e.attr,o.tfName,o.defaultValue),i===void 0&&!!o.tfDeprecatedName&&(i=SS(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"bool[]":i=OS(e.attr,o.tfName,o.defaultValue),i===void 0&&!!o.tfDeprecatedName&&(i=OS(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"shape":i=NS(e.attr,o.tfName,o.defaultValue),i===void 0&&!!o.tfDeprecatedName&&(i=NS(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"shape[]":i=AS(e.attr,o.tfName,o.defaultValue),i===void 0&&!!o.tfDeprecatedName&&(i=AS(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"dtype":i=kS(e.attr,o.tfName,o.defaultValue),i===void 0&&!!o.tfDeprecatedName&&(i=kS(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"dtype[]":i=TS(e.attr,o.tfName,o.defaultValue),i===void 0&&!!o.tfDeprecatedName&&(i=TS(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"func":i=D9(e.attr,o.tfName,o.defaultValue),i===void 0&&!!o.tfDeprecatedName&&(i=D9(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${o.type} for op: ${e.op}`)}return r[o.name]={value:i,type:a},r},{})),s}mapFunction(e){const n=e.nodeDef,s=[],r=[];let o={};n!=null&&(o=n.reduce((d,f)=>(d[f.name]=this.mapNode(f),f.op==="Const"&&r.push(d[f.name]),d),{}));const a=[],i=[];e.signature.inputArg.forEach(d=>{const[f]=bi(d.name),h={name:f,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:jE(d.type),type:"dtype"}},children:[]};h.signatureKey=d.name,a.push(h),o[f]=h}),Object.keys(o).forEach(d=>{const f=o[d];f.inputNames.forEach((h,p)=>{const[m,,g]=bi(h),y=o[m];if(y.outputs!=null){const w=y.outputs.indexOf(g);if(w!==-1){const b=`${m}:${w}`;f.inputNames[p]=b}}f.inputs.push(y),y.children.push(f)})});const u=e.ret;e.signature.outputArg.forEach(d=>{const[f,h]=bi(u[d.name]),p=o[f];p!=null&&(p.defaultOutput=h,i.push(p))});const c=this.mapArgsToSignature(e);return{nodes:o,inputs:a,outputs:i,weights:r,placeholders:s,signature:c}}mapArgsToSignature(e){return{methodName:e.signature.name,inputs:e.signature.inputArg.reduce((n,s)=>(n[s.name]=this.mapArgToTensorInfo(s),n),{}),outputs:e.signature.outputArg.reduce((n,s)=>(n[s.name]=this.mapArgToTensorInfo(s,e.ret),n),{})}}mapArgToTensorInfo(e,n){let s=e.name;return n!=null&&(s=n[s]),{name:s,dtype:e.type}}}function YLt(t){const e=en().global;if(typeof e.atob<"u")return e.atob(t);if(typeof Buffer<"u")return new Buffer(t,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}function FJ(t,e){const n=Array.isArray(t)?String.fromCharCode.apply(null,t):YLt(t);return e?n:n.toLowerCase()}function xS(t,e,n,s=!1){const r=t[e];return r!=null?FJ(r.s,s):n}function SS(t,e,n){const s=t[e];return s?s.b:n}function CS(t,e,n){const s=t[e]||{},r=s.i!=null?s.i:s.f!=null?s.f:n;return typeof r=="number"?r:parseInt(r,10)}function jE(t){switch(typeof t=="string"&&(t=sa[t]),t){case sa.DT_FLOAT:case sa.DT_HALF:return"float32";case sa.DT_INT32:case sa.DT_INT64:case sa.DT_INT8:case sa.DT_UINT8:return"int32";case sa.DT_BOOL:return"bool";case sa.DT_DOUBLE:return"float32";case sa.DT_STRING:return"string";default:return null}}function D9(t,e,n){const s=t[e];return s&&s.func?s.func.name:n}function kS(t,e,n){const s=t[e];return s&&s.type?jE(s.type):n}function TS(t,e,n){const s=t[e];return s&&s.list&&s.list.type?s.list.type.map(r=>jE(r)):n}function MJ(t){if(!t.unknownRank)return t.dim!=null?t.dim.map(e=>typeof e.size=="number"?e.size:parseInt(e.size,10)):[]}function NS(t,e,n){const s=t[e];return s&&s.shape?MJ(s.shape):n}function IS(t,e,n){const s=t[e];return s?((s.list.f&&s.list.f.length?s.list.f:s.list.i)||[]).map(r=>typeof r=="number"?r:parseInt(r,10)):n}function ES(t,e,n,s=!1){const r=t[e];return r&&r.list&&r.list.s?r.list.s.map(o=>FJ(o,s)):n}function AS(t,e,n){const s=t[e];return s&&s.list&&s.list.shape?s.list.shape.map(r=>MJ(r)):n}function OS(t,e,n){const s=t[e];return s&&s.list&&s.list.b?s.list.b:n}class ZLt{constructor(e,n,s){this.node=e,this.tensorMap=n,this.context=s,this.inputs=[],this.attrs={},this.inputs=e.inputNames.map(r=>this.getInput(r)),e.rawAttrs!=null&&(this.attrs=Object.keys(e.rawAttrs).reduce((r,o)=>(r[o]=this.getAttr(o),r),{}))}getInput(e){return Ar(e,this.tensorMap,this.context)}getAttr(e,n){const s=this.node.rawAttrs[e];if(s.tensor!=null)return Ar(e,this.tensorMap,this.context);if(s.i!=null||s.f!=null)return CS(this.node.rawAttrs,e,n);if(s.s!=null)return xS(this.node.rawAttrs,e,n);if(s.b!=null)return SS(this.node.rawAttrs,e,n);if(s.shape!=null)return NS(this.node.rawAttrs,e,n);if(s.type!=null)return kS(this.node.rawAttrs,e,n);if(s.list!=null){if(s.list.i!=null||s.list.f!=null)return IS(this.node.rawAttrs,e,n);if(s.list.s!=null)return ES(this.node.rawAttrs,e,n);if(s.list.shape!=null)return AS(this.node.rawAttrs,e,n);if(s.list.b!=null)return OS(this.node.rawAttrs,e,n);if(s.list.type!=null)return TS(this.node.rawAttrs,e,n)}return n}}const _r=Object.freeze(Object.defineProperty({__proto__:null,abs:co,acos:gY,acosh:vY,add:Wt,addN:yY,all:bY,any:wY,argMax:iE,argMin:_Y,asin:$Y,asinh:xY,atan:SY,atan2:CY,atanh:kY,avgPool:uE,avgPool3d:EY,basicLSTMCell:AY,batchToSpaceND:cE,batchNorm:M2,batchNorm2d:OY,batchNorm3d:RY,batchNorm4d:DY,bincount:dE,broadcastArgs:FY,broadcastTo:v0,buffer:ji,cast:es,ceil:MY,clipByValue:PY,clone:bl,complex:Dl,concat:sr,concat1d:LY,concat2d:zY,concat3d:BY,concat4d:VY,conv1d:HY,conv2d:P2,conv2dTranspose:UY,conv3d:GY,conv3dTranspose:jY,cos:KY,cosh:qY,cumprod:XY,cumsum:YY,denseBincount:ZY,depthToSpace:JY,depthwiseConv2d:l4,diag:QY,dilation2d:eZ,div:En,divNoNan:tZ,dot:nZ,einsum:sZ,elu:hE,equal:fE,erf:rZ,euclideanNorm:iZ,exp:rc,expandDims:Va,expm1:lZ,eye:mE,fill:_m,floor:gE,floorDiv:aE,gather:vE,greater:B2,greaterEqual:yE,imag:D2,isFinite:uZ,isInf:cZ,isNaN:dZ,leakyRelu:bE,less:fZ,lessEqual:u4,linspace:hZ,localResponseNormalization:pZ,log:Uh,log1p:wE,logSigmoid:gZ,logSoftmax:vZ,logSumExp:$E,logicalAnd:bg,logicalNot:xE,logicalOr:SE,logicalXor:yZ,lowerBound:bZ,matMul:Tn,max:md,maxPool:CE,maxPool3d:wZ,maxPoolWithArgmax:_Z,maximum:kE,mean:wg,meshgrid:$Z,min:Mb,minimum:TE,mirrorPad:xZ,mod:SZ,moments:CZ,mul:gt,multiRNNCell:kZ,multinomial:TZ,neg:Pi,notEqual:NE,oneHot:Rb,ones:Au,onesLike:NZ,outerProduct:IZ,pad:$m,pad1d:EZ,pad2d:AZ,pad3d:IE,pad4d:OZ,pool:RZ,pow:Wh,prelu:AE,print:YI,prod:DZ,raggedGather:FZ,raggedTensorToTensor:MZ,rand:PZ,randomGamma:LZ,randomNormal:RE,randomStandardNormal:zZ,randomUniform:DE,range:Gh,real:Hh,reciprocal:BZ,relu:V2,relu6:FE,reshape:Ze,reverse:oc,reverse1d:VZ,reverse2d:HZ,reverse3d:WZ,reverse4d:UZ,round:ME,rsqrt:GZ,scalar:an,selu:jZ,separableConv2d:KZ,setdiff1dAsync:qZ,sigmoid:Bu,sign:XZ,sin:YZ,sinh:ZZ,slice:Mn,slice1d:JZ,slice2d:QZ,slice3d:eJ,slice4d:tJ,softmax:nJ,softplus:_E,spaceToBatchND:EE,fft:f4,ifft:_g,irfft:PE,rfft:h4,split:jh,sqrt:Ki,square:ba,squaredDifference:LE,squeeze:H2,stack:Xi,step:zE,stridedSlice:sJ,sub:rn,sum:Wn,tan:rJ,tanh:Fb,tensor:Za,tensor1d:ga,tensor2d:gd,tensor3d:tE,tensor4d:oJ,tensor5d:aJ,tensor6d:iJ,tile:th,topk:lJ,truncatedNormal:uJ,unique:cJ,unsortedSegmentSum:dJ,unstack:_c,upperBound:fJ,variable:hJ,where:jd,whereAsync:BE,zeros:Kd,zerosLike:bo,op:Ce,OP_SCOPE_SUFFIX:jI,booleanMaskAsync:mJ,transpose:vg,norm:z2,movingAverage:gJ,scatterND:vJ,searchSorted:d4,sparseToDense:yJ,gatherND:bJ,dropout:wJ,enclosingPowerOfTwo:VE,cosineWindow:p4,inTopKAsync:_J,image:WE,linalg:EJ,losses:AJ,spectral:NJ,fused:$J,signal:IJ,sparse:OJ,string:RJ},Symbol.toStringTag,{value:"Module"}));const JLt=(t,e,n,s=_r)=>{switch(t.op){case"BiasAdd":case"AddV2":case"Add":return[s.add(W("a",t,e,n),W("b",t,e,n))];case"AddN":return[s.addN(W("tensors",t,e,n))];case"FloorMod":case"Mod":return[s.mod(W("a",t,e,n),W("b",t,e,n))];case"Mul":return[s.mul(W("a",t,e,n),W("b",t,e,n))];case"RealDiv":case"Div":return[s.div(W("a",t,e,n),W("b",t,e,n))];case"DivNoNan":return[s.divNoNan(W("a",t,e,n),W("b",t,e,n))];case"FloorDiv":return[s.floorDiv(W("a",t,e,n),W("b",t,e,n))];case"Sub":return[s.sub(W("a",t,e,n),W("b",t,e,n))];case"Minimum":return[s.minimum(W("a",t,e,n),W("b",t,e,n))];case"Maximum":return[s.maximum(W("a",t,e,n),W("b",t,e,n))];case"Pow":return[s.pow(W("a",t,e,n),W("b",t,e,n))];case"SquaredDifference":return[s.squaredDifference(W("a",t,e,n),W("b",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};const QLt=(t,e,n,s=_r)=>{switch(t.op){case"Abs":case"ComplexAbs":return[s.abs(W("x",t,e,n))];case"Acos":return[s.acos(W("x",t,e,n))];case"Acosh":return[s.acosh(W("x",t,e,n))];case"Asin":return[s.asin(W("x",t,e,n))];case"Asinh":return[s.asinh(W("x",t,e,n))];case"Atan":return[s.atan(W("x",t,e,n))];case"Atan2":return[s.atan2(W("x",t,e,n),W("y",t,e,n))];case"Atanh":return[s.atanh(W("x",t,e,n))];case"Ceil":return[s.ceil(W("x",t,e,n))];case"Complex":return[s.complex(W("real",t,e,n),W("imag",t,e,n))];case"Cos":return[s.cos(W("x",t,e,n))];case"Cosh":return[s.cosh(W("x",t,e,n))];case"Elu":return[s.elu(W("x",t,e,n))];case"Erf":return[s.erf(W("x",t,e,n))];case"Exp":return[s.exp(W("x",t,e,n))];case"Expm1":return[s.expm1(W("x",t,e,n))];case"Floor":return[s.floor(W("x",t,e,n))];case"Log":return[s.log(W("x",t,e,n))];case"Log1p":return[s.log1p(W("x",t,e,n))];case"Imag":return[s.imag(W("x",t,e,n))];case"Neg":return[s.neg(W("x",t,e,n))];case"Reciprocal":return[s.reciprocal(W("x",t,e,n))];case"Real":return[s.real(W("x",t,e,n))];case"Relu":return[s.relu(W("x",t,e,n))];case"Round":return[s.round(W("x",t,e,n))];case"Selu":return[s.selu(W("x",t,e,n))];case"Sigmoid":return[s.sigmoid(W("x",t,e,n))];case"Sin":return[s.sin(W("x",t,e,n))];case"Sign":return[s.sign(W("x",t,e,n))];case"Sinh":return[s.sinh(W("x",t,e,n))];case"Softplus":return[s.softplus(W("x",t,e,n))];case"Sqrt":return[s.sqrt(W("x",t,e,n))];case"Square":return[s.square(W("x",t,e,n))];case"Tanh":return[s.tanh(W("x",t,e,n))];case"Tan":return[s.tan(W("x",t,e,n))];case"ClipByValue":return[s.clipByValue(W("x",t,e,n),W("clipValueMin",t,e,n),W("clipValueMax",t,e,n))];case"Relu6":return[s.relu6(W("x",t,e,n))];case"Rsqrt":return[s.rsqrt(Ar(t.inputNames[0],e,n))];case"Prod":return[s.prod(W("x",t,e,n),W("axes",t,e,n))];case"LeakyRelu":return[s.leakyRelu(W("x",t,e,n),W("alpha",t,e,n))];case"Prelu":return[s.prelu(W("x",t,e,n),W("alpha",t,e,n))];case"IsNan":return[s.isNaN(Ar(t.inputNames[0],e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};function aa(t,e,n=""){if(!(typeof t=="number"||typeof e=="number")){le(t.length===e.length,()=>n+` Shapes ${t} and ${e} must match`);for(let s=0;s<t.length;s++){const r=t[s],o=e[s];le(r<0||o<0||r===o,()=>n+` Shapes ${t} and ${e} must match`)}}}function F9(t){return!(typeof t=="number"||t.some(e=>e<0))}function Bm(t,e,n){let s=RS(t,n);const r=!F9(s);if(r&&e.length===0)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${s}`);if(r&&e.forEach(o=>{s=RS(o.shape,s)}),!F9(s))throw new Error(`Non-fully-defined elementShape: ${s}`);return s}function RS(t,e){if(typeof t=="number")return e;if(typeof e=="number")return t;if(t.length!==e.length)throw new Error(`Incompatible ranks during merge: ${t} vs. ${e}`);const n=[];for(let s=0;s<t.length;++s){const r=t[s],o=e[s];if(r>=0&&o>=0&&r!==o)throw new Error(`Incompatible shape during merge: ${t} vs. ${e}`);n[s]=r>=0?r:o}return n}class ezt{constructor(e,n,s,r,o,a,i){this.name=e,this.dtype=n,this.maxSize=s,this.elementShape=r,this.identicalElementShapes=o,this.dynamicSize=a,this.clearAfterRead=i,this.tensors=[],this.closed_=!1,this.idTensor=an(0),Ii(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(e){this.tensors.forEach(n=>{(e==null||!e.has(n.tensor.id))&&n.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||e>=this.size())throw new Error(`Tried to read from index ${e}, but array size is: ${this.size()}`);const n=this.tensors[e];if(n.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${e} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(n.cleared=!0),n.read=!0,n.tensor}readMany(e){return e.map(n=>this.read(n))}write(e,n){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||!this.dynamicSize&&e>=this.maxSize)throw new Error(`Tried to write to index ${e}, but array is not resizeable and size is: ${this.maxSize}`);const s=this.tensors[e]||{};if(n.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e},
          because the value dtype is ${n.dtype}, but TensorArray dtype is ${this.dtype}.`);if(this.size()===0&&(this.elementShape==null||this.elementShape.length===0)&&(this.elementShape=n.shape),aa(this.elementShape,n.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${e}.`),s.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been read.`);if(s.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been written.`);s.tensor=n,Ii(n),s.written=!0,this.tensors[e]=s}writeMany(e,n){if(e.length!==n.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${e.length} is not the same as tensors size: ${n.length}.`);e.forEach((s,r)=>this.write(s,n[r]))}gather(e,n){if(!!n&&n!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${n}`);if(e)e=e.slice(0,this.size());else{e=[];for(let r=0;r<this.size();r++)e.push(r)}if(e.length===0)return Za([],[0].concat(this.elementShape));const s=this.readMany(e);return aa(this.elementShape,s[0].shape,"TensorArray shape mismatch: "),Xi(s,0)}concat(e){if(!!e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${e}`);if(this.size()===0)return Za([],[0].concat(this.elementShape));const n=[];for(let r=0;r<this.size();r++)n.push(r);const s=this.readMany(n);return aa(this.elementShape,s[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${s[0].shape})`),sr(s,0)}scatter(e,n){if(n.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${n.dtype}`);if(e.length!==n.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${n.shape[0]}`);const s=Math.max(...e);if(!this.dynamicSize&&s>=this.maxSize)throw new Error(`Max index must be < array size (${s}  vs. ${this.maxSize})`);this.writeMany(e,_c(n,0))}split(e,n){if(n.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${n.dtype}`);let s=0;const r=e.map(l=>(s+=l,s));if(s!==n.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${s}, and tensor's shape is: ${n.shape}`);if(!this.dynamicSize&&e.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${e.length}), and the TensorArray is not marked as dynamically resizeable`);const o=s===0?0:n.size/s,a=[];vn(()=>{n=Ze(n,[1,s,o]);for(let l=0;l<e.length;++l){const c=[0,l===0?0:r[l-1],0],d=[1,e[l],o];a[l]=Ze(Mn(n,c,d),this.elementShape)}return a});const i=[];for(let l=0;l<e.length;l++)i[l]=l;this.writeMany(i,a)}}class qd{constructor(e,n,s,r=-1){this.tensors=e,this.elementShape=n,this.elementDtype=s,e!=null&&e.forEach(o=>{if(s!==o.dtype)throw new Error(`Invalid data types; op elements ${s}, but list elements ${o.dtype}`);aa(n,o.shape,"TensorList shape mismatch: "),Ii(o)}),this.idTensor=an(0),this.maxNumElements=r,Ii(this.idTensor)}get id(){return this.idTensor.id}copy(){return new qd([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(e){this.tensors.forEach(n=>{(e==null||!e.has(n.id))&&n.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(e,n,s=-1){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);if(s!==-1&&this.tensors.length!==s)throw new Error(`Operation expected a list with ${s} elements but got a list with ${this.tensors.length} elements.`);aa(e,this.elementShape,"TensorList shape mismatch: ");const r=Bm(this.elementShape,this.tensors,e);return vn(()=>{const o=this.tensors.map(a=>Ze(a,r));return Xi(o,0)})}popBack(e,n){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);if(this.size()===0)throw new Error("Trying to pop from an empty list.");const s=Bm(this.elementShape,this.tensors,e),r=this.tensors.pop();return r.kept=!1,aa(r.shape,e,"TensorList shape mismatch: "),Ze(r,s)}pushBack(e){if(e.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if(aa(e.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");Ii(e),this.tensors.push(e)}resize(e){if(e<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${e}`);if(this.maxNumElements!==-1&&e>this.maxNumElements)throw new Error(`TensorListResize input size ${e} is greater maxNumElement ${this.maxNumElements}.`);const n=new qd([],this.elementShape,this.elementDtype,this.maxNumElements);n.tensors.length=e;for(let s=0;s<Math.min(this.tensors.length,e);++s)n.tensors[s]=this.tensors[s];return n}getItem(e,n,s){if(s!==this.elementDtype)throw new Error(`Invalid data types; op elements ${s}, but list elements ${this.elementDtype}`);if(e<0||e>this.tensors.length)throw new Error(`Trying to access element ${e} in a list with ${this.tensors.length} elements.`);if(this.tensors[e]==null)throw new Error(`element at index ${e} is null.`);aa(this.tensors[e].shape,n,"TensorList shape mismatch: ");const r=Bm(this.elementShape,this.tensors,n);return Ze(this.tensors[e],r)}setItem(e,n){if(n.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n.dtype}, but list elements ${this.elementDtype}`);if(e<0||this.maxNumElements!==-1&&e>=this.maxNumElements)throw new Error(`Trying to set element ${e} in a list with max ${this.maxNumElements} elements.`);aa(this.elementShape,n.shape,"TensorList shape mismatch: "),Ii(n),this.tensors[e]!=null&&(this.tensors[e].kept=!1),this.tensors[e]=n}gather(e,n,s){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);aa(this.elementShape,s,"TensorList shape mismatch: "),e=e.slice(0,this.size());const r=Bm(this.elementShape,this.tensors,s);return e.length===0?Za([],[0].concat(r)):vn(()=>{const o=e.map(a=>Ze(this.tensors[a],r));return Xi(o,0)})}concat(e,n){if(!!e&&e!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${e}`);aa(this.elementShape,n,"TensorList shape mismatch: ");const s=Bm(this.elementShape,this.tensors,n);return this.size()===0?Za([],[0].concat(s)):vn(()=>{const r=this.tensors.map(o=>Ze(o,s));return sr(r,0)})}}function tzt(t,e,n){const s=t.dtype;if(t.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${t.shape}`);if(t.dtype!==n)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${n}`);const r=t.shape.slice(1);aa(r,e,"TensorList shape mismatch: ");const o=_c(t);return new qd(o,e,s)}function nzt(t,e,n,s){return new qd([],t,e,s)}function szt(t,e,n,s){if(e.length!==t.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${t.shape[0]}`);const r=Math.max(...e);if(s!=null&&s!==-1&&r>=s)throw new Error(`Max index must be < array size (${r}  vs. ${s})`);const o=new qd([],n,t.dtype,s),a=_c(t,0);return e.forEach((i,l)=>{o.setItem(i,a[l])}),o}function rzt(t,e,n){let s=0;const r=e.map(c=>(s+=c,s));if(s!==t.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${s}, and tensor's shape is: ${t.shape}`);const o=t.shape.slice(1),a=RS(o,n),i=s===0?0:t.size/s,l=vn(()=>{const c=[];t=Ze(t,[1,s,i]);for(let d=0;d<e.length;++d){const h=[0,d===0?0:r[d-1],0],p=[1,e[d],i];c[d]=Ze(Mn(t,h,p),a)}return t.dispose(),c}),u=new qd([],n,t.dtype,e.length);for(let c=0;c<l.length;c++)u.setItem(c,l[c]);return u}const ozt=async(t,e,n)=>{switch(t.op){case"If":case"StatelessIf":{const s=W("thenBranch",t,e,n),r=W("elseBranch",t,e,n),o=W("cond",t,e,n),a=W("args",t,e,n);return(await o.data())[0]?n.functionMap[s].executeFunctionAsync(a,n.tensorArrayMap,n.tensorListMap):n.functionMap[r].executeFunctionAsync(a,n.tensorArrayMap,n.tensorListMap)}case"While":case"StatelessWhile":{const s=W("body",t,e,n),r=W("cond",t,e,n),o=W("args",t,e,n),a=await n.functionMap[r].executeFunctionAsync(o,n.tensorArrayMap,n.tensorListMap),i=o.map(c=>c.id);let l=await a[0].data();a.forEach(c=>{!c.kept&&i.indexOf(c.id)===-1&&c.dispose()});let u=o;for(;l[0];){const c=u;u=await n.functionMap[s].executeFunctionAsync(u,n.tensorArrayMap,n.tensorListMap);const d=u.map(h=>h.id);c.forEach(h=>{!h.kept&&i.indexOf(h.id)===-1&&d.indexOf(h.id)===-1&&h.dispose()});const f=await n.functionMap[r].executeFunctionAsync(u,n.tensorArrayMap,n.tensorListMap);l=await f[0].data(),f.forEach(h=>{!h.kept&&i.indexOf(h.id)===-1&&d.indexOf(h.id)===-1&&h.dispose()})}return u}case"LoopCond":{const s=W("pred",t,e,n);return[cl(s)]}case"Switch":{const s=W("pred",t,e,n);let r=W("data",t,e,n);return r.kept||(r=cl(r)),(await s.data())[0]?[void 0,r]:[r,void 0]}case"Merge":{const s=t.inputNames.find(r=>Ar(r,e,n)!==void 0);if(s){const r=Ar(s,e,n);return[cl(r)]}return}case"Enter":{const s=W("frameName",t,e,n),r=W("tensor",t,e,n);return n.enterFrame(s),[cl(r)]}case"Exit":{const s=W("tensor",t,e,n);return n.exitFrame(),[cl(s)]}case"NextIteration":{const s=W("tensor",t,e,n);return n.nextIteration(),[cl(s)]}case"TensorArrayV3":{const s=W("size",t,e,n),r=W("dtype",t,e,n),o=W("elementShape",t,e,n),a=W("dynamicSize",t,e,n),i=W("clearAfterRead",t,e,n),l=W("identicalElementShapes",t,e,n),u=W("name",t,e,n),c=new ezt(u,r,s,o,l,a,i);return n.addTensorArray(c),[c.idTensor,an(1)]}case"TensorArrayWriteV3":{const s=W("tensorArrayId",t,e,n),r=W("index",t,e,n),o=W("tensor",t,e,n),a=n.getTensorArray(s.id);return a.write(r,o),[a.idTensor]}case"TensorArrayReadV3":{const s=W("tensorArrayId",t,e,n),r=W("index",t,e,n);return[n.getTensorArray(s.id).read(r)]}case"TensorArrayGatherV3":{const s=W("tensorArrayId",t,e,n),r=W("indices",t,e,n),o=W("dtype",t,e,n);return[n.getTensorArray(s.id).gather(r,o)]}case"TensorArrayScatterV3":{const s=W("tensorArrayId",t,e,n),r=W("indices",t,e,n),o=W("tensor",t,e,n),a=n.getTensorArray(s.id);return a.scatter(r,o),[a.idTensor]}case"TensorArrayConcatV3":{const s=W("tensorArrayId",t,e,n),r=n.getTensorArray(s.id),o=W("dtype",t,e,n);return[r.concat(o)]}case"TensorArraySplitV3":{const s=W("tensorArrayId",t,e,n),r=W("tensor",t,e,n),o=W("lengths",t,e,n),a=n.getTensorArray(s.id);return a.split(o,r),[a.idTensor]}case"TensorArraySizeV3":{const s=W("tensorArrayId",t,e,n),r=n.getTensorArray(s.id);return[an(r.size(),"int32")]}case"TensorArrayCloseV3":{const s=W("tensorArrayId",t,e,n),r=n.getTensorArray(s.id);return r.clearAndClose(),[r.idTensor]}case"TensorListSetItem":{const s=W("tensorListId",t,e,n),r=W("index",t,e,n),o=W("tensor",t,e,n),a=n.getTensorList(s.id);return a.setItem(r,o),[a.idTensor]}case"TensorListGetItem":{const s=W("tensorListId",t,e,n),r=W("index",t,e,n),o=W("elementShape",t,e,n),a=W("elementDType",t,e,n);return[n.getTensorList(s.id).getItem(r,o,a)]}case"TensorListScatterV2":case"TensorListScatter":{const s=W("indices",t,e,n),r=W("tensor",t,e,n),o=W("elementShape",t,e,n),a=W("numElements",t,e,n),i=szt(r,s,o,a);return n.addTensorList(i),[i.idTensor]}case"TensorListReserve":case"EmptyTensorList":{const s=W("elementShape",t,e,n),r=W("elementDType",t,e,n);let o;t.op==="TensorListReserve"?o="numElements":o="maxNumElements";const a=W(o,t,e,n),i=t.op==="TensorListReserve"?-1:a,l=nzt(s,r,a,i);return n.addTensorList(l),[l.idTensor]}case"TensorListGather":{const s=W("tensorListId",t,e,n),r=W("indices",t,e,n),o=W("elementShape",t,e,n),a=W("elementDType",t,e,n);return[n.getTensorList(s.id).gather(r,a,o)]}case"TensorListStack":{const s=W("tensorListId",t,e,n),r=W("elementShape",t,e,n),o=W("elementDType",t,e,n),a=W("numElements",t,e,n);return[n.getTensorList(s.id).stack(r,o,a)]}case"TensorListFromTensor":{const s=W("tensor",t,e,n),r=W("elementShape",t,e,n),o=W("elementDType",t,e,n),a=tzt(s,r,o);return n.addTensorList(a),[a.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{const s=W("tensorListId",t,e,n),r=n.getTensorList(s.id),o=W("dtype",t,e,n),a=W("elementShape",t,e,n);return[r.concat(o,a)]}case"TensorListPushBack":{const s=W("tensorListId",t,e,n),r=W("tensor",t,e,n),o=n.getTensorList(s.id);return o.pushBack(r),[o.idTensor]}case"TensorListPopBack":{const s=W("tensorListId",t,e,n),r=W("elementShape",t,e,n),o=W("elementDType",t,e,n);return[n.getTensorList(s.id).popBack(r,o)]}case"TensorListSplit":{const s=W("tensor",t,e,n),r=W("elementShape",t,e,n),o=W("lengths",t,e,n),a=rzt(s,o,r);return n.addTensorList(a),[a.idTensor]}case"TensorListLength":{const s=W("tensorListId",t,e,n),r=n.getTensorList(s.id);return[an(r.size(),"int32")]}case"TensorListResize":{const s=W("tensorListId",t,e,n),r=W("size",t,e,n),a=n.getTensorList(s.id).resize(r);return n.addTensorList(a),[a.idTensor]}default:throw TypeError(`Node type ${t.op} is not implemented`)}};function M9(t,e,n){const[s,r]=W("fusedOps",t,e,n),o=s==="biasadd",a=!o,i=r==="prelu",l=s==="fusedbatchnorm",u=W("numArgs",t,e,n);if(o){if(i&&u!==2)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!i&&o&&u!==1)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(l)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");const c=W("strides",t,e,n),d=yy(t,e,n),f=W("dataFormat",t,e,n).toUpperCase(),h=W("dilations",t,e,n);let[p,m]=W("args",t,e,n);a&&(m=p,p=void 0);const g=W("leakyreluAlpha",t,e,n);return{stride:c,pad:d,dataFormat:f,dilations:h,biasArg:p,preluArg:m,activationFunc:r,leakyreluAlpha:g}}const azt=(t,e,n,s=_r)=>{switch(t.op){case"Conv1D":{const r=W("stride",t,e,n),o=W("pad",t,e,n),a=W("dataFormat",t,e,n).toUpperCase(),i=W("dilation",t,e,n);return[s.conv1d(W("x",t,e,n),W("filter",t,e,n),r,o,a,i)]}case"Conv2D":{const r=W("strides",t,e,n),o=yy(t,e,n),a=W("dataFormat",t,e,n).toUpperCase(),i=W("dilations",t,e,n);return[s.conv2d(W("x",t,e,n),W("filter",t,e,n),[r[1],r[2]],o,a,[i[1],i[2]])]}case"_FusedConv2D":{const{stride:r,pad:o,dataFormat:a,dilations:i,biasArg:l,preluArg:u,activationFunc:c,leakyreluAlpha:d}=M9(t,e,n);return[s.fused.conv2d({x:W("x",t,e,n),filter:W("filter",t,e,n),strides:[r[1],r[2]],pad:o,dataFormat:a,dilations:[i[1],i[2]],bias:l,activation:c,preluActivationWeights:u,leakyreluAlpha:d})]}case"FusedDepthwiseConv2dNative":{const{stride:r,pad:o,dataFormat:a,dilations:i,biasArg:l,preluArg:u,activationFunc:c,leakyreluAlpha:d}=M9(t,e,n);return[s.fused.depthwiseConv2d({x:W("x",t,e,n),filter:W("filter",t,e,n),strides:[r[1],r[2]],pad:o,dataFormat:a,dilations:[i[1],i[2]],bias:l,activation:c,preluActivationWeights:u,leakyreluAlpha:d})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{const r=W("outputShape",t,e,n),o=W("strides",t,e,n),a=yy(t,e,n);return[s.conv2dTranspose(W("x",t,e,n),W("filter",t,e,n),r,[o[1],o[2]],a)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{const r=W("strides",t,e,n),o=yy(t,e,n),a=W("dilations",t,e,n),i=W("dataFormat",t,e,n).toUpperCase();return[s.depthwiseConv2d(W("input",t,e,n),W("filter",t,e,n),[r[1],r[2]],o,i,[a[1],a[2]])]}case"Conv3D":{const r=W("strides",t,e,n),o=W("pad",t,e,n),a=W("dataFormat",t,e,n).toUpperCase(),i=W("dilations",t,e,n);return[s.conv3d(W("x",t,e,n),W("filter",t,e,n),[r[1],r[2],r[3]],o,a,[i[1],i[2],i[3]])]}case"AvgPool":{const r=W("strides",t,e,n),o=W("pad",t,e,n),a=W("kernelSize",t,e,n);return[s.avgPool(W("x",t,e,n),[a[1],a[2]],[r[1],r[2]],o)]}case"MaxPool":{const r=W("strides",t,e,n),o=W("pad",t,e,n),a=W("kernelSize",t,e,n);return[s.maxPool(W("x",t,e,n),[a[1],a[2]],[r[1],r[2]],o)]}case"MaxPoolWithArgmax":{const r=W("strides",t,e,n),o=W("pad",t,e,n),a=W("kernelSize",t,e,n),i=W("includeBatchInIndex",t,e,n),{result:l,indexes:u}=s.maxPoolWithArgmax(W("x",t,e,n),[a[1],a[2]],[r[1],r[2]],o,i);return[l,u]}case"AvgPool3D":{const r=W("strides",t,e,n),o=W("pad",t,e,n),a=W("kernelSize",t,e,n);return[s.avgPool3d(W("x",t,e,n),[a[1],a[2],a[3]],[r[1],r[2],r[3]],o)]}case"MaxPool3D":{const r=W("strides",t,e,n),o=W("pad",t,e,n),a=W("kernelSize",t,e,n);return[s.maxPool3d(W("x",t,e,n),[a[1],a[2],a[3]],[r[1],r[2],r[3]],o)]}case"Dilation2D":{const r=W("strides",t,e,n),o=W("pad",t,e,n),a=W("dilations",t,e,n),i=r[1],l=r[2],u=a[1],c=a[2];return[s.dilation2d(W("x",t,e,n),W("filter",t,e,n),[i,l],o,[u,c],"NHWC")]}default:throw TypeError(`Node type ${t.op} is not implemented`)}};const izt=(t,e,n,s=_r)=>{switch(t.op){case"Fill":{const r=W("shape",t,e,n),o=W("dtype",t,e,n),a=W("value",t,e,n);return[s.fill(r,a,o)]}case"LinSpace":{const r=W("start",t,e,n),o=W("stop",t,e,n),a=W("num",t,e,n);return[s.linspace(r,o,a)]}case"Multinomial":{const r=W("logits",t,e,n),o=W("numSamples",t,e,n),a=W("seed",t,e,n);return[s.multinomial(r,o,a)]}case"OneHot":{const r=W("indices",t,e,n),o=W("depth",t,e,n),a=W("onValue",t,e,n),i=W("offValue",t,e,n),l=W("dtype",t,e,n);return[s.oneHot(r,o,a,i,l)]}case"Ones":return[s.ones(W("shape",t,e,n),W("dtype",t,e,n))];case"OnesLike":return[s.onesLike(W("x",t,e,n))];case"RandomStandardNormal":return[s.randomStandardNormal(W("shape",t,e,n),W("dtype",t,e,n),W("seed",t,e,n))];case"RandomUniform":return[s.randomUniform(W("shape",t,e,n),W("minval",t,e,n),W("maxval",t,e,n),W("dtype",t,e,n))];case"Range":{const r=W("start",t,e,n),o=W("stop",t,e,n),a=W("step",t,e,n);return[s.range(r,o,a,W("dtype",t,e,n))]}case"TruncatedNormal":{const r=W("shape",t,e,n),o=W("mean",t,e,n),a=W("stdDev",t,e,n),i=W("seed",t,e,n);return[s.truncatedNormal(r,o,a,W("dtype",t,e,n),i)]}case"Zeros":return[s.zeros(W("shape",t,e,n),W("dtype",t,e,n))];case"ZerosLike":return[s.zerosLike(W("x",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};function z$(t,e,n){const s=W("boxes",t,e,n),r=W("scores",t,e,n),o=W("maxOutputSize",t,e,n),a=W("iouThreshold",t,e,n),i=W("scoreThreshold",t,e,n),l=W("softNmsSigma",t,e,n);return{boxes:s,scores:r,maxOutputSize:o,iouThreshold:a,scoreThreshold:i,softNmsSigma:l}}const lzt=async(t,e,n,s,r=_r)=>{switch(t.op){case"NonMaxSuppressionV5":{const{boxes:o,scores:a,maxOutputSize:i,iouThreshold:l,scoreThreshold:u,softNmsSigma:c}=z$(t,e,n),d=await r.image.nonMaxSuppressionWithScoreAsync(o,a,i,l,u,c);return[d.selectedIndices,d.selectedScores]}case"NonMaxSuppressionV4":{const{boxes:o,scores:a,maxOutputSize:i,iouThreshold:l,scoreThreshold:u}=z$(t,e,n),c=W("padToMaxOutputSize",t,e,n),d=await r.image.nonMaxSuppressionPaddedAsync(o,a,i,l,u,c);return[d.selectedIndices,d.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{const{boxes:o,scores:a,maxOutputSize:i,iouThreshold:l,scoreThreshold:u}=z$(t,e,n);return[await r.image.nonMaxSuppressionAsync(o,a,i,l,u)]}case"Where":{const o=r.cast(W("condition",t,e,n),"bool"),a=[await r.whereAsync(o)];return o.dispose(),a}case"ListDiff":return r.setdiff1dAsync(W("x",t,e,n),W("y",t,e,n));default:throw TypeError(`Node type ${t.op} is not implemented`)}};const uzt=(t,e,n,s=_r)=>{switch(t.op){case"LowerBound":{const r=W("sortedSequence",t,e,n),o=W("values",t,e,n);return[s.lowerBound(r,o)]}case"TopKV2":{const r=W("x",t,e,n),o=W("k",t,e,n),a=W("sorted",t,e,n),i=s.topk(r,o,a);return[i.values,i.indices]}case"UpperBound":{const r=W("sortedSequence",t,e,n),o=W("values",t,e,n);return[s.upperBound(r,o)]}case"Unique":{const r=W("x",t,e,n),o=s.unique(r);return[o.values,o.indices]}case"UniqueV2":{const r=W("x",t,e,n),o=W("axis",t,e,n),a=s.unique(r,o);return[a.values,a.indices]}default:throw TypeError(`Node type ${t.op} is not implemented`)}};const czt=(t,e,n,s=_r)=>{switch(t.op){case"Const":return e[t.name];case"PlaceholderWithDefault":const r=W("default",t,e,n);return[Ar(t.name,e,n)||r];case"Placeholder":return[Ar(t.name,e,n)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":{const c=W("x",t,e,n);return[cl(c)]}case"IdentityN":return W("x",t,e,n).map(c=>cl(c));case"Snapshot":const o=W("x",t,e,n);return[cl(o)];case"Shape":return[s.tensor1d(W("x",t,e,n).shape,"int32")];case"ShapeN":return W("x",t,e,n).map(c=>s.tensor1d(c.shape));case"Size":return[s.scalar(W("x",t,e,n).size,"int32")];case"Rank":return[s.scalar(W("x",t,e,n).rank,"int32")];case"NoOp":return[s.scalar(1)];case"Print":const a=W("x",t,e,n),i=W("data",t,e,n),l=W("message",t,e,n),u=W("summarize",t,e,n);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(l);for(let c=0;c<i.length;c++)console.log(Array.prototype.slice.call(i[c].dataSync()).slice(0,u));return[a];default:throw TypeError(`Node type ${t.op} is not implemented`)}};class dzt{constructor(e,n){this.keyDType=e,this.valueDType=n,this.handle=an(0),this.tensorMap=new Map,Ii(this.handle)}get id(){return this.handle.id}clearAndClose(){this.tensorMap.forEach(e=>e.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return an(this.size(),"int32")}async import(e,n){this.checkKeyAndValueTensor(e,n);const s=await e.data();return this.tensorMap.forEach(r=>r.dispose()),this.tensorMap.clear(),vn(()=>{const r=_c(n),o=s.length,a=r.length;le(o===a,()=>`The number of elements doesn't match, keys has ${o} elements, the values has ${a} elements.`);for(let i=0;i<o;i++){const l=s[i],u=r[i];Ii(u),this.tensorMap.set(l,u)}return this.handle})}async find(e,n){this.checkKeyAndValueTensor(e,n);const s=await e.data();return vn(()=>{const r=[];for(let o=0;o<s.length;o++){const a=s[o],i=this.findWithDefault(a,n);r.push(i)}return Xi(r)})}findWithDefault(e,n){const s=this.tensorMap.get(e);return s??n}checkKeyAndValueTensor(e,n){if(e.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${e.dtype}`);if(n.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${n.dtype}`)}}const fzt=async(t,e,n,s)=>{switch(t.op){case"HashTable":case"HashTableV2":{const r=W("keyDType",t,e,n),o=W("valueDType",t,e,n),a=new dzt(r,o);return s.addHashTable(t.name,a),[a.handle]}case"LookupTableImport":case"LookupTableImportV2":{const r=W("tableHandle",t,e,n,s),o=W("keys",t,e,n),a=W("values",t,e,n);return[await s.getHashTableById(r.id).import(o,a)]}case"LookupTableFind":case"LookupTableFindV2":{const r=W("tableHandle",t,e,n,s),o=W("keys",t,e,n),a=W("defaultValue",t,e,n);return[await s.getHashTableById(r.id).find(o,a)]}case"LookupTableSize":case"LookupTableSizeV2":{const r=W("tableHandle",t,e,n,s);return[s.getHashTableById(r.id).tensorSize()]}default:throw TypeError(`Node type ${t.op} is not implemented`)}};const hzt=(t,e,n,s=_r)=>{switch(t.op){case"ResizeBilinear":{const r=W("images",t,e,n),o=W("size",t,e,n),a=W("alignCorners",t,e,n),i=W("halfPixelCenters",t,e,n);return[s.image.resizeBilinear(r,[o[0],o[1]],a,i)]}case"ResizeNearestNeighbor":{const r=W("images",t,e,n),o=W("size",t,e,n),a=W("alignCorners",t,e,n),i=W("halfPixelCenters",t,e,n);return[s.image.resizeNearestNeighbor(r,[o[0],o[1]],a,i)]}case"CropAndResize":{const r=W("image",t,e,n),o=W("boxes",t,e,n),a=W("boxInd",t,e,n),i=W("cropSize",t,e,n),l=W("method",t,e,n),u=W("extrapolationValue",t,e,n);return[s.image.cropAndResize(r,o,a,i,l,u)]}case"ImageProjectiveTransformV3":{const r=W("images",t,e,n),o=W("transforms",t,e,n),a=W("outputShape",t,e,n),i=W("fillValue",t,e,n),l=W("interpolation",t,e,n),u=W("fillMode",t,e,n);return[s.image.transform(r,o,l.toLowerCase(),u.toLowerCase(),i,a)]}default:throw TypeError(`Node type ${t.op} is not implemented`)}};const pzt=(t,e,n,s=_r)=>{switch(t.op){case"Equal":return[s.equal(W("a",t,e,n),W("b",t,e,n))];case"NotEqual":return[s.notEqual(W("a",t,e,n),W("b",t,e,n))];case"Greater":return[s.greater(W("a",t,e,n),W("b",t,e,n))];case"GreaterEqual":return[s.greaterEqual(W("a",t,e,n),W("b",t,e,n))];case"Less":return[s.less(W("a",t,e,n),W("b",t,e,n))];case"LessEqual":return[s.lessEqual(W("a",t,e,n),W("b",t,e,n))];case"LogicalAnd":return[s.logicalAnd(W("a",t,e,n),W("b",t,e,n))];case"LogicalNot":return[s.logicalNot(W("a",t,e,n))];case"LogicalOr":return[s.logicalOr(W("a",t,e,n),W("b",t,e,n))];case"Select":case"SelectV2":return[s.where(W("condition",t,e,n),W("a",t,e,n),W("b",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};const mzt=(t,e,n,s=_r)=>{switch(t.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[s.matMul(W("a",t,e,n),W("b",t,e,n),W("transposeA",t,e,n),W("transposeB",t,e,n))];case"Einsum":return[s.einsum(W("equation",t,e,n),...W("tensors",t,e,n))];case"Transpose":return[s.transpose(W("x",t,e,n),W("perm",t,e,n))];case"_FusedMatMul":const[r,o]=W("fusedOps",t,e,n),a=r==="biasadd",i=o==="prelu",l=W("numArgs",t,e,n),u=W("leakyreluAlpha",t,e,n);if(a){if(i&&l!==2)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!i&&l!==1)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}const[c,d]=W("args",t,e,n);return[s.fused.matMul({a:W("a",t,e,n),b:W("b",t,e,n),transposeA:W("transposeA",t,e,n),transposeB:W("transposeB",t,e,n),bias:c,activation:o,preluActivationWeights:d,leakyreluAlpha:u})];default:throw TypeError(`Node type ${t.op} is not implemented`)}};const gzt=(t,e,n,s=_r)=>{switch(t.op){case"EuclideanNorm":return[s.euclideanNorm(W("x",t,e,n),W("axis",t,e,n),W("keepDims",t,e,n))];case"FusedBatchNorm":case"FusedBatchNormV2":return[s.batchNorm(W("x",t,e,n),W("mean",t,e,n),W("variance",t,e,n),W("offset",t,e,n),W("scale",t,e,n),W("epsilon",t,e,n))];case"FusedBatchNormV3":return[s.batchNorm(W("x",t,e,n),W("mean",t,e,n),W("variance",t,e,n),W("offset",t,e,n),W("scale",t,e,n),W("epsilon",t,e,n))];case"LRN":return[s.localResponseNormalization(W("x",t,e,n),W("radius",t,e,n),W("bias",t,e,n),W("alpha",t,e,n),W("beta",t,e,n))];case"Softmax":return[s.softmax(W("x",t,e,n))];case"LogSoftmax":return[s.logSoftmax(W("x",t,e,n))];case"SparseToDense":return[s.sparseToDense(W("sparseIndices",t,e,n),W("outputShape",t,e,n),W("sparseValues",t,e,n),W("defaultValue",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};const vzt=(t,e,n,s=_r)=>{switch(t.op){case"Max":{const i=W("axis",t,e,n),l=W("keepDims",t,e,n);return[s.max(W("x",t,e,n),i,l)]}case"Mean":{const i=W("axis",t,e,n),l=W("keepDims",t,e,n);return[s.mean(W("x",t,e,n),i,l)]}case"Min":{const i=W("axis",t,e,n),l=W("keepDims",t,e,n);return[s.min(W("x",t,e,n),i,l)]}case"Sum":{const i=W("axis",t,e,n),l=W("keepDims",t,e,n);return[s.sum(W("x",t,e,n),i,l)]}case"All":{const i=W("axis",t,e,n),l=W("keepDims",t,e,n);return[s.all(W("x",t,e,n),i,l)]}case"Any":{const i=W("axis",t,e,n),l=W("keepDims",t,e,n);return[s.any(W("x",t,e,n),i,l)]}case"ArgMax":{const i=W("axis",t,e,n);return[s.argMax(W("x",t,e,n),i)]}case"ArgMin":{const i=W("axis",t,e,n);return[s.argMin(W("x",t,e,n),i)]}case"Prod":{const i=W("axis",t,e,n),l=W("keepDims",t,e,n);return[s.prod(W("x",t,e,n),i,l)]}case"Cumprod":{const i=W("axis",t,e,n),l=W("exclusive",t,e,n),u=W("reverse",t,e,n);return[s.cumprod(W("x",t,e,n),i,l,u)]}case"Cumsum":{const i=W("axis",t,e,n),l=W("exclusive",t,e,n),u=W("reverse",t,e,n);return[s.cumsum(W("x",t,e,n),i,l,u)]}case"Bincount":const r=W("x",t,e,n),o=W("weights",t,e,n),a=W("size",t,e,n);return[s.bincount(r,o,a)];case"DenseBincount":{const i=W("x",t,e,n),l=W("weights",t,e,n),u=W("size",t,e,n),c=W("binaryOutput",t,e,n);return[s.denseBincount(i,l,u,c)]}default:throw TypeError(`Node type ${t.op} is not implemented`)}};const yzt=(t,e,n,s=_r)=>{switch(t.op){case"ConcatV2":case"Concat":{const r=W("n",t,e,n),o=W("axis",t,e,n);let a=W("tensors",t,e,n);return a=a.slice(0,r),[s.concat(a,o)]}case"Gather":{const r=W("x",t,e,n),o=W("indices",t,e,n);return[s.gather(r,s.cast(o,"int32"),0)]}case"GatherV2":{const r=W("axis",t,e,n),o=W("batchDims",t,e,n),a=W("x",t,e,n),i=W("indices",t,e,n);return[s.gather(a,s.cast(i,"int32"),r,o)]}case"Reverse":{const r=W("dims",t,e,n),o=[];for(let i=0;i<r.length;i++)r[i]&&o.push(i);const a=W("x",t,e,n);return[s.reverse(a,o)]}case"ReverseV2":{const r=W("axis",t,e,n),o=W("x",t,e,n);return[s.reverse(o,r)]}case"Slice":{const r=W("begin",t,e,n),o=W("size",t,e,n);return[s.slice(W("x",t,e,n),r,o)]}case"StridedSlice":{const r=W("begin",t,e,n),o=W("end",t,e,n),a=W("strides",t,e,n),i=W("beginMask",t,e,n),l=W("endMask",t,e,n),u=W("ellipsisMask",t,e,n),c=W("newAxisMask",t,e,n),d=W("shrinkAxisMask",t,e,n),f=W("x",t,e,n);return[s.stridedSlice(f,r,o,a,i,l,u,c,d)]}case"Pack":return vn(()=>{const r=W("axis",t,e,n),o=W("tensors",t,e,n),a=o[0].shape,i=s.squeeze(o[0]).shape,l=o.map(u=>{const c=Ui(u.shape,a);if(!c&&!Ui(s.squeeze(u).shape,i))throw new Error("the input tensors shape does not match");return c?u:s.reshape(u,a)});return[s.stack(l,r)]});case"Unpack":{const r=W("axis",t,e,n),o=W("tensor",t,e,n);return s.unstack(o,r)}case"Tile":{const r=W("reps",t,e,n);return[s.tile(W("x",t,e,n),r)]}case"Split":case"SplitV":{const r=W("axis",t,e,n),o=W("numOrSizeSplits",t,e,n),a=W("x",t,e,n);return s.split(a,o,r)}case"ScatterNd":{const r=W("indices",t,e,n),o=W("values",t,e,n),a=W("shape",t,e,n);return[s.scatterND(r,o,a)]}case"GatherNd":{const r=W("x",t,e,n),o=W("indices",t,e,n);return[s.gatherND(r,o)]}case"SparseToDense":{const r=W("sparseIndices",t,e,n),o=W("outputShape",t,e,n),a=W("sparseValues",t,e,n),i=W("defaultValue",t,e,n);return[s.sparseToDense(r,a,o,a.dtype===i.dtype?i:s.cast(i,a.dtype))]}default:throw TypeError(`Node type ${t.op} is not implemented`)}};const bzt=(t,e,n,s=_r)=>{switch(t.op){case"SparseFillEmptyRows":{const{outputIndices:r,outputValues:o,emptyRowIndicator:a,reverseIndexMap:i}=s.sparse.sparseFillEmptyRows(W("indices",t,e,n),W("values",t,e,n),W("denseShape",t,e,n),W("defaultValue",t,e,n));return[r,o,a,i]}case"SparseReshape":{const{outputIndices:r,outputShape:o}=s.sparse.sparseReshape(W("inputIndices",t,e,n),W("inputShape",t,e,n),W("newShape",t,e,n));return[r,o]}case"SparseSegmentMean":return[s.sparse.sparseSegmentMean(W("data",t,e,n),W("indices",t,e,n),W("segmentIds",t,e,n))];case"SparseSegmentSum":return[s.sparse.sparseSegmentSum(W("data",t,e,n),W("indices",t,e,n),W("segmentIds",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};const wzt=(t,e,n,s=_r)=>{switch(t.op){case"FFT":return[s.fft(W("x",t,e,n))];case"IFFT":return[s.ifft(W("x",t,e,n))];case"RFFT":return[s.rfft(W("x",t,e,n))];case"IRFFT":return[s.irfft(W("x",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};const _zt=(t,e,n,s=_r)=>{switch(t.op){case"StringNGrams":{const{nGrams:r,nGramsSplits:o}=s.string.stringNGrams(W("data",t,e,n),W("dataSplits",t,e,n),W("separator",t,e,n),W("nGramWidths",t,e,n),W("leftPad",t,e,n),W("rightPad",t,e,n),W("padWidth",t,e,n),W("preserveShortSequences",t,e,n));return[r,o]}case"StringSplit":{const{indices:r,values:o,shape:a}=s.string.stringSplit(W("input",t,e,n),W("delimiter",t,e,n),W("skipEmpty",t,e,n));return[r,o,a]}case"StringToHashBucketFast":return[s.string.stringToHashBucketFast(W("input",t,e,n),W("numBuckets",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};const $zt=(t,e,n,s=_r)=>{switch(t.op){case"Cast":return[s.cast(W("x",t,e,n),W("dtype",t,e,n))];case"ExpandDims":{const r=W("axis",t,e,n);return[s.expandDims(W("x",t,e,n),r)]}case"Squeeze":{const r=W("axis",t,e,n);return[s.squeeze(W("x",t,e,n),r)]}case"Reshape":return[s.reshape(W("x",t,e,n),W("shape",t,e,n))];case"MirrorPad":return[s.mirrorPad(W("x",t,e,n),W("padding",t,e,n),W("mode",t,e,n))];case"PadV2":case"Pad":return[s.pad(W("x",t,e,n),W("padding",t,e,n),W("constantValue",t,e,n))];case"SpaceToBatchND":{const r=W("blockShape",t,e,n),o=W("paddings",t,e,n);return[s.spaceToBatchND(W("x",t,e,n),r,o)]}case"BatchToSpaceND":{const r=W("blockShape",t,e,n),o=W("crops",t,e,n);return[s.batchToSpaceND(W("x",t,e,n),r,o)]}case"DepthToSpace":{const r=W("blockSize",t,e,n),o=W("dataFormat",t,e,n).toUpperCase();return[s.depthToSpace(W("x",t,e,n),r,o)]}case"BroadcastTo":return[s.broadcastTo(W("x",t,e,n),W("shape",t,e,n))];case"BroadcastArgs":return[s.broadcastArgs(W("s0",t,e,n),W("s1",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};function P9(t,e,n,s,r=vn){const o=((a,i,l)=>{switch(a.category){case"arithmetic":return r(()=>JLt(a,i,l));case"basic_math":return r(()=>QLt(a,i,l));case"control":return ozt(a,i,l);case"convolution":return r(()=>azt(a,i,l));case"creation":return r(()=>izt(a,i,l));case"dynamic":return lzt(a,i,l);case"evaluation":return r(()=>uzt(a,i,l));case"image":return r(()=>hzt(a,i,l));case"graph":return r(()=>czt(a,i,l));case"logical":return r(()=>pzt(a,i,l));case"matrices":return r(()=>mzt(a,i,l));case"normalization":return r(()=>gzt(a,i,l));case"reduction":return r(()=>vzt(a,i,l));case"slice_join":return r(()=>yzt(a,i,l));case"sparse":return r(()=>bzt(a,i,l));case"spectral":return r(()=>wzt(a,i,l));case"string":return r(()=>_zt(a,i,l));case"transformation":return r(()=>$zt(a,i,l));case"hash_table":return fzt(a,i,l,s);case"custom":const u=DJ(a.op);if(u&&u.customExecutor)return u.customExecutor(new ZLt(a,i,l));throw TypeError(`Custom op ${a.op} is not registered.`);default:throw TypeError(`Unknown op '${a.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(t,e,n);return Hd(o)?o.then(a=>[].concat(a)):[].concat(o)}class L9{constructor(e={},n={},s={},r={}){this.weightMap=e,this.tensorArrayMap=n,this.tensorListMap=s,this.functionMap=r,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(e,n){return{id:e,frameName:n,iterationId:0}}set currentContext(e){this.contexts!==e&&(this.contexts=e,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){const e=[];for(let n=0;n<this.contexts.length-1;n++){const s=this.contexts.slice(0,this.contexts.length-n);e.push(this.contextIdforContexts(s))}e.push(""),this._currentContextIds=e}contextIdforContexts(e){return e?e.map(n=>n.id===0&&n.iterationId===0?"":`${n.frameName}-${n.iterationId}`).join("/"):""}enterFrame(e){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,e)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(this.contexts&&this.contexts.length>1)this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift();else throw new Error("Cannot exit frame, the context is empty")}nextIteration(){if(this.contexts&&this.contexts.length>0){this.contexts=this.contexts.slice(),this.lastId++;const e=Object.assign({},this.contexts[this.contexts.length-1]);e.iterationId+=1,e.id=this.lastId,this.contexts.splice(-1,1,e),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}else throw new Error("Cannot increase frame iteration, the context is empty")}getWeight(e){return this.weightMap[e]}addTensorArray(e){this.tensorArrayMap[e.id]=e}getTensorArray(e){return this.tensorArrayMap[e]}addTensorList(e){this.tensorListMap[e.id]=e}getTensorList(e){return this.tensorListMap[e]}dispose(e){for(const n in this.tensorArrayMap)this.tensorArrayMap[n].clearAndClose(e);for(const n in this.tensorListMap)this.tensorListMap[n].clearAndClose(e)}}function z9(t,e,n,s){const r=new Set,o=[];let a=null,i=null;const l=new Set,u=Object.keys(t).map(f=>uo(f)[0]);let c=[];s!=null&&(c=s.map(f=>uo(f.name)[0]));const d=[...e];for(;d.length>0;){const f=d.pop();if((PJ(f)||Tzt(f)||Nzt(f))&&a==null&&(a=f,i=a.children.map(h=>h.name).filter(h=>r.has(h))),r.add(f.name),n[f.name]==null&&u.indexOf(f.name)===-1&&c.indexOf(f.name)===-1){if(f.inputs.length===0){o.push(f.name);continue}f.inputs.forEach(h=>{l.has(h.name)||(l.add(h.name),d.push(h))})}}return{inputs:t,outputs:e,usedNodes:r,missingInputs:o,dynamicNode:a,syncInputs:i}}function xzt(t,e,n){const{usedNodes:s,inputs:r}=n,o=[],a=Object.keys(r).map(c=>uo(c)[0]).map(c=>t.nodes[c]),i=t.initNodes;a.forEach(c=>{s.has(c.name)&&o.push(c)}),t.weights.forEach(c=>{s.has(c.name)&&o.push(c)}),i!=null&&i.forEach(c=>{s.has(c.name)&&o.push(c)});const l=new Set,u=[];for(;o.length>0;){const c=o.pop();l.add(c.name),e[c.name]||u.push(c),c.children.forEach(d=>{!l.has(d.name)&&s.has(d.name)&&d.inputs.every(f=>l.has(f.name))&&o.push(d)})}return u}const Szt=["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"],Czt=["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"],kzt=["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"];function PJ(t){return Szt.indexOf(t.op)>=0}function Tzt(t){return Czt.indexOf(t.op)>=0}function Nzt(t){return kzt.indexOf(t.op)>=0}class Lb{constructor(e,n){this.graph=e,this.parent=n,this.compiledMap=new Map,this._weightMap={},this.SEPERATOR=",",this._functions={},this._functionExecutorMap={},this.intermediateTensors={},this.keepTensorForDebug=!1,this._outputs=e.outputs,this._inputs=e.inputs,this._initNodes=e.initNodes,this._signature=e.signature,this._functions=e.functions,e.functions!=null&&Object.keys(e.functions).forEach(s=>{this._functionExecutorMap[s]=new Lb(e.functions[s],this)})}get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(e){const n=Object.keys(e).map(s=>e[s].map(r=>r.id));this._weightIds=[].concat(...n),this._weightMap=e}set resourceManager(e){this._resourceManager=e}get inputs(){return this._inputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(e=>e.signatureKey||e.name)}get outputNodes(){return this._outputs.map(e=>{const n=e.signatureKey||e.name;return e.defaultOutput?`${n}:${e.defaultOutput}`:n})}get functions(){return Object.keys(this._functions).reduce((e,n)=>(e[n]=this._functions[n].signature,e),{})}getCompilationKey(e,n){const s=e.map(o=>o.name).sort(),r=n.map(o=>o.name).sort();return s.join(this.SEPERATOR)+"--"+r.join(this.SEPERATOR)}compile(e,n){const s=z9(e,n,this.weightMap,this._initNodes),{missingInputs:r,dynamicNode:o,syncInputs:a}=s;if(o!=null)throw new Error(`This execution contains the node '${o.name}', which has the dynamic op '${o.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${a}]`);if(r.length>0){const i=n.map(u=>u.name),l=Object.keys(e);throw new Error(`Cannot compute the outputs [${i}] from the provided inputs [${l}]. Missing the following inputs: [${r}]`)}return xzt(this.graph,this.weightMap,s)}execute(e,n){e=this.mapInputs(e);const s=Object.keys(e).sort();this.checkInputs(e),this.checkInputShapeAndType(e),n=this.mapOutputs(n),this.checkOutputs(n);const r=s.map(d=>this.graph.nodes[uo(d)[0]]),o=n.map(d=>uo(d)[0]);let a=o.map(d=>this.graph.nodes[d]);this.resetIntermediateTensors(),a.length===0&&(a=this._outputs);const i=this.getCompilationKey(r,a);let l=this.compiledMap.get(i);l==null&&(l=this.compile(e,a),this.compiledMap.set(i,l));const u={},c={};return vn(()=>{const d=new L9(this.weightMap,u,c,this.functionExecutorMap),f=Object.assign({},this.weightMap);Object.keys(e).forEach(m=>{const[g,y]=uo(m),w=[];w[y]=e[m],f[g]=w});const h=this.getFrozenTensorIds(f),p={};for(let m=0;m<l.length;m++){const g=l[m];if(!f[g.name]){const y=P9(g,f,d,this._resourceManager);if(Hd(y))throw new Error(`The execution of the op '${g.op}' returned a promise. Please use model.executeAsync() instead.`);f[g.name]=y,this.checkTensorForDisposal(g.name,g,f,d,h,o,p)}}return this.parent==null&&d.dispose(h),n.map(m=>Ar(m,f,d))})}getFrozenTensorIds(e){const n=[].concat.apply([],Object.keys(e).map(s=>e[s]).map(s=>s.map(r=>r.id)));return new Set(n)}checkTensorForDisposal(e,n,s,r,o,a,i){n.category==="control"||a.indexOf(e)!==-1||(s[e].forEach(l=>{l!=null&&(i[l.id]=(i[l.id]||0)+n.children.length)}),n.inputs.forEach(l=>{if(l.category!=="control"){const u=dLt(l.name,s,r);u!=null&&u.forEach(c=>{if(c&&!c.kept&&!o.has(c.id)){const d=i[c.id];if(d===1){if(!this.keepTensorForDebug)c.dispose();else{const[f,h]=bi(n.name,r);this.intermediateTensors[f]?this.intermediateTensors[f][h]=c:(this.intermediateTensors[f]=[],this.intermediateTensors[f][h]=c)}delete i[c.id]}else d!=null&&i[c.id]--}})}}))}async executeAsync(e,n){return this._executeAsync(e,n)}disposeIntermediateTensors(){!this.intermediateTensors||(Object.keys(this.intermediateTensors).forEach(e=>this.intermediateTensors[e].forEach(n=>n.dispose())),this.disposeTensorsMap())}disposeTensorsMap(){!this.tensorsMap||Object.keys(this.tensorsMap).forEach(e=>{this.tensorsMap[e].forEach(s=>{s&&!s.kept&&!s.isDisposed&&!this.keepIds.has(s.id)&&s.dispose()})})}getIntermediateTensors(){return this.tensorsMap}resetIntermediateTensors(){for(const e in this.intermediateTensors)this.intermediateTensors[e].forEach(n=>n.dispose()),delete this.intermediateTensors[e]}async _executeAsync(e,n,s=!1,r={},o={}){s||(e=this.mapInputs(e),this.checkInputs(e),this.checkInputShapeAndType(e),n=this.mapOutputs(n),this.checkOutputs(n));try{this.keepTensorForDebug=en().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(c){console.warn(c.message)}this.resetIntermediateTensors();const a=new L9(this.weightMap,r,o,this.functionExecutorMap);this.tensorsMap=await this.executeWithControlFlow(e,a,n,s);const i=n.map(c=>Ar(c,this.tensorsMap,a)),l=i.map(c=>c.id),u=Object.keys(e).map(c=>e[c].id);return this.keepIds=new Set([...l,...u,...this.weightIds]),this.keepTensorForDebug||this.disposeTensorsMap(),this.parent==null&&a.dispose(this.keepIds),i}async executeFunctionAsync(e,n,s){const r=e.reduce((o,a,i)=>(o[this.inputs[i].name]=a,o),{});return this._executeAsync(r,this.outputNodes,!0,n,s)}async executeWithControlFlow(e,n,s,r){const o=Object.keys(e),a=o.map(b=>this.graph.nodes[uo(b)[0]]),i=s.map(b=>uo(b)[0]);let l=i.map(b=>this.graph.nodes[b]);l.length===0&&(l=this._outputs);const{usedNodes:u,missingInputs:c,dynamicNode:d,syncInputs:f}=z9(e,l,this.weightMap,this._initNodes),h=[...a,...this.graph.weights,...this._initNodes||[]].map(b=>({node:b,contexts:n.currentContext})),p=Object.assign({},this.weightMap);Object.keys(e).forEach(b=>{const[_,$]=uo(b),x=[];x[$]=e[b],p[_]=x});const m={},g=this.getFrozenTensorIds(p),y={};for(;h.length>0;){const b=this.processStack(a,h,n,p,y,g,i,m,u);await Promise.all(b)}d==null&&!r&&console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");const w=l.filter(b=>!PJ(b)&&!Ar(b.name,p,n)).map(b=>b.name);if(w.length>0){let b="";throw d!=null&&(b=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${f}]`),new Error(`Cannot compute the outputs [${w}] from the provided inputs [${o}]. Consider providing the following inputs: [${c}]. ${b}`)}return p}processStack(e,n,s,r,o,a,i,l,u){const c=[];for(;n.length>0;){const d=n.pop();s.currentContext=d.contexts;let f="";if(d.node.op==="Enter"&&W("isConstant",d.node,r,s)&&([f]=bi(d.node.name,s)),r[d.node.name]==null){const h=P9(d.node,r,s,this._resourceManager);f||([f]=bi(d.node.name,s));const p=s.currentContext;Hd(h)?c.push(h.then(m=>(r[f]=m,s.currentContext=p,this.checkTensorForDisposal(f,d.node,r,s,a,i,l),this.processChildNodes(d.node,n,s,r,o,u),m))):(r[f]=h,this.checkTensorForDisposal(f,d.node,r,s,a,i,l),this.processChildNodes(d.node,n,s,r,o,u))}else this.processChildNodes(d.node,n,s,r,o,u)}return c}processChildNodes(e,n,s,r,o,a){e.children.forEach(i=>{const[l]=bi(i.name,s);o[l]||!a.has(i.name)||(i.op==="Merge"?i.inputNames.some(u=>!!Ar(u,r,s))&&(o[l]=!0,n.push({contexts:s.currentContext,node:i})):i.inputNames.every(u=>!!Ar(u,r,s))&&(o[l]=!0,n.push({contexts:s.currentContext,node:i})))})}dispose(){Object.keys(this.weightMap).forEach(e=>this.weightMap[e].forEach(n=>n.dispose()))}checkInputShapeAndType(e){Object.keys(e).forEach(n=>{const s=e[n],[r]=uo(n),o=this.graph.nodes[r];if(o.attrParams.shape&&o.attrParams.shape.value){const a=o.attrParams.shape.value,i=a.length===s.shape.length&&s.shape.every((l,u)=>a[u]===-1||a[u]===l);le(i,()=>`The shape of dict['${o.name}'] provided in model.execute(dict) must be [${a}], but was [${s.shape}]`)}o.attrParams.dtype&&o.attrParams.dtype.value&&le(s.dtype===o.attrParams.dtype.value,()=>`The dtype of dict['${o.name}'] provided in model.execute(dict) must be ${o.attrParams.dtype.value}, but was ${s.dtype}`)})}mapInputs(e){const n={};for(const s in e)if(this._signature!=null&&this._signature.inputs!=null&&this._signature.inputs[s]!=null){const r=this._signature.inputs[s];n[r.name]=e[s]}else n[s]=e[s];return n}checkInputs(e){const n=Object.keys(e).filter(s=>{const[r]=uo(s);return this.graph.nodes[r]==null});if(n.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${n}] that are not part of graph`)}mapOutputs(e){return e.map(n=>this._signature!=null&&this._signature.outputs!=null&&this._signature.outputs[n]!=null?this._signature.outputs[n].name:n,{})}checkOutputs(e){e.forEach(n=>{const[s]=uo(n);if(!this.graph.nodes[s])throw new Error(`The output '${n}' is not found in the graph`)})}}class Izt{constructor(e={},n={}){this.hashTableNameToHandle=e,this.hashTableMap=n}addHashTable(e,n){this.hashTableNameToHandle[e]=n.handle,this.hashTableMap[n.id]=n}getHashTableHandleByName(e){return this.hashTableNameToHandle[e]}getHashTableById(e){return this.hashTableMap[e]}dispose(){for(const e in this.hashTableMap)this.hashTableMap[e].clearAndClose(),delete this.hashTableMap[e];for(const e in this.hashTableNameToHandle)this.hashTableNameToHandle[e].dispose(),delete this.hashTableNameToHandle[e]}}const Ezt="?tfjs-format=file",Azt="model.json";class Ozt{constructor(e,n={},s=QI){this.modelUrl=e,this.loadOptions=n,this.version="n/a",this.io=s,n==null&&(this.loadOptions={}),this.resourceManager=new Izt}get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}findIOHandler(){const e=this.modelUrl;if(e.load!=null)this.handler=e;else if(this.loadOptions.requestInit!=null)this.handler=this.io.browserHTTPRequest(e,this.loadOptions);else{const n=this.io.getLoadHandlers(e,this.loadOptions);if(n.length===0)n.push(this.io.browserHTTPRequest(e,this.loadOptions));else if(n.length>1)throw new Error(`Found more than one (${n.length}) load handlers for URL '${[e]}'`);this.handler=n[0]}}load(){if(this.findIOHandler(),this.handler.load==null)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const e=this.handler.load();return Hd(e)?e.then(n=>this.loadSync(n)):this.loadSync(e)}loadSync(e){this.artifacts=e;const n=this.artifacts.modelTopology;let s=this.artifacts.signature;if(this.artifacts.userDefinedMetadata!=null){const o=this.artifacts.userDefinedMetadata;o.signature!=null&&(s=o.signature),o.structuredOutputKeys!=null&&(this.structuredOutputKeys=o.structuredOutputKeys)}this.signature=s,this.version=`${n.versions.producer}.${n.versions.minConsumer}`;const r=this.io.decodeWeights(this.artifacts.weightData,this.artifacts.weightSpecs);if(this.executor=new Lb(R9.Instance.transformGraph(n,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(r),this.executor.resourceManager=this.resourceManager,e.modelInitializer!=null&&e.modelInitializer.node!=null){const o=R9.Instance.transformGraph(e.modelInitializer);this.initializer=new Lb(o),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializer.executeAsync({},[])}return!0}async save(e,n){if(typeof e=="string"){const s=this.io.getSaveHandlers(e);if(s.length===0)throw new Error(`Cannot find any save handlers for URL '${e}'`);if(s.length>1)throw new Error(`Found more than one (${s.length}) save handlers for URL '${e}'`);e=s[0]}if(e.save==null)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return e.save(this.artifacts)}predict(e,n){const s=this.execute(e,this.outputNodes);if(this.structuredOutputKeys){const r=s instanceof os?[s]:s,o={};return r.forEach((a,i)=>o[this.structuredOutputKeys[i]]=a),o}return s}normalizeInputs(e){if(!(e instanceof os)&&!Array.isArray(e))return e;if(e=Array.isArray(e)?e:[e],e.length!==this.inputNodes.length)throw new Error(`Input tensor count mismatch,the graph model has ${this.inputNodes.length} placeholders, while there are ${e.length} input tensors.`);return this.inputNodes.reduce((n,s,r)=>(n[s]=e[r],n),{})}normalizeOutputs(e){return e=e||this.outputNodes,Array.isArray(e)?e:[e]}execute(e,n){e=this.normalizeInputs(e),n=this.normalizeOutputs(n);const s=this.executor.execute(e,n);return s.length>1?s:s[0]}async executeAsync(e,n){e=this.normalizeInputs(e),n=this.normalizeOutputs(n);const s=await this.executor.executeAsync(e,n);return s.length>1?s:s[0]}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(e){return Object.keys(e).reduce((n,s)=>(n[s]=[e[s]],n),{})}dispose(){this.executor.dispose(),this.initializer&&this.initializer.dispose(),this.resourceManager.dispose()}}async function LJ(t,e={},n=QI){if(t==null)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");e==null&&(e={}),e.fromTFHub&&typeof t=="string"&&(t=Rzt(t));const s=new Ozt(t,e,n);return await s.load(),s}function Rzt(t){return t.endsWith("/")||(t=t+"/"),`${t}${Azt}${Ezt}`}var zJ=function(t,e){return(zJ=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(n,s){n.__proto__=s}||function(n,s){for(var r in s)s.hasOwnProperty(r)&&(n[r]=s[r])})(t,e)};function BJ(t,e){function n(){this.constructor=t}zJ(t,e),t.prototype=e===null?Object.create(e):(n.prototype=e.prototype,new n)}var DS=function(){return(DS=Object.assign||function(t){for(var e,n=1,s=arguments.length;n<s;n++)for(var r in e=arguments[n])Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t}).apply(this,arguments)};function Vu(t,e,n,s){return new(n||(n=Promise))(function(r,o){function a(u){try{l(s.next(u))}catch(c){o(c)}}function i(u){try{l(s.throw(u))}catch(c){o(c)}}function l(u){u.done?r(u.value):new n(function(c){c(u.value)}).then(a,i)}l((s=s.apply(t,e||[])).next())})}function Hu(t,e){var n,s,r,o,a={label:0,sent:function(){if(1&r[0])throw r[1];return r[1]},trys:[],ops:[]};return o={next:i(0),throw:i(1),return:i(2)},typeof Symbol=="function"&&(o[Symbol.iterator]=function(){return this}),o;function i(l){return function(u){return function(c){if(n)throw new TypeError("Generator is already executing.");for(;a;)try{if(n=1,s&&(r=2&c[0]?s.return:c[0]?s.throw||((r=s.return)&&r.call(s),0):s.next)&&!(r=r.call(s,c[1])).done)return r;switch(s=0,r&&(c=[2&c[0],r.value]),c[0]){case 0:case 1:r=c;break;case 4:return a.label++,{value:c[1],done:!1};case 5:a.label++,s=c[1],c=[0];continue;case 7:c=a.ops.pop(),a.trys.pop();continue;default:if(!(r=(r=a.trys).length>0&&r[r.length-1])&&(c[0]===6||c[0]===2)){a=0;continue}if(c[0]===3&&(!r||c[1]>r[0]&&c[1]<r[3])){a.label=c[1];break}if(c[0]===6&&a.label<r[1]){a.label=r[1],r=c;break}if(r&&a.label<r[2]){a.label=r[2],a.ops.push(c);break}r[2]&&a.ops.pop(),a.trys.pop();continue}c=e.call(t,a)}catch(d){c=[6,d],s=0}finally{n=r=0}if(5&c[0])throw c[1];return{value:c[0]?c[1]:void 0,done:!0}}([l,u])}}}var VJ=function(){function t(e,n){this.model=e,this.outputStride=n;var s=this.model.inputs[0].shape;le(s[1]===-1&&s[2]===-1,function(){return"Input shape ["+s[1]+", "+s[2]+"] must both be equal to or -1"})}return t.prototype.predict=function(e){var n=this;return vn(function(){var s=n.preprocessInput(es(e,"float32")),r=Va(s,0),o=n.model.predict(r).map(function(i){return H2(i,[0])}),a=n.nameOutputResults(o);return{heatmapScores:Bu(a.heatmap),offsets:a.offsets,displacementFwd:a.displacementFwd,displacementBwd:a.displacementBwd}})},t.prototype.dispose=function(){this.model.dispose()},t}(),HJ=function(t){function e(){return t!==null&&t.apply(this,arguments)||this}return BJ(e,t),e.prototype.preprocessInput=function(n){return vn(function(){return rn(En(n,127.5),1)})},e.prototype.nameOutputResults=function(n){return{offsets:n[0],heatmap:n[1],displacementFwd:n[2],displacementBwd:n[3]}},e}(VJ);function B$(t){return Math.floor(t/2)}var Dzt=function(){function t(e,n){this.priorityQueue=new Array(e),this.numberOfElements=-1,this.getElementValue=n}return t.prototype.enqueue=function(e){this.priorityQueue[++this.numberOfElements]=e,this.swim(this.numberOfElements)},t.prototype.dequeue=function(){var e=this.priorityQueue[0];return this.exchange(0,this.numberOfElements--),this.sink(0),this.priorityQueue[this.numberOfElements+1]=null,e},t.prototype.empty=function(){return this.numberOfElements===-1},t.prototype.size=function(){return this.numberOfElements+1},t.prototype.all=function(){return this.priorityQueue.slice(0,this.numberOfElements+1)},t.prototype.max=function(){return this.priorityQueue[0]},t.prototype.swim=function(e){for(;e>0&&this.less(B$(e),e);)this.exchange(e,B$(e)),e=B$(e)},t.prototype.sink=function(e){for(;2*e<=this.numberOfElements;){var n=2*e;if(n<this.numberOfElements&&this.less(n,n+1)&&n++,!this.less(e,n))break;this.exchange(e,n),e=n}},t.prototype.getValueAt=function(e){return this.getElementValue(this.priorityQueue[e])},t.prototype.less=function(e,n){return this.getValueAt(e)<this.getValueAt(n)},t.prototype.exchange=function(e,n){var s=this.priorityQueue[e];this.priorityQueue[e]=this.priorityQueue[n],this.priorityQueue[n]=s},t}();function Fzt(t,e,n,s,r,o){for(var a=o.shape,i=a[0],l=a[1],u=!0,c=Math.max(n-r,0),d=Math.min(n+r+1,i),f=c;f<d;++f){for(var h=Math.max(s-r,0),p=Math.min(s+r+1,l),m=h;m<p;++m)if(o.get(f,m,t)>e){u=!1;break}if(!u)break}return u}function Mzt(t,e,n){for(var s=n.shape,r=s[0],o=s[1],a=s[2],i=new Dzt(r*o*a,function(f){return f.score}),l=0;l<r;++l)for(var u=0;u<o;++u)for(var c=0;c<a;++c){var d=n.get(l,u,c);d<t||Fzt(c,d,l,u,e,n)&&i.enqueue({score:d,part:{heatmapY:l,heatmapX:u,id:c}})}return i}var Sm=["nose","leftEye","rightEye","leftEar","rightEar","leftShoulder","rightShoulder","leftElbow","rightElbow","leftWrist","rightWrist","leftHip","rightHip","leftKnee","rightKnee","leftAnkle","rightAnkle"],zb=Sm.length,$g=Sm.reduce(function(t,e,n){return t[e]=n,t},{}),Pzt=[["leftHip","leftShoulder"],["leftElbow","leftShoulder"],["leftElbow","leftWrist"],["leftHip","leftKnee"],["leftKnee","leftAnkle"],["rightHip","rightShoulder"],["rightElbow","rightShoulder"],["rightElbow","rightWrist"],["rightHip","rightKnee"],["rightKnee","rightAnkle"],["leftShoulder","rightShoulder"],["leftHip","rightHip"]],WJ=[["nose","leftEye"],["leftEye","leftEar"],["nose","rightEye"],["rightEye","rightEar"],["nose","leftShoulder"],["leftShoulder","leftElbow"],["leftElbow","leftWrist"],["leftShoulder","leftHip"],["leftHip","leftKnee"],["leftKnee","leftAnkle"],["nose","rightShoulder"],["rightShoulder","rightElbow"],["rightElbow","rightWrist"],["rightShoulder","rightHip"],["rightHip","rightKnee"],["rightKnee","rightAnkle"]],Lzt=Pzt.map(function(t){var e=t[0],n=t[1];return[$g[e],$g[n]]}),zzt=["left_face","right_face","right_upper_leg_front","right_lower_leg_back","right_upper_leg_back","left_lower_leg_front","left_upper_leg_front","left_upper_leg_back","left_lower_leg_back","right_feet","right_lower_leg_front","left_feet","torso_front","torso_back","right_upper_arm_front","right_upper_arm_back","right_lower_arm_back","left_lower_arm_front","left_upper_arm_front","left_upper_arm_back","left_lower_arm_back","right_hand","right_lower_arm_front","left_hand"];function UJ(t,e,n,s){return{y:s.get(t,e,n),x:s.get(t,e,n+zb)}}function GJ(t,e,n){var s=UJ(t.heatmapY,t.heatmapX,t.id,n),r=s.y,o=s.x;return{x:t.heatmapX*e+o,y:t.heatmapY*e+r}}function B9(t,e,n){return t<e?e:t>n?n:t}function Bzt(t,e,n,s){var r=n-t,o=s-e;return r*r+o*o}function V9(t,e){return{x:t.x+e.x,y:t.y+e.y}}var jJ=WJ.map(function(t){var e=t[0],n=t[1];return[$g[e],$g[n]]}),V$=jJ.map(function(t){return t[1]}),H9=jJ.map(function(t){return t[0]});function Vzt(t,e,n){var s=n.shape[2]/2;return{y:n.get(e.y,e.x,t),x:n.get(e.y,e.x,s+t)}}function H$(t,e,n,s){return{y:B9(Math.round(t.y/e),0,n-1),x:B9(Math.round(t.x/e),0,s-1)}}function W9(t,e,n,s,r,o,a,i){i===void 0&&(i=2);for(var l=s.shape,u=l[0],c=l[1],d=Vzt(t,H$(e.position,o,u,c),a),f=V9(e.position,d),h=0;h<i;h++){var p=H$(f,o,u,c),m=UJ(p.y,p.x,n,r);f=V9({x:p.x*o,y:p.y*o},{x:m.x,y:m.y})}var g=H$(f,o,u,c),y=s.get(g.y,g.x,n);return{position:f,part:Sm[n],score:y}}function Hzt(t,e,n,s,r,o){var a=e.shape[2],i=V$.length,l=new Array(a),u=t.part,c=t.score,d=GJ(u,s,n);l[u.id]={score:c,part:Sm[u.id],position:d};for(var f=i-1;f>=0;--f){var h=V$[f],p=H9[f];l[h]&&!l[p]&&(l[p]=W9(f,l[h],p,e,n,s,o))}for(f=0;f<i;++f)h=H9[f],p=V$[f],l[h]&&!l[p]&&(l[p]=W9(f,l[h],p,e,n,s,r));return l}function KJ(t,e,n,s){var r=n.x,o=n.y;return t.some(function(a){var i=a.keypoints[s].position;return Bzt(o,r,i.y,i.x)<=e})}function Wzt(t,e,n){return n.reduce(function(s,r,o){var a=r.position,i=r.score;return KJ(t,e,a,o)||(s+=i),s},0)/n.length}var Uzt=1;function qJ(t,e,n,s,r,o,a,i){a===void 0&&(a=.5),i===void 0&&(i=20);for(var l=[],u=Mzt(a,Uzt,t),c=i*i;l.length<o&&!u.empty();){var d=u.dequeue();if(!KJ(l,c,GJ(d.part,r,e),d.part.id)){var f=Hzt(d,t,e,r,n,s),h=Wzt(l,c,f);l.push({keypoints:f,score:h})}}return l}function Gzt(t,e){return vn(function(){var n=En(t,an(e,"int32"));return rn(t,gt(n,an(e,"int32")))})}function jzt(t){var e=t.shape,n=e[0],s=e[1],r=e[2];return vn(function(){var o=Ze(t,[n*s,r]),a=iE(o,0),i=Va(En(a,an(s,"int32")),1),l=Va(Gzt(a,s),1);return sr([i,l],1)})}function Kzt(t,e){for(var n=e.shape[0],s=new Float32Array(n),r=0;r<n;r++){var o=e.get(r,0),a=e.get(r,1);s[r]=t.get(o,a,r)}return s}function qzt(t,e,n,s){return{y:s.get(t,e,n),x:s.get(t,e,n+zb)}}function Xzt(t,e){for(var n=[],s=0;s<zb;s++){var r=qzt(t.get(s,0).valueOf(),t.get(s,1).valueOf(),s,e),o=r.x,a=r.y;n.push(a),n.push(o)}return gd(n,[zb,2])}function Yzt(t,e,n){return vn(function(){var s=Xzt(t,n);return Wt(es(gt(t.toTensor(),an(e,"int32")),"float32"),s)})}function XJ(t,e,n){return Vu(this,void 0,void 0,function(){var s,r,o,a,i,l,u,c,d,f;return Hu(this,function(h){switch(h.label){case 0:return s=0,r=jzt(t),[4,Promise.all([t.buffer(),e.buffer(),r.buffer()])];case 1:return o=h.sent(),a=o[0],i=o[1],l=o[2],[4,(u=Yzt(l,n,i)).buffer()];case 2:return c=h.sent(),d=Array.from(Kzt(a,l)),f=d.map(function(p,m){return s+=p,{position:{y:c.get(m,0),x:c.get(m,1)},part:Sm[m],score:p}}),r.dispose(),u.dispose(),[2,{keypoints:f,score:s/f.length}]}})})}var U9="https://storage.googleapis.com/tfjs-models/savedmodel/posenet/mobilenet/",G9="https://storage.googleapis.com/tfjs-models/savedmodel/posenet/resnet50/";function Zzt(t,e){var n="model-stride"+t+".json";return e===4?G9+"float/"+n:G9+"quant"+e+"/"+n}function Jzt(t,e,n){var s={1:"100",.75:"075",.5:"050"},r="model-stride"+t+".json";return n===4?U9+"float/"+s[e]+"/"+r:U9+"quant"+n+"/"+s[e]+"/"+r}var Qzt=[-123.15,-115.9,-103.06],e7t=function(t){function e(){return t!==null&&t.apply(this,arguments)||this}return BJ(e,t),e.prototype.preprocessInput=function(n){return Wt(n,Qzt)},e.prototype.nameOutputResults=function(n){var s=n[0],r=n[1];return{offsets:n[2],heatmap:n[3],displacementFwd:s,displacementBwd:r}},e}(VJ);function t7t(t,e,n){return t<n||e<n}function n7t(t,e){return Lzt.reduce(function(n,s){var r=s[0],o=s[1];return t7t(t[r].score,t[o].score,e)||n.push([t[r],t[o]]),n},[])}var j9=Number.NEGATIVE_INFINITY,K9=Number.POSITIVE_INFINITY;function YJ(t){return t.reduce(function(e,n){var s=e.maxX,r=e.maxY,o=e.minX,a=e.minY,i=n.position,l=i.x,u=i.y;return{maxX:Math.max(s,l),maxY:Math.max(r,u),minX:Math.min(o,l),minY:Math.min(a,u)}},{maxX:j9,maxY:j9,minX:K9,minY:K9})}function s7t(t){var e=YJ(t),n=e.minX,s=e.minY,r=e.maxX,o=e.maxY;return[{x:n,y:s},{x:r,y:s},{x:r,y:o},{x:n,y:o}]}function r7t(t){return Vu(this,void 0,void 0,function(){return Hu(this,function(e){return[2,Promise.all(t.map(function(n){return n.buffer()}))]})})}function ZJ(t,e,n,s,r){return s===void 0&&(s=0),r===void 0&&(r=0),{score:t.score,keypoints:t.keypoints.map(function(o){var a=o.score,i=o.part,l=o.position;return{score:a,part:i,position:{x:l.x*n+r,y:l.y*e+s}}})}}function o7t(t,e,n,s,r){return s===void 0&&(s=0),r===void 0&&(r=0),n===1&&e===1&&s===0&&r===0?t:t.map(function(o){return ZJ(o,e,n,s,r)})}function a7t(t,e){return{score:t.score,keypoints:t.keypoints.map(function(n){var s=n.score,r=n.part,o=n.position;return{score:s,part:r,position:{x:e-1-o.x,y:o.y}}})}}function i7t(t,e){return e<=0?t:t.map(function(n){return a7t(n,e)})}function Rv(t,e){return FS(t,e)?t:Math.floor(t/e)*e+1}function JJ(t){le(typeof t=="number"||typeof t=="object",function(){return"Invalid inputResolution "+t+". Should be a number or an object with width and height"}),typeof t=="object"&&(le(typeof t.width=="number",function(){return"inputResolution.width has a value of "+t.width+" which is invalid; it must be a number"}),le(typeof t.height=="number",function(){return"inputResolution.height has a value of "+t.height+" which is invalid; it must be a number"}))}function QJ(t,e){return JJ(t),typeof t=="object"?[Rv(t.height,e),Rv(t.width,e)]:[Rv(t,e),Rv(t,e)]}var l7t=[8,16,32];function u7t(t){le(typeof t=="number",function(){return"outputStride is not a number"}),le(l7t.indexOf(t)>=0,function(){return"outputStride of "+t+" is invalid. It must be either 8, 16, or 32"})}function FS(t,e){return(t-1)%e==0}function c7t(t,e){le(typeof t[0]=="number"&&typeof t[1]=="number",function(){return"both resolution values must be a number but had values "+t}),le(FS(t[0],e),function(){return"height of "+t[0]+" is invalid for output stride "+e+"."}),le(FS(t[1],e),function(){return"width of "+t[1]+" is invalid for output stride "+e+"."})}function MS(t){return t instanceof os?[t.shape[0],t.shape[1]]:[t.height,t.width]}function d7t(t){return t instanceof os?t:tY(t)}function q9(t,e){var n=e[0],s=e[1],r=MS(t),o=r[0],a=r[1],i=s/n,l=[0,0,0,0],u=l[0],c=l[1],d=l[2],f=l[3];return a/o<i?(u=0,c=0,d=Math.round(.5*(i*o-a)),f=Math.round(.5*(i*o-a))):(u=Math.round(.5*(1/i*a-o)),c=Math.round(.5*(1/i*a-o)),d=0,f=0),{resized:vn(function(){var h=d7t(t);return h=IE(h,[[u,c],[d,f],[0,0]]),WE.resizeBilinear(h,[n,s])}),padding:{top:u,left:d,right:f,bottom:c}}}function PS(t,e,n,s,r){var o=e[0],a=e[1],i=n[0],l=n[1],u=o7t(t,(o+s.top+s.bottom)/i,(a+s.left+s.right)/l,-s.top,-s.left);return r?i7t(u,a):u}var eQ={architecture:"MobileNetV1",outputStride:16,multiplier:.75,inputResolution:257},X9=["MobileNetV1","ResNet50"],Y9={MobileNetV1:[8,16,32],ResNet50:[32,16]},Z9={MobileNetV1:[.5,.75,1],ResNet50:[1]},J9=[1,2,4];function f7t(t){if((t=t||eQ).architecture==null&&(t.architecture="MobileNetV1"),X9.indexOf(t.architecture)<0)throw new Error("Invalid architecture "+t.architecture+". Should be one of "+X9);if(t.inputResolution==null&&(t.inputResolution=257),JJ(t.inputResolution),t.outputStride==null&&(t.outputStride=16),Y9[t.architecture].indexOf(t.outputStride)<0)throw new Error("Invalid outputStride "+t.outputStride+". Should be one of "+Y9[t.architecture]+" for architecture "+t.architecture+".");if(t.multiplier==null&&(t.multiplier=1),Z9[t.architecture].indexOf(t.multiplier)<0)throw new Error("Invalid multiplier "+t.multiplier+". Should be one of "+Z9[t.architecture]+" for architecture "+t.architecture+".");if(t.quantBytes==null&&(t.quantBytes=4),J9.indexOf(t.quantBytes)<0)throw new Error("Invalid quantBytes "+t.quantBytes+". Should be one of "+J9+" for architecture "+t.architecture+".");if(t.architecture==="MobileNetV1"&&t.outputStride===32&&t.multiplier!==1)throw new Error("When using an output stride of 32, you must select 1 as the multiplier.");return t}var Q9={flipHorizontal:!1},eF={flipHorizontal:!1,maxDetections:5,scoreThreshold:.5,nmsRadius:20};function h7t(t){var e=t.maxDetections,n=t.scoreThreshold,s=t.nmsRadius;if(e<=0)throw new Error("Invalid maxDetections "+e+". Should be > 0");if(n<0||n>1)throw new Error("Invalid scoreThreshold "+n+". Should be in range [0.0, 1.0]");if(s<=0)throw new Error("Invalid nmsRadius "+s+".")}var KE=function(){function t(e,n){u7t(e.outputStride),c7t(n,e.outputStride),this.baseModel=e,this.inputResolution=n}return t.prototype.estimateMultiplePoses=function(e,n){return n===void 0&&(n=eF),Vu(this,void 0,void 0,function(){var s,r,o,a,i,l,u,c,d,f,h,p,m,g,y,w,b,_,$,x,k;return Hu(this,function(C){switch(C.label){case 0:return s=DS({},eF,n),h7t(n),r=this.baseModel.outputStride,o=this.inputResolution,a=MS(e),i=a[0],l=a[1],u=q9(e,o),c=u.resized,d=u.padding,f=this.baseModel.predict(c),h=f.heatmapScores,p=f.offsets,m=f.displacementFwd,g=f.displacementBwd,[4,r7t([h,p,m,g])];case 1:return y=C.sent(),w=y[0],b=y[1],_=y[2],$=y[3],[4,qJ(w,b,_,$,r,s.maxDetections,s.scoreThreshold,s.nmsRadius)];case 2:return x=C.sent(),k=PS(x,[i,l],o,d,s.flipHorizontal),h.dispose(),p.dispose(),m.dispose(),g.dispose(),c.dispose(),[2,k]}})})},t.prototype.estimateSinglePose=function(e,n){return n===void 0&&(n=Q9),Vu(this,void 0,void 0,function(){var s,r,o,a,i,l,u,c,d,f,h,p,m,g,y,w;return Hu(this,function(b){switch(b.label){case 0:return s=DS({},Q9,n),r=this.baseModel.outputStride,o=this.inputResolution,a=MS(e),i=a[0],l=a[1],u=q9(e,o),c=u.resized,d=u.padding,f=this.baseModel.predict(c),h=f.heatmapScores,p=f.offsets,m=f.displacementFwd,g=f.displacementBwd,[4,XJ(h,p,r)];case 1:return y=b.sent(),w=PS([y],[i,l],o,d,s.flipHorizontal),h.dispose(),p.dispose(),m.dispose(),g.dispose(),c.dispose(),[2,w[0]]}})})},t.prototype.estimatePoses=function(e,n){return Vu(this,void 0,void 0,function(){return Hu(this,function(s){switch(s.label){case 0:return n.decodingMethod!=="single-person"?[3,2]:[4,this.estimateSinglePose(e,n)];case 1:return[2,[s.sent()]];case 2:return[2,this.estimateMultiplePoses(e,n)]}})})},t.prototype.dispose=function(){this.baseModel.dispose()},t}();function p7t(t){return Vu(this,void 0,void 0,function(){var e,n,s,r,o,a,i;return Hu(this,function(l){switch(l.label){case 0:if(e=t.outputStride,n=t.quantBytes,s=t.multiplier,GE==null)throw new Error(`Cannot find TensorFlow.js. If you are using a <script> tag, please also include @tensorflow/tfjs on the page before using this
        model.`);return r=Jzt(e,s,n),[4,LJ(t.modelUrl||r)];case 1:return o=l.sent(),a=new HJ(o,e),i=QJ(t.inputResolution,a.outputStride),[2,new KE(a,i)]}})})}function m7t(t){return Vu(this,void 0,void 0,function(){var e,n,s,r,o,a;return Hu(this,function(i){switch(i.label){case 0:if(e=t.outputStride,n=t.quantBytes,GE==null)throw new Error(`Cannot find TensorFlow.js. If you are using a <script> tag, please also include @tensorflow/tfjs on the page before using this
        model.`);return s=Zzt(e,n),[4,LJ(t.modelUrl||s)];case 1:return r=i.sent(),o=new e7t(r,e),a=QJ(t.inputResolution,o.outputStride),[2,new KE(o,a)]}})})}function g7t(t){return t===void 0&&(t=eQ),Vu(this,void 0,void 0,function(){return Hu(this,function(e){return(t=f7t(t)).architecture==="ResNet50"?[2,m7t(t)]:t.architecture==="MobileNetV1"?[2,p7t(t)]:[2,null]})})}var v7t="2.2.2";const y7t=Object.freeze(Object.defineProperty({__proto__:null,decodeMultiplePoses:qJ,decodeSinglePose:XJ,MobileNet:HJ,partChannels:zzt,partIds:$g,partNames:Sm,poseChain:WJ,load:g7t,PoseNet:KE,getAdjacentKeyPoints:n7t,getBoundingBox:YJ,getBoundingBoxPoints:s7t,scaleAndFlipPoses:PS,scalePose:ZJ,version:v7t},Symbol.toStringTag,{value:"Module"})),tQ=Mg(y7t);var Es={};const b7t=Mg(GE);var nQ={};(function(t){Object.defineProperty(t,"__esModule",{value:!0}),t.partNames=["nose","leftEye","rightEye","leftEar","rightEar","leftShoulder","rightShoulder","leftElbow","rightElbow","leftWrist","rightWrist","leftHip","rightHip","leftKnee","rightKnee","leftAnkle","rightAnkle"],t.NUM_KEYPOINTS=t.partNames.length,t.partIds=t.partNames.reduce(function(n,s,r){return n[s]=r,n},{});var e=[["leftHip","leftShoulder"],["leftElbow","leftShoulder"],["leftElbow","leftWrist"],["leftHip","leftKnee"],["leftKnee","leftAnkle"],["rightHip","rightShoulder"],["rightElbow","rightShoulder"],["rightElbow","rightWrist"],["rightHip","rightKnee"],["rightKnee","rightAnkle"],["leftShoulder","rightShoulder"],["leftHip","rightHip"]];t.poseChain=[["nose","leftEye"],["leftEye","leftEar"],["nose","rightEye"],["rightEye","rightEar"],["nose","leftShoulder"],["leftShoulder","leftElbow"],["leftElbow","leftWrist"],["leftShoulder","leftHip"],["leftHip","leftKnee"],["leftKnee","leftAnkle"],["nose","rightShoulder"],["rightShoulder","rightElbow"],["rightElbow","rightWrist"],["rightShoulder","rightHip"],["rightHip","rightKnee"],["rightKnee","rightAnkle"]],t.connectedPartIndices=e.map(function(n){var s=n[0],r=n[1];return[t.partIds[s],t.partIds[r]]}),t.partChannels=["left_face","right_face","right_upper_leg_front","right_lower_leg_back","right_upper_leg_back","left_lower_leg_front","left_upper_leg_front","left_upper_leg_back","left_lower_leg_back","right_feet","right_lower_leg_front","left_feet","torso_front","torso_back","right_upper_arm_front","right_upper_arm_back","right_lower_arm_back","left_lower_arm_front","left_upper_arm_front","left_upper_arm_back","left_lower_arm_back","right_hand","right_lower_arm_front","left_hand"]})(nQ);var w7t=wn&&wn.__awaiter||function(t,e,n,s){return new(n||(n=Promise))(function(r,o){function a(u){try{l(s.next(u))}catch(c){o(c)}}function i(u){try{l(s.throw(u))}catch(c){o(c)}}function l(u){u.done?r(u.value):new n(function(c){c(u.value)}).then(a,i)}l((s=s.apply(t,e||[])).next())})},_7t=wn&&wn.__generator||function(t,e){var n={label:0,sent:function(){if(o[0]&1)throw o[1];return o[1]},trys:[],ops:[]},s,r,o,a;return a={next:i(0),throw:i(1),return:i(2)},typeof Symbol=="function"&&(a[Symbol.iterator]=function(){return this}),a;function i(u){return function(c){return l([u,c])}}function l(u){if(s)throw new TypeError("Generator is already executing.");for(;n;)try{if(s=1,r&&(o=u[0]&2?r.return:u[0]?r.throw||((o=r.return)&&o.call(r),0):r.next)&&!(o=o.call(r,u[1])).done)return o;switch(r=0,o&&(u=[u[0]&2,o.value]),u[0]){case 0:case 1:o=u;break;case 4:return n.label++,{value:u[1],done:!1};case 5:n.label++,r=u[1],u=[0];continue;case 7:u=n.ops.pop(),n.trys.pop();continue;default:if(o=n.trys,!(o=o.length>0&&o[o.length-1])&&(u[0]===6||u[0]===2)){n=0;continue}if(u[0]===3&&(!o||u[1]>o[0]&&u[1]<o[3])){n.label=u[1];break}if(u[0]===6&&n.label<o[1]){n.label=o[1],o=u;break}if(o&&n.label<o[2]){n.label=o[2],n.ops.push(u);break}o[2]&&n.ops.pop(),n.trys.pop();continue}u=e.call(t,n)}catch(c){u=[6,c],r=0}finally{s=o=0}if(u[0]&5)throw u[1];return{value:u[0]?u[1]:void 0,done:!0}}};Object.defineProperty(Es,"__esModule",{value:!0});var tr=b7t,$7t=nQ;function x7t(t,e,n){return t<n||e<n}function S7t(t,e){return $7t.connectedPartIndices.reduce(function(n,s){var r=s[0],o=s[1];return x7t(t[r].score,t[o].score,e)||n.push([t[r],t[o]]),n},[])}Es.getAdjacentKeyPoints=S7t;var tF=Number.NEGATIVE_INFINITY,nF=Number.POSITIVE_INFINITY;function sQ(t){return t.reduce(function(e,n){var s=e.maxX,r=e.maxY,o=e.minX,a=e.minY,i=n.position,l=i.x,u=i.y;return{maxX:Math.max(s,l),maxY:Math.max(r,u),minX:Math.min(o,l),minY:Math.min(a,u)}},{maxX:tF,maxY:tF,minX:nF,minY:nF})}Es.getBoundingBox=sQ;function C7t(t){var e=sQ(t),n=e.minX,s=e.minY,r=e.maxX,o=e.maxY;return[{x:n,y:s},{x:r,y:s},{x:r,y:o},{x:n,y:o}]}Es.getBoundingBoxPoints=C7t;function k7t(t){return w7t(this,void 0,void 0,function(){return _7t(this,function(e){return[2,Promise.all(t.map(function(n){return n.buffer()}))]})})}Es.toTensorBuffers3D=k7t;function rQ(t,e,n,s,r){return s===void 0&&(s=0),r===void 0&&(r=0),{score:t.score,keypoints:t.keypoints.map(function(o){var a=o.score,i=o.part,l=o.position;return{score:a,part:i,position:{x:l.x*n+r,y:l.y*e+s}}})}}Es.scalePose=rQ;function oQ(t,e,n,s,r){return s===void 0&&(s=0),r===void 0&&(r=0),n===1&&e===1&&s===0&&r===0?t:t.map(function(o){return rQ(o,e,n,s,r)})}Es.scalePoses=oQ;function aQ(t,e){return{score:t.score,keypoints:t.keypoints.map(function(n){var s=n.score,r=n.part,o=n.position;return{score:s,part:r,position:{x:e-1-o.x,y:o.y}}})}}Es.flipPoseHorizontal=aQ;function iQ(t,e){return e<=0?t:t.map(function(n){return aQ(n,e)})}Es.flipPosesHorizontal=iQ;function Qm(t,e){return LS(t,e)?t:Math.floor(t/e)*e+1}Es.toValidInputResolution=Qm;function lQ(t){tr.util.assert(typeof t=="number"||typeof t=="object",function(){return"Invalid inputResolution "+t+". Should be a number or an object with width and height"}),typeof t=="object"&&(tr.util.assert(typeof t.width=="number",function(){return"inputResolution.width has a value of "+t.width+" which is invalid; it must be a number"}),tr.util.assert(typeof t.height=="number",function(){return"inputResolution.height has a value of "+t.height+" which is invalid; it must be a number"}))}Es.validateInputResolution=lQ;function T7t(t,e){return lQ(t),typeof t=="object"?[Qm(t.height,e),Qm(t.width,e)]:[Qm(t,e),Qm(t,e)]}Es.getValidInputResolutionDimensions=T7t;var N7t=[8,16,32];function I7t(t){tr.util.assert(typeof t=="number",function(){return"outputStride is not a number"}),tr.util.assert(N7t.indexOf(t)>=0,function(){return"outputStride of "+t+" is invalid. It must be either 8, 16, or 32"})}Es.assertValidOutputStride=I7t;function LS(t,e){return(t-1)%e===0}function E7t(t,e){tr.util.assert(typeof t[0]=="number"&&typeof t[1]=="number",function(){return"both resolution values must be a number but had values "+t}),tr.util.assert(LS(t[0],e),function(){return"height of "+t[0]+" is invalid for output stride "+(e+".")}),tr.util.assert(LS(t[1],e),function(){return"width of "+t[1]+" is invalid for output stride "+(e+".")})}Es.assertValidResolution=E7t;function uQ(t){return t instanceof tr.Tensor?[t.shape[0],t.shape[1]]:[t.height,t.width]}Es.getInputTensorDimensions=uQ;function qE(t){return t instanceof tr.Tensor?t:tr.browser.fromPixels(t)}Es.toInputTensor=qE;function A7t(t,e,n,s){return tr.tidy(function(){var r=qE(t);return s?tr.image.resizeBilinear(tr.reverse(r,1),[e,n]):tr.image.resizeBilinear(r,[e,n])})}Es.toResizedInputTensor=A7t;function O7t(t,e){var n=e[0],s=e[1],r=uQ(t),o=r[0],a=r[1],i=s/n,l=a/o,u=[0,0,0,0],c=u[0],d=u[1],f=u[2],h=u[3];l<i?(c=0,d=0,f=Math.round(.5*(i*o-a)),h=Math.round(.5*(i*o-a))):(c=Math.round(.5*(1/i*a-o)),d=Math.round(.5*(1/i*a-o)),f=0,h=0);var p=tr.tidy(function(){var m=qE(t);return m=tr.pad3d(m,[[c,d],[f,h],[0,0]]),tr.image.resizeBilinear(m,[n,s])});return{resized:p,padding:{top:c,left:f,right:h,bottom:d}}}Es.padAndResizeTo=O7t;function R7t(t,e,n,s,r){var o=e[0],a=e[1],i=n[0],l=n[1],u=(o+s.top+s.bottom)/i,c=(a+s.left+s.right)/l,d=oQ(t,u,c,-s.top,-s.left);return r?iQ(d,a):d}Es.scaleAndFlipPoses=R7t;var C4={};Object.defineProperty(C4,"__esModule",{value:!0});var D7t="0.8.6";C4.version=D7t;var _i=wn&&wn.__awaiter||function(t,e,n,s){function r(o){return o instanceof n?o:new n(function(a){a(o)})}return new(n||(n=Promise))(function(o,a){function i(c){try{u(s.next(c))}catch(d){a(d)}}function l(c){try{u(s.throw(c))}catch(d){a(d)}}function u(c){c.done?o(c.value):r(c.value).then(i,l)}u((s=s.apply(t,e||[])).next())})},$i=wn&&wn.__generator||function(t,e){var n={label:0,sent:function(){if(o[0]&1)throw o[1];return o[1]},trys:[],ops:[]},s,r,o,a;return a={next:i(0),throw:i(1),return:i(2)},typeof Symbol=="function"&&(a[Symbol.iterator]=function(){return this}),a;function i(u){return function(c){return l([u,c])}}function l(u){if(s)throw new TypeError("Generator is already executing.");for(;n;)try{if(s=1,r&&(o=u[0]&2?r.return:u[0]?r.throw||((o=r.return)&&o.call(r),0):r.next)&&!(o=o.call(r,u[1])).done)return o;switch(r=0,o&&(u=[u[0]&2,o.value]),u[0]){case 0:case 1:o=u;break;case 4:return n.label++,{value:u[1],done:!1};case 5:n.label++,r=u[1],u=[0];continue;case 7:u=n.ops.pop(),n.trys.pop();continue;default:if(o=n.trys,!(o=o.length>0&&o[o.length-1])&&(u[0]===6||u[0]===2)){n=0;continue}if(u[0]===3&&(!o||u[1]>o[0]&&u[1]<o[3])){n.label=u[1];break}if(u[0]===6&&n.label<o[1]){n.label=o[1],o=u;break}if(o&&n.label<o[2]){n.label=o[2],n.ops.push(u);break}o[2]&&n.ops.pop(),n.trys.pop();continue}u=e.call(t,n)}catch(c){u=[6,c],r=0}finally{s=o=0}if(u[0]&5)throw u[1];return{value:u[0]?u[1]:void 0,done:!0}}};Object.defineProperty(cc,"__esModule",{value:!0});var vd=FI,F7t=tQ,Dv=Es,M7t=C4,P7t=tQ,sF=3,cQ=function(t){return t.packageVersion=t.packageVersion||M7t.version,t.packageName="@teachablemachine/pose",t.timeStamp=t.timeStamp||new Date().toISOString(),t.userMetadata=t.userMetadata||{},t.modelName=t.modelName||"untitled",t.labels=t.labels||[],t.modelSettings=fQ(t.modelSettings),t},L7t=function(t){return!!t&&Array.isArray(t.labels)},dQ=function(t){return _i(void 0,void 0,void 0,function(){var e,n;return $i(this,function(s){switch(s.label){case 0:return typeof t!="string"?[3,3]:[4,fetch(t)];case 1:return n=s.sent(),[4,n.json()];case 2:return e=s.sent(),[3,4];case 3:if(L7t(t))e=t;else throw new Error("Invalid Metadata provided");s.label=4;case 4:return[2,cQ(e)]}})})},fQ=function(t){return t===void 0&&(t={}),t.posenet||(t.posenet={}),t.posenet.architecture=t.posenet.architecture||"MobileNetV1",t.posenet.outputStride=t.posenet.outputStride||16,t.posenet.inputResolution=t.posenet.inputResolution||257,t.posenet.multiplier=t.posenet.multiplier||.75,t};function hQ(t,e,n){return n===void 0&&(n=3),_i(this,void 0,void 0,function(){var s;return $i(this,function(r){switch(r.label){case 0:return[4,e.data()];case 1:return s=r.sent(),[2,vd.tidy(function(){n=Math.min(n,s.length);for(var o=[],a=0;a<s.length;a++)o.push({value:s[a],index:a});o.sort(function(c,d){return d.value-c.value});for(var i=new Float32Array(n),l=new Int32Array(n),a=0;a<n;a++)i[a]=o[a].value,l[a]=o[a].index;for(var u=[],a=0;a<l.length;a++)u.push({className:t[l[a]],probability:i[a]});return u})]}})})}cc.getTopKClasses=hQ;var XE=function(){function t(e,n,s){this.model=e,this.posenetModel=n,this._metadata=cQ(s)}return t.prototype.getMetadata=function(){return this._metadata},t.prototype.getClassLabels=function(){return this._metadata.labels},t.prototype.getTotalClasses=function(){var e=this.model.output,n=e.shape[1];return n},t.prototype.estimatePose=function(e,n){return n===void 0&&(n=!1),_i(this,void 0,void 0,function(){var s,r,o,a,i,l,u,c;return $i(this,function(d){switch(d.label){case 0:return[4,this.estimatePoseOutputs(e)];case 1:return s=d.sent(),r=s.heatmapScores,o=s.offsets,a=s.displacementFwd,i=s.displacementBwd,l=s.padding,u=this.poseOutputsToAray(r,o,a,i),[4,this.poseOutputsToKeypoints(e,r,o,a,i,l,n)];case 2:return c=d.sent(),[2,{pose:c,posenetOutput:u}]}})})},t.prototype.estimatePoseOutputs=function(e){return _i(this,void 0,void 0,function(){var n,s,r,o,a,i,l,u,c;return $i(this,function(d){switch(d.label){case 0:return n=this.posenetModel.inputResolution,s=Dv.padAndResizeTo(e,n),r=s.resized,o=s.padding,[4,this.posenetModel.baseModel.predict(r)];case 1:return a=d.sent(),i=a.heatmapScores,l=a.offsets,u=a.displacementFwd,c=a.displacementBwd,r.dispose(),[2,{heatmapScores:i,offsets:l,displacementFwd:u,displacementBwd:c,padding:o}]}})})},t.prototype.poseOutputsToAray=function(e,n,s,r){var o=2,a=vd.concat([e,n],o),i=a.dataSync();return a.dispose(),i},t.prototype.poseOutputsToKeypoints=function(e,n,s,r,o,a,i){return i===void 0&&(i=!1),_i(this,void 0,void 0,function(){var l,u,c,d,f,h,p,m,g,y,w,b,_;return $i(this,function($){switch($.label){case 0:return l={maxDetections:sF,scoreThreshold:.5,nmsRadius:20},u=Dv.getInputTensorDimensions(e),c=u[0],d=u[1],f=this.posenetModel.baseModel.outputStride,h=this.posenetModel.inputResolution,[4,Dv.toTensorBuffers3D([n,s,r,o])];case 1:return p=$.sent(),m=p[0],g=p[1],y=p[2],w=p[3],[4,P7t.decodeMultiplePoses(m,g,y,w,f,l.maxDetections,l.scoreThreshold,l.nmsRadius)];case 2:return b=$.sent(),_=Dv.scaleAndFlipPoses(b,[c,d],h,a,i),n.dispose(),s.dispose(),r.dispose(),o.dispose(),[2,_[0]]}})})},t.prototype.predict=function(e){return _i(this,void 0,void 0,function(){var n,s,r,o,a;return $i(this,function(i){switch(i.label){case 0:return n=vd.tensor([e]),s=this.model.predict(n),[4,s.data()];case 1:for(r=i.sent(),o=[],a=0;a<r.length;a++)o.push({className:this._metadata.labels[a],probability:r[a]});return n.dispose(),s.dispose(),[2,o]}})})},t.prototype.predictTopK=function(e,n){return n===void 0&&(n=sF),_i(this,void 0,void 0,function(){var s,r,o;return $i(this,function(a){switch(a.label){case 0:return s=vd.tensor([e]),r=this.model.predict(s),[4,hQ(this._metadata.labels,r,n)];case 1:return o=a.sent(),s.dispose(),r.dispose(),[2,o]}})})},t.prototype.dispose=function(){this.posenetModel.dispose()},t}();cc.CustomPoseNet=XE;function YE(t){return t===void 0&&(t={}),_i(this,void 0,void 0,function(){var e;return $i(this,function(n){switch(n.label){case 0:return t=fQ(t),[4,F7t.load({architecture:t.posenet.architecture,outputStride:t.posenet.outputStride,inputResolution:t.posenet.inputResolution,multiplier:t.posenet.multiplier})];case 1:return e=n.sent(),[2,e]}})})}cc.loadPoseNet=YE;function z7t(t,e){return _i(this,void 0,void 0,function(){var n,s,r,o;return $i(this,function(a){switch(a.label){case 0:return[4,vd.loadLayersModel(t)];case 1:return n=a.sent(),e?[4,dQ(e)]:[3,3];case 2:return r=a.sent(),[3,4];case 3:r=null,a.label=4;case 4:return s=r,[4,YE(s.modelSettings)];case 5:return o=a.sent(),[2,new XE(n,o,s)]}})})}cc.load=z7t;function B7t(t,e,n){return _i(this,void 0,void 0,function(){var s,r,o,a,i;return $i(this,function(l){switch(l.label){case 0:return[4,vd.loadLayersModel(vd.io.browserFiles([t,e]))];case 1:return s=l.sent(),[4,new Response(n).json()];case 2:return r=l.sent(),n?[4,dQ(r)]:[3,4];case 3:return a=l.sent(),[3,5];case 4:a=null,l.label=5;case 5:return o=a,[4,YE(o.modelSettings)];case 6:return i=l.sent(),[2,new XE(s,i,o)]}})})}cc.loadFromFiles=B7t;var k4={};var V7t=wn&&wn.__extends||function(){var t=function(e,n){return t=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(s,r){s.__proto__=r}||function(s,r){for(var o in r)r.hasOwnProperty(o)&&(s[o]=r[o])},t(e,n)};return function(e,n){t(e,n);function s(){this.constructor=e}e.prototype=n===null?Object.create(n):(s.prototype=n.prototype,new s)}}(),sl=wn&&wn.__awaiter||function(t,e,n,s){function r(o){return o instanceof n?o:new n(function(a){a(o)})}return new(n||(n=Promise))(function(o,a){function i(c){try{u(s.next(c))}catch(d){a(d)}}function l(c){try{u(s.throw(c))}catch(d){a(d)}}function u(c){c.done?o(c.value):r(c.value).then(i,l)}u((s=s.apply(t,e||[])).next())})},rl=wn&&wn.__generator||function(t,e){var n={label:0,sent:function(){if(o[0]&1)throw o[1];return o[1]},trys:[],ops:[]},s,r,o,a;return a={next:i(0),throw:i(1),return:i(2)},typeof Symbol=="function"&&(a[Symbol.iterator]=function(){return this}),a;function i(u){return function(c){return l([u,c])}}function l(u){if(s)throw new TypeError("Generator is already executing.");for(;n;)try{if(s=1,r&&(o=u[0]&2?r.return:u[0]?r.throw||((o=r.return)&&o.call(r),0):r.next)&&!(o=o.call(r,u[1])).done)return o;switch(r=0,o&&(u=[u[0]&2,o.value]),u[0]){case 0:case 1:o=u;break;case 4:return n.label++,{value:u[1],done:!1};case 5:n.label++,r=u[1],u=[0];continue;case 7:u=n.ops.pop(),n.trys.pop();continue;default:if(o=n.trys,!(o=o.length>0&&o[o.length-1])&&(u[0]===6||u[0]===2)){n=0;continue}if(u[0]===3&&(!o||u[1]>o[0]&&u[1]<o[3])){n.label=u[1];break}if(u[0]===6&&n.label<o[1]){n.label=o[1],o=u;break}if(o&&n.label<o[2]){n.label=o[2],n.ops.push(u);break}o[2]&&n.ops.pop(),n.trys.pop();continue}u=e.call(t,n)}catch(c){u=[6,c],r=0}finally{s=o=0}if(u[0]&5)throw u[1];return{value:u[0]?u[1]:void 0,done:!0}}};Object.defineProperty(k4,"__esModule",{value:!0});var $r=FI,H7t=FI,pQ=cc,W7t=Ji,U7t=.15;function G7t(t,e){var n=new Array(e).fill(0);return n[t]=1,n}function W$(t,e){for(var n,s=t.length,r=t.slice(),o=s-1;o>0;o-=1){var a=void 0;e?a=Math.floor(e()*(o+1)):a=Math.floor(Math.random()*(o+1)),n=[r[a],r[o]],r[o]=n[0],r[a]=n[1]}return r}var mQ=function(t){V7t(e,t);function e(n,s,r){var o=t.call(this,n,s,r)||this;return o.model=n,o.posenetModel=s,o.examples=[],o}return Object.defineProperty(e.prototype,"isTrained",{get:function(){return!!this.model&&this.model.layers&&this.model.layers.length>2},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"isPrepared",{get:function(){return!!this.trainDataset},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"numClasses",{get:function(){return this._metadata.labels.length},enumerable:!0,configurable:!0}),e.prototype.addExample=function(n,s){return sl(this,void 0,void 0,function(){return rl(this,function(r){return this.examples[n].push(s),[2]})})},e.prototype.predict=function(n){return sl(this,void 0,void 0,function(){return rl(this,function(s){if(!this.model)throw new Error("Model has not been trained yet, called train() first");return[2,t.prototype.predict.call(this,n)]})})},e.prototype.predictTopK=function(n,s){return s===void 0&&(s=3),sl(this,void 0,void 0,function(){return rl(this,function(r){if(!this.model)throw new Error("Model has not been trained yet, called train() first");return[2,t.prototype.predictTopK.call(this,n,s)]})})},e.prototype.prepare=function(){for(var n in this.examples)if(n.length===0)throw new Error("Add some examples before training");var s=this.convertToTfDataset();this.trainDataset=s.trainDataset,this.validationDataset=s.validationDataset},e.prototype.convertToTfDataset=function(){for(var n=0;n<this.examples.length;n++)this.examples[n]=W$(this.examples[n],this.seed);for(var s=[],r=[],o=function(d){var f=G7t(d,a.numClasses),h=a.examples[d].length,p=Math.ceil(U7t*h),m=h-p,g=a.examples[d].slice(0,m).map(function(w){return{data:w,label:f}}),y=a.examples[d].slice(m).map(function(w){return{data:w,label:f}});s=s.concat(g),r=r.concat(y)},a=this,n=0;n<this.examples.length;n++)o(n);s=W$(s,this.seed),r=W$(r,this.seed);var i=$r.data.array(s.map(function(d){return d.data})),l=$r.data.array(r.map(function(d){return d.data})),u=$r.data.array(s.map(function(d){return d.label})),c=$r.data.array(r.map(function(d){return d.label}));return{trainDataset:$r.data.zip({xs:i,ys:u}),validationDataset:$r.data.zip({xs:l,ys:c})}},e.prototype.save=function(n,s){return sl(this,void 0,void 0,function(){return rl(this,function(r){return[2,this.model.save(n,s)]})})},e.prototype.train=function(n,s){return s===void 0&&(s={}),sl(this,void 0,void 0,function(){var r,o,a,i,l,u,c,d=this;return rl(this,function(f){switch(f.label){case 0:if(r=s.onTrainEnd||function(){},s.onTrainEnd=function(h){d.__stopTrainingResolve&&(d.__stopTrainingResolve(),d.__stopTrainingResolve=null),r(h)},this.isPrepared||this.prepare(),o=this.getLabels().length,H7t.util.assert(o===this.numClasses,function(){return"Can not train, has "+o+" labels and "+d.numClasses+" classes"}),a=this.examples[0][1].length,this.seed?i=$r.initializers.varianceScaling({seed:3.14}):i=$r.initializers.varianceScaling({}),this.model=$r.sequential({layers:[$r.layers.dense({inputShape:[a],units:n.denseUnits,activation:"relu",kernelInitializer:i,useBias:!0}),$r.layers.dropout({rate:.5}),$r.layers.dense({units:this.numClasses,kernelInitializer:i,useBias:!1,activation:"softmax"})]}),l=$r.train.rmsprop(n.learningRate),this.model.compile({optimizer:l,loss:"categoricalCrossentropy",metrics:["accuracy"]}),!(n.batchSize>0))throw new Error("Batch size is 0 or NaN. Please choose a non-zero fraction");return u=this.trainDataset.batch(n.batchSize),c=this.validationDataset.batch(n.batchSize),[4,this.model.fitDataset(u,{epochs:n.epochs,validationData:c,callbacks:s})];case 1:return f.sent(),l.dispose(),[2,this.model]}})})},e.prototype.prepareDataset=function(){for(var n=0;n<this.numClasses;n++)this.examples[n]=[]},e.prototype.stopTraining=function(){var n=this,s=new Promise(function(r,o){n.model.stopTraining=!0,n.__stopTrainingResolve=r});return s},e.prototype.dispose=function(){this.model.dispose(),t.prototype.dispose.call(this)},e.prototype.setLabel=function(n,s){this._metadata.labels[n]=s},e.prototype.setLabels=function(n){this._metadata.labels=n,this.prepareDataset()},e.prototype.getLabel=function(n){return this._metadata.labels[n]},e.prototype.getLabels=function(){return this._metadata.labels},e.prototype.setName=function(n){this._metadata.modelName=n},e.prototype.getName=function(){return this._metadata.modelName},e.prototype.calculateAccuracyPerClass=function(){return sl(this,void 0,void 0,function(){var n,s,r,o,a,i,l,u,c,d,b,f,h,p,m,g,y,w,b,_=this;return rl(this,function($){switch($.label){case 0:return n=this.validationDataset.mapAsync(function(x){return sl(_,void 0,void 0,function(){return rl(this,function(k){return[2,x.xs]})})}),s=this.validationDataset.mapAsync(function(x){return sl(_,void 0,void 0,function(){return rl(this,function(k){return[2,x.ys]})})}),r=Math.min(s.size,32),o=Math.ceil(s.size/r),a=n.batch(r),i=s.batch(r),[4,a.iterator()];case 1:return l=$.sent(),[4,i.iterator()];case 2:u=$.sent(),c=[],d=[],b=0,$.label=3;case 3:return b<o?[4,l.next()]:[3,7];case 4:return f=$.sent(),h=this.model.predict(f.value),p=h.argMax(1),c.push(p),[4,u.next()];case 5:m=$.sent(),g=m.value.argMax(1),d.push(g),f.value.dispose(),h.dispose(),m.value.dispose(),$.label=6;case 6:return b++,[3,3];case 7:if(y=$r.concat(d),w=$r.concat(c),o!==1)for(b=0;b<c.length;b++)c[b].dispose(),d[b].dispose();return[2,{reference:y,predictions:w}]}})})},e.prototype.setSeed=function(n){this.seed=W7t(n)},e}(pQ.CustomPoseNet);k4.TeachablePoseNet=mQ;function j7t(t){return sl(this,void 0,void 0,function(){var e;return rl(this,function(n){switch(n.label){case 0:return[4,pQ.loadPoseNet(t.modelSettings)];case 1:return e=n.sent(),[2,new mQ($r.sequential(),e,t)]}})})}k4.createTeachable=j7t;var ZE={};function by(t){return typeof Symbol=="function"&&typeof Symbol.iterator=="symbol"?by=function(n){return typeof n}:by=function(n){return n&&typeof Symbol=="function"&&n.constructor===Symbol&&n!==Symbol.prototype?"symbol":typeof n},by(t)}function JE(t,e,n){var s=n.value;if(typeof s!="function")throw new TypeError("@boundMethod decorator can only be applied to methods not: ".concat(by(s)));var r=!1;return{configurable:!0,get:function(){if(r||this===t.prototype||this.hasOwnProperty(e)||typeof s!="function")return s;var a=s.bind(this);return r=!0,Object.defineProperty(this,e,{configurable:!0,get:function(){return a},set:function(l){s=l,delete this[e]}}),r=!1,a},set:function(a){s=a}}}function gQ(t){var e;return typeof Reflect<"u"&&typeof Reflect.ownKeys=="function"?e=Reflect.ownKeys(t.prototype):(e=Object.getOwnPropertyNames(t.prototype),typeof Object.getOwnPropertySymbols=="function"&&(e=e.concat(Object.getOwnPropertySymbols(t.prototype)))),e.forEach(function(n){if(n!=="constructor"){var s=Object.getOwnPropertyDescriptor(t.prototype,n);typeof s.value=="function"&&Object.defineProperty(t.prototype,n,JE(t,n,s))}}),t}function K7t(){return arguments.length===1?gQ.apply(void 0,arguments):JE.apply(void 0,arguments)}const q7t=Object.freeze(Object.defineProperty({__proto__:null,boundMethod:JE,boundClass:gQ,default:K7t},Symbol.toStringTag,{value:"Module"})),X7t=Mg(q7t);var U2={};Object.defineProperty(U2,"__esModule",{value:!0});var Y7t=function(){return document.createElement("canvas")};function Z7t(t,e,n){t===void 0&&(t=200),e===void 0&&(e=200),n===void 0&&(n=!1);var s=document.createElement("canvas");if(s.width=t,s.height=e,n){var r=s.getContext("2d");r.translate(t,0),r.scale(-1,1)}return s}U2.createCanvas=Z7t;function J7t(t,e,n,s){n===void 0&&(n=!1),s===void 0&&(s=Y7t());var r=t.width,o=t.height;t instanceof HTMLVideoElement&&(r=t.videoWidth,o=t.videoHeight);var a=Math.min(r,o),i=e/a,l=Math.ceil(r*i),u=Math.ceil(o*i),c=l-e,d=u-e;s.width=s.height=e;var f=s.getContext("2d");return f.drawImage(t,~~(c/2)*-1,~~(d/2)*-1,l,u),n&&(f.scale(-1,1),f.drawImage(s,e*-1,0)),s}U2.cropTo=J7t;var lu=wn&&wn.__decorate||function(t,e,n,s){var r=arguments.length,o=r<3?e:s===null?s=Object.getOwnPropertyDescriptor(e,n):s,a;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")o=Reflect.decorate(t,e,n,s);else for(var i=t.length-1;i>=0;i--)(a=t[i])&&(o=(r<3?a(o):r>3?a(e,n,o):a(e,n))||o);return r>3&&o&&Object.defineProperty(e,n,o),o},Q7t=wn&&wn.__awaiter||function(t,e,n,s){function r(o){return o instanceof n?o:new n(function(a){a(o)})}return new(n||(n=Promise))(function(o,a){function i(c){try{u(s.next(c))}catch(d){a(d)}}function l(c){try{u(s.throw(c))}catch(d){a(d)}}function u(c){c.done?o(c.value):r(c.value).then(i,l)}u((s=s.apply(t,e||[])).next())})},eBt=wn&&wn.__generator||function(t,e){var n={label:0,sent:function(){if(o[0]&1)throw o[1];return o[1]},trys:[],ops:[]},s,r,o,a;return a={next:i(0),throw:i(1),return:i(2)},typeof Symbol=="function"&&(a[Symbol.iterator]=function(){return this}),a;function i(u){return function(c){return l([u,c])}}function l(u){if(s)throw new TypeError("Generator is already executing.");for(;n;)try{if(s=1,r&&(o=u[0]&2?r.return:u[0]?r.throw||((o=r.return)&&o.call(r),0):r.next)&&!(o=o.call(r,u[1])).done)return o;switch(r=0,o&&(u=[u[0]&2,o.value]),u[0]){case 0:case 1:o=u;break;case 4:return n.label++,{value:u[1],done:!1};case 5:n.label++,r=u[1],u=[0];continue;case 7:u=n.ops.pop(),n.trys.pop();continue;default:if(o=n.trys,!(o=o.length>0&&o[o.length-1])&&(u[0]===6||u[0]===2)){n=0;continue}if(u[0]===3&&(!o||u[1]>o[0]&&u[1]<o[3])){n.label=u[1];break}if(u[0]===6&&n.label<o[1]){n.label=o[1],o=u;break}if(o&&n.label<o[2]){n.label=o[2],n.ops.push(u);break}o[2]&&n.ops.pop(),n.trys.pop();continue}u=e.call(t,n)}catch(c){u=[6,c],r=0}finally{s=o=0}if(u[0]&5)throw u[1];return{value:u[0]?u[1]:void 0,done:!0}}};Object.defineProperty(ZE,"__esModule",{value:!0});var uu=X7t,tBt=U2,U$={facingMode:"user",frameRate:24},nBt=function(t){return t.facingMode=t.facingMode||U$.facingMode,t.frameRate=t.frameRate||U$.frameRate,t.aspectRatio=t.aspectRatio||U$.aspectRatio,t},sBt=function(){function t(e,n,s){e===void 0&&(e=400),n===void 0&&(n=400),s===void 0&&(s=!1),this.width=e,this.height=n,this.flip=s}return t.prototype.getWebcam=function(e){if(e===void 0&&(e={}),!window.navigator.mediaDevices||!window.navigator.mediaDevices.getUserMedia)return Promise.reject("Your browser does not support WebRTC. Please try another one.");e.width=640;var n=nBt(e),s=document.createElement("video");return window.navigator.mediaDevices.getUserMedia({video:n}).then(function(r){return s.srcObject=r,s.addEventListener("loadedmetadata",function(o){var a=s.videoWidth,i=s.videoHeight;s.width=a,s.height=i}),s},function(){return Promise.reject("Could not open your camera. You may have denied access.")})},t.prototype.setup=function(e){return e===void 0&&(e={}),Q7t(this,void 0,void 0,function(){var n;return eBt(this,function(s){switch(s.label){case 0:return this.webcam?[3,2]:(n=this,[4,this.getWebcam(e)]);case 1:n.webcam=s.sent(),this.canvas||(this.canvas=document.createElement("canvas"),this.canvas.width=this.width,this.canvas.height=this.height),s.label=2;case 2:return[2]}})})},t.prototype.play=function(){var e=this.webcam.play();return e},t.prototype.pause=function(){this.webcam.pause()},t.prototype.stop=function(){this.stopStreamedVideo(this.webcam)},t.prototype.update=function(){this.renderCameraToCanvas()},t.prototype.stopStreamedVideo=function(e){var n=e.srcObject,s=n.getTracks();s.forEach(function(r){r.stop()}),e.srcObject=null},t.prototype.renderCameraToCanvas=function(){if(this.canvas&&this.webcam){var e=this.canvas.getContext("2d");if(this.webcam.videoWidth!==0){var n=tBt.cropTo(this.webcam,this.width,this.flip);e.drawImage(n,0,0)}}},lu([uu.default],t.prototype,"getWebcam",null),lu([uu.default],t.prototype,"setup",null),lu([uu.default],t.prototype,"play",null),lu([uu.default],t.prototype,"pause",null),lu([uu.default],t.prototype,"stop",null),lu([uu.default],t.prototype,"update",null),lu([uu.default],t.prototype,"stopStreamedVideo",null),lu([uu.default],t.prototype,"renderCameraToCanvas",null),t}();ZE.Webcam=sBt;var vf={};Object.defineProperty(vf,"__esModule",{value:!0});var rBt=Es,oBt="aqua",vQ="aqua",aBt=4,iBt=2;function lBt(t,e,n,s,r,o,a){s===void 0&&(s=aBt),r===void 0&&(r=oBt),o===void 0&&(o=vQ),a===void 0&&(a=1);for(var i=0;i<t.length;i++){var l=t[i];if(!(l.score<e)){var u=l.position,c=u.y,d=u.x;yQ(n,c*a,d*a,s,r,o)}}}vf.drawKeypoints=lBt;function yQ(t,e,n,s,r,o){t.fillStyle=r,t.strokeStyle=o,t.beginPath(),t.arc(n,e,s,0,2*Math.PI),t.fill(),t.stroke()}vf.drawPoint=yQ;function zS(t){return[t.y,t.x]}vf.toTuple=zS;function uBt(t,e,n,s,r,o){s===void 0&&(s=iBt),r===void 0&&(r=vQ),o===void 0&&(o=1);var a=rBt.getAdjacentKeyPoints(t,e);a.forEach(function(i){bQ(zS(i[0].position),zS(i[1].position),n,s,r,o)})}vf.drawSkeleton=uBt;function bQ(t,e,n,s,r,o){var a=t[0],i=t[1],l=e[0],u=e[1];n.beginPath(),n.moveTo(i*o,a*o),n.lineTo(u*o,l*o),n.lineWidth=s,n.strokeStyle=r,n.stroke()}vf.drawSegment=bQ;Object.defineProperty(Zo,"__esModule",{value:!0});var QE=cc;Zo.CustomPoseNet=QE.CustomPoseNet;var cBt=Zo.load=QE.load;Zo.loadFromFiles=QE.loadFromFiles;var wQ=k4;Zo.TeachablePoseNet=wQ.TeachablePoseNet;Zo.createTeachable=wQ.createTeachable;var dBt=ZE,fBt=Zo.Webcam=dBt.Webcam,hBt=U2;Zo.createCanvas=hBt.createCanvas;var T4=vf,pBt=Zo.drawKeypoints=T4.drawKeypoints,mBt=Zo.drawSkeleton=T4.drawSkeleton;Zo.drawPoint=T4.drawPoint;Zo.drawSegment=T4.drawSegment;var gBt=C4;Zo.version=gBt.version;const N4=t=>(_ee("data-v-1e980c27"),t=t(),$ee(),t),vBt=N4(()=>I("h1",{class:"text-3xl mb-6"},"坐姿偵測",-1)),yBt={key:0,class:"flex items-center flex-col"},bBt=N4(()=>I("img",{style:{width:"40rem",height:"100%"},src:tse},null,-1)),wBt=N4(()=>I("p",{class:"text-2xl mt-8"},"請將攝像機以側面拍攝以獲得準確體驗",-1)),_Bt={key:1,class:"flex items-center flex-col"},$Bt=N4(()=>I("div",{class:"border flex"},[I("canvas",{id:"canvas"})],-1)),xBt={__name:"HomeView",setup(t){const e=U(!1);let n=U(0),s=U(!1),r=U(0),o=U(0),a=U(!1),i=U(0),l,u,c;async function d(){l=await cBt("./models/model.json","./models/metadata.json"),l.getTotalClasses();const w=400,b=!0;u=new fBt(w,w,b);try{await u.setup(),e.value=!0}catch{m()}await u.play(),window.requestAnimationFrame(f);const _=document.getElementById("canvas");_.width=w,_.height=w,c=_.getContext("2d")}async function f(g){u.update(),await h(),window.requestAnimationFrame(f)}async function h(){const{pose:g,posenetOutput:y}=await l.estimatePose(u.canvas),w=await l.predict(y);n.value=w[0].probability.toFixed(2),o.value=w[1].probability.toFixed(2),n.value>.9?r.value++:r.value=0,o.value>.9?i.value++:i.value=0,r.value>30?s.value=!0:s.value=!1,i.value>30?a.value=!0:a.value=!1,p(g)}function p(g){u.canvas&&(c.drawImage(u.canvas,0,0),g&&(pBt(g.keypoints,.5,c),mBt(g.keypoints,.5,c)))}const m=()=>{vB({message:"請允許攝影機開放或選擇正確的來源 !",type:"warning"})};return(g,y)=>{const w=pt("el-button");return S(),E("div",{class:P(["flex items-center flex-col h-screen p-8",{"bg-red-500":v(s),"bg-green-500":v(a)}])},[vBt,e.value?(S(),E("div",_Bt,[$Bt,Yt(" 駝背 : "+Ue(v(n))+" 坐正 : "+Ue(v(o)),1)])):(S(),E("div",yBt,[se(w,{type:"primary",size:"large",onClick:y[0]||(y[0]=b=>d()),class:"mb-8"},{default:ce(()=>[Yt(" 開始判斷 ")]),_:1}),bBt,wBt]))],2)}}},SBt=hM(xBt,[["__scopeId","data-v-1e980c27"]]),CBt=Qne({history:mne("/"),routes:[{path:"/",name:"home",component:SBt}]}),I4=fM(Zte);for(const[t,e]of Object.entries(D9e))I4.component(t,e);I4.use(ast);I4.use(CBt);I4.mount("#app")});export default kBt();
